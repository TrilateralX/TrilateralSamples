// Generated by Haxe 4.2.0-rc.1+3ef20749a
#include <hxcpp.h>

#ifndef INCLUDED_c8a65390b4b62196
#define INCLUDED_c8a65390b4b62196
#include "/usr/local/lib/haxeLibrary/gluon/git/src/gluon/webgl/native/ES2Context.h"
#endif
#ifndef INCLUDED_AppGL
#include <AppGL.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_dsHelper_flat_io__Float32Flat_Float32Flat_Impl_
#include <dsHelper/flat/io/_Float32Flat/Float32Flat_Impl_.h>
#endif
#ifndef INCLUDED_gluon_webgl__GLContext_GLContext_Impl_
#include <gluon/webgl/_GLContext/GLContext_Impl_.h>
#endif
#ifndef INCLUDED_gluon_webgl_native_GLBuffer
#include <gluon/webgl/native/GLBuffer.h>
#endif
#ifndef INCLUDED_gluon_webgl_native_GLContext
#include <gluon/webgl/native/GLContext.h>
#endif
#ifndef INCLUDED_gluon_webgl_native_GLObject
#include <gluon/webgl/native/GLObject.h>
#endif
#ifndef INCLUDED_gluon_webgl_native_GLProgram
#include <gluon/webgl/native/GLProgram.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io__Float32Array_Float32Array_Impl_
#include <haxe/io/_Float32Array/Float32Array_Impl_.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Pen
#include <trilateral3/drawing/Pen.h>
#endif
#ifndef INCLUDED_trilateral3_nodule_PenNodule
#include <trilateral3/nodule/PenNodule.h>
#endif


void AppGL_obj::__construct(int width_,int height_){
            	HX_JUST_GC_STACKFRAME
	this->penNodule =  ::trilateral3::nodule::PenNodule_obj::__alloc( HX_CTX ,null());
	this->width = width_;
	this->height = height_;
}

Dynamic AppGL_obj::__CreateEmpty() { return new AppGL_obj; }

void *AppGL_obj::_hx_vtable = 0;

Dynamic AppGL_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< AppGL_obj > _hx_result = new AppGL_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool AppGL_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x53f8aa26;
}

void AppGL_obj::render(){
	{
		 ::gluon::webgl::native::GLContext gl = this->gl;
		{
			glViewport(0,0,this->width,this->height);
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("viewport",66,4c,a5,9c));
		}
		{
			glClearColor(( (float)(((Float)0.0)) ),( (float)(((Float)0.0)) ),( (float)(((Float)0.0)) ),( (float)(((Float)1.0)) ));
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("clearColor",96,b0,66,1f));
		}
		{
			glClear(( (unsigned int)(16384) ));
			::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(gl,HX_("clear",8d,71,5b,48));
		}
	}
	this->renderDraw(this->penNodule->pen);
	{
		 ::gluon::webgl::native::GLContext this1 = this->gl;
		 ::gluon::webgl::native::GLBuffer buffer = this->buf;
		{
			unsigned int ref;
			if (::hx::IsNotNull( buffer )) {
				ref = buffer->handle;
			}
			else {
				ref = ( (unsigned int)(0) );
			}
			glBindBuffer(( (unsigned int)(34962) ),ref);
		}
		::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this1,HX_("bindBuffer",9d,92,be,f8));
	}
	{
		 ::gluon::webgl::native::GLContext this2 = this->gl;
		 ::haxe::io::ArrayBufferViewImpl this3 = this->penNodule->colorTriangles;
		 ::Dynamic end = ((this3->byteLength >> 2) - 2);
		 ::Dynamic data;
		if (::hx::IsNull( end )) {
			data = null();
		}
		else {
			data = (( (int)(end) ) << 2);
		}
		 ::haxe::io::Bytes data1 = ( ( ::haxe::io::Bytes)(::haxe::io::_Float32Array::Float32Array_Impl__obj::fromData(this3->subarray(8,data))) );
		int data2 = data1->length;
		::cpp::Pointer< unsigned char > _hx_tmp = ( (::cpp::Pointer< unsigned char >)(::cpp::Pointer_obj::arrayElem(data1->b,0)) );
		glBufferSubData(( (unsigned int)(34962) ),( (::cpp::Int64)(0) ),( (::cpp::Int64)(data2) ),( (const void *)(( (unsigned char *)(_hx_tmp->get_raw()) )) ));
		::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this2,HX_("bufferSubData",aa,f6,e4,45));
	}
	{
		 ::gluon::webgl::native::GLContext this4 = this->gl;
		 ::gluon::webgl::native::GLProgram program = this->program;
		{
			unsigned int ref1;
			if (::hx::IsNotNull( program )) {
				ref1 = program->handle;
			}
			else {
				ref1 = ( (unsigned int)(0) );
			}
			glUseProgram(ref1);
		}
		::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this4,HX_("useProgram",fd,6c,ac,f6));
	}
	{
		 ::gluon::webgl::native::GLContext this5 = this->gl;
		glDrawArrays(( (unsigned int)(4) ),0,::Std_obj::_hx_int(( (Float)((::dsHelper::flat::io::_Float32Flat::Float32Flat_Impl__obj::get_size(this->penNodule->colorTriangles) * 3)) )));
		::gluon::webgl::_GLContext::GLContext_Impl__obj::reportErrors(this5,HX_("drawArrays",de,f3,b3,f9));
	}
}


HX_DEFINE_DYNAMIC_FUNC0(AppGL_obj,render,(void))

void AppGL_obj::renderDraw( ::trilateral3::drawing::Pen pen){
}


HX_DEFINE_DYNAMIC_FUNC1(AppGL_obj,renderDraw,(void))


::hx::ObjectPtr< AppGL_obj > AppGL_obj::__new(int width_,int height_) {
	::hx::ObjectPtr< AppGL_obj > __this = new AppGL_obj();
	__this->__construct(width_,height_);
	return __this;
}

::hx::ObjectPtr< AppGL_obj > AppGL_obj::__alloc(::hx::Ctx *_hx_ctx,int width_,int height_) {
	AppGL_obj *__this = (AppGL_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(AppGL_obj), true, "AppGL"));
	*(void **)__this = AppGL_obj::_hx_vtable;
	__this->__construct(width_,height_);
	return __this;
}

AppGL_obj::AppGL_obj()
{
}

void AppGL_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(AppGL);
	HX_MARK_MEMBER_NAME(gl,"gl");
	HX_MARK_MEMBER_NAME(program,"program");
	HX_MARK_MEMBER_NAME(penNodule,"penNodule");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(buf,"buf");
	HX_MARK_END_CLASS();
}

void AppGL_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(gl,"gl");
	HX_VISIT_MEMBER_NAME(program,"program");
	HX_VISIT_MEMBER_NAME(penNodule,"penNodule");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(buf,"buf");
}

::hx::Val AppGL_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { return ::hx::Val( gl ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"buf") ) { return ::hx::Val( buf ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		if (HX_FIELD_EQ(inName,"render") ) { return ::hx::Val( render_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"program") ) { return ::hx::Val( program ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"penNodule") ) { return ::hx::Val( penNodule ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"renderDraw") ) { return ::hx::Val( renderDraw_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val AppGL_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { gl=inValue.Cast<  ::gluon::webgl::native::GLContext >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"buf") ) { buf=inValue.Cast<  ::gluon::webgl::native::GLBuffer >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"program") ) { program=inValue.Cast<  ::gluon::webgl::native::GLProgram >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"penNodule") ) { penNodule=inValue.Cast<  ::trilateral3::nodule::PenNodule >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void AppGL_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("gl",25,5a,00,00));
	outFields->push(HX_("program",84,4a,f9,f3));
	outFields->push(HX_("penNodule",c4,02,81,14));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("buf",33,c3,4a,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo AppGL_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::gluon::webgl::native::GLContext */ ,(int)offsetof(AppGL_obj,gl),HX_("gl",25,5a,00,00)},
	{::hx::fsObject /*  ::gluon::webgl::native::GLProgram */ ,(int)offsetof(AppGL_obj,program),HX_("program",84,4a,f9,f3)},
	{::hx::fsObject /*  ::trilateral3::nodule::PenNodule */ ,(int)offsetof(AppGL_obj,penNodule),HX_("penNodule",c4,02,81,14)},
	{::hx::fsInt,(int)offsetof(AppGL_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsInt,(int)offsetof(AppGL_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsObject /*  ::gluon::webgl::native::GLBuffer */ ,(int)offsetof(AppGL_obj,buf),HX_("buf",33,c3,4a,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *AppGL_obj_sStaticStorageInfo = 0;
#endif

static ::String AppGL_obj_sMemberFields[] = {
	HX_("gl",25,5a,00,00),
	HX_("program",84,4a,f9,f3),
	HX_("penNodule",c4,02,81,14),
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("buf",33,c3,4a,00),
	HX_("render",56,6b,29,05),
	HX_("renderDraw",7a,26,7a,df),
	::String(null()) };

::hx::Class AppGL_obj::__mClass;

void AppGL_obj::__register()
{
	AppGL_obj _hx_dummy;
	AppGL_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("AppGL",e6,d4,68,b7);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(AppGL_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< AppGL_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = AppGL_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = AppGL_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

