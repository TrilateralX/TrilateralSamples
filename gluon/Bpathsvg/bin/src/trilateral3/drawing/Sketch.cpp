// Generated by Haxe 4.2.0-rc.1+3ef20749a
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_fracs_DifferencePreference
#include <fracs/DifferencePreference.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_justPath_IPathContext
#include <justPath/IPathContext.h>
#endif
#ifndef INCLUDED_trilateral3_Trilateral
#include <trilateral3/Trilateral.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Contour
#include <trilateral3/drawing/Contour.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Pen
#include <trilateral3/drawing/Pen.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Sketch
#include <trilateral3/drawing/Sketch.h>
#endif
#ifndef INCLUDED_trilateral3_math__Algebra_Algebra_Fields_
#include <trilateral3/math/_Algebra/Algebra_Fields_.h>
#endif
#ifndef INCLUDED_trilateral3_matrix_MatrixDozen
#include <trilateral3/matrix/MatrixDozen.h>
#endif

namespace trilateral3{
namespace drawing{

void Sketch_obj::__construct( ::trilateral3::drawing::Pen pen_,int sketchForm_,::hx::Null< int >  __o_endLine_){
	int endLine_ = __o_endLine_.Default(0);
            	HX_JUST_GC_STACKFRAME
	this->width = ((Float)0.01);
	this->y = ((Float)0.);
	this->x = ((Float)0.);
	this->contour =  ::trilateral3::drawing::Contour_obj::__alloc( HX_CTX ,pen_,endLine_);
	this->pen = pen_;
	this->endLine = endLine_;
	this->sketchForm = sketchForm_;
	switch((int)(sketchForm_)){
		case (int)0: {
			this->line = this->tracerLine_dyn();
		}
		break;
		case (int)1: {
			this->line = this->baseLine_dyn();
		}
		break;
		case (int)2: {
			this->line = this->crudeLine_dyn();
		}
		break;
		case (int)3: {
			this->line = this->fillOnlyLine_dyn();
		}
		break;
		case (int)4: {
			this->line = this->fineLine_dyn();
		}
		break;
		case (int)5: {
			this->line = this->fineOverlapLine_dyn();
		}
		break;
		case (int)6: {
			this->line = this->mediumLine_dyn();
		}
		break;
		case (int)7: {
			this->line = this->mediumOverlapLine_dyn();
		}
		break;
		case (int)8: {
			this->line = this->roundEndLine_dyn();
		}
		break;
	}
	this->points = ::Array_obj< ::Dynamic>::__new(0);
	this->pointsClock = ::Array_obj< ::Dynamic>::__new(0);
	this->pointsAnti = ::Array_obj< ::Dynamic>::__new(0);
	this->points[0] = ::Array_obj< Float >::__new();
	this->dim = ::Array_obj< ::Dynamic>::__new();
}

Dynamic Sketch_obj::__CreateEmpty() { return new Sketch_obj; }

void *Sketch_obj::_hx_vtable = 0;

Dynamic Sketch_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Sketch_obj > _hx_result = new Sketch_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool Sketch_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x100e59ef;
}

static ::justPath::IPathContext_obj _hx_trilateral3_drawing_Sketch__hx_justPath_IPathContext= {
	( void (::hx::Object::*)(Float,Float))&::trilateral3::drawing::Sketch_obj::moveTo,
	( void (::hx::Object::*)(Float,Float))&::trilateral3::drawing::Sketch_obj::lineTo,
	( void (::hx::Object::*)(Float,Float,Float,Float))&::trilateral3::drawing::Sketch_obj::quadTo,
	( void (::hx::Object::*)(Float,Float,Float,Float,Float,Float))&::trilateral3::drawing::Sketch_obj::curveTo,
};

void *Sketch_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0xed67b972: return &_hx_trilateral3_drawing_Sketch__hx_justPath_IPathContext;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void Sketch_obj::tracerLine(Float x_,Float y_){
	::haxe::Log_obj::trace(((((((((HX_("lineTo( ",47,6b,2a,8a) + this->x) + HX_(", ",74,26,00,00)) + this->y) + HX_(", ",74,26,00,00)) + x_) + HX_(", ",74,26,00,00)) + y_) + HX_(", width )",9b,2f,cd,98)),::hx::SourceInfo(HX_("trilateral3/drawing/Sketch.hx",39,8a,a7,5a),38,HX_("trilateral3.drawing.Sketch",23,f7,00,b3),HX_("tracerLine",e1,14,6f,0a)));
}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,tracerLine,(void))

void Sketch_obj::fillOnlyLine(Float x_,Float y_){
}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,fillOnlyLine,(void))

void Sketch_obj::baseLine(Float x_,Float y_){
	::haxe::Log_obj::trace(((((((((HX_("lineTo( ",47,6b,2a,8a) + this->x) + HX_(", ",74,26,00,00)) + this->y) + HX_(", ",74,26,00,00)) + x_) + HX_(", ",74,26,00,00)) + y_) + HX_(", width )",9b,2f,cd,98)),::hx::SourceInfo(HX_("trilateral3/drawing/Sketch.hx",39,8a,a7,5a),38,HX_("trilateral3.drawing.Sketch",23,f7,00,b3),HX_("tracerLine",e1,14,6f,0a)));
	{
		 ::trilateral3::drawing::Contour _this = this->contour;
		Float ax_ = this->x;
		Float ay_ = this->y;
		Float width_ = this->width;
		_this->ax = x_;
		_this->ay = y_;
		_this->bx = ax_;
		_this->by = ay_;
		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
		{
			{
				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
				if ((_this->theta > 0)) {
					if ((_this->halfA < 0)) {
						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
						_this->angle1 = (_this->theta - _this->halfA);
					}
					else {
						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
						_this->angle2 = (_this->theta + _this->halfA);
					}
				}
				else {
					if ((_this->halfA > 0)) {
						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
						_this->angle2 = (_this->theta + _this->halfA);
					}
					else {
						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
						_this->angle1 = (_this->theta - _this->halfA);
					}
				}
			}
			if (::hx::IsNotNull( _this->dxPrev )) {
				_this->dxOld = _this->dxPrev;
			}
			if (::hx::IsNotNull( _this->dyPrev )) {
				_this->dyOld = _this->dyPrev;
			}
			if (::hx::IsNotNull( _this->exPrev )) {
				_this->exOld = _this->exPrev;
			}
			if (::hx::IsNotNull( _this->eyPrev )) {
				_this->eyOld = _this->eyPrev;
			}
			if (::hx::IsNotNull( _this->dx )) {
				_this->dxPrev = _this->dx;
			}
			if (::hx::IsNotNull( _this->dy )) {
				_this->dyPrev = _this->dy;
			}
			if (::hx::IsNotNull( _this->ex )) {
				_this->exPrev = _this->ex;
			}
			if (::hx::IsNotNull( _this->ey )) {
				_this->eyPrev = _this->ey;
			}
			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
		}
		 ::Dynamic dxPrev_ = _this->dx;
		 ::Dynamic dyPrev_ = _this->dy;
		 ::Dynamic exPrev_ = _this->ex;
		 ::Dynamic eyPrev_ = _this->ey;
		_this->ax = ax_;
		_this->ay = ay_;
		_this->bx = x_;
		_this->by = y_;
		{
			{
				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
				if ((_this->theta > 0)) {
					if ((_this->halfA < 0)) {
						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
						_this->angle1 = (_this->theta - _this->halfA);
					}
					else {
						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
						_this->angle2 = (_this->theta + _this->halfA);
					}
				}
				else {
					if ((_this->halfA > 0)) {
						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
						_this->angle2 = (_this->theta + _this->halfA);
					}
					else {
						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
						_this->angle1 = (_this->theta - _this->halfA);
					}
				}
			}
			if (::hx::IsNotNull( _this->dxPrev )) {
				_this->dxOld = _this->dxPrev;
			}
			if (::hx::IsNotNull( _this->dyPrev )) {
				_this->dyOld = _this->dyPrev;
			}
			if (::hx::IsNotNull( _this->exPrev )) {
				_this->exOld = _this->exPrev;
			}
			if (::hx::IsNotNull( _this->eyPrev )) {
				_this->eyOld = _this->eyPrev;
			}
			if (::hx::IsNotNull( _this->dx )) {
				_this->dxPrev = _this->dx;
			}
			if (::hx::IsNotNull( _this->dy )) {
				_this->dyPrev = _this->dy;
			}
			if (::hx::IsNotNull( _this->ex )) {
				_this->exPrev = _this->ex;
			}
			if (::hx::IsNotNull( _this->ey )) {
				_this->eyPrev = _this->ey;
			}
			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
		}
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			{
				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(exPrev_) ),( (Float)(eyPrev_) ),0);
				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
				}
				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
			}
			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
		}
		{
			 ::trilateral3::drawing::Pen _this2 = _this->pen;
			int color1 = -1;
			if ((color1 == -1)) {
				color1 = _this2->currentColor;
			}
			{
				_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
					_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
				}
				_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
			}
			_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
		}
	}
}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,baseLine,(void))

void Sketch_obj::crudeLine(Float x_,Float y_){
	 ::trilateral3::drawing::Contour _this = this->contour;
	Float ax_ = this->x;
	Float ay_ = this->y;
	Float width_ = this->width;
	_this->ax = x_;
	_this->ay = y_;
	_this->bx = ax_;
	_this->by = ay_;
	_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
	_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
	_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
	{
		{
			_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
			if ((_this->theta > 0)) {
				if ((_this->halfA < 0)) {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
				else {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
			}
			else {
				if ((_this->halfA > 0)) {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
				else {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
			}
		}
		if (::hx::IsNotNull( _this->dxPrev )) {
			_this->dxOld = _this->dxPrev;
		}
		if (::hx::IsNotNull( _this->dyPrev )) {
			_this->dyOld = _this->dyPrev;
		}
		if (::hx::IsNotNull( _this->exPrev )) {
			_this->exOld = _this->exPrev;
		}
		if (::hx::IsNotNull( _this->eyPrev )) {
			_this->eyOld = _this->eyPrev;
		}
		if (::hx::IsNotNull( _this->dx )) {
			_this->dxPrev = _this->dx;
		}
		if (::hx::IsNotNull( _this->dy )) {
			_this->dyPrev = _this->dy;
		}
		if (::hx::IsNotNull( _this->ex )) {
			_this->exPrev = _this->ex;
		}
		if (::hx::IsNotNull( _this->ey )) {
			_this->eyPrev = _this->ey;
		}
		_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
		_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
		_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
		_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
	}
	 ::Dynamic dxPrev_ = _this->dx;
	 ::Dynamic dyPrev_ = _this->dy;
	 ::Dynamic exPrev_ = _this->ex;
	 ::Dynamic eyPrev_ = _this->ey;
	_this->ax = ax_;
	_this->ay = ay_;
	_this->bx = x_;
	_this->by = y_;
	{
		{
			_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
			if ((_this->theta > 0)) {
				if ((_this->halfA < 0)) {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
				else {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
			}
			else {
				if ((_this->halfA > 0)) {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
				else {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
			}
		}
		if (::hx::IsNotNull( _this->dxPrev )) {
			_this->dxOld = _this->dxPrev;
		}
		if (::hx::IsNotNull( _this->dyPrev )) {
			_this->dyOld = _this->dyPrev;
		}
		if (::hx::IsNotNull( _this->exPrev )) {
			_this->exOld = _this->exPrev;
		}
		if (::hx::IsNotNull( _this->eyPrev )) {
			_this->eyOld = _this->eyPrev;
		}
		if (::hx::IsNotNull( _this->dx )) {
			_this->dxPrev = _this->dx;
		}
		if (::hx::IsNotNull( _this->dy )) {
			_this->dyPrev = _this->dy;
		}
		if (::hx::IsNotNull( _this->ex )) {
			_this->exPrev = _this->ex;
		}
		if (::hx::IsNotNull( _this->ey )) {
			_this->eyPrev = _this->ey;
		}
		_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
		_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
		_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
		_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
	}
	{
		 ::trilateral3::drawing::Pen _this1 = _this->pen;
		int color = -1;
		if ((color == -1)) {
			color = _this1->currentColor;
		}
		{
			_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(exPrev_) ),( (Float)(eyPrev_) ),0);
			if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
				_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
			}
			_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
		}
		_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
	}
	{
		 ::trilateral3::drawing::Pen _this2 = _this->pen;
		int color1 = -1;
		if ((color1 == -1)) {
			color1 = _this2->currentColor;
		}
		{
			_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
			if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
				_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
			}
			_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
		}
		_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
	}
}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,crudeLine,(void))

void Sketch_obj::roundEndLine(Float x_,Float y_){
	 ::trilateral3::drawing::Contour _this = this->contour;
	Float ax_ = this->x;
	Float ay_ = this->y;
	Float width_ = this->width;
	 ::Dynamic endLineCurve = 3;
	if (::hx::IsNull( endLineCurve )) {
		endLineCurve = 0;
	}
	_this->ax = x_;
	_this->ay = y_;
	_this->bx = ax_;
	_this->by = ay_;
	_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
	_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
	_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
	{
		{
			_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
			if ((_this->theta > 0)) {
				if ((_this->halfA < 0)) {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
				else {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
			}
			else {
				if ((_this->halfA > 0)) {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
				else {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
			}
		}
		if (::hx::IsNotNull( _this->dxPrev )) {
			_this->dxOld = _this->dxPrev;
		}
		if (::hx::IsNotNull( _this->dyPrev )) {
			_this->dyOld = _this->dyPrev;
		}
		if (::hx::IsNotNull( _this->exPrev )) {
			_this->exOld = _this->exPrev;
		}
		if (::hx::IsNotNull( _this->eyPrev )) {
			_this->eyOld = _this->eyPrev;
		}
		if (::hx::IsNotNull( _this->dx )) {
			_this->dxPrev = _this->dx;
		}
		if (::hx::IsNotNull( _this->dy )) {
			_this->dyPrev = _this->dy;
		}
		if (::hx::IsNotNull( _this->ex )) {
			_this->exPrev = _this->ex;
		}
		if (::hx::IsNotNull( _this->ey )) {
			_this->eyPrev = _this->ey;
		}
		_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
		_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
		_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
		_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
	}
	 ::Dynamic dxPrev_ = _this->dx;
	 ::Dynamic dyPrev_ = _this->dy;
	 ::Dynamic exPrev_ = _this->ex;
	 ::Dynamic eyPrev_ = _this->ey;
	_this->ax = ax_;
	_this->ay = ay_;
	_this->bx = x_;
	_this->by = y_;
	{
		{
			_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
			if ((_this->theta > 0)) {
				if ((_this->halfA < 0)) {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
				else {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
			}
			else {
				if ((_this->halfA > 0)) {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
				else {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
			}
		}
		if (::hx::IsNotNull( _this->dxPrev )) {
			_this->dxOld = _this->dxPrev;
		}
		if (::hx::IsNotNull( _this->dyPrev )) {
			_this->dyOld = _this->dyPrev;
		}
		if (::hx::IsNotNull( _this->exPrev )) {
			_this->exOld = _this->exPrev;
		}
		if (::hx::IsNotNull( _this->eyPrev )) {
			_this->eyOld = _this->eyPrev;
		}
		if (::hx::IsNotNull( _this->dx )) {
			_this->dxPrev = _this->dx;
		}
		if (::hx::IsNotNull( _this->dy )) {
			_this->dyPrev = _this->dy;
		}
		if (::hx::IsNotNull( _this->ex )) {
			_this->exPrev = _this->ex;
		}
		if (::hx::IsNotNull( _this->ey )) {
			_this->eyPrev = _this->ey;
		}
		_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
		_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
		_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
		_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
	}
	 ::Dynamic _hx_switch_0 = endLineCurve;
	if (  (_hx_switch_0==0) ){
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==1) ){
		Float radius = (width_ / ( (Float)(2) ));
		Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
		Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
		 ::Dynamic drawType = _this->pen->drawType;
		 ::Dynamic sides = 36;
		if (::hx::IsNull( sides )) {
			sides = 36;
		}
		Float pi = ::Math_obj::PI;
		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
		Float dif;
		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
			case (int)0: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if ((dif1 > 0)) {
					dif = dif1;
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
				}
			}
			break;
			case (int)1: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if ((dif1 < 0)) {
					dif = dif1;
				}
				else {
					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
				}
			}
			break;
			case (int)2: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool smallest = (theta <= ::Math_obj::PI);
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if (smallest) {
					dif = dif1;
				}
				else {
					if (clockwise) {
						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
					}
				}
			}
			break;
			case (int)3: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool largest = (theta > ::Math_obj::PI);
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if (largest) {
					dif = dif1;
				}
				else {
					if (clockwise) {
						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
					}
				}
			}
			break;
		}
		bool positive = (dif >= 0);
		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
		Float step1 = (dif / ( (Float)(totalSteps) ));
		Float angle = beta;
		Float cx;
		Float cy;
		Float bx = ( (Float)(0) );
		Float by = ( (Float)(0) );
		{
			int _g = 0;
			int _g1 = (totalSteps + 1);
			while((_g < _g1)){
				_g = (_g + 1);
				int i = (_g - 1);
				cx = (ax_ + (radius * ::Math_obj::sin(angle)));
				cy = (ay_ + (radius * ::Math_obj::cos(angle)));
				if ((i != 0)) {
					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
					if (::hx::IsNotNull( m )) {
						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
					}
					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				angle = (angle + step1);
				bx = cx;
				by = cy;
			}
		}
		int len = totalSteps;
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = 0;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
		}
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==2) ){
		Float radius = (width_ / ( (Float)(2) ));
		Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
		Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
		 ::Dynamic drawType = _this->pen->drawType;
		 ::Dynamic sides = 36;
		if (::hx::IsNull( sides )) {
			sides = 36;
		}
		Float pi = ::Math_obj::PI;
		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
		Float dif;
		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
			case (int)0: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if ((dif1 > 0)) {
					dif = dif1;
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
				}
			}
			break;
			case (int)1: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if ((dif1 < 0)) {
					dif = dif1;
				}
				else {
					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
				}
			}
			break;
			case (int)2: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool smallest = (theta <= ::Math_obj::PI);
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if (smallest) {
					dif = dif1;
				}
				else {
					if (clockwise) {
						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
					}
				}
			}
			break;
			case (int)3: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool largest = (theta > ::Math_obj::PI);
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if (largest) {
					dif = dif1;
				}
				else {
					if (clockwise) {
						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
					}
				}
			}
			break;
		}
		bool positive = (dif >= 0);
		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
		Float step1 = (dif / ( (Float)(totalSteps) ));
		Float angle = beta;
		Float cx;
		Float cy;
		Float bx = ( (Float)(0) );
		Float by = ( (Float)(0) );
		{
			int _g = 0;
			int _g1 = (totalSteps + 1);
			while((_g < _g1)){
				_g = (_g + 1);
				int i = (_g - 1);
				cx = (x_ + (radius * ::Math_obj::sin(angle)));
				cy = (y_ + (radius * ::Math_obj::cos(angle)));
				if ((i != 0)) {
					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(x_,y_,0,bx,by,0,cx,cy,0);
					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
					if (::hx::IsNotNull( m )) {
						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
					}
					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				angle = (angle + step1);
				bx = cx;
				by = cy;
			}
		}
		int len = totalSteps;
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = 0;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
		}
		goto _hx_goto_0;
	}
	if (  (_hx_switch_0==3) ){
		{
			Float radius = (width_ / ( (Float)(2) ));
			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
			 ::Dynamic drawType = _this->pen->drawType;
			 ::Dynamic sides = 36;
			if (::hx::IsNull( sides )) {
				sides = 36;
			}
			Float pi = ::Math_obj::PI;
			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
			Float dif;
			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
				case (int)0: {
					Float f;
					bool f1;
					if ((beta >= 0)) {
						f1 = (beta > ::Math_obj::PI);
					}
					else {
						f1 = false;
					}
					if (f1) {
						f = beta;
					}
					else {
						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f = a;
						}
						else {
							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this1 = f;
					Float za = this1;
					Float f2;
					bool f3;
					if ((gamma >= 0)) {
						f3 = (gamma > ::Math_obj::PI);
					}
					else {
						f3 = false;
					}
					if (f3) {
						f2 = gamma;
					}
					else {
						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f2 = a;
						}
						else {
							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this2 = f2;
					Float zb = this2;
					Float fa = za;
					Float fb = zb;
					Float theta = ::Math_obj::abs((fa - fb));
					bool clockwise = (fa < fb);
					Float dif1;
					if (clockwise) {
						dif1 = theta;
					}
					else {
						dif1 = -(theta);
					}
					if ((dif1 > 0)) {
						dif = dif1;
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
					}
				}
				break;
				case (int)1: {
					Float f;
					bool f1;
					if ((beta >= 0)) {
						f1 = (beta > ::Math_obj::PI);
					}
					else {
						f1 = false;
					}
					if (f1) {
						f = beta;
					}
					else {
						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f = a;
						}
						else {
							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this1 = f;
					Float za = this1;
					Float f2;
					bool f3;
					if ((gamma >= 0)) {
						f3 = (gamma > ::Math_obj::PI);
					}
					else {
						f3 = false;
					}
					if (f3) {
						f2 = gamma;
					}
					else {
						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f2 = a;
						}
						else {
							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this2 = f2;
					Float zb = this2;
					Float fa = za;
					Float fb = zb;
					Float theta = ::Math_obj::abs((fa - fb));
					bool clockwise = (fa < fb);
					Float dif1;
					if (clockwise) {
						dif1 = theta;
					}
					else {
						dif1 = -(theta);
					}
					if ((dif1 < 0)) {
						dif = dif1;
					}
					else {
						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
					}
				}
				break;
				case (int)2: {
					Float f;
					bool f1;
					if ((beta >= 0)) {
						f1 = (beta > ::Math_obj::PI);
					}
					else {
						f1 = false;
					}
					if (f1) {
						f = beta;
					}
					else {
						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f = a;
						}
						else {
							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this1 = f;
					Float za = this1;
					Float f2;
					bool f3;
					if ((gamma >= 0)) {
						f3 = (gamma > ::Math_obj::PI);
					}
					else {
						f3 = false;
					}
					if (f3) {
						f2 = gamma;
					}
					else {
						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f2 = a;
						}
						else {
							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this2 = f2;
					Float zb = this2;
					Float fa = za;
					Float fb = zb;
					Float theta = ::Math_obj::abs((fa - fb));
					bool smallest = (theta <= ::Math_obj::PI);
					bool clockwise = (fa < fb);
					Float dif1;
					if (clockwise) {
						dif1 = theta;
					}
					else {
						dif1 = -(theta);
					}
					if (smallest) {
						dif = dif1;
					}
					else {
						if (clockwise) {
							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
						}
						else {
							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
						}
					}
				}
				break;
				case (int)3: {
					Float f;
					bool f1;
					if ((beta >= 0)) {
						f1 = (beta > ::Math_obj::PI);
					}
					else {
						f1 = false;
					}
					if (f1) {
						f = beta;
					}
					else {
						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f = a;
						}
						else {
							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this1 = f;
					Float za = this1;
					Float f2;
					bool f3;
					if ((gamma >= 0)) {
						f3 = (gamma > ::Math_obj::PI);
					}
					else {
						f3 = false;
					}
					if (f3) {
						f2 = gamma;
					}
					else {
						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f2 = a;
						}
						else {
							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this2 = f2;
					Float zb = this2;
					Float fa = za;
					Float fb = zb;
					Float theta = ::Math_obj::abs((fa - fb));
					bool largest = (theta > ::Math_obj::PI);
					bool clockwise = (fa < fb);
					Float dif1;
					if (clockwise) {
						dif1 = theta;
					}
					else {
						dif1 = -(theta);
					}
					if (largest) {
						dif = dif1;
					}
					else {
						if (clockwise) {
							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
						}
						else {
							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
						}
					}
				}
				break;
			}
			bool positive = (dif >= 0);
			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
			Float step1 = (dif / ( (Float)(totalSteps) ));
			Float angle = beta;
			Float cx;
			Float cy;
			Float bx = ( (Float)(0) );
			Float by = ( (Float)(0) );
			{
				int _g = 0;
				int _g1 = (totalSteps + 1);
				while((_g < _g1)){
					_g = (_g + 1);
					int i = (_g - 1);
					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
					if ((i != 0)) {
						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
						if (::hx::IsNotNull( m )) {
							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
						}
						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
					}
					angle = (angle + step1);
					bx = cx;
					by = cy;
				}
			}
			int len = totalSteps;
			{
				 ::trilateral3::drawing::Pen _this1 = _this->pen;
				int color = 0;
				if ((color == -1)) {
					color = _this1->currentColor;
				}
				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
			}
		}
		{
			Float radius1 = (width_ / ( (Float)(2) ));
			Float beta1 = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
			Float gamma1 = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
			 ::Dynamic drawType1 = _this->pen->drawType;
			 ::Dynamic sides1 = 36;
			if (::hx::IsNull( sides1 )) {
				sides1 = 36;
			}
			Float pi1 = ::Math_obj::PI;
			Float step2 = ((pi1 * ( (Float)(2) )) / ( (Float)(sides1) ));
			Float dif1;
			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
				case (int)0: {
					Float f;
					bool f1;
					if ((beta1 >= 0)) {
						f1 = (beta1 > ::Math_obj::PI);
					}
					else {
						f1 = false;
					}
					if (f1) {
						f = beta1;
					}
					else {
						Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f = a;
						}
						else {
							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this1 = f;
					Float za = this1;
					Float f2;
					bool f3;
					if ((gamma1 >= 0)) {
						f3 = (gamma1 > ::Math_obj::PI);
					}
					else {
						f3 = false;
					}
					if (f3) {
						f2 = gamma1;
					}
					else {
						Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f2 = a;
						}
						else {
							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this2 = f2;
					Float zb = this2;
					Float fa = za;
					Float fb = zb;
					Float theta = ::Math_obj::abs((fa - fb));
					bool clockwise = (fa < fb);
					Float dif;
					if (clockwise) {
						dif = theta;
					}
					else {
						dif = -(theta);
					}
					if ((dif > 0)) {
						dif1 = dif;
					}
					else {
						dif1 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
					}
				}
				break;
				case (int)1: {
					Float f;
					bool f1;
					if ((beta1 >= 0)) {
						f1 = (beta1 > ::Math_obj::PI);
					}
					else {
						f1 = false;
					}
					if (f1) {
						f = beta1;
					}
					else {
						Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f = a;
						}
						else {
							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this1 = f;
					Float za = this1;
					Float f2;
					bool f3;
					if ((gamma1 >= 0)) {
						f3 = (gamma1 > ::Math_obj::PI);
					}
					else {
						f3 = false;
					}
					if (f3) {
						f2 = gamma1;
					}
					else {
						Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f2 = a;
						}
						else {
							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this2 = f2;
					Float zb = this2;
					Float fa = za;
					Float fb = zb;
					Float theta = ::Math_obj::abs((fa - fb));
					bool clockwise = (fa < fb);
					Float dif;
					if (clockwise) {
						dif = theta;
					}
					else {
						dif = -(theta);
					}
					if ((dif < 0)) {
						dif1 = dif;
					}
					else {
						dif1 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
					}
				}
				break;
				case (int)2: {
					Float f;
					bool f1;
					if ((beta1 >= 0)) {
						f1 = (beta1 > ::Math_obj::PI);
					}
					else {
						f1 = false;
					}
					if (f1) {
						f = beta1;
					}
					else {
						Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f = a;
						}
						else {
							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this1 = f;
					Float za = this1;
					Float f2;
					bool f3;
					if ((gamma1 >= 0)) {
						f3 = (gamma1 > ::Math_obj::PI);
					}
					else {
						f3 = false;
					}
					if (f3) {
						f2 = gamma1;
					}
					else {
						Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f2 = a;
						}
						else {
							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this2 = f2;
					Float zb = this2;
					Float fa = za;
					Float fb = zb;
					Float theta = ::Math_obj::abs((fa - fb));
					bool smallest = (theta <= ::Math_obj::PI);
					bool clockwise = (fa < fb);
					Float dif;
					if (clockwise) {
						dif = theta;
					}
					else {
						dif = -(theta);
					}
					if (smallest) {
						dif1 = dif;
					}
					else {
						if (clockwise) {
							dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
						}
						else {
							dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
						}
					}
				}
				break;
				case (int)3: {
					Float f;
					bool f1;
					if ((beta1 >= 0)) {
						f1 = (beta1 > ::Math_obj::PI);
					}
					else {
						f1 = false;
					}
					if (f1) {
						f = beta1;
					}
					else {
						Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f = a;
						}
						else {
							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this1 = f;
					Float za = this1;
					Float f2;
					bool f3;
					if ((gamma1 >= 0)) {
						f3 = (gamma1 > ::Math_obj::PI);
					}
					else {
						f3 = false;
					}
					if (f3) {
						f2 = gamma1;
					}
					else {
						Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f2 = a;
						}
						else {
							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this2 = f2;
					Float zb = this2;
					Float fa = za;
					Float fb = zb;
					Float theta = ::Math_obj::abs((fa - fb));
					bool largest = (theta > ::Math_obj::PI);
					bool clockwise = (fa < fb);
					Float dif;
					if (clockwise) {
						dif = theta;
					}
					else {
						dif = -(theta);
					}
					if (largest) {
						dif1 = dif;
					}
					else {
						if (clockwise) {
							dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
						}
						else {
							dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
						}
					}
				}
				break;
			}
			bool positive1 = (dif1 >= 0);
			int totalSteps1 = ::Math_obj::ceil((::Math_obj::abs(dif1) / step2));
			Float step3 = (dif1 / ( (Float)(totalSteps1) ));
			Float angle1 = beta1;
			Float cx1;
			Float cy1;
			Float bx1 = ( (Float)(0) );
			Float by1 = ( (Float)(0) );
			{
				int _g2 = 0;
				int _g3 = (totalSteps1 + 1);
				while((_g2 < _g3)){
					_g2 = (_g2 + 1);
					int i = (_g2 - 1);
					cx1 = (x_ + (radius1 * ::Math_obj::sin(angle1)));
					cy1 = (y_ + (radius1 * ::Math_obj::cos(angle1)));
					if ((i != 0)) {
						drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(x_,y_,0,bx1,by1,0,cx1,cy1,0);
						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
						if (::hx::IsNotNull( m )) {
							drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
						}
						drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
					}
					angle1 = (angle1 + step3);
					bx1 = cx1;
					by1 = cy1;
				}
			}
			int len1 = totalSteps1;
			{
				 ::trilateral3::drawing::Pen _this2 = _this->pen;
				int color1 = 0;
				if ((color1 == -1)) {
					color1 = _this2->currentColor;
				}
				_this2->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
			}
		}
		goto _hx_goto_0;
	}
	_hx_goto_0:;
	{
		 ::trilateral3::drawing::Pen _this1 = _this->pen;
		int color = -1;
		if ((color == -1)) {
			color = _this1->currentColor;
		}
		{
			_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(exPrev_) ),( (Float)(eyPrev_) ),0);
			if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
				_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
			}
			_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
		}
		_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
	}
	{
		 ::trilateral3::drawing::Pen _this2 = _this->pen;
		int color1 = -1;
		if ((color1 == -1)) {
			color1 = _this2->currentColor;
		}
		{
			_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
			if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
				_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
			}
			_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
		}
		_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
	}
}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,roundEndLine,(void))

void Sketch_obj::mediumLine(Float x_,Float y_){
	 ::trilateral3::drawing::Contour _this = this->contour;
	Float ax_ = this->x;
	Float ay_ = this->y;
	Float width_ = this->width;
	bool overlap = false;
	 ::Dynamic oldAngle;
	if (::hx::IsNotNull( _this->dx )) {
		oldAngle = _this->angle1;
	}
	else {
		oldAngle = null();
	}
	_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
	_this->ax = x_;
	_this->ay = y_;
	_this->bx = ax_;
	_this->by = ay_;
	_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
	_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
	{
		{
			_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
			if ((_this->theta > 0)) {
				if ((_this->halfA < 0)) {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
				else {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
			}
			else {
				if ((_this->halfA > 0)) {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
				else {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
			}
		}
		if (::hx::IsNotNull( _this->dxPrev )) {
			_this->dxOld = _this->dxPrev;
		}
		if (::hx::IsNotNull( _this->dyPrev )) {
			_this->dyOld = _this->dyPrev;
		}
		if (::hx::IsNotNull( _this->exPrev )) {
			_this->exOld = _this->exPrev;
		}
		if (::hx::IsNotNull( _this->eyPrev )) {
			_this->eyOld = _this->eyPrev;
		}
		if (::hx::IsNotNull( _this->dx )) {
			_this->dxPrev = _this->dx;
		}
		if (::hx::IsNotNull( _this->dy )) {
			_this->dyPrev = _this->dy;
		}
		if (::hx::IsNotNull( _this->ex )) {
			_this->exPrev = _this->ex;
		}
		if (::hx::IsNotNull( _this->ey )) {
			_this->eyPrev = _this->ey;
		}
		_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
		_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
		_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
		_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
	}
	_this->ax = ax_;
	_this->ay = ay_;
	_this->bx = x_;
	_this->by = y_;
	{
		{
			_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
			if ((_this->theta > 0)) {
				if ((_this->halfA < 0)) {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
				else {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
			}
			else {
				if ((_this->halfA > 0)) {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
				else {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
			}
		}
		if (::hx::IsNotNull( _this->dxPrev )) {
			_this->dxOld = _this->dxPrev;
		}
		if (::hx::IsNotNull( _this->dyPrev )) {
			_this->dyOld = _this->dyPrev;
		}
		if (::hx::IsNotNull( _this->exPrev )) {
			_this->exOld = _this->exPrev;
		}
		if (::hx::IsNotNull( _this->eyPrev )) {
			_this->eyOld = _this->eyPrev;
		}
		if (::hx::IsNotNull( _this->dx )) {
			_this->dxPrev = _this->dx;
		}
		if (::hx::IsNotNull( _this->dy )) {
			_this->dyPrev = _this->dy;
		}
		if (::hx::IsNotNull( _this->ex )) {
			_this->exPrev = _this->ex;
		}
		if (::hx::IsNotNull( _this->ey )) {
			_this->eyPrev = _this->ey;
		}
		_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
		_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
		_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
		_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
	}
	Float x = (( (Float)(_this->dxOld) ) - x_);
	Float y = (( (Float)(_this->dyOld) ) - y_);
	Float x1 = (( (Float)(_this->exOld) ) - x_);
	Float y1 = (( (Float)(_this->eyOld) ) - y_);
	bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
	Float theta0;
	Float theta1;
	if (clockWise) {
		theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
		theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
	}
	else {
		theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
		theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
	}
	Float dif;
	switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
		case (int)0: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if ((dif1 > 0)) {
				dif = dif1;
			}
			else {
				dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
			}
		}
		break;
		case (int)1: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if ((dif1 < 0)) {
				dif = dif1;
			}
			else {
				dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
			}
		}
		break;
		case (int)2: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool smallest = (theta <= ::Math_obj::PI);
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if (smallest) {
				dif = dif1;
			}
			else {
				if (clockwise) {
					dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
				}
			}
		}
		break;
		case (int)3: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool largest = (theta > ::Math_obj::PI);
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if (largest) {
				dif = dif1;
			}
			else {
				if (clockwise) {
					dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
				}
			}
		}
		break;
	}
	bool _hx_tmp;
	if (!(overlap)) {
		_hx_tmp = (_this->count != 0);
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
		Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
		Float f;
		bool f1;
		if ((theta0 <= ::Math_obj::PI)) {
			f1 = (theta0 > -(::Math_obj::PI));
		}
		else {
			f1 = false;
		}
		if (f1) {
			f = theta0;
		}
		else {
			Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
			if ((a >= 0)) {
				f = (a - ::Math_obj::PI);
			}
			else {
				f = (a + ::Math_obj::PI);
			}
		}
		Float this1 = f;
		Float start = this1;
		Float start2 = start;
		Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
		_this->jx = (_this->ax + (h * ::Math_obj::sin(delta)));
		_this->jy = (_this->ay + (h * ::Math_obj::cos(delta)));
	}
	bool _hx_tmp1;
	if ((_this->count == 0)) {
		if ((_this->endLine != 1)) {
			_hx_tmp1 = (_this->endLine == 3);
		}
		else {
			_hx_tmp1 = true;
		}
	}
	else {
		_hx_tmp1 = false;
	}
	if (_hx_tmp1) {
		Float ax = _this->ax;
		Float ay = _this->ay;
		Float radius = (width_ / ( (Float)(2) ));
		Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
		Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
		::Array< Float > temp = ::Array_obj< Float >::__new();
		 ::Dynamic drawType = _this->pen->drawType;
		 ::Dynamic sides = 36;
		if (::hx::IsNull( sides )) {
			sides = 36;
		}
		Float pi = ::Math_obj::PI;
		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
		Float dif;
		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
			case (int)0: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if ((dif1 > 0)) {
					dif = dif1;
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
				}
			}
			break;
			case (int)1: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if ((dif1 < 0)) {
					dif = dif1;
				}
				else {
					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
				}
			}
			break;
			case (int)2: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool smallest = (theta <= ::Math_obj::PI);
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if (smallest) {
					dif = dif1;
				}
				else {
					if (clockwise) {
						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
					}
				}
			}
			break;
			case (int)3: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool largest = (theta > ::Math_obj::PI);
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if (largest) {
					dif = dif1;
				}
				else {
					if (clockwise) {
						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
					}
				}
			}
			break;
		}
		bool positive = (dif >= 0);
		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
		Float step1 = (dif / ( (Float)(totalSteps) ));
		Float angle = beta;
		Float cx;
		Float cy;
		Float bx = ( (Float)(0) );
		Float by = ( (Float)(0) );
		int p2 = temp->length;
		{
			int _g = 0;
			int _g1 = (totalSteps + 1);
			while((_g < _g1)){
				_g = (_g + 1);
				int i = (_g - 1);
				cx = (ax + (radius * ::Math_obj::sin(angle)));
				cy = (ay + (radius * ::Math_obj::cos(angle)));
				p2 = (p2 + 1);
				temp[(p2 - 1)] = cx;
				p2 = (p2 + 1);
				temp[(p2 - 1)] = cy;
				if ((i != 0)) {
					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
					if (::hx::IsNotNull( m )) {
						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
					}
					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				angle = (angle + step1);
				bx = cx;
				by = cy;
			}
		}
		int len = totalSteps;
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
		}
		int pA = _this->pointsAnti->length;
		int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
		int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
		{
			int _g2 = 0;
			int _g3 = p4;
			while((_g2 < _g3)){
				_g2 = (_g2 + 1);
				int i = (_g2 - 1);
				pA = (pA + 1);
				_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
				pA = (pA + 1);
				_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
			}
		}
		int pC = _this->pointsClock->length;
		{
			int _g4 = 0;
			int _g5 = p4;
			while((_g4 < _g5)){
				_g4 = (_g4 + 1);
				int i = (_g4 - 1);
				pC = (pC + 1);
				_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
				pC = (pC + 1);
				_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
			}
		}
	}
	if (overlap) {
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			{
				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
				}
				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
			}
			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
		}
		{
			 ::trilateral3::drawing::Pen _this2 = _this->pen;
			int color1 = -1;
			if ((color1 == -1)) {
				color1 = _this2->currentColor;
			}
			{
				_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
					_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
				}
				_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
			}
			_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
		}
	}
	else {
		if ((_this->count != 0)) {
			_this->addQuads(clockWise,width_);
		}
		{
			_this->quadIndex = ( (Float)(_this->pen->drawType->__Field(HX_("get_pos",2b,26,ca,26),::hx::paccDynamic)()) );
			if ((_this->count == 0)) {
				_this->penultimateAX = ( (Float)(_this->dxPrev) );
				_this->penultimateAY = ( (Float)(_this->dyPrev) );
				_this->lastAntiX = ( (Float)(_this->ex) );
				_this->lastAntiY = ( (Float)(_this->ey) );
				_this->penultimateCX = ( (Float)(_this->dx) );
				_this->penultimateCY = ( (Float)(_this->dy) );
				_this->lastClockX = ( (Float)(_this->exPrev) );
				_this->lastClockY = ( (Float)(_this->eyPrev) );
				{
					 ::trilateral3::drawing::Pen _this1 = _this->pen;
					int color = -1;
					if ((color == -1)) {
						color = _this1->currentColor;
					}
					{
						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
						}
						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
					}
					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
				}
				{
					 ::trilateral3::drawing::Pen _this2 = _this->pen;
					int color1 = -1;
					if ((color1 == -1)) {
						color1 = _this2->currentColor;
					}
					{
						_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
							_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
						}
						_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
					}
					_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
				}
			}
			else {
				bool _hx_tmp;
				if (clockWise) {
					_hx_tmp = !(_this->lastClock);
				}
				else {
					_hx_tmp = false;
				}
				if (_hx_tmp) {
					_this->penultimateAX = _this->jx;
					_this->penultimateAY = _this->jy;
					_this->lastAntiX = ( (Float)(_this->ex) );
					_this->lastAntiY = ( (Float)(_this->ey) );
					_this->penultimateCX = ( (Float)(_this->dx) );
					_this->penultimateCY = ( (Float)(_this->dy) );
					_this->lastClockX = ( (Float)(_this->exPrev) );
					_this->lastClockY = ( (Float)(_this->eyPrev) );
					{
						 ::trilateral3::drawing::Pen _this1 = _this->pen;
						int color = -1;
						if ((color == -1)) {
							color = _this1->currentColor;
						}
						{
							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
					}
					{
						 ::trilateral3::drawing::Pen _this2 = _this->pen;
						int color1 = -1;
						if ((color1 == -1)) {
							color1 = _this2->currentColor;
						}
						{
							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
					}
				}
				bool _hx_tmp1;
				if (clockWise) {
					_hx_tmp1 = _this->lastClock;
				}
				else {
					_hx_tmp1 = false;
				}
				if (_hx_tmp1) {
					_this->penultimateAX = _this->jx;
					_this->penultimateAY = _this->jy;
					_this->lastAntiX = ( (Float)(_this->ex) );
					_this->lastAntiY = ( (Float)(_this->ey) );
					_this->penultimateCX = ( (Float)(_this->dx) );
					_this->penultimateCY = ( (Float)(_this->dy) );
					_this->lastClockX = ( (Float)(_this->exPrev) );
					_this->lastClockY = ( (Float)(_this->eyPrev) );
					{
						 ::trilateral3::drawing::Pen _this1 = _this->pen;
						int color = -1;
						if ((color == -1)) {
							color = _this1->currentColor;
						}
						{
							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
					}
					{
						 ::trilateral3::drawing::Pen _this2 = _this->pen;
						int color1 = -1;
						if ((color1 == -1)) {
							color1 = _this2->currentColor;
						}
						{
							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
					}
				}
				bool _hx_tmp2;
				if (!(clockWise)) {
					_hx_tmp2 = !(_this->lastClock);
				}
				else {
					_hx_tmp2 = false;
				}
				if (_hx_tmp2) {
					_this->penultimateCX = ( (Float)(_this->dx) );
					_this->penultimateCY = ( (Float)(_this->dy) );
					_this->lastClockX = _this->jx;
					_this->lastClockY = _this->jy;
					_this->penultimateAX = ( (Float)(_this->dxPrev) );
					_this->penultimateAY = ( (Float)(_this->dyPrev) );
					_this->lastAntiX = ( (Float)(_this->ex) );
					_this->lastAntiY = ( (Float)(_this->ey) );
					{
						 ::trilateral3::drawing::Pen _this1 = _this->pen;
						int color = -1;
						if ((color == -1)) {
							color = _this1->currentColor;
						}
						{
							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,_this->jx,_this->jy,0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
					}
					{
						 ::trilateral3::drawing::Pen _this2 = _this->pen;
						int color1 = -1;
						if ((color1 == -1)) {
							color1 = _this2->currentColor;
						}
						{
							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
					}
				}
				bool _hx_tmp3;
				if (!(clockWise)) {
					_hx_tmp3 = _this->lastClock;
				}
				else {
					_hx_tmp3 = false;
				}
				if (_hx_tmp3) {
					_this->penultimateAX = ( (Float)(_this->dxPrev) );
					_this->penultimateAY = ( (Float)(_this->dyPrev) );
					_this->lastAntiX = ( (Float)(_this->ex) );
					_this->lastAntiY = ( (Float)(_this->ey) );
					_this->penultimateCX = _this->jx;
					_this->penultimateCY = _this->jy;
					_this->lastClockX = ( (Float)(_this->dx) );
					_this->lastClockY = ( (Float)(_this->dy) );
					{
						 ::trilateral3::drawing::Pen _this1 = _this->pen;
						int color = -1;
						if ((color == -1)) {
							color = _this1->currentColor;
						}
						{
							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
					}
					{
						 ::trilateral3::drawing::Pen _this2 = _this->pen;
						int color1 = -1;
						if ((color1 == -1)) {
							color1 = _this2->currentColor;
						}
						{
							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
					}
				}
			}
		}
	}
	if ((_this->count != 0)) {
		if (overlap) {
			if (clockWise) {
				 ::trilateral3::drawing::Pen _this1 = _this->pen;
				int color = -1;
				if ((color == -1)) {
					color = _this1->currentColor;
				}
				{
					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->ax,_this->ay,0);
					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
					}
					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
			}
			else {
				 ::trilateral3::drawing::Pen _this1 = _this->pen;
				int color = -1;
				if ((color == -1)) {
					color = _this1->currentColor;
				}
				{
					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->ax,_this->ay,0);
					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
					}
					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
			}
		}
		else {
			if (clockWise) {
				 ::trilateral3::drawing::Pen _this1 = _this->pen;
				int color = -1;
				if ((color == -1)) {
					color = _this1->currentColor;
				}
				{
					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->jx,_this->jy,0);
					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
					}
					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
			}
			else {
				 ::trilateral3::drawing::Pen _this1 = _this->pen;
				int color = -1;
				if ((color == -1)) {
					color = _this1->currentColor;
				}
				{
					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0);
					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
					}
					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
			}
		}
	}
	{
		_this->kax = ( (Float)(_this->dxPrev) );
		_this->kay = ( (Float)(_this->dyPrev) );
		_this->kbx = ( (Float)(_this->dx) );
		_this->kby = ( (Float)(_this->dy) );
		_this->ncx = ( (Float)(_this->exPrev) );
		_this->ncy = ( (Float)(_this->eyPrev) );
		_this->kcx = ( (Float)(_this->ex) );
		_this->kcy = ( (Float)(_this->ey) );
	}
	_this->jxOld = _this->jx;
	_this->jyOld = _this->jy;
	_this->lastClock = clockWise;
	_this->count++;
}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,mediumLine,(void))

void Sketch_obj::mediumOverlapLine(Float x_,Float y_){
	 ::trilateral3::drawing::Contour _this = this->contour;
	Float ax_ = this->x;
	Float ay_ = this->y;
	Float width_ = this->width;
	 ::Dynamic oldAngle;
	if (::hx::IsNotNull( _this->dx )) {
		oldAngle = _this->angle1;
	}
	else {
		oldAngle = null();
	}
	_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
	_this->ax = x_;
	_this->ay = y_;
	_this->bx = ax_;
	_this->by = ay_;
	_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
	_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
	{
		{
			_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
			if ((_this->theta > 0)) {
				if ((_this->halfA < 0)) {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
				else {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
			}
			else {
				if ((_this->halfA > 0)) {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
				else {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
			}
		}
		if (::hx::IsNotNull( _this->dxPrev )) {
			_this->dxOld = _this->dxPrev;
		}
		if (::hx::IsNotNull( _this->dyPrev )) {
			_this->dyOld = _this->dyPrev;
		}
		if (::hx::IsNotNull( _this->exPrev )) {
			_this->exOld = _this->exPrev;
		}
		if (::hx::IsNotNull( _this->eyPrev )) {
			_this->eyOld = _this->eyPrev;
		}
		if (::hx::IsNotNull( _this->dx )) {
			_this->dxPrev = _this->dx;
		}
		if (::hx::IsNotNull( _this->dy )) {
			_this->dyPrev = _this->dy;
		}
		if (::hx::IsNotNull( _this->ex )) {
			_this->exPrev = _this->ex;
		}
		if (::hx::IsNotNull( _this->ey )) {
			_this->eyPrev = _this->ey;
		}
		_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
		_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
		_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
		_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
	}
	_this->ax = ax_;
	_this->ay = ay_;
	_this->bx = x_;
	_this->by = y_;
	{
		{
			_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
			if ((_this->theta > 0)) {
				if ((_this->halfA < 0)) {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
				else {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
			}
			else {
				if ((_this->halfA > 0)) {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
				else {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
			}
		}
		if (::hx::IsNotNull( _this->dxPrev )) {
			_this->dxOld = _this->dxPrev;
		}
		if (::hx::IsNotNull( _this->dyPrev )) {
			_this->dyOld = _this->dyPrev;
		}
		if (::hx::IsNotNull( _this->exPrev )) {
			_this->exOld = _this->exPrev;
		}
		if (::hx::IsNotNull( _this->eyPrev )) {
			_this->eyOld = _this->eyPrev;
		}
		if (::hx::IsNotNull( _this->dx )) {
			_this->dxPrev = _this->dx;
		}
		if (::hx::IsNotNull( _this->dy )) {
			_this->dyPrev = _this->dy;
		}
		if (::hx::IsNotNull( _this->ex )) {
			_this->exPrev = _this->ex;
		}
		if (::hx::IsNotNull( _this->ey )) {
			_this->eyPrev = _this->ey;
		}
		_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
		_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
		_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
		_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
	}
	Float x = (( (Float)(_this->dxOld) ) - x_);
	Float y = (( (Float)(_this->dyOld) ) - y_);
	Float x1 = (( (Float)(_this->exOld) ) - x_);
	Float y1 = (( (Float)(_this->eyOld) ) - y_);
	bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
	Float theta0;
	Float theta1;
	if (clockWise) {
		theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
		theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
	}
	else {
		theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
		theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
	}
	Float dif;
	switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
		case (int)0: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if ((dif1 > 0)) {
				dif = dif1;
			}
			else {
				dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
			}
		}
		break;
		case (int)1: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if ((dif1 < 0)) {
				dif = dif1;
			}
			else {
				dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
			}
		}
		break;
		case (int)2: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool smallest = (theta <= ::Math_obj::PI);
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if (smallest) {
				dif = dif1;
			}
			else {
				if (clockwise) {
					dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
				}
			}
		}
		break;
		case (int)3: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool largest = (theta > ::Math_obj::PI);
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if (largest) {
				dif = dif1;
			}
			else {
				if (clockwise) {
					dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
				}
			}
		}
		break;
	}
	bool _hx_tmp;
	if ((_this->count == 0)) {
		if ((_this->endLine != 1)) {
			_hx_tmp = (_this->endLine == 3);
		}
		else {
			_hx_tmp = true;
		}
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		Float ax = _this->ax;
		Float ay = _this->ay;
		Float radius = (width_ / ( (Float)(2) ));
		Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
		Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
		::Array< Float > temp = ::Array_obj< Float >::__new();
		 ::Dynamic drawType = _this->pen->drawType;
		 ::Dynamic sides = 36;
		if (::hx::IsNull( sides )) {
			sides = 36;
		}
		Float pi = ::Math_obj::PI;
		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
		Float dif;
		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
			case (int)0: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if ((dif1 > 0)) {
					dif = dif1;
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
				}
			}
			break;
			case (int)1: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if ((dif1 < 0)) {
					dif = dif1;
				}
				else {
					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
				}
			}
			break;
			case (int)2: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool smallest = (theta <= ::Math_obj::PI);
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if (smallest) {
					dif = dif1;
				}
				else {
					if (clockwise) {
						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
					}
				}
			}
			break;
			case (int)3: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool largest = (theta > ::Math_obj::PI);
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if (largest) {
					dif = dif1;
				}
				else {
					if (clockwise) {
						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
					}
				}
			}
			break;
		}
		bool positive = (dif >= 0);
		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
		Float step1 = (dif / ( (Float)(totalSteps) ));
		Float angle = beta;
		Float cx;
		Float cy;
		Float bx = ( (Float)(0) );
		Float by = ( (Float)(0) );
		int p2 = temp->length;
		{
			int _g = 0;
			int _g1 = (totalSteps + 1);
			while((_g < _g1)){
				_g = (_g + 1);
				int i = (_g - 1);
				cx = (ax + (radius * ::Math_obj::sin(angle)));
				cy = (ay + (radius * ::Math_obj::cos(angle)));
				p2 = (p2 + 1);
				temp[(p2 - 1)] = cx;
				p2 = (p2 + 1);
				temp[(p2 - 1)] = cy;
				if ((i != 0)) {
					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
					if (::hx::IsNotNull( m )) {
						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
					}
					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				angle = (angle + step1);
				bx = cx;
				by = cy;
			}
		}
		int len = totalSteps;
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
		}
		int pA = _this->pointsAnti->length;
		int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
		int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
		{
			int _g2 = 0;
			int _g3 = p4;
			while((_g2 < _g3)){
				_g2 = (_g2 + 1);
				int i = (_g2 - 1);
				pA = (pA + 1);
				_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
				pA = (pA + 1);
				_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
			}
		}
		int pC = _this->pointsClock->length;
		{
			int _g4 = 0;
			int _g5 = p4;
			while((_g4 < _g5)){
				_g4 = (_g4 + 1);
				int i = (_g4 - 1);
				pC = (pC + 1);
				_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
				pC = (pC + 1);
				_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
			}
		}
	}
	{
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			{
				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
				}
				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
			}
			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
		}
		{
			 ::trilateral3::drawing::Pen _this2 = _this->pen;
			int color1 = -1;
			if ((color1 == -1)) {
				color1 = _this2->currentColor;
			}
			{
				_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
					_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
				}
				_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
			}
			_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
		}
	}
	if ((_this->count != 0)) {
		if (clockWise) {
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			{
				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->ax,_this->ay,0);
				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
				}
				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
			}
			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
		}
		else {
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			{
				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->ax,_this->ay,0);
				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
				}
				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
			}
			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
		}
	}
	{
		_this->kax = ( (Float)(_this->dxPrev) );
		_this->kay = ( (Float)(_this->dyPrev) );
		_this->kbx = ( (Float)(_this->dx) );
		_this->kby = ( (Float)(_this->dy) );
		_this->ncx = ( (Float)(_this->exPrev) );
		_this->ncy = ( (Float)(_this->eyPrev) );
		_this->kcx = ( (Float)(_this->ex) );
		_this->kcy = ( (Float)(_this->ey) );
	}
	_this->jxOld = _this->jx;
	_this->jyOld = _this->jy;
	_this->lastClock = clockWise;
	_this->count++;
}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,mediumOverlapLine,(void))

void Sketch_obj::fineLine(Float x_,Float y_){
	 ::trilateral3::drawing::Contour _this = this->contour;
	Float ax_ = this->x;
	Float ay_ = this->y;
	Float width_ = this->width;
	bool overlap = false;
	 ::Dynamic oldAngle;
	if (::hx::IsNotNull( _this->dx )) {
		oldAngle = _this->angle1;
	}
	else {
		oldAngle = null();
	}
	_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
	_this->ax = x_;
	_this->ay = y_;
	_this->bx = ax_;
	_this->by = ay_;
	_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
	_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
	{
		{
			_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
			if ((_this->theta > 0)) {
				if ((_this->halfA < 0)) {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
				else {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
			}
			else {
				if ((_this->halfA > 0)) {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
				else {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
			}
		}
		if (::hx::IsNotNull( _this->dxPrev )) {
			_this->dxOld = _this->dxPrev;
		}
		if (::hx::IsNotNull( _this->dyPrev )) {
			_this->dyOld = _this->dyPrev;
		}
		if (::hx::IsNotNull( _this->exPrev )) {
			_this->exOld = _this->exPrev;
		}
		if (::hx::IsNotNull( _this->eyPrev )) {
			_this->eyOld = _this->eyPrev;
		}
		if (::hx::IsNotNull( _this->dx )) {
			_this->dxPrev = _this->dx;
		}
		if (::hx::IsNotNull( _this->dy )) {
			_this->dyPrev = _this->dy;
		}
		if (::hx::IsNotNull( _this->ex )) {
			_this->exPrev = _this->ex;
		}
		if (::hx::IsNotNull( _this->ey )) {
			_this->eyPrev = _this->ey;
		}
		_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
		_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
		_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
		_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
	}
	_this->ax = ax_;
	_this->ay = ay_;
	_this->bx = x_;
	_this->by = y_;
	{
		{
			_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
			if ((_this->theta > 0)) {
				if ((_this->halfA < 0)) {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
				else {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
			}
			else {
				if ((_this->halfA > 0)) {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
				else {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
			}
		}
		if (::hx::IsNotNull( _this->dxPrev )) {
			_this->dxOld = _this->dxPrev;
		}
		if (::hx::IsNotNull( _this->dyPrev )) {
			_this->dyOld = _this->dyPrev;
		}
		if (::hx::IsNotNull( _this->exPrev )) {
			_this->exOld = _this->exPrev;
		}
		if (::hx::IsNotNull( _this->eyPrev )) {
			_this->eyOld = _this->eyPrev;
		}
		if (::hx::IsNotNull( _this->dx )) {
			_this->dxPrev = _this->dx;
		}
		if (::hx::IsNotNull( _this->dy )) {
			_this->dyPrev = _this->dy;
		}
		if (::hx::IsNotNull( _this->ex )) {
			_this->exPrev = _this->ex;
		}
		if (::hx::IsNotNull( _this->ey )) {
			_this->eyPrev = _this->ey;
		}
		_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
		_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
		_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
		_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
	}
	Float x = (( (Float)(_this->dxOld) ) - x_);
	Float y = (( (Float)(_this->dyOld) ) - y_);
	Float x1 = (( (Float)(_this->exOld) ) - x_);
	Float y1 = (( (Float)(_this->eyOld) ) - y_);
	bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
	Float theta0;
	Float theta1;
	if (clockWise) {
		theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
		theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
	}
	else {
		theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
		theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
	}
	Float dif;
	switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
		case (int)0: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if ((dif1 > 0)) {
				dif = dif1;
			}
			else {
				dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
			}
		}
		break;
		case (int)1: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if ((dif1 < 0)) {
				dif = dif1;
			}
			else {
				dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
			}
		}
		break;
		case (int)2: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool smallest = (theta <= ::Math_obj::PI);
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if (smallest) {
				dif = dif1;
			}
			else {
				if (clockwise) {
					dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
				}
			}
		}
		break;
		case (int)3: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool largest = (theta > ::Math_obj::PI);
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if (largest) {
				dif = dif1;
			}
			else {
				if (clockwise) {
					dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
				}
			}
		}
		break;
	}
	bool _hx_tmp;
	if (!(overlap)) {
		_hx_tmp = (_this->count != 0);
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
		Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
		Float f;
		bool f1;
		if ((theta0 <= ::Math_obj::PI)) {
			f1 = (theta0 > -(::Math_obj::PI));
		}
		else {
			f1 = false;
		}
		if (f1) {
			f = theta0;
		}
		else {
			Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
			if ((a >= 0)) {
				f = (a - ::Math_obj::PI);
			}
			else {
				f = (a + ::Math_obj::PI);
			}
		}
		Float this1 = f;
		Float start = this1;
		Float start2 = start;
		Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
		_this->jx = (_this->ax + (h * ::Math_obj::sin(delta)));
		_this->jy = (_this->ay + (h * ::Math_obj::cos(delta)));
	}
	bool _hx_tmp1;
	if ((_this->count == 0)) {
		if ((_this->endLine != 1)) {
			_hx_tmp1 = (_this->endLine == 3);
		}
		else {
			_hx_tmp1 = true;
		}
	}
	else {
		_hx_tmp1 = false;
	}
	if (_hx_tmp1) {
		Float ax = _this->ax;
		Float ay = _this->ay;
		Float radius = (width_ / ( (Float)(2) ));
		Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
		Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
		::Array< Float > temp = ::Array_obj< Float >::__new();
		 ::Dynamic drawType = _this->pen->drawType;
		 ::Dynamic sides = 36;
		if (::hx::IsNull( sides )) {
			sides = 36;
		}
		Float pi = ::Math_obj::PI;
		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
		Float dif;
		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
			case (int)0: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if ((dif1 > 0)) {
					dif = dif1;
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
				}
			}
			break;
			case (int)1: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if ((dif1 < 0)) {
					dif = dif1;
				}
				else {
					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
				}
			}
			break;
			case (int)2: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool smallest = (theta <= ::Math_obj::PI);
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if (smallest) {
					dif = dif1;
				}
				else {
					if (clockwise) {
						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
					}
				}
			}
			break;
			case (int)3: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool largest = (theta > ::Math_obj::PI);
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if (largest) {
					dif = dif1;
				}
				else {
					if (clockwise) {
						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
					}
				}
			}
			break;
		}
		bool positive = (dif >= 0);
		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
		Float step1 = (dif / ( (Float)(totalSteps) ));
		Float angle = beta;
		Float cx;
		Float cy;
		Float bx = ( (Float)(0) );
		Float by = ( (Float)(0) );
		int p2 = temp->length;
		{
			int _g = 0;
			int _g1 = (totalSteps + 1);
			while((_g < _g1)){
				_g = (_g + 1);
				int i = (_g - 1);
				cx = (ax + (radius * ::Math_obj::sin(angle)));
				cy = (ay + (radius * ::Math_obj::cos(angle)));
				p2 = (p2 + 1);
				temp[(p2 - 1)] = cx;
				p2 = (p2 + 1);
				temp[(p2 - 1)] = cy;
				if ((i != 0)) {
					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
					if (::hx::IsNotNull( m )) {
						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
					}
					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				angle = (angle + step1);
				bx = cx;
				by = cy;
			}
		}
		int len = totalSteps;
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
		}
		int pA = _this->pointsAnti->length;
		int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
		int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
		{
			int _g2 = 0;
			int _g3 = p4;
			while((_g2 < _g3)){
				_g2 = (_g2 + 1);
				int i = (_g2 - 1);
				pA = (pA + 1);
				_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
				pA = (pA + 1);
				_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
			}
		}
		int pC = _this->pointsClock->length;
		{
			int _g4 = 0;
			int _g5 = p4;
			while((_g4 < _g5)){
				_g4 = (_g4 + 1);
				int i = (_g4 - 1);
				pC = (pC + 1);
				_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
				pC = (pC + 1);
				_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
			}
		}
	}
	if (overlap) {
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			{
				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
				}
				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
			}
			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
		}
		{
			 ::trilateral3::drawing::Pen _this2 = _this->pen;
			int color1 = -1;
			if ((color1 == -1)) {
				color1 = _this2->currentColor;
			}
			{
				_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
					_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
				}
				_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
			}
			_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
		}
	}
	else {
		if ((_this->count != 0)) {
			_this->addQuads(clockWise,width_);
		}
		{
			_this->quadIndex = ( (Float)(_this->pen->drawType->__Field(HX_("get_pos",2b,26,ca,26),::hx::paccDynamic)()) );
			if ((_this->count == 0)) {
				_this->penultimateAX = ( (Float)(_this->dxPrev) );
				_this->penultimateAY = ( (Float)(_this->dyPrev) );
				_this->lastAntiX = ( (Float)(_this->ex) );
				_this->lastAntiY = ( (Float)(_this->ey) );
				_this->penultimateCX = ( (Float)(_this->dx) );
				_this->penultimateCY = ( (Float)(_this->dy) );
				_this->lastClockX = ( (Float)(_this->exPrev) );
				_this->lastClockY = ( (Float)(_this->eyPrev) );
				{
					 ::trilateral3::drawing::Pen _this1 = _this->pen;
					int color = -1;
					if ((color == -1)) {
						color = _this1->currentColor;
					}
					{
						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
						}
						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
					}
					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
				}
				{
					 ::trilateral3::drawing::Pen _this2 = _this->pen;
					int color1 = -1;
					if ((color1 == -1)) {
						color1 = _this2->currentColor;
					}
					{
						_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
							_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
						}
						_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
					}
					_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
				}
			}
			else {
				bool _hx_tmp;
				if (clockWise) {
					_hx_tmp = !(_this->lastClock);
				}
				else {
					_hx_tmp = false;
				}
				if (_hx_tmp) {
					_this->penultimateAX = _this->jx;
					_this->penultimateAY = _this->jy;
					_this->lastAntiX = ( (Float)(_this->ex) );
					_this->lastAntiY = ( (Float)(_this->ey) );
					_this->penultimateCX = ( (Float)(_this->dx) );
					_this->penultimateCY = ( (Float)(_this->dy) );
					_this->lastClockX = ( (Float)(_this->exPrev) );
					_this->lastClockY = ( (Float)(_this->eyPrev) );
					{
						 ::trilateral3::drawing::Pen _this1 = _this->pen;
						int color = -1;
						if ((color == -1)) {
							color = _this1->currentColor;
						}
						{
							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
					}
					{
						 ::trilateral3::drawing::Pen _this2 = _this->pen;
						int color1 = -1;
						if ((color1 == -1)) {
							color1 = _this2->currentColor;
						}
						{
							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
					}
				}
				bool _hx_tmp1;
				if (clockWise) {
					_hx_tmp1 = _this->lastClock;
				}
				else {
					_hx_tmp1 = false;
				}
				if (_hx_tmp1) {
					_this->penultimateAX = _this->jx;
					_this->penultimateAY = _this->jy;
					_this->lastAntiX = ( (Float)(_this->ex) );
					_this->lastAntiY = ( (Float)(_this->ey) );
					_this->penultimateCX = ( (Float)(_this->dx) );
					_this->penultimateCY = ( (Float)(_this->dy) );
					_this->lastClockX = ( (Float)(_this->exPrev) );
					_this->lastClockY = ( (Float)(_this->eyPrev) );
					{
						 ::trilateral3::drawing::Pen _this1 = _this->pen;
						int color = -1;
						if ((color == -1)) {
							color = _this1->currentColor;
						}
						{
							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
					}
					{
						 ::trilateral3::drawing::Pen _this2 = _this->pen;
						int color1 = -1;
						if ((color1 == -1)) {
							color1 = _this2->currentColor;
						}
						{
							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
					}
				}
				bool _hx_tmp2;
				if (!(clockWise)) {
					_hx_tmp2 = !(_this->lastClock);
				}
				else {
					_hx_tmp2 = false;
				}
				if (_hx_tmp2) {
					_this->penultimateCX = ( (Float)(_this->dx) );
					_this->penultimateCY = ( (Float)(_this->dy) );
					_this->lastClockX = _this->jx;
					_this->lastClockY = _this->jy;
					_this->penultimateAX = ( (Float)(_this->dxPrev) );
					_this->penultimateAY = ( (Float)(_this->dyPrev) );
					_this->lastAntiX = ( (Float)(_this->ex) );
					_this->lastAntiY = ( (Float)(_this->ey) );
					{
						 ::trilateral3::drawing::Pen _this1 = _this->pen;
						int color = -1;
						if ((color == -1)) {
							color = _this1->currentColor;
						}
						{
							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,_this->jx,_this->jy,0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
					}
					{
						 ::trilateral3::drawing::Pen _this2 = _this->pen;
						int color1 = -1;
						if ((color1 == -1)) {
							color1 = _this2->currentColor;
						}
						{
							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
					}
				}
				bool _hx_tmp3;
				if (!(clockWise)) {
					_hx_tmp3 = _this->lastClock;
				}
				else {
					_hx_tmp3 = false;
				}
				if (_hx_tmp3) {
					_this->penultimateAX = ( (Float)(_this->dxPrev) );
					_this->penultimateAY = ( (Float)(_this->dyPrev) );
					_this->lastAntiX = ( (Float)(_this->ex) );
					_this->lastAntiY = ( (Float)(_this->ey) );
					_this->penultimateCX = _this->jx;
					_this->penultimateCY = _this->jy;
					_this->lastClockX = ( (Float)(_this->dx) );
					_this->lastClockY = ( (Float)(_this->dy) );
					{
						 ::trilateral3::drawing::Pen _this1 = _this->pen;
						int color = -1;
						if ((color == -1)) {
							color = _this1->currentColor;
						}
						{
							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
					}
					{
						 ::trilateral3::drawing::Pen _this2 = _this->pen;
						int color1 = -1;
						if ((color1 == -1)) {
							color1 = _this2->currentColor;
						}
						{
							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
							}
							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
						}
						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
					}
				}
			}
		}
	}
	if (clockWise) {
		 ::Dynamic drawType = _this->pen->drawType;
		Float radius = (width_ / ( (Float)(2) ));
		::Array< Float > edgePoly = _this->pointsClock;
		Float pi = ::Math_obj::PI;
		Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
		bool positive = (dif >= 0);
		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
		Float step1 = (dif / ( (Float)(totalSteps) ));
		Float angle = theta0;
		Float cx;
		Float cy;
		Float bx = ( (Float)(0) );
		Float by = ( (Float)(0) );
		int p2 = edgePoly->length;
		{
			int _g = 0;
			int _g1 = (totalSteps + 1);
			while((_g < _g1)){
				_g = (_g + 1);
				int i = (_g - 1);
				cx = (ax_ + (radius * ::Math_obj::sin(angle)));
				cy = (ay_ + (radius * ::Math_obj::cos(angle)));
				p2 = (p2 + 1);
				edgePoly[(p2 - 1)] = cx;
				p2 = (p2 + 1);
				edgePoly[(p2 - 1)] = cy;
				if ((i != 0)) {
					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
					if (::hx::IsNotNull( m )) {
						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
					}
					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				angle = (angle + step1);
				bx = cx;
				by = cy;
			}
		}
		int len = totalSteps;
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
		}
	}
	else {
		 ::Dynamic drawType = _this->pen->drawType;
		Float radius = (width_ / ( (Float)(2) ));
		::Array< Float > edgePoly = _this->pointsAnti;
		Float pi = ::Math_obj::PI;
		Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
		bool positive = (dif >= 0);
		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
		Float step1 = (dif / ( (Float)(totalSteps) ));
		Float angle = theta0;
		Float cx;
		Float cy;
		Float bx = ( (Float)(0) );
		Float by = ( (Float)(0) );
		int p2 = edgePoly->length;
		{
			int _g = 0;
			int _g1 = (totalSteps + 1);
			while((_g < _g1)){
				_g = (_g + 1);
				int i = (_g - 1);
				cx = (ax_ + (radius * ::Math_obj::sin(angle)));
				cy = (ay_ + (radius * ::Math_obj::cos(angle)));
				p2 = (p2 + 1);
				edgePoly[(p2 - 1)] = cx;
				p2 = (p2 + 1);
				edgePoly[(p2 - 1)] = cy;
				if ((i != 0)) {
					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
					if (::hx::IsNotNull( m )) {
						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
					}
					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				angle = (angle + step1);
				bx = cx;
				by = cy;
			}
		}
		int len = totalSteps;
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
		}
	}
	{
		_this->kax = ( (Float)(_this->dxPrev) );
		_this->kay = ( (Float)(_this->dyPrev) );
		_this->kbx = ( (Float)(_this->dx) );
		_this->kby = ( (Float)(_this->dy) );
		_this->ncx = ( (Float)(_this->exPrev) );
		_this->ncy = ( (Float)(_this->eyPrev) );
		_this->kcx = ( (Float)(_this->ex) );
		_this->kcy = ( (Float)(_this->ey) );
	}
	bool _hx_tmp2;
	if (!(overlap)) {
		_hx_tmp2 = (_this->count != 0);
	}
	else {
		_hx_tmp2 = false;
	}
	if (_hx_tmp2) {
		if (clockWise) {
			{
				 ::trilateral3::drawing::Pen _this1 = _this->pen;
				int color = -1;
				if ((color == -1)) {
					color = _this1->currentColor;
				}
				{
					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,_this->jx,_this->jy,0);
					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
					}
					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
			}
			{
				 ::trilateral3::drawing::Pen _this2 = _this->pen;
				int color1 = -1;
				if ((color1 == -1)) {
					color1 = _this2->currentColor;
				}
				{
					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->jx,_this->jy,0);
					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
					}
					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
			}
		}
		else {
			{
				 ::trilateral3::drawing::Pen _this1 = _this->pen;
				int color = -1;
				if ((color == -1)) {
					color = _this1->currentColor;
				}
				{
					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,_this->jx,_this->jy,0);
					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
					}
					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
			}
			{
				 ::trilateral3::drawing::Pen _this2 = _this->pen;
				int color1 = -1;
				if ((color1 == -1)) {
					color1 = _this2->currentColor;
				}
				{
					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0);
					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
					}
					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
			}
		}
	}
	_this->jxOld = _this->jx;
	_this->jyOld = _this->jy;
	_this->lastClock = clockWise;
	_this->count++;
}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,fineLine,(void))

void Sketch_obj::fineOverlapLine(Float x_,Float y_){
	 ::trilateral3::drawing::Contour _this = this->contour;
	Float ax_ = this->x;
	Float ay_ = this->y;
	Float width_ = this->width;
	 ::Dynamic oldAngle;
	if (::hx::IsNotNull( _this->dx )) {
		oldAngle = _this->angle1;
	}
	else {
		oldAngle = null();
	}
	_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
	_this->ax = x_;
	_this->ay = y_;
	_this->bx = ax_;
	_this->by = ay_;
	_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
	_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
	{
		{
			_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
			if ((_this->theta > 0)) {
				if ((_this->halfA < 0)) {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
				else {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
			}
			else {
				if ((_this->halfA > 0)) {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
				else {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
			}
		}
		if (::hx::IsNotNull( _this->dxPrev )) {
			_this->dxOld = _this->dxPrev;
		}
		if (::hx::IsNotNull( _this->dyPrev )) {
			_this->dyOld = _this->dyPrev;
		}
		if (::hx::IsNotNull( _this->exPrev )) {
			_this->exOld = _this->exPrev;
		}
		if (::hx::IsNotNull( _this->eyPrev )) {
			_this->eyOld = _this->eyPrev;
		}
		if (::hx::IsNotNull( _this->dx )) {
			_this->dxPrev = _this->dx;
		}
		if (::hx::IsNotNull( _this->dy )) {
			_this->dyPrev = _this->dy;
		}
		if (::hx::IsNotNull( _this->ex )) {
			_this->exPrev = _this->ex;
		}
		if (::hx::IsNotNull( _this->ey )) {
			_this->eyPrev = _this->ey;
		}
		_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
		_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
		_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
		_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
	}
	_this->ax = ax_;
	_this->ay = ay_;
	_this->bx = x_;
	_this->by = y_;
	{
		{
			_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
			if ((_this->theta > 0)) {
				if ((_this->halfA < 0)) {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
				else {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
			}
			else {
				if ((_this->halfA > 0)) {
					_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
					_this->angle2 = (_this->theta + _this->halfA);
				}
				else {
					_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
					_this->angle1 = (_this->theta - _this->halfA);
				}
			}
		}
		if (::hx::IsNotNull( _this->dxPrev )) {
			_this->dxOld = _this->dxPrev;
		}
		if (::hx::IsNotNull( _this->dyPrev )) {
			_this->dyOld = _this->dyPrev;
		}
		if (::hx::IsNotNull( _this->exPrev )) {
			_this->exOld = _this->exPrev;
		}
		if (::hx::IsNotNull( _this->eyPrev )) {
			_this->eyOld = _this->eyPrev;
		}
		if (::hx::IsNotNull( _this->dx )) {
			_this->dxPrev = _this->dx;
		}
		if (::hx::IsNotNull( _this->dy )) {
			_this->dyPrev = _this->dy;
		}
		if (::hx::IsNotNull( _this->ex )) {
			_this->exPrev = _this->ex;
		}
		if (::hx::IsNotNull( _this->ey )) {
			_this->eyPrev = _this->ey;
		}
		_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
		_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
		_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
		_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
	}
	Float x = (( (Float)(_this->dxOld) ) - x_);
	Float y = (( (Float)(_this->dyOld) ) - y_);
	Float x1 = (( (Float)(_this->exOld) ) - x_);
	Float y1 = (( (Float)(_this->eyOld) ) - y_);
	bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
	Float theta0;
	Float theta1;
	if (clockWise) {
		theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
		theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
	}
	else {
		theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
		theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
	}
	Float dif;
	switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
		case (int)0: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if ((dif1 > 0)) {
				dif = dif1;
			}
			else {
				dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
			}
		}
		break;
		case (int)1: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if ((dif1 < 0)) {
				dif = dif1;
			}
			else {
				dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
			}
		}
		break;
		case (int)2: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool smallest = (theta <= ::Math_obj::PI);
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if (smallest) {
				dif = dif1;
			}
			else {
				if (clockwise) {
					dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
				}
			}
		}
		break;
		case (int)3: {
			Float f;
			bool f1;
			if ((theta0 >= 0)) {
				f1 = (theta0 > ::Math_obj::PI);
			}
			else {
				f1 = false;
			}
			if (f1) {
				f = theta0;
			}
			else {
				Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f = a;
				}
				else {
					f = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this1 = f;
			Float za = this1;
			Float f2;
			bool f3;
			if ((theta1 >= 0)) {
				f3 = (theta1 > ::Math_obj::PI);
			}
			else {
				f3 = false;
			}
			if (f3) {
				f2 = theta1;
			}
			else {
				Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
				if ((a >= 0)) {
					f2 = a;
				}
				else {
					f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
				}
			}
			Float this2 = f2;
			Float zb = this2;
			Float fa = za;
			Float fb = zb;
			Float theta = ::Math_obj::abs((fa - fb));
			bool largest = (theta > ::Math_obj::PI);
			bool clockwise = (fa < fb);
			Float dif1;
			if (clockwise) {
				dif1 = theta;
			}
			else {
				dif1 = -(theta);
			}
			if (largest) {
				dif = dif1;
			}
			else {
				if (clockwise) {
					dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
				}
			}
		}
		break;
	}
	bool _hx_tmp;
	if ((_this->count == 0)) {
		if ((_this->endLine != 1)) {
			_hx_tmp = (_this->endLine == 3);
		}
		else {
			_hx_tmp = true;
		}
	}
	else {
		_hx_tmp = false;
	}
	if (_hx_tmp) {
		Float ax = _this->ax;
		Float ay = _this->ay;
		Float radius = (width_ / ( (Float)(2) ));
		Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
		Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
		::Array< Float > temp = ::Array_obj< Float >::__new();
		 ::Dynamic drawType = _this->pen->drawType;
		 ::Dynamic sides = 36;
		if (::hx::IsNull( sides )) {
			sides = 36;
		}
		Float pi = ::Math_obj::PI;
		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
		Float dif;
		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
			case (int)0: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if ((dif1 > 0)) {
					dif = dif1;
				}
				else {
					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
				}
			}
			break;
			case (int)1: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if ((dif1 < 0)) {
					dif = dif1;
				}
				else {
					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
				}
			}
			break;
			case (int)2: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool smallest = (theta <= ::Math_obj::PI);
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if (smallest) {
					dif = dif1;
				}
				else {
					if (clockwise) {
						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
					}
				}
			}
			break;
			case (int)3: {
				Float f;
				bool f1;
				if ((beta >= 0)) {
					f1 = (beta > ::Math_obj::PI);
				}
				else {
					f1 = false;
				}
				if (f1) {
					f = beta;
				}
				else {
					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f = a;
					}
					else {
						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this1 = f;
				Float za = this1;
				Float f2;
				bool f3;
				if ((gamma >= 0)) {
					f3 = (gamma > ::Math_obj::PI);
				}
				else {
					f3 = false;
				}
				if (f3) {
					f2 = gamma;
				}
				else {
					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
					if ((a >= 0)) {
						f2 = a;
					}
					else {
						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
					}
				}
				Float this2 = f2;
				Float zb = this2;
				Float fa = za;
				Float fb = zb;
				Float theta = ::Math_obj::abs((fa - fb));
				bool largest = (theta > ::Math_obj::PI);
				bool clockwise = (fa < fb);
				Float dif1;
				if (clockwise) {
					dif1 = theta;
				}
				else {
					dif1 = -(theta);
				}
				if (largest) {
					dif = dif1;
				}
				else {
					if (clockwise) {
						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
					}
				}
			}
			break;
		}
		bool positive = (dif >= 0);
		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
		Float step1 = (dif / ( (Float)(totalSteps) ));
		Float angle = beta;
		Float cx;
		Float cy;
		Float bx = ( (Float)(0) );
		Float by = ( (Float)(0) );
		int p2 = temp->length;
		{
			int _g = 0;
			int _g1 = (totalSteps + 1);
			while((_g < _g1)){
				_g = (_g + 1);
				int i = (_g - 1);
				cx = (ax + (radius * ::Math_obj::sin(angle)));
				cy = (ay + (radius * ::Math_obj::cos(angle)));
				p2 = (p2 + 1);
				temp[(p2 - 1)] = cx;
				p2 = (p2 + 1);
				temp[(p2 - 1)] = cy;
				if ((i != 0)) {
					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
					if (::hx::IsNotNull( m )) {
						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
					}
					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				angle = (angle + step1);
				bx = cx;
				by = cy;
			}
		}
		int len = totalSteps;
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
		}
		int pA = _this->pointsAnti->length;
		int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
		int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
		{
			int _g2 = 0;
			int _g3 = p4;
			while((_g2 < _g3)){
				_g2 = (_g2 + 1);
				int i = (_g2 - 1);
				pA = (pA + 1);
				_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
				pA = (pA + 1);
				_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
			}
		}
		int pC = _this->pointsClock->length;
		{
			int _g4 = 0;
			int _g5 = p4;
			while((_g4 < _g5)){
				_g4 = (_g4 + 1);
				int i = (_g4 - 1);
				pC = (pC + 1);
				_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
				pC = (pC + 1);
				_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
			}
		}
	}
	{
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			{
				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
				}
				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
			}
			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
		}
		{
			 ::trilateral3::drawing::Pen _this2 = _this->pen;
			int color1 = -1;
			if ((color1 == -1)) {
				color1 = _this2->currentColor;
			}
			{
				_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
					_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
				}
				_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
			}
			_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
		}
	}
	if (clockWise) {
		 ::Dynamic drawType = _this->pen->drawType;
		Float radius = (width_ / ( (Float)(2) ));
		::Array< Float > edgePoly = _this->pointsClock;
		Float pi = ::Math_obj::PI;
		Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
		bool positive = (dif >= 0);
		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
		Float step1 = (dif / ( (Float)(totalSteps) ));
		Float angle = theta0;
		Float cx;
		Float cy;
		Float bx = ( (Float)(0) );
		Float by = ( (Float)(0) );
		int p2 = edgePoly->length;
		{
			int _g = 0;
			int _g1 = (totalSteps + 1);
			while((_g < _g1)){
				_g = (_g + 1);
				int i = (_g - 1);
				cx = (ax_ + (radius * ::Math_obj::sin(angle)));
				cy = (ay_ + (radius * ::Math_obj::cos(angle)));
				p2 = (p2 + 1);
				edgePoly[(p2 - 1)] = cx;
				p2 = (p2 + 1);
				edgePoly[(p2 - 1)] = cy;
				if ((i != 0)) {
					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
					if (::hx::IsNotNull( m )) {
						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
					}
					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				angle = (angle + step1);
				bx = cx;
				by = cy;
			}
		}
		int len = totalSteps;
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
		}
	}
	else {
		 ::Dynamic drawType = _this->pen->drawType;
		Float radius = (width_ / ( (Float)(2) ));
		::Array< Float > edgePoly = _this->pointsAnti;
		Float pi = ::Math_obj::PI;
		Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
		bool positive = (dif >= 0);
		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
		Float step1 = (dif / ( (Float)(totalSteps) ));
		Float angle = theta0;
		Float cx;
		Float cy;
		Float bx = ( (Float)(0) );
		Float by = ( (Float)(0) );
		int p2 = edgePoly->length;
		{
			int _g = 0;
			int _g1 = (totalSteps + 1);
			while((_g < _g1)){
				_g = (_g + 1);
				int i = (_g - 1);
				cx = (ax_ + (radius * ::Math_obj::sin(angle)));
				cy = (ay_ + (radius * ::Math_obj::cos(angle)));
				p2 = (p2 + 1);
				edgePoly[(p2 - 1)] = cx;
				p2 = (p2 + 1);
				edgePoly[(p2 - 1)] = cy;
				if ((i != 0)) {
					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
					if (::hx::IsNotNull( m )) {
						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
					}
					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
				}
				angle = (angle + step1);
				bx = cx;
				by = cy;
			}
		}
		int len = totalSteps;
		{
			 ::trilateral3::drawing::Pen _this1 = _this->pen;
			int color = -1;
			if ((color == -1)) {
				color = _this1->currentColor;
			}
			_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
		}
	}
	{
		_this->kax = ( (Float)(_this->dxPrev) );
		_this->kay = ( (Float)(_this->dyPrev) );
		_this->kbx = ( (Float)(_this->dx) );
		_this->kby = ( (Float)(_this->dy) );
		_this->ncx = ( (Float)(_this->exPrev) );
		_this->ncy = ( (Float)(_this->eyPrev) );
		_this->kcx = ( (Float)(_this->ex) );
		_this->kcy = ( (Float)(_this->ey) );
	}
	_this->jxOld = _this->jx;
	_this->jyOld = _this->jy;
	_this->lastClock = clockWise;
	_this->count++;
}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,fineOverlapLine,(void))

void Sketch_obj::moveTo(Float x_,Float y_){
	bool _hx_tmp;
	if ((this->endLine != 2)) {
		_hx_tmp = (this->endLine == 3);
	}
	else {
		_hx_tmp = true;
	}
	if (_hx_tmp) {
		 ::trilateral3::drawing::Contour _this = this->contour;
		Float width_ = this->width;
		_this->endEdges();
		if ((_this->count != 0)) {
			Float ax = _this->bx;
			Float ay = _this->by;
			Float radius = (width_ / ( (Float)(2) ));
			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
			::Array< Float > temp = ::Array_obj< Float >::__new();
			 ::Dynamic drawType = _this->pen->drawType;
			 ::Dynamic sides = 36;
			if (::hx::IsNull( sides )) {
				sides = 36;
			}
			Float pi = ::Math_obj::PI;
			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
			Float dif;
			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
				case (int)0: {
					Float f;
					bool f1;
					if ((beta >= 0)) {
						f1 = (beta > ::Math_obj::PI);
					}
					else {
						f1 = false;
					}
					if (f1) {
						f = beta;
					}
					else {
						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f = a;
						}
						else {
							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this1 = f;
					Float za = this1;
					Float f2;
					bool f3;
					if ((gamma >= 0)) {
						f3 = (gamma > ::Math_obj::PI);
					}
					else {
						f3 = false;
					}
					if (f3) {
						f2 = gamma;
					}
					else {
						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f2 = a;
						}
						else {
							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this2 = f2;
					Float zb = this2;
					Float fa = za;
					Float fb = zb;
					Float theta = ::Math_obj::abs((fa - fb));
					bool clockwise = (fa < fb);
					Float dif1;
					if (clockwise) {
						dif1 = theta;
					}
					else {
						dif1 = -(theta);
					}
					if ((dif1 > 0)) {
						dif = dif1;
					}
					else {
						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
					}
				}
				break;
				case (int)1: {
					Float f;
					bool f1;
					if ((beta >= 0)) {
						f1 = (beta > ::Math_obj::PI);
					}
					else {
						f1 = false;
					}
					if (f1) {
						f = beta;
					}
					else {
						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f = a;
						}
						else {
							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this1 = f;
					Float za = this1;
					Float f2;
					bool f3;
					if ((gamma >= 0)) {
						f3 = (gamma > ::Math_obj::PI);
					}
					else {
						f3 = false;
					}
					if (f3) {
						f2 = gamma;
					}
					else {
						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f2 = a;
						}
						else {
							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this2 = f2;
					Float zb = this2;
					Float fa = za;
					Float fb = zb;
					Float theta = ::Math_obj::abs((fa - fb));
					bool clockwise = (fa < fb);
					Float dif1;
					if (clockwise) {
						dif1 = theta;
					}
					else {
						dif1 = -(theta);
					}
					if ((dif1 < 0)) {
						dif = dif1;
					}
					else {
						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
					}
				}
				break;
				case (int)2: {
					Float f;
					bool f1;
					if ((beta >= 0)) {
						f1 = (beta > ::Math_obj::PI);
					}
					else {
						f1 = false;
					}
					if (f1) {
						f = beta;
					}
					else {
						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f = a;
						}
						else {
							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this1 = f;
					Float za = this1;
					Float f2;
					bool f3;
					if ((gamma >= 0)) {
						f3 = (gamma > ::Math_obj::PI);
					}
					else {
						f3 = false;
					}
					if (f3) {
						f2 = gamma;
					}
					else {
						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f2 = a;
						}
						else {
							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this2 = f2;
					Float zb = this2;
					Float fa = za;
					Float fb = zb;
					Float theta = ::Math_obj::abs((fa - fb));
					bool smallest = (theta <= ::Math_obj::PI);
					bool clockwise = (fa < fb);
					Float dif1;
					if (clockwise) {
						dif1 = theta;
					}
					else {
						dif1 = -(theta);
					}
					if (smallest) {
						dif = dif1;
					}
					else {
						if (clockwise) {
							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
						}
						else {
							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
						}
					}
				}
				break;
				case (int)3: {
					Float f;
					bool f1;
					if ((beta >= 0)) {
						f1 = (beta > ::Math_obj::PI);
					}
					else {
						f1 = false;
					}
					if (f1) {
						f = beta;
					}
					else {
						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f = a;
						}
						else {
							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this1 = f;
					Float za = this1;
					Float f2;
					bool f3;
					if ((gamma >= 0)) {
						f3 = (gamma > ::Math_obj::PI);
					}
					else {
						f3 = false;
					}
					if (f3) {
						f2 = gamma;
					}
					else {
						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
						if ((a >= 0)) {
							f2 = a;
						}
						else {
							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
						}
					}
					Float this2 = f2;
					Float zb = this2;
					Float fa = za;
					Float fb = zb;
					Float theta = ::Math_obj::abs((fa - fb));
					bool largest = (theta > ::Math_obj::PI);
					bool clockwise = (fa < fb);
					Float dif1;
					if (clockwise) {
						dif1 = theta;
					}
					else {
						dif1 = -(theta);
					}
					if (largest) {
						dif = dif1;
					}
					else {
						if (clockwise) {
							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
						}
						else {
							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
						}
					}
				}
				break;
			}
			bool positive = (dif >= 0);
			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
			Float step1 = (dif / ( (Float)(totalSteps) ));
			Float angle = beta;
			Float cx;
			Float cy;
			Float bx = ( (Float)(0) );
			Float by = ( (Float)(0) );
			int p2 = temp->length;
			{
				int _g = 0;
				int _g1 = (totalSteps + 1);
				while((_g < _g1)){
					_g = (_g + 1);
					int i = (_g - 1);
					cx = (ax + (radius * ::Math_obj::sin(angle)));
					cy = (ay + (radius * ::Math_obj::cos(angle)));
					p2 = (p2 + 1);
					temp[(p2 - 1)] = cx;
					p2 = (p2 + 1);
					temp[(p2 - 1)] = cy;
					if ((i != 0)) {
						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
						if (::hx::IsNotNull( m )) {
							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
						}
						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
					}
					angle = (angle + step1);
					bx = cx;
					by = cy;
				}
			}
			int len = totalSteps;
			{
				 ::trilateral3::drawing::Pen _this1 = _this->pen;
				int color = 0;
				if ((color == -1)) {
					color = _this1->currentColor;
				}
				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
			}
			int pA = _this->pointsAnti->length;
			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
			{
				int _g2 = 0;
				int _g3 = (len1 + 2);
				while((_g2 < _g3)){
					_g2 = (_g2 + 1);
					int i = (_g2 - 1);
					pA = (pA + 1);
					_this->pointsAnti[(pA - 1)] = temp->__get(i);
				}
			}
			int pC = _this->pointsClock->length;
			{
				int _g4 = 1;
				int _g5 = ::Std_obj::_hx_int(((( (Float)(len1) ) / ( (Float)(2) )) + 1));
				while((_g4 < _g5)){
					_g4 = (_g4 + 1);
					int i = (_g4 - 1);
					pC = (pC + 1);
					_this->pointsClock[(pC - 1)] = temp->__get((temp->length - (2 * i)));
					pC = (pC + 1);
					_this->pointsClock[(pC - 1)] = temp->__get(((temp->length - (2 * i)) - 1));
				}
			}
		}
	}
	this->x = x_;
	this->y = y_;
	int l = this->points->length;
	this->points[l] = ::Array_obj< Float >::__new();
	this->points->__get(l).StaticCast< ::Array< Float > >()[0] = x_;
	this->points->__get(l).StaticCast< ::Array< Float > >()[1] = y_;
	this->pointsClock[this->pointsClock->length] = this->contour->pointsClock->copy();
	this->pointsAnti[this->pointsAnti->length] = this->contour->pointsAnti->copy();
	this->dim[this->dim->length] =  ::Dynamic(::hx::Anon_obj::Create(4)
		->setFixed(0,HX_("maxX",34,45,56,48),::Math_obj::NEGATIVE_INFINITY)
		->setFixed(1,HX_("maxY",35,45,56,48),::Math_obj::NEGATIVE_INFINITY)
		->setFixed(2,HX_("minX",86,4e,5c,48),::Math_obj::POSITIVE_INFINITY)
		->setFixed(3,HX_("minY",87,4e,5c,48),::Math_obj::POSITIVE_INFINITY));
	{
		 ::Dynamic d = this->dim->__get((this->dim->length - 1));
		if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
			d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
		}
		if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
			d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
		}
		if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
			d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
		}
		if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
			d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
		}
	}
	this->contour->reset();
}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,moveTo,(void))

void Sketch_obj::lineTo(Float x_,Float y_){
	bool repeat;
	if ((this->x == x_)) {
		repeat = (this->y == y_);
	}
	else {
		repeat = false;
	}
	if (!(repeat)) {
		if (::hx::IsNotNull( this->widthFunction )) {
			this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
		}
		if (::hx::IsNotNull( this->colourFunction )) {
			this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
		}
		this->line(x_,y_);
		int l = this->points->length;
		::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
		int l2 = p->length;
		p[l2] = x_;
		p[(l2 + 1)] = y_;
		{
			 ::Dynamic d = this->dim->__get((this->dim->length - 1));
			if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
				d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
			}
			if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
				d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
			}
			if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
				d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
			}
			if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
				d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
			}
		}
		this->x = x_;
		this->y = y_;
	}
}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,lineTo,(void))

void Sketch_obj::quadTo(Float x1,Float y1,Float x2,Float y2){
	this->tempArr = ::Array_obj< Float >::__new(0);
	{
		::Array< Float > p = this->tempArr;
		Float ax = this->x;
		Float ay = this->y;
		Float x = (ax - x1);
		Float y = (ay - y1);
		Float x3 = (x1 - x2);
		Float y3 = (y1 - y2);
		Float approxDistance = (::Math_obj::sqrt(((x * x) + (y * y))) + ::Math_obj::sqrt(((x3 * x3) + (y3 * y3))));
		if ((approxDistance == 0)) {
			approxDistance = ((Float)0.000001);
		}
		Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),::trilateral3::math::_Algebra::Algebra_Fields__obj::quadStep);
		int l = p->length;
		l = (l + 1);
		p[(l - 1)] = ax;
		l = (l + 1);
		p[(l - 1)] = ay;
		Float t = step;
		while((t < ((Float)1.))){
			l = (l + 1);
			Float u = (( (Float)(1) ) - t);
			p[(l - 1)] = (((::Math_obj::pow(u,( (Float)(2) )) * ax) + (((( (Float)(2) ) * u) * t) * x1)) + (::Math_obj::pow(t,( (Float)(2) )) * x2));
			l = (l + 1);
			Float u1 = (( (Float)(1) ) - t);
			p[(l - 1)] = (((::Math_obj::pow(u1,( (Float)(2) )) * ay) + (((( (Float)(2) ) * u1) * t) * y1)) + (::Math_obj::pow(t,( (Float)(2) )) * y2));
			t = (t + step);
		}
		l = (l + 1);
		p[(l - 1)] = x2;
		l = (l + 1);
		p[(l - 1)] = y2;
	}
	{
		::Array< Float > arr = this->tempArr;
		 ::Dynamic withMove = false;
		if (::hx::IsNull( withMove )) {
			withMove = true;
		}
		int l1 = arr->length;
		int i = 2;
		if (( (bool)(withMove) )) {
			this->moveTo(arr->__get(0),arr->__get(1));
		}
		else {
			Float x_ = arr->__get(0);
			Float y_ = arr->__get(1);
			bool repeat;
			if ((this->x == x_)) {
				repeat = (this->y == y_);
			}
			else {
				repeat = false;
			}
			if (!(repeat)) {
				if (::hx::IsNotNull( this->widthFunction )) {
					this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
				}
				if (::hx::IsNotNull( this->colourFunction )) {
					this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
				}
				this->line(x_,y_);
				int l = this->points->length;
				::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
				int l2 = p->length;
				p[l2] = x_;
				p[(l2 + 1)] = y_;
				{
					 ::Dynamic d = this->dim->__get((this->dim->length - 1));
					if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
						d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
					}
					if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
						d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
					}
					if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
						d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
					}
					if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
						d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
					}
				}
				this->x = x_;
				this->y = y_;
			}
		}
		while((i < l1)){
			{
				Float x_ = arr->__get(i);
				Float y_ = arr->__get((i + 1));
				bool repeat;
				if ((this->x == x_)) {
					repeat = (this->y == y_);
				}
				else {
					repeat = false;
				}
				if (!(repeat)) {
					if (::hx::IsNotNull( this->widthFunction )) {
						this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
					}
					if (::hx::IsNotNull( this->colourFunction )) {
						this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
					}
					this->line(x_,y_);
					int l = this->points->length;
					::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
					int l2 = p->length;
					p[l2] = x_;
					p[(l2 + 1)] = y_;
					{
						 ::Dynamic d = this->dim->__get((this->dim->length - 1));
						if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
							d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
						}
						if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
							d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
						}
						if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
							d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
						}
						if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
							d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
						}
					}
					this->x = x_;
					this->y = y_;
				}
			}
			i = (i + 2);
		}
	}
	this->x = x2;
	this->y = y2;
}


HX_DEFINE_DYNAMIC_FUNC4(Sketch_obj,quadTo,(void))

void Sketch_obj::curveTo(Float x1,Float y1,Float x2,Float y2,Float x3,Float y3){
	this->tempArr = ::Array_obj< Float >::__new(0);
	{
		::Array< Float > p = this->tempArr;
		Float ax = this->x;
		Float ay = this->y;
		Float x = (ax - x1);
		Float y = (ay - y1);
		Float x4 = (x1 - x2);
		Float y4 = (y1 - y2);
		Float x5 = (x2 - x3);
		Float y5 = (y2 - y3);
		Float approxDistance = ((::Math_obj::sqrt(((x * x) + (y * y))) + ::Math_obj::sqrt(((x4 * x4) + (y4 * y4)))) + ::Math_obj::sqrt(((x5 * x5) + (y5 * y5))));
		if ((approxDistance == 0)) {
			approxDistance = ((Float)0.000001);
		}
		Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),((Float)0.03));
		int l = p->length;
		l = (l + 1);
		p[(l - 1)] = ax;
		l = (l + 1);
		p[(l - 1)] = ay;
		Float t = step;
		while((t < ((Float)1.))){
			l = (l + 1);
			Float u = (( (Float)(1) ) - t);
			p[(l - 1)] = ((((::Math_obj::pow(u,( (Float)(3) )) * ax) + (((( (Float)(3) ) * ::Math_obj::pow(u,( (Float)(2) ))) * t) * x1)) + (((( (Float)(3) ) * u) * ::Math_obj::pow(t,( (Float)(2) ))) * x2)) + (::Math_obj::pow(t,( (Float)(3) )) * x3));
			l = (l + 1);
			Float u1 = (( (Float)(1) ) - t);
			p[(l - 1)] = ((((::Math_obj::pow(u1,( (Float)(3) )) * ay) + (((( (Float)(3) ) * ::Math_obj::pow(u1,( (Float)(2) ))) * t) * y1)) + (((( (Float)(3) ) * u1) * ::Math_obj::pow(t,( (Float)(2) ))) * y2)) + (::Math_obj::pow(t,( (Float)(3) )) * y3));
			t = (t + step);
		}
		l = (l + 1);
		p[(l - 1)] = x3;
		l = (l + 1);
		p[(l - 1)] = y3;
	}
	{
		::Array< Float > arr = this->tempArr;
		 ::Dynamic withMove = false;
		if (::hx::IsNull( withMove )) {
			withMove = true;
		}
		int l1 = arr->length;
		int i = 2;
		if (( (bool)(withMove) )) {
			this->moveTo(arr->__get(0),arr->__get(1));
		}
		else {
			Float x_ = arr->__get(0);
			Float y_ = arr->__get(1);
			bool repeat;
			if ((this->x == x_)) {
				repeat = (this->y == y_);
			}
			else {
				repeat = false;
			}
			if (!(repeat)) {
				if (::hx::IsNotNull( this->widthFunction )) {
					this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
				}
				if (::hx::IsNotNull( this->colourFunction )) {
					this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
				}
				this->line(x_,y_);
				int l = this->points->length;
				::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
				int l2 = p->length;
				p[l2] = x_;
				p[(l2 + 1)] = y_;
				{
					 ::Dynamic d = this->dim->__get((this->dim->length - 1));
					if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
						d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
					}
					if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
						d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
					}
					if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
						d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
					}
					if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
						d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
					}
				}
				this->x = x_;
				this->y = y_;
			}
		}
		while((i < l1)){
			{
				Float x_ = arr->__get(i);
				Float y_ = arr->__get((i + 1));
				bool repeat;
				if ((this->x == x_)) {
					repeat = (this->y == y_);
				}
				else {
					repeat = false;
				}
				if (!(repeat)) {
					if (::hx::IsNotNull( this->widthFunction )) {
						this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
					}
					if (::hx::IsNotNull( this->colourFunction )) {
						this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
					}
					this->line(x_,y_);
					int l = this->points->length;
					::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
					int l2 = p->length;
					p[l2] = x_;
					p[(l2 + 1)] = y_;
					{
						 ::Dynamic d = this->dim->__get((this->dim->length - 1));
						if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
							d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
						}
						if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
							d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
						}
						if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
							d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
						}
						if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
							d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
						}
					}
					this->x = x_;
					this->y = y_;
				}
			}
			i = (i + 2);
		}
	}
	this->x = x3;
	this->y = y3;
}


HX_DEFINE_DYNAMIC_FUNC6(Sketch_obj,curveTo,(void))


::hx::ObjectPtr< Sketch_obj > Sketch_obj::__new( ::trilateral3::drawing::Pen pen_,int sketchForm_,::hx::Null< int >  __o_endLine_) {
	::hx::ObjectPtr< Sketch_obj > __this = new Sketch_obj();
	__this->__construct(pen_,sketchForm_,__o_endLine_);
	return __this;
}

::hx::ObjectPtr< Sketch_obj > Sketch_obj::__alloc(::hx::Ctx *_hx_ctx, ::trilateral3::drawing::Pen pen_,int sketchForm_,::hx::Null< int >  __o_endLine_) {
	Sketch_obj *__this = (Sketch_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Sketch_obj), true, "trilateral3.drawing.Sketch"));
	*(void **)__this = Sketch_obj::_hx_vtable;
	__this->__construct(pen_,sketchForm_,__o_endLine_);
	return __this;
}

Sketch_obj::Sketch_obj()
{
}

void Sketch_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Sketch);
	HX_MARK_MEMBER_NAME(x,"x");
	HX_MARK_MEMBER_NAME(y,"y");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(widthFunction,"widthFunction");
	HX_MARK_MEMBER_NAME(colourFunction,"colourFunction");
	HX_MARK_MEMBER_NAME(tempArr,"tempArr");
	HX_MARK_MEMBER_NAME(contour,"contour");
	HX_MARK_MEMBER_NAME(pen,"pen");
	HX_MARK_MEMBER_NAME(endLine,"endLine");
	HX_MARK_MEMBER_NAME(sketchForm,"sketchForm");
	HX_MARK_MEMBER_NAME(points,"points");
	HX_MARK_MEMBER_NAME(pointsClock,"pointsClock");
	HX_MARK_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_MARK_MEMBER_NAME(dim,"dim");
	HX_MARK_MEMBER_NAME(line,"line");
	HX_MARK_END_CLASS();
}

void Sketch_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(x,"x");
	HX_VISIT_MEMBER_NAME(y,"y");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(widthFunction,"widthFunction");
	HX_VISIT_MEMBER_NAME(colourFunction,"colourFunction");
	HX_VISIT_MEMBER_NAME(tempArr,"tempArr");
	HX_VISIT_MEMBER_NAME(contour,"contour");
	HX_VISIT_MEMBER_NAME(pen,"pen");
	HX_VISIT_MEMBER_NAME(endLine,"endLine");
	HX_VISIT_MEMBER_NAME(sketchForm,"sketchForm");
	HX_VISIT_MEMBER_NAME(points,"points");
	HX_VISIT_MEMBER_NAME(pointsClock,"pointsClock");
	HX_VISIT_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_VISIT_MEMBER_NAME(dim,"dim");
	HX_VISIT_MEMBER_NAME(line,"line");
}

::hx::Val Sketch_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return ::hx::Val( x ); }
		if (HX_FIELD_EQ(inName,"y") ) { return ::hx::Val( y ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { return ::hx::Val( pen ); }
		if (HX_FIELD_EQ(inName,"dim") ) { return ::hx::Val( dim ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"line") ) { return ::hx::Val( line ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { return ::hx::Val( points ); }
		if (HX_FIELD_EQ(inName,"moveTo") ) { return ::hx::Val( moveTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"lineTo") ) { return ::hx::Val( lineTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"quadTo") ) { return ::hx::Val( quadTo_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tempArr") ) { return ::hx::Val( tempArr ); }
		if (HX_FIELD_EQ(inName,"contour") ) { return ::hx::Val( contour ); }
		if (HX_FIELD_EQ(inName,"endLine") ) { return ::hx::Val( endLine ); }
		if (HX_FIELD_EQ(inName,"curveTo") ) { return ::hx::Val( curveTo_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"baseLine") ) { return ::hx::Val( baseLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"fineLine") ) { return ::hx::Val( fineLine_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"crudeLine") ) { return ::hx::Val( crudeLine_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sketchForm") ) { return ::hx::Val( sketchForm ); }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { return ::hx::Val( pointsAnti ); }
		if (HX_FIELD_EQ(inName,"tracerLine") ) { return ::hx::Val( tracerLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"mediumLine") ) { return ::hx::Val( mediumLine_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { return ::hx::Val( pointsClock ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"fillOnlyLine") ) { return ::hx::Val( fillOnlyLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"roundEndLine") ) { return ::hx::Val( roundEndLine_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"widthFunction") ) { return ::hx::Val( widthFunction ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colourFunction") ) { return ::hx::Val( colourFunction ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"fineOverlapLine") ) { return ::hx::Val( fineOverlapLine_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"mediumOverlapLine") ) { return ::hx::Val( mediumOverlapLine_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Sketch_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { y=inValue.Cast< Float >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { pen=inValue.Cast<  ::trilateral3::drawing::Pen >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dim") ) { dim=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"line") ) { line=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { points=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tempArr") ) { tempArr=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"contour") ) { contour=inValue.Cast<  ::trilateral3::drawing::Contour >(); return inValue; }
		if (HX_FIELD_EQ(inName,"endLine") ) { endLine=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sketchForm") ) { sketchForm=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { pointsAnti=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { pointsClock=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"widthFunction") ) { widthFunction=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colourFunction") ) { colourFunction=inValue.Cast<  ::Dynamic >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Sketch_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x",78,00,00,00));
	outFields->push(HX_("y",79,00,00,00));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("tempArr",ad,17,ac,46));
	outFields->push(HX_("contour",da,29,7f,19));
	outFields->push(HX_("pen",d9,54,55,00));
	outFields->push(HX_("endLine",6f,d1,d7,29));
	outFields->push(HX_("sketchForm",d0,2c,96,9a));
	outFields->push(HX_("points",23,12,2e,f7));
	outFields->push(HX_("pointsClock",ab,c8,9e,88));
	outFields->push(HX_("pointsAnti",65,1b,f0,ae));
	outFields->push(HX_("dim",48,3d,4c,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Sketch_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(Sketch_obj,x),HX_("x",78,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Sketch_obj,y),HX_("y",79,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Sketch_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketch_obj,widthFunction),HX_("widthFunction",3e,93,b5,7c)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketch_obj,colourFunction),HX_("colourFunction",84,5b,3e,e4)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(Sketch_obj,tempArr),HX_("tempArr",ad,17,ac,46)},
	{::hx::fsObject /*  ::trilateral3::drawing::Contour */ ,(int)offsetof(Sketch_obj,contour),HX_("contour",da,29,7f,19)},
	{::hx::fsObject /*  ::trilateral3::drawing::Pen */ ,(int)offsetof(Sketch_obj,pen),HX_("pen",d9,54,55,00)},
	{::hx::fsInt,(int)offsetof(Sketch_obj,endLine),HX_("endLine",6f,d1,d7,29)},
	{::hx::fsInt,(int)offsetof(Sketch_obj,sketchForm),HX_("sketchForm",d0,2c,96,9a)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,points),HX_("points",23,12,2e,f7)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,pointsClock),HX_("pointsClock",ab,c8,9e,88)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,pointsAnti),HX_("pointsAnti",65,1b,f0,ae)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,dim),HX_("dim",48,3d,4c,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketch_obj,line),HX_("line",f4,17,b3,47)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Sketch_obj_sStaticStorageInfo = 0;
#endif

static ::String Sketch_obj_sMemberFields[] = {
	HX_("x",78,00,00,00),
	HX_("y",79,00,00,00),
	HX_("width",06,b6,62,ca),
	HX_("widthFunction",3e,93,b5,7c),
	HX_("colourFunction",84,5b,3e,e4),
	HX_("tempArr",ad,17,ac,46),
	HX_("contour",da,29,7f,19),
	HX_("pen",d9,54,55,00),
	HX_("endLine",6f,d1,d7,29),
	HX_("sketchForm",d0,2c,96,9a),
	HX_("points",23,12,2e,f7),
	HX_("pointsClock",ab,c8,9e,88),
	HX_("pointsAnti",65,1b,f0,ae),
	HX_("dim",48,3d,4c,00),
	HX_("tracerLine",e1,14,6f,0a),
	HX_("fillOnlyLine",23,35,20,bc),
	HX_("baseLine",a5,08,01,fc),
	HX_("crudeLine",7b,a3,d6,62),
	HX_("roundEndLine",c1,c6,50,fc),
	HX_("mediumLine",09,77,f0,3b),
	HX_("mediumOverlapLine",a6,34,72,5e),
	HX_("fineLine",4e,b9,ad,2d),
	HX_("fineOverlapLine",01,f5,59,3a),
	HX_("line",f4,17,b3,47),
	HX_("moveTo",ec,d2,ac,cc),
	HX_("lineTo",8f,46,a0,ec),
	HX_("quadTo",22,82,9f,cc),
	HX_("curveTo",0a,60,88,ce),
	::String(null()) };

::hx::Class Sketch_obj::__mClass;

void Sketch_obj::__register()
{
	Sketch_obj _hx_dummy;
	Sketch_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("trilateral3.drawing.Sketch",23,f7,00,b3);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Sketch_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Sketch_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Sketch_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Sketch_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace trilateral3
} // end namespace drawing
