// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_TrilateralRegularColor
#include <TrilateralRegularColor.h>
#endif
#ifndef INCLUDED_fracs_DifferencePreference
#include <fracs/DifferencePreference.h>
#endif
#ifndef INCLUDED_gluon_webgl_native_GLContext
#include <gluon/webgl/native/GLContext.h>
#endif
#ifndef INCLUDED_kitGL_gluon_InterleaveAlterGL
#include <kitGL/gluon/InterleaveAlterGL.h>
#endif
#ifndef INCLUDED_pallette_utils_ARGB
#include <pallette/utils/ARGB.h>
#endif
#ifndef INCLUDED_trilateral3_Trilateral
#include <trilateral3/Trilateral.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Pen
#include <trilateral3/drawing/Pen.h>
#endif
#ifndef INCLUDED_trilateral3_matrix_MatrixDozen
#include <trilateral3/matrix/MatrixDozen.h>
#endif
#ifndef INCLUDED_trilateral3_nodule_PenNodule
#include <trilateral3/nodule/PenNodule.h>
#endif
#ifndef INCLUDED_trilateral3_shape__Regular_Regular_Impl_
#include <trilateral3/shape/_Regular/Regular_Impl_.h>
#endif
#ifndef INCLUDED_trilateral3_structure_RegularShape
#include <trilateral3/structure/RegularShape.h>
#endif
#ifndef INCLUDED_trilateral3_structure_StartEnd
#include <trilateral3/structure/StartEnd.h>
#endif
#ifndef INCLUDED_trilateral3_structure_TriInt
#include <trilateral3/structure/TriInt.h>
#endif
#ifndef INCLUDED_typedarray_ArrayBufferView
#include <typedarray/ArrayBufferView.h>
#endif
#ifndef INCLUDED_typedarray_ArrayBufferViewBase
#include <typedarray/ArrayBufferViewBase.h>
#endif
#ifndef INCLUDED_typedarray_Float32ArrayImpl
#include <typedarray/Float32ArrayImpl.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_b6ca0cd7a8a876b7_34_new,"TrilateralRegularColor","new",0x490342c5,"TrilateralRegularColor.new","TrilateralRegularColor.hx",34,0x4d3dfc4b)
HX_LOCAL_STACK_FRAME(_hx_pos_b6ca0cd7a8a876b7_44_draw,"TrilateralRegularColor","draw",0x9344d1ff,"TrilateralRegularColor.draw","TrilateralRegularColor.hx",44,0x4d3dfc4b)
static const int _hx_array_data_18977c53_11[] = {
	(int)-16777216,(int)-65536,(int)-33024,(int)-256,(int)-16711936,(int)-16776961,(int)-11861886,(int)-7077677,(int)-1,(int)-2961215,(int)-3309528,(int)-2974447,(int)-1871576,(int)-1022095,(int)-3000015,(int)-5297103,(int)-7326914,(int)-7979696,(int)-10991011,(int)-11231549,(int)-13864803,(int)-12223826,(int)-13218451,(int)-13136787,(int)-9525432,(int)-13214300,(int)-12227006,(int)-4093906,(int)-8309724,(int)-12571100,(int)-14080992,(int)-11380911,(int)-15000807,(int)-12303292,(int)-13421773,(int)-15987700,(int)-525059,(int)-1706503,(int)-3347226,(int)-6694711,(int)-10042716,(int)-12472714,(int)-14447803,(int)-16749268,(int)-16759781,(int)-525059,(int)-2036492,(int)-4205594,(int)-6374182,(int)-7563578,(int)-7574607,(int)-7847523,(int)-8319108,(int)-11730869,(int)-525072,(int)-2034725,(int)-3347515,(int)-5710411,(int)-8663868,(int)-11619373,(int)-13923138,(int)-16226132,(int)-16236415,(int)-2068,(int)-71480,(int)-142178,(int)-148604,(int)-225959,(int)-1088184,(int)-2674657,(int)-5046272,(int)-8454144,(int)-2053,(int)-1251342,(int)-3091994,(int)-5849637,(int)-9131569,(int)-13201216,(int)-16420688,(int)-16491891,(int)-16631720,(int)-2053,(int)-1252624,(int)-3091994,(int)-5849637,(int)-9983537,(int)-13201216,(int)-16612982,(int)-16683943,(int)-16693706,(int)-527111,(int)-1580561,(int)-2836006,(int)-3566393,(int)-2136656,(int)-1627766,(int)-3272106,(int)-6815677,(int)-10026977,(int)-2061,(int)-139043,(int)-211520,(int)-352331,(int)-563039,(int)-2280297,(int)-5373570,(int)-8781449,(int)-11992982,(int)-27,(int)-525127,(int)-2494301,(int)-5382770,(int)-8862087,(int)-12473507,(int)-14449597,(int)-16750537,(int)-16759511,(int)-39,(int)-1181519,(int)-3675724,(int)-8401477,(int)-12470588,(int)-14839360,(int)-14524760,(int)-14338924,(int)-16245416,(int)-27,(int)-2116,(int)-72815,(int)-80817,(int)-91863,(int)-1282028,(int)-3388414,(int)-6736892,(int)-10083066,(int)-52,(int)-4704,(int)-75402,(int)-85428,(int)-160452,(int)-242134,(int)-1893860,(int)-4390874,(int)-8388570,(int)-525313,(int)-2167817,(int)-3744785,(int)-6370591,(int)-9720106,(int)-12414266,(int)-14585419,(int)-16232036,(int)-16240533,(int)-525067,(int)-1706528,(int)-3675712,(int)-6170213,(int)-9124746,(int)-12473507,(int)-14447803,(int)-16749268,(int)-16759781,(int)-1,(int)-986896,(int)-2500135,(int)-4342339,(int)-6908266,(int)-9211021,(int)-11382190,(int)-14342875,(int)-16777216,(int)-2581,(int)-71986,(int)-143198,(int)-151957,(int)-160452,(int)-956141,(int)-2537471,(int)-5884413,(int)-8444156,(int)-197635,(int)-1053195,(int)-2434325,(int)-4407844,(int)-6382904,(int)-8356422,(int)-9809501,(int)-11262065,(int)-12648323,(int)-2576,(int)-73518,(int)-214111,(int)-224654,(int)-300470,(int)-1098964,(int)-3467235,(int)-5959915,(int)-10026995,(int)-7581430,(int)-4226771,(int)-2112899,(int)-595773,(int)-657931,(int)-3675419,(int)-8335935,(int)-13265009,(int)-16685474,(int)-3859587,(int)-2197586,(int)-936230,(int)-139025,(int)-526345,(int)-1641008,(int)-4660858,(int)-8405951,(int)-11693535,(int)-9033085,(int)-6721365,(int)-4020785,(int)-1583896,(int)-526345,(int)-2494253,(int)-5842016,(int)-10834335,(int)-14976969,(int)-5023738,(int)-2063852,(int)-149405,(int)-73546,(int)-526345,(int)-2565397,(int)-5067822,(int)-8358996,(int)-11262072,(int)-5105621,(int)-2727859,(int)-744062,(int)-140345,(int)-526345,(int)-3021328,(int)-7158306,(int)-12348477,(int)-14588244,(int)-5105621,(int)-2727859,(int)-744062,(int)-140345,(int)-1,(int)-2039584,(int)-4539718,(int)-7895161,(int)-11711155,(int)-2674649,(int)-758461,(int)-151967,(int)-73584,(int)-65,(int)-2034696,(int)-5514775,(int)-9130543,(int)-12225100,(int)-2674649,(int)-758461,(int)-151967,(int)-73589,(int)-65,(int)-2494581,(int)-5842582,(int)-10044061,(int)-15034288,(int)-2802097,(int)-758461,(int)-151967,(int)-73589,(int)-65,(int)-1641064,(int)-5513820,(int)-10042715,(int)-13465411,(int)-5845277,(int)-14714700,(int)-5054582,(int)-13393876,(int)-288103,(int)-1893860,(int)-147601,(int)-33024,(int)-3493162,(int)-281426,(int)-4993565,(int)-3347515,(int)-2176028,(int)-75354,(int)-52,(int)-1713987,(int)-140564,(int)-855310,(int)-1828324,(int)-13140296,(int)-11686070,(int)-6795613,(int)-33024,(int)-205,(int)-5876184,(int)-556609,(int)-6710887,(int)-7482425,(int)-77,(int)-4277542,(int)-294798,(int)-8343085,(int)-150430,(int)-4989335,(int)-209435,(int)-2500135,
};
HX_LOCAL_STACK_FRAME(_hx_pos_b6ca0cd7a8a876b7_70_renderDraw,"TrilateralRegularColor","renderDraw",0xa263fab5,"TrilateralRegularColor.renderDraw","TrilateralRegularColor.hx",70,0x4d3dfc4b)

void TrilateralRegularColor_obj::__construct( ::gluon::webgl::native::GLContext gl){
            	HX_GC_STACKFRAME(&_hx_pos_b6ca0cd7a8a876b7_34_new)
HXLINE(  68)		this->count = 1;
HXLINE(  67)		this->delayStart = 100;
HXLINE(  66)		this->dStep = ((Float)0.);
HXLINE(  65)		this->range = ((Float)80.);
HXLINE(  64)		this->tick = 0;
HXLINE(  39)		this->penNodule =  ::trilateral3::nodule::PenNodule_obj::__alloc( HX_CTX ,null());
HXLINE(  36)		this->arr = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  41)		super::__construct(gl);
            	}

Dynamic TrilateralRegularColor_obj::__CreateEmpty() { return new TrilateralRegularColor_obj; }

void *TrilateralRegularColor_obj::_hx_vtable = 0;

Dynamic TrilateralRegularColor_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TrilateralRegularColor_obj > _hx_result = new TrilateralRegularColor_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool TrilateralRegularColor_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1c3f678c) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x1c3f678c;
	} else {
		return inClassId==(int)0x29e3bf13;
	}
}

void TrilateralRegularColor_obj::draw(){
            	HX_GC_STACKFRAME(&_hx_pos_b6ca0cd7a8a876b7_44_draw)
HXLINE(  45)		this->interleaveDataGL =  ::Dynamic(::hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("get_data",b3,11,1e,c2),this->penNodule->get_data_dyn())
            			->setFixed(1,HX_("get_size",4a,5c,0e,cc),this->penNodule->get_size_dyn()));
HXLINE(  46)		this->pen = this->penNodule->pen;
HXLINE(  47)		this->regular = ::trilateral3::shape::_Regular::Regular_Impl__obj::_new(this->pen);
HXLINE(  48)		int c = 1;
HXLINE(  49)		this->count = c;
HXLINE(  50)		this->nines = ::Array_obj< int >::fromData( _hx_array_data_18977c53_11,315);
HXLINE(  51)		int x = 0;
HXLINE(  52)		int y = 0;
HXLINE(  53)		int dx = 300;
HXLINE(  54)		int dy = 200;
HXLINE(  55)		::Array< ::Dynamic> _hx_tmp = this->arr;
HXDLIN(  55)		 ::trilateral3::drawing::Pen this1 = this->regular;
HXDLIN(  55)		 ::trilateral3::structure::RegularShape rs =  ::trilateral3::structure::RegularShape_obj::__alloc( HX_CTX ,( (Float)((x + dx)) ),( (Float)((y + dy)) ),( (Float)(50) ),this->nines->__get(c));
HXDLIN(  55)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  55)		 ::Dynamic drawType = this1->drawType;
HXDLIN(  55)		Float ax = rs->x;
HXDLIN(  55)		Float ay = rs->y;
HXDLIN(  55)		Float radius = rs->radius;
HXDLIN(  55)		 ::Dynamic sides = 4;
HXDLIN(  55)		if (::hx::IsNull( sides )) {
HXLINE(  55)			sides = 36;
            		}
HXDLIN(  55)		Float pi = ::Math_obj::PI;
HXDLIN(  55)		Float theta = (pi / ( (Float)(2) ));
HXDLIN(  55)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  55)		Float bx;
HXDLIN(  55)		Float by;
HXDLIN(  55)		Float cx;
HXDLIN(  55)		Float cy;
HXDLIN(  55)		{
HXLINE(  55)			int _g = 0;
HXDLIN(  55)			 ::Dynamic _g1 = sides;
HXDLIN(  55)			while(::hx::IsLess( _g,_g1 )){
HXLINE(  55)				_g = (_g + 1);
HXDLIN(  55)				int i = (_g - 1);
HXDLIN(  55)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  55)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  55)				theta = (theta + step);
HXDLIN(  55)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  55)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  55)				{
HXLINE(  55)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  55)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  55)					if (::hx::IsNotNull( m )) {
HXLINE(  55)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  55)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  55)		int len = ( (int)(sides) );
HXDLIN(  55)		{
HXLINE(  55)			int col = rs->color;
HXDLIN(  55)			{
HXLINE(  55)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  55)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN(  55)			{
HXLINE(  55)				int color = col;
HXDLIN(  55)				if ((color == -1)) {
HXLINE(  55)					color = this1->currentColor;
            				}
HXDLIN(  55)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  55)		int end = ((start + len) - 1);
HXDLIN(  55)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  55)		_hx_tmp[0] = startEnd;
HXLINE(  56)		::Array< ::Dynamic> _hx_tmp1 = this->arr;
HXDLIN(  56)		 ::trilateral3::drawing::Pen this2 = this->regular;
HXDLIN(  56)		 ::trilateral3::structure::RegularShape rs1 =  ::trilateral3::structure::RegularShape_obj::__alloc( HX_CTX ,( (Float)((x + dx)) ),( (Float)((y + (2 * dy))) ),( (Float)(50) ),this->nines->__get((c + 2)));
HXDLIN(  56)		int start1 = ( (int)(this2->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  56)		 ::Dynamic drawType1 = this2->drawType;
HXDLIN(  56)		Float ax1 = rs1->x;
HXDLIN(  56)		Float ay1 = rs1->y;
HXDLIN(  56)		Float radius1 = rs1->radius;
HXDLIN(  56)		 ::Dynamic sides1 = 5;
HXDLIN(  56)		if (::hx::IsNull( sides1 )) {
HXLINE(  56)			sides1 = 36;
            		}
HXDLIN(  56)		Float pi1 = ::Math_obj::PI;
HXDLIN(  56)		Float theta1 = (pi1 / ( (Float)(2) ));
HXDLIN(  56)		Float step1 = ((pi1 * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN(  56)		Float bx1;
HXDLIN(  56)		Float by1;
HXDLIN(  56)		Float cx1;
HXDLIN(  56)		Float cy1;
HXDLIN(  56)		{
HXLINE(  56)			int _g2 = 0;
HXDLIN(  56)			 ::Dynamic _g3 = sides1;
HXDLIN(  56)			while(::hx::IsLess( _g2,_g3 )){
HXLINE(  56)				_g2 = (_g2 + 1);
HXDLIN(  56)				int i = (_g2 - 1);
HXDLIN(  56)				bx1 = (ax1 + (radius1 * ::Math_obj::sin(theta1)));
HXDLIN(  56)				by1 = (ay1 + (radius1 * ::Math_obj::cos(theta1)));
HXDLIN(  56)				theta1 = (theta1 + step1);
HXDLIN(  56)				cx1 = (ax1 + (radius1 * ::Math_obj::sin(theta1)));
HXDLIN(  56)				cy1 = (ay1 + (radius1 * ::Math_obj::cos(theta1)));
HXDLIN(  56)				{
HXLINE(  56)					drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax1,ay1,0,bx1,by1,0,cx1,cy1,0);
HXDLIN(  56)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  56)					if (::hx::IsNotNull( m )) {
HXLINE(  56)						drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  56)					drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  56)		int len1 = ( (int)(sides1) );
HXDLIN(  56)		{
HXLINE(  56)			int col1 = rs1->color;
HXDLIN(  56)			{
HXLINE(  56)				this2->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
HXDLIN(  56)				this2->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
            			}
HXDLIN(  56)			{
HXLINE(  56)				int color1 = col1;
HXDLIN(  56)				if ((color1 == -1)) {
HXLINE(  56)					color1 = this2->currentColor;
            				}
HXDLIN(  56)				this2->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
            			}
            		}
HXDLIN(  56)		int end1 = ((start1 + len1) - 1);
HXDLIN(  56)		 ::trilateral3::structure::StartEnd startEnd1 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start1,end1);
HXDLIN(  56)		_hx_tmp1[1] = startEnd1;
HXLINE(  57)		::Array< ::Dynamic> _hx_tmp2 = this->arr;
HXDLIN(  57)		 ::trilateral3::drawing::Pen this3 = this->regular;
HXDLIN(  57)		 ::trilateral3::structure::RegularShape rs2 =  ::trilateral3::structure::RegularShape_obj::__alloc( HX_CTX ,( (Float)((x + dx)) ),( (Float)((y + (3 * dy))) ),( (Float)(50) ),this->nines->__get((c + 4)));
HXDLIN(  57)		int start2 = ( (int)(this3->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  57)		 ::Dynamic drawType2 = this3->drawType;
HXDLIN(  57)		Float ax2 = rs2->x;
HXDLIN(  57)		Float ay2 = rs2->y;
HXDLIN(  57)		Float radius2 = rs2->radius;
HXDLIN(  57)		 ::Dynamic sides2 = 36;
HXDLIN(  57)		if (::hx::IsNull( sides2 )) {
HXLINE(  57)			sides2 = 36;
            		}
HXDLIN(  57)		Float pi2 = ::Math_obj::PI;
HXDLIN(  57)		Float theta2 = (pi2 / ( (Float)(2) ));
HXDLIN(  57)		Float step2 = ((pi2 * ( (Float)(2) )) / ( (Float)(sides2) ));
HXDLIN(  57)		Float bx2;
HXDLIN(  57)		Float by2;
HXDLIN(  57)		Float cx2;
HXDLIN(  57)		Float cy2;
HXDLIN(  57)		{
HXLINE(  57)			int _g4 = 0;
HXDLIN(  57)			 ::Dynamic _g5 = sides2;
HXDLIN(  57)			while(::hx::IsLess( _g4,_g5 )){
HXLINE(  57)				_g4 = (_g4 + 1);
HXDLIN(  57)				int i = (_g4 - 1);
HXDLIN(  57)				bx2 = (ax2 + (radius2 * ::Math_obj::sin(theta2)));
HXDLIN(  57)				by2 = (ay2 + (radius2 * ::Math_obj::cos(theta2)));
HXDLIN(  57)				theta2 = (theta2 + step2);
HXDLIN(  57)				cx2 = (ax2 + (radius2 * ::Math_obj::sin(theta2)));
HXDLIN(  57)				cy2 = (ay2 + (radius2 * ::Math_obj::cos(theta2)));
HXDLIN(  57)				{
HXLINE(  57)					drawType2->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax2,ay2,0,bx2,by2,0,cx2,cy2,0);
HXDLIN(  57)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  57)					if (::hx::IsNotNull( m )) {
HXLINE(  57)						drawType2->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  57)					drawType2->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  57)		int len2 = ( (int)(sides2) );
HXDLIN(  57)		{
HXLINE(  57)			int col2 = rs2->color;
HXDLIN(  57)			{
HXLINE(  57)				this3->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start2);
HXDLIN(  57)				this3->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start2);
            			}
HXDLIN(  57)			{
HXLINE(  57)				int color2 = col2;
HXDLIN(  57)				if ((color2 == -1)) {
HXLINE(  57)					color2 = this3->currentColor;
            				}
HXDLIN(  57)				this3->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color2,len2);
            			}
            		}
HXDLIN(  57)		int end2 = ((start2 + len2) - 1);
HXDLIN(  57)		 ::trilateral3::structure::StartEnd startEnd2 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start2,end2);
HXDLIN(  57)		_hx_tmp2[2] = startEnd2;
HXLINE(  58)		::Array< ::Dynamic> _hx_tmp3 = this->arr;
HXDLIN(  58)		 ::trilateral3::drawing::Pen this4 = this->regular;
HXDLIN(  58)		 ::trilateral3::structure::RegularShape rs3 =  ::trilateral3::structure::RegularShape_obj::__alloc( HX_CTX ,( (Float)((x + dx)) ),( (Float)((y + (4 * dy))) ),( (Float)(50) ),this->nines->__get((c + 6)));
HXDLIN(  58)		int start3 = ( (int)(this4->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  58)		 ::Dynamic drawType3 = this4->drawType;
HXDLIN(  58)		Float ax3 = rs3->x;
HXDLIN(  58)		Float ay3 = rs3->y;
HXDLIN(  58)		Float radius3 = rs3->radius;
HXDLIN(  58)		 ::Dynamic sides3 = 3;
HXDLIN(  58)		if (::hx::IsNull( sides3 )) {
HXLINE(  58)			sides3 = 36;
            		}
HXDLIN(  58)		Float pi3 = ::Math_obj::PI;
HXDLIN(  58)		Float theta3 = (pi3 / ( (Float)(2) ));
HXDLIN(  58)		Float step3 = ((pi3 * ( (Float)(2) )) / ( (Float)(sides3) ));
HXDLIN(  58)		Float bx3;
HXDLIN(  58)		Float by3;
HXDLIN(  58)		Float cx3;
HXDLIN(  58)		Float cy3;
HXDLIN(  58)		{
HXLINE(  58)			int _g6 = 0;
HXDLIN(  58)			 ::Dynamic _g7 = sides3;
HXDLIN(  58)			while(::hx::IsLess( _g6,_g7 )){
HXLINE(  58)				_g6 = (_g6 + 1);
HXDLIN(  58)				int i = (_g6 - 1);
HXDLIN(  58)				bx3 = (ax3 + (radius3 * ::Math_obj::sin(theta3)));
HXDLIN(  58)				by3 = (ay3 + (radius3 * ::Math_obj::cos(theta3)));
HXDLIN(  58)				theta3 = (theta3 + step3);
HXDLIN(  58)				cx3 = (ax3 + (radius3 * ::Math_obj::sin(theta3)));
HXDLIN(  58)				cy3 = (ay3 + (radius3 * ::Math_obj::cos(theta3)));
HXDLIN(  58)				{
HXLINE(  58)					drawType3->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax3,ay3,0,bx3,by3,0,cx3,cy3,0);
HXDLIN(  58)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  58)					if (::hx::IsNotNull( m )) {
HXLINE(  58)						drawType3->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  58)					drawType3->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  58)		int len3 = ( (int)(sides3) );
HXDLIN(  58)		{
HXLINE(  58)			int col3 = rs3->color;
HXDLIN(  58)			{
HXLINE(  58)				this4->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start3);
HXDLIN(  58)				this4->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start3);
            			}
HXDLIN(  58)			{
HXLINE(  58)				int color3 = col3;
HXDLIN(  58)				if ((color3 == -1)) {
HXLINE(  58)					color3 = this4->currentColor;
            				}
HXDLIN(  58)				this4->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color3,len3);
            			}
            		}
HXDLIN(  58)		int end3 = ((start3 + len3) - 1);
HXDLIN(  58)		 ::trilateral3::structure::StartEnd startEnd3 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start3,end3);
HXDLIN(  58)		_hx_tmp3[3] = startEnd3;
HXLINE(  59)		::Array< ::Dynamic> _hx_tmp4 = this->arr;
HXDLIN(  59)		 ::trilateral3::drawing::Pen this5 = this->regular;
HXDLIN(  59)		 ::trilateral3::structure::RegularShape rs4 =  ::trilateral3::structure::RegularShape_obj::__alloc( HX_CTX ,( (Float)((x + (dx * 2))) ),( (Float)((y + dy)) ),( (Float)(50) ),this->nines->__get((c + 1)));
HXDLIN(  59)		int start4 = ( (int)(this5->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  59)		 ::Dynamic drawType4 = this5->drawType;
HXDLIN(  59)		Float x1 = (rs4->x - rs4->radius);
HXDLIN(  59)		Float ax4 = x1;
HXDLIN(  59)		Float ay4 = (rs4->y - (rs4->radius / ( (Float)(4) )));
HXDLIN(  59)		Float bx4 = (x1 + (rs4->radius * ( (Float)(2) )));
HXDLIN(  59)		Float by4 = ay4;
HXDLIN(  59)		Float cx4 = bx4;
HXDLIN(  59)		Float cy4 = (ay4 + (rs4->radius / ( (Float)(3) )));
HXDLIN(  59)		Float dx1 = x1;
HXDLIN(  59)		Float dy1 = cy4;
HXDLIN(  59)		{
HXLINE(  59)			drawType4->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax4,ay4,0,bx4,by4,0,dx1,dy1,0);
HXDLIN(  59)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  59)			if (::hx::IsNotNull( m )) {
HXLINE(  59)				drawType4->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN(  59)			drawType4->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  59)		{
HXLINE(  59)			drawType4->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx4,by4,0,cx4,cy4,0,dx1,dy1,0);
HXDLIN(  59)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  59)			if (::hx::IsNotNull( m1 )) {
HXLINE(  59)				drawType4->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN(  59)			drawType4->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  59)		int len4 = 2;
HXDLIN(  59)		{
HXLINE(  59)			int col4 = rs4->color;
HXDLIN(  59)			{
HXLINE(  59)				this5->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start4);
HXDLIN(  59)				this5->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start4);
            			}
HXDLIN(  59)			{
HXLINE(  59)				int color4 = col4;
HXDLIN(  59)				if ((color4 == -1)) {
HXLINE(  59)					color4 = this5->currentColor;
            				}
HXDLIN(  59)				this5->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color4,len4);
            			}
            		}
HXDLIN(  59)		int end4 = ((start4 + len4) - 1);
HXDLIN(  59)		_hx_tmp4[4] =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start4,end4);
HXLINE(  60)		::Array< ::Dynamic> _hx_tmp5 = this->arr;
HXDLIN(  60)		 ::trilateral3::drawing::Pen this6 = this->regular;
HXDLIN(  60)		 ::trilateral3::structure::RegularShape rs5 =  ::trilateral3::structure::RegularShape_obj::__alloc( HX_CTX ,( (Float)((x + (dx * 2))) ),( (Float)((y + (2 * dy))) ),( (Float)(50) ),this->nines->__get((c + 3)));
HXDLIN(  60)		int start5 = ( (int)(this6->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  60)		 ::Dynamic drawType5 = this6->drawType;
HXDLIN(  60)		Float ax5 = rs5->x;
HXDLIN(  60)		Float ay5 = rs5->y;
HXDLIN(  60)		Float radius4 = rs5->radius;
HXDLIN(  60)		 ::Dynamic sides4 = 6;
HXDLIN(  60)		if (::hx::IsNull( sides4 )) {
HXLINE(  60)			sides4 = 36;
            		}
HXDLIN(  60)		Float pi4 = ::Math_obj::PI;
HXDLIN(  60)		Float theta4 = (pi4 / ( (Float)(2) ));
HXDLIN(  60)		Float step4 = ((pi4 * ( (Float)(2) )) / ( (Float)(sides4) ));
HXDLIN(  60)		Float bx5;
HXDLIN(  60)		Float by5;
HXDLIN(  60)		Float cx5;
HXDLIN(  60)		Float cy5;
HXDLIN(  60)		{
HXLINE(  60)			int _g8 = 0;
HXDLIN(  60)			 ::Dynamic _g9 = sides4;
HXDLIN(  60)			while(::hx::IsLess( _g8,_g9 )){
HXLINE(  60)				_g8 = (_g8 + 1);
HXDLIN(  60)				int i = (_g8 - 1);
HXDLIN(  60)				bx5 = (ax5 + (radius4 * ::Math_obj::sin(theta4)));
HXDLIN(  60)				by5 = (ay5 + (radius4 * ::Math_obj::cos(theta4)));
HXDLIN(  60)				theta4 = (theta4 + step4);
HXDLIN(  60)				cx5 = (ax5 + (radius4 * ::Math_obj::sin(theta4)));
HXDLIN(  60)				cy5 = (ay5 + (radius4 * ::Math_obj::cos(theta4)));
HXDLIN(  60)				{
HXLINE(  60)					drawType5->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax5,ay5,0,bx5,by5,0,cx5,cy5,0);
HXDLIN(  60)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  60)					if (::hx::IsNotNull( m )) {
HXLINE(  60)						drawType5->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  60)					drawType5->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  60)		int len5 = ( (int)(sides4) );
HXDLIN(  60)		{
HXLINE(  60)			int col5 = rs5->color;
HXDLIN(  60)			{
HXLINE(  60)				this6->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start5);
HXDLIN(  60)				this6->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start5);
            			}
HXDLIN(  60)			{
HXLINE(  60)				int color5 = col5;
HXDLIN(  60)				if ((color5 == -1)) {
HXLINE(  60)					color5 = this6->currentColor;
            				}
HXDLIN(  60)				this6->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color5,len5);
            			}
            		}
HXDLIN(  60)		int end5 = ((start5 + len5) - 1);
HXDLIN(  60)		 ::trilateral3::structure::StartEnd startEnd4 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start5,end5);
HXDLIN(  60)		_hx_tmp5[5] = startEnd4;
HXLINE(  61)		::Array< ::Dynamic> _hx_tmp6 = this->arr;
HXDLIN(  61)		 ::trilateral3::drawing::Pen this7 = this->regular;
HXDLIN(  61)		 ::trilateral3::structure::RegularShape rs6 =  ::trilateral3::structure::RegularShape_obj::__alloc( HX_CTX ,( (Float)((x + (dx * 2))) ),( (Float)((y + (3 * dy))) ),( (Float)(50) ),this->nines->__get((c + 5)));
HXDLIN(  61)		int start6 = ( (int)(this7->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  61)		 ::Dynamic drawType6 = this7->drawType;
HXDLIN(  61)		Float x2 = (rs6->x - rs6->radius);
HXDLIN(  61)		Float y1 = (rs6->y - rs6->radius);
HXDLIN(  61)		Float width = (rs6->radius * ( (Float)(2) ));
HXDLIN(  61)		Float height = (rs6->radius * ( (Float)(2) ));
HXDLIN(  61)		Float radius5 = this7->rounded;
HXDLIN(  61)		Float pi5 = ::Math_obj::PI;
HXDLIN(  61)		Float pi_2 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  61)		Float ax6 = (x2 + radius5);
HXDLIN(  61)		Float ay6 = (y1 + radius5);
HXDLIN(  61)		Float bx6 = ((x2 + width) - radius5);
HXDLIN(  61)		Float by6 = (y1 + radius5);
HXDLIN(  61)		Float cx6 = bx6;
HXDLIN(  61)		Float cy6 = ((y1 + height) - radius5);
HXDLIN(  61)		Float dx2 = ax6;
HXDLIN(  61)		Float dy2 = cy6;
HXDLIN(  61)		int count = 0;
HXDLIN(  61)		Float ax7 = ax6;
HXDLIN(  61)		Float ay7 = y1;
HXDLIN(  61)		Float bx7 = (ax6 + (width - (radius5 * ( (Float)(2) ))));
HXDLIN(  61)		Float by7 = ay7;
HXDLIN(  61)		Float cx7 = bx7;
HXDLIN(  61)		Float cy7 = (ay7 + height);
HXDLIN(  61)		Float dx3 = ax6;
HXDLIN(  61)		Float dy3 = cy7;
HXDLIN(  61)		{
HXLINE(  61)			drawType6->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax7,ay7,0,bx7,by7,0,dx3,dy3,0);
HXDLIN(  61)			 ::trilateral3::matrix::MatrixDozen m2 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  61)			if (::hx::IsNotNull( m2 )) {
HXLINE(  61)				drawType6->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m2);
            			}
HXDLIN(  61)			drawType6->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  61)		{
HXLINE(  61)			drawType6->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx7,by7,0,cx7,cy7,0,dx3,dy3,0);
HXDLIN(  61)			 ::trilateral3::matrix::MatrixDozen m3 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  61)			if (::hx::IsNotNull( m3 )) {
HXLINE(  61)				drawType6->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m3);
            			}
HXDLIN(  61)			drawType6->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  61)		count = (count + 2);
HXDLIN(  61)		Float dimY = (height - (( (Float)(2) ) * radius5));
HXDLIN(  61)		Float ax8 = x2;
HXDLIN(  61)		Float ay8 = ay6;
HXDLIN(  61)		Float bx8 = (x2 + radius5);
HXDLIN(  61)		Float by8 = ay8;
HXDLIN(  61)		Float cx8 = bx8;
HXDLIN(  61)		Float cy8 = (ay8 + dimY);
HXDLIN(  61)		Float dx4 = x2;
HXDLIN(  61)		Float dy4 = cy8;
HXDLIN(  61)		{
HXLINE(  61)			drawType6->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax8,ay8,0,bx8,by8,0,dx4,dy4,0);
HXDLIN(  61)			 ::trilateral3::matrix::MatrixDozen m4 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  61)			if (::hx::IsNotNull( m4 )) {
HXLINE(  61)				drawType6->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m4);
            			}
HXDLIN(  61)			drawType6->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  61)		{
HXLINE(  61)			drawType6->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx8,by8,0,cx8,cy8,0,dx4,dy4,0);
HXDLIN(  61)			 ::trilateral3::matrix::MatrixDozen m5 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  61)			if (::hx::IsNotNull( m5 )) {
HXLINE(  61)				drawType6->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m5);
            			}
HXDLIN(  61)			drawType6->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  61)		count = (count + 2);
HXDLIN(  61)		Float ax9 = bx6;
HXDLIN(  61)		Float ay9 = by6;
HXDLIN(  61)		Float bx9 = (bx6 + radius5);
HXDLIN(  61)		Float by9 = ay9;
HXDLIN(  61)		Float cx9 = bx9;
HXDLIN(  61)		Float cy9 = (ay9 + dimY);
HXDLIN(  61)		Float dx5 = bx6;
HXDLIN(  61)		Float dy5 = cy9;
HXDLIN(  61)		{
HXLINE(  61)			drawType6->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax9,ay9,0,bx9,by9,0,dx5,dy5,0);
HXDLIN(  61)			 ::trilateral3::matrix::MatrixDozen m6 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  61)			if (::hx::IsNotNull( m6 )) {
HXLINE(  61)				drawType6->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m6);
            			}
HXDLIN(  61)			drawType6->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  61)		{
HXLINE(  61)			drawType6->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx9,by9,0,cx9,cy9,0,dx5,dy5,0);
HXDLIN(  61)			 ::trilateral3::matrix::MatrixDozen m7 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  61)			if (::hx::IsNotNull( m7 )) {
HXLINE(  61)				drawType6->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m7);
            			}
HXDLIN(  61)			drawType6->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  61)		count = (count + 2);
HXDLIN(  61)		Float beta = -(pi5);
HXDLIN(  61)		Float gamma = -(pi_2);
HXDLIN(  61)		Float pi6 = ::Math_obj::PI;
HXDLIN(  61)		Float step5 = ((pi6 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  61)		Float dif;
HXDLIN(  61)		switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE(  61)				Float f;
HXDLIN(  61)				bool f1;
HXDLIN(  61)				if ((beta >= 0)) {
HXLINE(  61)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f1 = false;
            				}
HXDLIN(  61)				if (f1) {
HXLINE(  61)					f = beta;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f2;
HXDLIN(  61)				bool f3;
HXDLIN(  61)				if ((gamma >= 0)) {
HXLINE(  61)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f3 = false;
            				}
HXDLIN(  61)				if (f3) {
HXLINE(  61)					f2 = gamma;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f2 = a;
            					}
            					else {
HXLINE(  61)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f2;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif1;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif1 = theta;
            				}
            				else {
HXLINE(  61)					dif1 = -(theta);
            				}
HXDLIN(  61)				if ((dif1 > 0)) {
HXLINE(  61)					dif = dif1;
            				}
            				else {
HXLINE(  61)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE(  61)				Float f;
HXDLIN(  61)				bool f1;
HXDLIN(  61)				if ((beta >= 0)) {
HXLINE(  61)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f1 = false;
            				}
HXDLIN(  61)				if (f1) {
HXLINE(  61)					f = beta;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f2;
HXDLIN(  61)				bool f3;
HXDLIN(  61)				if ((gamma >= 0)) {
HXLINE(  61)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f3 = false;
            				}
HXDLIN(  61)				if (f3) {
HXLINE(  61)					f2 = gamma;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f2 = a;
            					}
            					else {
HXLINE(  61)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f2;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif1;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif1 = theta;
            				}
            				else {
HXLINE(  61)					dif1 = -(theta);
            				}
HXDLIN(  61)				if ((dif1 < 0)) {
HXLINE(  61)					dif = dif1;
            				}
            				else {
HXLINE(  61)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE(  61)				Float f;
HXDLIN(  61)				bool f1;
HXDLIN(  61)				if ((beta >= 0)) {
HXLINE(  61)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f1 = false;
            				}
HXDLIN(  61)				if (f1) {
HXLINE(  61)					f = beta;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f2;
HXDLIN(  61)				bool f3;
HXDLIN(  61)				if ((gamma >= 0)) {
HXLINE(  61)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f3 = false;
            				}
HXDLIN(  61)				if (f3) {
HXLINE(  61)					f2 = gamma;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f2 = a;
            					}
            					else {
HXLINE(  61)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f2;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif1;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif1 = theta;
            				}
            				else {
HXLINE(  61)					dif1 = -(theta);
            				}
HXDLIN(  61)				if (smallest) {
HXLINE(  61)					dif = dif1;
            				}
            				else {
HXLINE(  61)					if (clockwise) {
HXLINE(  61)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE(  61)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE(  61)				Float f;
HXDLIN(  61)				bool f1;
HXDLIN(  61)				if ((beta >= 0)) {
HXLINE(  61)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f1 = false;
            				}
HXDLIN(  61)				if (f1) {
HXLINE(  61)					f = beta;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f2;
HXDLIN(  61)				bool f3;
HXDLIN(  61)				if ((gamma >= 0)) {
HXLINE(  61)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f3 = false;
            				}
HXDLIN(  61)				if (f3) {
HXLINE(  61)					f2 = gamma;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f2 = a;
            					}
            					else {
HXLINE(  61)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f2;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif1;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif1 = theta;
            				}
            				else {
HXLINE(  61)					dif1 = -(theta);
            				}
HXDLIN(  61)				if (largest) {
HXLINE(  61)					dif = dif1;
            				}
            				else {
HXLINE(  61)					if (clockwise) {
HXLINE(  61)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE(  61)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  61)		bool positive = (dif >= 0);
HXDLIN(  61)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step5));
HXDLIN(  61)		Float step6 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  61)		Float angle = beta;
HXDLIN(  61)		Float cx10;
HXDLIN(  61)		Float cy10;
HXDLIN(  61)		Float bx10 = ( (Float)(0) );
HXDLIN(  61)		Float by10 = ( (Float)(0) );
HXDLIN(  61)		{
HXLINE(  61)			int _g10 = 0;
HXDLIN(  61)			int _g11 = (totalSteps + 1);
HXDLIN(  61)			while((_g10 < _g11)){
HXLINE(  61)				_g10 = (_g10 + 1);
HXDLIN(  61)				int i = (_g10 - 1);
HXDLIN(  61)				cx10 = (ax6 + (radius5 * ::Math_obj::sin(angle)));
HXDLIN(  61)				cy10 = (ay6 + (radius5 * ::Math_obj::cos(angle)));
HXDLIN(  61)				if ((i != 0)) {
HXLINE(  61)					drawType6->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax6,ay6,0,bx10,by10,0,cx10,cy10,0);
HXDLIN(  61)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  61)					if (::hx::IsNotNull( m )) {
HXLINE(  61)						drawType6->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  61)					drawType6->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  61)				angle = (angle + step6);
HXDLIN(  61)				bx10 = cx10;
HXDLIN(  61)				by10 = cy10;
            			}
            		}
HXDLIN(  61)		count = (count + totalSteps);
HXDLIN(  61)		Float pi7 = ::Math_obj::PI;
HXDLIN(  61)		Float step7 = ((pi7 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  61)		Float dif1;
HXDLIN(  61)		switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE(  61)				Float f;
HXDLIN(  61)				bool f1;
HXDLIN(  61)				if ((pi_2 >= 0)) {
HXLINE(  61)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f1 = false;
            				}
HXDLIN(  61)				if (f1) {
HXLINE(  61)					f = pi_2;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f2;
HXDLIN(  61)				bool f3;
HXDLIN(  61)				if ((pi5 >= 0)) {
HXLINE(  61)					f3 = (pi5 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f3 = false;
            				}
HXDLIN(  61)				if (f3) {
HXLINE(  61)					f2 = pi5;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(pi5,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f2 = a;
            					}
            					else {
HXLINE(  61)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f2;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif = theta;
            				}
            				else {
HXLINE(  61)					dif = -(theta);
            				}
HXDLIN(  61)				if ((dif > 0)) {
HXLINE(  61)					dif1 = dif;
            				}
            				else {
HXLINE(  61)					dif1 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE(  61)				Float f;
HXDLIN(  61)				bool f1;
HXDLIN(  61)				if ((pi_2 >= 0)) {
HXLINE(  61)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f1 = false;
            				}
HXDLIN(  61)				if (f1) {
HXLINE(  61)					f = pi_2;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f2;
HXDLIN(  61)				bool f3;
HXDLIN(  61)				if ((pi5 >= 0)) {
HXLINE(  61)					f3 = (pi5 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f3 = false;
            				}
HXDLIN(  61)				if (f3) {
HXLINE(  61)					f2 = pi5;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(pi5,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f2 = a;
            					}
            					else {
HXLINE(  61)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f2;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif = theta;
            				}
            				else {
HXLINE(  61)					dif = -(theta);
            				}
HXDLIN(  61)				if ((dif < 0)) {
HXLINE(  61)					dif1 = dif;
            				}
            				else {
HXLINE(  61)					dif1 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE(  61)				Float f;
HXDLIN(  61)				bool f1;
HXDLIN(  61)				if ((pi_2 >= 0)) {
HXLINE(  61)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f1 = false;
            				}
HXDLIN(  61)				if (f1) {
HXLINE(  61)					f = pi_2;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f2;
HXDLIN(  61)				bool f3;
HXDLIN(  61)				if ((pi5 >= 0)) {
HXLINE(  61)					f3 = (pi5 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f3 = false;
            				}
HXDLIN(  61)				if (f3) {
HXLINE(  61)					f2 = pi5;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(pi5,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f2 = a;
            					}
            					else {
HXLINE(  61)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f2;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif = theta;
            				}
            				else {
HXLINE(  61)					dif = -(theta);
            				}
HXDLIN(  61)				if (smallest) {
HXLINE(  61)					dif1 = dif;
            				}
            				else {
HXLINE(  61)					if (clockwise) {
HXLINE(  61)						dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE(  61)						dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE(  61)				Float f;
HXDLIN(  61)				bool f1;
HXDLIN(  61)				if ((pi_2 >= 0)) {
HXLINE(  61)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f1 = false;
            				}
HXDLIN(  61)				if (f1) {
HXLINE(  61)					f = pi_2;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f2;
HXDLIN(  61)				bool f3;
HXDLIN(  61)				if ((pi5 >= 0)) {
HXLINE(  61)					f3 = (pi5 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f3 = false;
            				}
HXDLIN(  61)				if (f3) {
HXLINE(  61)					f2 = pi5;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(pi5,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f2 = a;
            					}
            					else {
HXLINE(  61)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f2;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif = theta;
            				}
            				else {
HXLINE(  61)					dif = -(theta);
            				}
HXDLIN(  61)				if (largest) {
HXLINE(  61)					dif1 = dif;
            				}
            				else {
HXLINE(  61)					if (clockwise) {
HXLINE(  61)						dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE(  61)						dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  61)		bool positive1 = (dif1 >= 0);
HXDLIN(  61)		int totalSteps1 = ::Math_obj::ceil((::Math_obj::abs(dif1) / step7));
HXDLIN(  61)		Float step8 = (dif1 / ( (Float)(totalSteps1) ));
HXDLIN(  61)		Float angle1 = pi_2;
HXDLIN(  61)		Float cx11;
HXDLIN(  61)		Float cy11;
HXDLIN(  61)		Float bx11 = ( (Float)(0) );
HXDLIN(  61)		Float by11 = ( (Float)(0) );
HXDLIN(  61)		{
HXLINE(  61)			int _g12 = 0;
HXDLIN(  61)			int _g13 = (totalSteps1 + 1);
HXDLIN(  61)			while((_g12 < _g13)){
HXLINE(  61)				_g12 = (_g12 + 1);
HXDLIN(  61)				int i = (_g12 - 1);
HXDLIN(  61)				cx11 = (bx6 + (radius5 * ::Math_obj::sin(angle1)));
HXDLIN(  61)				cy11 = (by6 + (radius5 * ::Math_obj::cos(angle1)));
HXDLIN(  61)				if ((i != 0)) {
HXLINE(  61)					drawType6->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx6,by6,0,bx11,by11,0,cx11,cy11,0);
HXDLIN(  61)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  61)					if (::hx::IsNotNull( m )) {
HXLINE(  61)						drawType6->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  61)					drawType6->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  61)				angle1 = (angle1 + step8);
HXDLIN(  61)				bx11 = cx11;
HXDLIN(  61)				by11 = cy11;
            			}
            		}
HXDLIN(  61)		count = (count + totalSteps1);
HXDLIN(  61)		Float pi8 = ::Math_obj::PI;
HXDLIN(  61)		Float step9 = ((pi8 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  61)		Float dif2;
HXDLIN(  61)		switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE(  61)				Float f;
HXDLIN(  61)				bool f1;
HXDLIN(  61)				if ((pi_2 >= 0)) {
HXLINE(  61)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f1 = false;
            				}
HXDLIN(  61)				if (f1) {
HXLINE(  61)					f = pi_2;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f2;
HXDLIN(  61)				if ((0 > ::Math_obj::PI)) {
HXLINE(  61)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f2 = a;
            					}
            					else {
HXLINE(  61)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f2;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif = theta;
            				}
            				else {
HXLINE(  61)					dif = -(theta);
            				}
HXDLIN(  61)				if ((dif > 0)) {
HXLINE(  61)					dif2 = dif;
            				}
            				else {
HXLINE(  61)					dif2 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE(  61)				Float f;
HXDLIN(  61)				bool f1;
HXDLIN(  61)				if ((pi_2 >= 0)) {
HXLINE(  61)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f1 = false;
            				}
HXDLIN(  61)				if (f1) {
HXLINE(  61)					f = pi_2;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f2;
HXDLIN(  61)				if ((0 > ::Math_obj::PI)) {
HXLINE(  61)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f2 = a;
            					}
            					else {
HXLINE(  61)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f2;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif = theta;
            				}
            				else {
HXLINE(  61)					dif = -(theta);
            				}
HXDLIN(  61)				if ((dif < 0)) {
HXLINE(  61)					dif2 = dif;
            				}
            				else {
HXLINE(  61)					dif2 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE(  61)				Float f;
HXDLIN(  61)				bool f1;
HXDLIN(  61)				if ((pi_2 >= 0)) {
HXLINE(  61)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f1 = false;
            				}
HXDLIN(  61)				if (f1) {
HXLINE(  61)					f = pi_2;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f2;
HXDLIN(  61)				if ((0 > ::Math_obj::PI)) {
HXLINE(  61)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f2 = a;
            					}
            					else {
HXLINE(  61)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f2;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif = theta;
            				}
            				else {
HXLINE(  61)					dif = -(theta);
            				}
HXDLIN(  61)				if (smallest) {
HXLINE(  61)					dif2 = dif;
            				}
            				else {
HXLINE(  61)					if (clockwise) {
HXLINE(  61)						dif2 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE(  61)						dif2 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE(  61)				Float f;
HXDLIN(  61)				bool f1;
HXDLIN(  61)				if ((pi_2 >= 0)) {
HXLINE(  61)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f1 = false;
            				}
HXDLIN(  61)				if (f1) {
HXLINE(  61)					f = pi_2;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f2;
HXDLIN(  61)				if ((0 > ::Math_obj::PI)) {
HXLINE(  61)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f2 = a;
            					}
            					else {
HXLINE(  61)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f2;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif = theta;
            				}
            				else {
HXLINE(  61)					dif = -(theta);
            				}
HXDLIN(  61)				if (largest) {
HXLINE(  61)					dif2 = dif;
            				}
            				else {
HXLINE(  61)					if (clockwise) {
HXLINE(  61)						dif2 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE(  61)						dif2 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  61)		bool positive2 = (dif2 >= 0);
HXDLIN(  61)		int totalSteps2 = ::Math_obj::ceil((::Math_obj::abs(dif2) / step9));
HXDLIN(  61)		Float step10 = (dif2 / ( (Float)(totalSteps2) ));
HXDLIN(  61)		Float angle2 = pi_2;
HXDLIN(  61)		Float cx12;
HXDLIN(  61)		Float cy12;
HXDLIN(  61)		Float bx12 = ( (Float)(0) );
HXDLIN(  61)		Float by12 = ( (Float)(0) );
HXDLIN(  61)		{
HXLINE(  61)			int _g14 = 0;
HXDLIN(  61)			int _g15 = (totalSteps2 + 1);
HXDLIN(  61)			while((_g14 < _g15)){
HXLINE(  61)				_g14 = (_g14 + 1);
HXDLIN(  61)				int i = (_g14 - 1);
HXDLIN(  61)				cx12 = (cx6 + (radius5 * ::Math_obj::sin(angle2)));
HXDLIN(  61)				cy12 = (cy6 + (radius5 * ::Math_obj::cos(angle2)));
HXDLIN(  61)				if ((i != 0)) {
HXLINE(  61)					drawType6->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(cx6,cy6,0,bx12,by12,0,cx12,cy12,0);
HXDLIN(  61)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  61)					if (::hx::IsNotNull( m )) {
HXLINE(  61)						drawType6->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  61)					drawType6->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  61)				angle2 = (angle2 + step10);
HXDLIN(  61)				bx12 = cx12;
HXDLIN(  61)				by12 = cy12;
            			}
            		}
HXDLIN(  61)		count = (count + totalSteps2);
HXDLIN(  61)		Float gamma1 = -(pi_2);
HXDLIN(  61)		Float pi9 = ::Math_obj::PI;
HXDLIN(  61)		Float step11 = ((pi9 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  61)		Float dif3;
HXDLIN(  61)		switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE(  61)				Float f;
HXDLIN(  61)				if ((0 > ::Math_obj::PI)) {
HXLINE(  61)					f = ( (Float)(0) );
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f1;
HXDLIN(  61)				bool f2;
HXDLIN(  61)				if ((gamma1 >= 0)) {
HXLINE(  61)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f2 = false;
            				}
HXDLIN(  61)				if (f2) {
HXLINE(  61)					f1 = gamma1;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f1 = a;
            					}
            					else {
HXLINE(  61)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f1;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif = theta;
            				}
            				else {
HXLINE(  61)					dif = -(theta);
            				}
HXDLIN(  61)				if ((dif > 0)) {
HXLINE(  61)					dif3 = dif;
            				}
            				else {
HXLINE(  61)					dif3 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE(  61)				Float f;
HXDLIN(  61)				if ((0 > ::Math_obj::PI)) {
HXLINE(  61)					f = ( (Float)(0) );
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f1;
HXDLIN(  61)				bool f2;
HXDLIN(  61)				if ((gamma1 >= 0)) {
HXLINE(  61)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f2 = false;
            				}
HXDLIN(  61)				if (f2) {
HXLINE(  61)					f1 = gamma1;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f1 = a;
            					}
            					else {
HXLINE(  61)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f1;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif = theta;
            				}
            				else {
HXLINE(  61)					dif = -(theta);
            				}
HXDLIN(  61)				if ((dif < 0)) {
HXLINE(  61)					dif3 = dif;
            				}
            				else {
HXLINE(  61)					dif3 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE(  61)				Float f;
HXDLIN(  61)				if ((0 > ::Math_obj::PI)) {
HXLINE(  61)					f = ( (Float)(0) );
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f1;
HXDLIN(  61)				bool f2;
HXDLIN(  61)				if ((gamma1 >= 0)) {
HXLINE(  61)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f2 = false;
            				}
HXDLIN(  61)				if (f2) {
HXLINE(  61)					f1 = gamma1;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f1 = a;
            					}
            					else {
HXLINE(  61)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f1;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif = theta;
            				}
            				else {
HXLINE(  61)					dif = -(theta);
            				}
HXDLIN(  61)				if (smallest) {
HXLINE(  61)					dif3 = dif;
            				}
            				else {
HXLINE(  61)					if (clockwise) {
HXLINE(  61)						dif3 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE(  61)						dif3 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE(  61)				Float f;
HXDLIN(  61)				if ((0 > ::Math_obj::PI)) {
HXLINE(  61)					f = ( (Float)(0) );
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f = a;
            					}
            					else {
HXLINE(  61)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this1 = f;
HXDLIN(  61)				Float za = this1;
HXDLIN(  61)				Float f1;
HXDLIN(  61)				bool f2;
HXDLIN(  61)				if ((gamma1 >= 0)) {
HXLINE(  61)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE(  61)					f2 = false;
            				}
HXDLIN(  61)				if (f2) {
HXLINE(  61)					f1 = gamma1;
            				}
            				else {
HXLINE(  61)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  61)					if ((a >= 0)) {
HXLINE(  61)						f1 = a;
            					}
            					else {
HXLINE(  61)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  61)				Float this2 = f1;
HXDLIN(  61)				Float zb = this2;
HXDLIN(  61)				Float fa = za;
HXDLIN(  61)				Float fb = zb;
HXDLIN(  61)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  61)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  61)				bool clockwise = (fa < fb);
HXDLIN(  61)				Float dif;
HXDLIN(  61)				if (clockwise) {
HXLINE(  61)					dif = theta;
            				}
            				else {
HXLINE(  61)					dif = -(theta);
            				}
HXDLIN(  61)				if (largest) {
HXLINE(  61)					dif3 = dif;
            				}
            				else {
HXLINE(  61)					if (clockwise) {
HXLINE(  61)						dif3 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE(  61)						dif3 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  61)		bool positive3 = (dif3 >= 0);
HXDLIN(  61)		int totalSteps3 = ::Math_obj::ceil((::Math_obj::abs(dif3) / step11));
HXDLIN(  61)		Float step12 = (dif3 / ( (Float)(totalSteps3) ));
HXDLIN(  61)		Float angle3 = ( (Float)(0) );
HXDLIN(  61)		Float cx13;
HXDLIN(  61)		Float cy13;
HXDLIN(  61)		Float bx13 = ( (Float)(0) );
HXDLIN(  61)		Float by13 = ( (Float)(0) );
HXDLIN(  61)		{
HXLINE(  61)			int _g16 = 0;
HXDLIN(  61)			int _g17 = (totalSteps3 + 1);
HXDLIN(  61)			while((_g16 < _g17)){
HXLINE(  61)				_g16 = (_g16 + 1);
HXDLIN(  61)				int i = (_g16 - 1);
HXDLIN(  61)				cx13 = (dx2 + (radius5 * ::Math_obj::sin(angle3)));
HXDLIN(  61)				cy13 = (dy2 + (radius5 * ::Math_obj::cos(angle3)));
HXDLIN(  61)				if ((i != 0)) {
HXLINE(  61)					drawType6->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx2,dy2,0,bx13,by13,0,cx13,cy13,0);
HXDLIN(  61)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  61)					if (::hx::IsNotNull( m )) {
HXLINE(  61)						drawType6->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  61)					drawType6->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  61)				angle3 = (angle3 + step12);
HXDLIN(  61)				bx13 = cx13;
HXDLIN(  61)				by13 = cy13;
            			}
            		}
HXDLIN(  61)		count = (count + totalSteps3);
HXDLIN(  61)		int len6 = count;
HXDLIN(  61)		{
HXLINE(  61)			int col6 = rs6->color;
HXDLIN(  61)			{
HXLINE(  61)				this7->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start6);
HXDLIN(  61)				this7->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start6);
            			}
HXDLIN(  61)			{
HXLINE(  61)				int color6 = col6;
HXDLIN(  61)				if ((color6 == -1)) {
HXLINE(  61)					color6 = this7->currentColor;
            				}
HXDLIN(  61)				this7->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color6,len6);
            			}
            		}
HXDLIN(  61)		int end6 = ((start6 + len6) - 1);
HXDLIN(  61)		_hx_tmp6[6] =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start6,end6);
HXLINE(  62)		::Array< ::Dynamic> _hx_tmp7 = this->arr;
HXDLIN(  62)		 ::trilateral3::drawing::Pen this8 = this->regular;
HXDLIN(  62)		 ::trilateral3::structure::RegularShape rs7 =  ::trilateral3::structure::RegularShape_obj::__alloc( HX_CTX ,( (Float)((x + (dx * 2))) ),( (Float)((y + (4 * dy))) ),( (Float)(50) ),this->nines->__get((c + 7)));
HXDLIN(  62)		int start7 = ( (int)(this8->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  62)		 ::Dynamic drawType7 = this8->drawType;
HXDLIN(  62)		Float px = (rs7->x - rs7->radius);
HXDLIN(  62)		Float py = (rs7->y - rs7->radius);
HXDLIN(  62)		Float radius6 = (rs7->radius * ( (Float)(2) ));
HXDLIN(  62)		 ::Dynamic theta5 = (rs7->radius * ( (Float)(2) ));
HXDLIN(  62)		if (::hx::IsNull( theta5 )) {
HXLINE(  62)			theta5 = 0;
            		}
HXDLIN(  62)		Float pi10 = ::Math_obj::PI;
HXDLIN(  62)		Float omega = (-(pi10) + theta5);
HXDLIN(  62)		radius6 = (radius6 / ((Float)1.9));
HXDLIN(  62)		px = (px + radius6);
HXDLIN(  62)		py = (py + radius6);
HXDLIN(  62)		Float a0x = (px + (radius6 * ::Math_obj::sin(omega)));
HXDLIN(  62)		Float a0y = (py + (radius6 * ::Math_obj::cos(omega)));
HXDLIN(  62)		omega = (omega + (pi10 / ( (Float)(3) )));
HXDLIN(  62)		Float a1x = (px + (radius6 * ::Math_obj::sin(omega)));
HXDLIN(  62)		Float a1y = (py + (radius6 * ::Math_obj::cos(omega)));
HXDLIN(  62)		omega = (omega + (pi10 / ( (Float)(3) )));
HXDLIN(  62)		Float b0x = (px + (radius6 * ::Math_obj::sin(omega)));
HXDLIN(  62)		Float b0y = (py + (radius6 * ::Math_obj::cos(omega)));
HXDLIN(  62)		omega = (omega + (pi10 / ( (Float)(3) )));
HXDLIN(  62)		Float b1x = (px + (radius6 * ::Math_obj::sin(omega)));
HXDLIN(  62)		Float b1y = (py + (radius6 * ::Math_obj::cos(omega)));
HXDLIN(  62)		omega = (omega + (pi10 / ( (Float)(3) )));
HXDLIN(  62)		Float c0x = (px + (radius6 * ::Math_obj::sin(omega)));
HXDLIN(  62)		Float c0y = (py + (radius6 * ::Math_obj::cos(omega)));
HXDLIN(  62)		omega = (omega + (pi10 / ( (Float)(3) )));
HXDLIN(  62)		Float c1x = (px + (radius6 * ::Math_obj::sin(omega)));
HXDLIN(  62)		Float c1y = (py + (radius6 * ::Math_obj::cos(omega)));
HXDLIN(  62)		{
HXLINE(  62)			drawType7->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(a0x,a0y,0,b0x,b0y,0,c0x,c0y,0);
HXDLIN(  62)			 ::trilateral3::matrix::MatrixDozen m8 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  62)			if (::hx::IsNotNull( m8 )) {
HXLINE(  62)				drawType7->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m8);
            			}
HXDLIN(  62)			drawType7->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  62)		{
HXLINE(  62)			drawType7->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(a1x,a1y,0,b1x,b1y,0,c1x,c1y,0);
HXDLIN(  62)			 ::trilateral3::matrix::MatrixDozen m9 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  62)			if (::hx::IsNotNull( m9 )) {
HXLINE(  62)				drawType7->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m9);
            			}
HXDLIN(  62)			drawType7->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  62)		int len7 = 2;
HXDLIN(  62)		{
HXLINE(  62)			int col7 = rs7->color;
HXDLIN(  62)			{
HXLINE(  62)				this8->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start7);
HXDLIN(  62)				this8->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start7);
            			}
HXDLIN(  62)			{
HXLINE(  62)				int color7 = col7;
HXDLIN(  62)				if ((color7 == -1)) {
HXLINE(  62)					color7 = this8->currentColor;
            				}
HXDLIN(  62)				this8->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color7,len7);
            			}
            		}
HXDLIN(  62)		int end7 = ((start7 + len7) - 1);
HXDLIN(  62)		_hx_tmp7[7] =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start7,end7);
            	}


HX_DEFINE_DYNAMIC_FUNC0(TrilateralRegularColor_obj,draw,(void))

void TrilateralRegularColor_obj::renderDraw(){
            	HX_GC_STACKFRAME(&_hx_pos_b6ca0cd7a8a876b7_70_renderDraw)
HXLINE(  71)		if ((this->tick > this->delayStart)) {
HXLINE(  72)			int currCount = this->count;
HXLINE(  73)			{
HXLINE(  73)				int _g = 0;
HXDLIN(  73)				while((_g < 8)){
HXLINE(  73)					_g = (_g + 1);
HXDLIN(  73)					int i = (_g - 1);
HXLINE(  74)					 ::trilateral3::structure::StartEnd startEnd = this->arr->__get(i).StaticCast<  ::trilateral3::structure::StartEnd >();
HXLINE(  75)					{
HXLINE(  75)						 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN(  75)						Float v = ( (Float)(startEnd->start) );
HXDLIN(  75)						_this->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
HXDLIN(  75)						_this->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
            					}
HXLINE(  76)					 ::trilateral3::structure::TriInt col3 = ( ( ::trilateral3::structure::TriInt)(this->pen->colorType->__Field(HX_("getTriInt",ba,b1,09,c7),::hx::paccDynamic)()) );
HXLINE(  77)					int colA = col3->a;
HXLINE(  78)					int nine = this->nines->__get(this->count);
HXLINE(  79)					Float t = this->dStep;
HXDLIN(  79)					Float v1 = (((t * t) * t) * ((t * ((t * ((Float)6.0)) - ((Float)15.0))) + ((Float)10.0)));
HXDLIN(  79)					Float a = (( (Float)(((colA >> 16) & 255)) ) / ( (Float)(255) ));
HXDLIN(  79)					Float r = (a + (v1 * ((( (Float)(((nine >> 16) & 255)) ) / ( (Float)(255) )) - a)));
HXDLIN(  79)					Float a1 = (( (Float)(((colA >> 8) & 255)) ) / ( (Float)(255) ));
HXDLIN(  79)					Float g = (a1 + (v1 * ((( (Float)(((nine >> 8) & 255)) ) / ( (Float)(255) )) - a1)));
HXDLIN(  79)					Float a2 = (( (Float)((colA & 255)) ) / ( (Float)(255) ));
HXDLIN(  79)					Float b = (a2 + (v1 * ((( (Float)((nine & 255)) ) / ( (Float)(255) )) - a2)));
HXDLIN(  79)					 ::pallette::utils::ARGB argb =  ::pallette::utils::ARGB_obj::__alloc( HX_CTX ,((Float)1.),r,g,b);
HXDLIN(  79)					int this1 = ((((::Math_obj::round((argb->a * ( (Float)(255) ))) << 24) | (::Math_obj::round((argb->r * ( (Float)(255) ))) << 16)) | (::Math_obj::round((argb->g * ( (Float)(255) ))) << 8)) | ::Math_obj::round((argb->b * ( (Float)(255) ))));
HXDLIN(  79)					int colInt = this1;
HXDLIN(  79)					int c = colInt;
HXDLIN(  79)					int col = c;
HXLINE(  80)					{
HXLINE(  80)						 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN(  80)						int color = col;
HXDLIN(  80)						int times = ::Std_obj::_hx_int(( (Float)(((startEnd->end - startEnd->start) + 1)) ));
HXDLIN(  80)						if ((color == -1)) {
HXLINE(  80)							color = _this1->currentColor;
            						}
HXDLIN(  80)						_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,times);
            					}
HXLINE(  81)					this->count++;
            				}
            			}
HXLINE(  83)			if ((::hx::Mod(this->tick,this->range) == 0)) {
HXLINE(  84)				this->count++;
HXLINE(  85)				this->dStep = ( (Float)(0) );
HXLINE(  86)				if ((this->count > (this->nines->length - 1))) {
HXLINE(  86)					this->count = 1;
            				}
            			}
            			else {
HXLINE(  88)				 ::TrilateralRegularColor _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN(  88)				_hx_tmp->dStep = (_hx_tmp->dStep + (((Float)1.) / this->range));
HXLINE(  89)				this->count = currCount;
            			}
            		}
HXLINE(  92)		this->tick++;
            	}



::hx::ObjectPtr< TrilateralRegularColor_obj > TrilateralRegularColor_obj::__new( ::gluon::webgl::native::GLContext gl) {
	::hx::ObjectPtr< TrilateralRegularColor_obj > __this = new TrilateralRegularColor_obj();
	__this->__construct(gl);
	return __this;
}

::hx::ObjectPtr< TrilateralRegularColor_obj > TrilateralRegularColor_obj::__alloc(::hx::Ctx *_hx_ctx, ::gluon::webgl::native::GLContext gl) {
	TrilateralRegularColor_obj *__this = (TrilateralRegularColor_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(TrilateralRegularColor_obj), true, "TrilateralRegularColor"));
	*(void **)__this = TrilateralRegularColor_obj::_hx_vtable;
	__this->__construct(gl);
	return __this;
}

TrilateralRegularColor_obj::TrilateralRegularColor_obj()
{
}

void TrilateralRegularColor_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(TrilateralRegularColor);
	HX_MARK_MEMBER_NAME(regular,"regular");
	HX_MARK_MEMBER_NAME(arr,"arr");
	HX_MARK_MEMBER_NAME(nines,"nines");
	HX_MARK_MEMBER_NAME(pen,"pen");
	HX_MARK_MEMBER_NAME(penNodule,"penNodule");
	HX_MARK_MEMBER_NAME(tick,"tick");
	HX_MARK_MEMBER_NAME(range,"range");
	HX_MARK_MEMBER_NAME(dStep,"dStep");
	HX_MARK_MEMBER_NAME(delayStart,"delayStart");
	HX_MARK_MEMBER_NAME(count,"count");
	 ::kitGL::gluon::InterleaveAlterGL_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void TrilateralRegularColor_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(regular,"regular");
	HX_VISIT_MEMBER_NAME(arr,"arr");
	HX_VISIT_MEMBER_NAME(nines,"nines");
	HX_VISIT_MEMBER_NAME(pen,"pen");
	HX_VISIT_MEMBER_NAME(penNodule,"penNodule");
	HX_VISIT_MEMBER_NAME(tick,"tick");
	HX_VISIT_MEMBER_NAME(range,"range");
	HX_VISIT_MEMBER_NAME(dStep,"dStep");
	HX_VISIT_MEMBER_NAME(delayStart,"delayStart");
	HX_VISIT_MEMBER_NAME(count,"count");
	 ::kitGL::gluon::InterleaveAlterGL_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val TrilateralRegularColor_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"arr") ) { return ::hx::Val( arr ); }
		if (HX_FIELD_EQ(inName,"pen") ) { return ::hx::Val( pen ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		if (HX_FIELD_EQ(inName,"tick") ) { return ::hx::Val( tick ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"nines") ) { return ::hx::Val( nines ); }
		if (HX_FIELD_EQ(inName,"range") ) { return ::hx::Val( range ); }
		if (HX_FIELD_EQ(inName,"dStep") ) { return ::hx::Val( dStep ); }
		if (HX_FIELD_EQ(inName,"count") ) { return ::hx::Val( count ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"regular") ) { return ::hx::Val( regular ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"penNodule") ) { return ::hx::Val( penNodule ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"delayStart") ) { return ::hx::Val( delayStart ); }
		if (HX_FIELD_EQ(inName,"renderDraw") ) { return ::hx::Val( renderDraw_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val TrilateralRegularColor_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"arr") ) { arr=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pen") ) { pen=inValue.Cast<  ::trilateral3::drawing::Pen >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"tick") ) { tick=inValue.Cast< int >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"nines") ) { nines=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"range") ) { range=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dStep") ) { dStep=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"count") ) { count=inValue.Cast< int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"regular") ) { regular=inValue.Cast<  ::trilateral3::drawing::Pen >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"penNodule") ) { penNodule=inValue.Cast<  ::trilateral3::nodule::PenNodule >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"delayStart") ) { delayStart=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void TrilateralRegularColor_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("regular",5c,52,88,82));
	outFields->push(HX_("arr",61,fe,49,00));
	outFields->push(HX_("nines",01,07,cf,9b));
	outFields->push(HX_("pen",d9,54,55,00));
	outFields->push(HX_("penNodule",c4,02,81,14));
	outFields->push(HX_("tick",5d,c3,fc,4c));
	outFields->push(HX_("range",bd,a5,1f,e4));
	outFields->push(HX_("dStep",d0,15,47,cb));
	outFields->push(HX_("delayStart",df,f1,a6,b1));
	outFields->push(HX_("count",cf,44,63,4a));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo TrilateralRegularColor_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::trilateral3::drawing::Pen */ ,(int)offsetof(TrilateralRegularColor_obj,regular),HX_("regular",5c,52,88,82)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(TrilateralRegularColor_obj,arr),HX_("arr",61,fe,49,00)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(TrilateralRegularColor_obj,nines),HX_("nines",01,07,cf,9b)},
	{::hx::fsObject /*  ::trilateral3::drawing::Pen */ ,(int)offsetof(TrilateralRegularColor_obj,pen),HX_("pen",d9,54,55,00)},
	{::hx::fsObject /*  ::trilateral3::nodule::PenNodule */ ,(int)offsetof(TrilateralRegularColor_obj,penNodule),HX_("penNodule",c4,02,81,14)},
	{::hx::fsInt,(int)offsetof(TrilateralRegularColor_obj,tick),HX_("tick",5d,c3,fc,4c)},
	{::hx::fsFloat,(int)offsetof(TrilateralRegularColor_obj,range),HX_("range",bd,a5,1f,e4)},
	{::hx::fsFloat,(int)offsetof(TrilateralRegularColor_obj,dStep),HX_("dStep",d0,15,47,cb)},
	{::hx::fsInt,(int)offsetof(TrilateralRegularColor_obj,delayStart),HX_("delayStart",df,f1,a6,b1)},
	{::hx::fsInt,(int)offsetof(TrilateralRegularColor_obj,count),HX_("count",cf,44,63,4a)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *TrilateralRegularColor_obj_sStaticStorageInfo = 0;
#endif

static ::String TrilateralRegularColor_obj_sMemberFields[] = {
	HX_("regular",5c,52,88,82),
	HX_("arr",61,fe,49,00),
	HX_("nines",01,07,cf,9b),
	HX_("pen",d9,54,55,00),
	HX_("penNodule",c4,02,81,14),
	HX_("draw",04,2c,70,42),
	HX_("tick",5d,c3,fc,4c),
	HX_("range",bd,a5,1f,e4),
	HX_("dStep",d0,15,47,cb),
	HX_("delayStart",df,f1,a6,b1),
	HX_("count",cf,44,63,4a),
	HX_("renderDraw",7a,26,7a,df),
	::String(null()) };

::hx::Class TrilateralRegularColor_obj::__mClass;

void TrilateralRegularColor_obj::__register()
{
	TrilateralRegularColor_obj _hx_dummy;
	TrilateralRegularColor_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("TrilateralRegularColor",53,7c,97,18);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(TrilateralRegularColor_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< TrilateralRegularColor_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TrilateralRegularColor_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TrilateralRegularColor_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

