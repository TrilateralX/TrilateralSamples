// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_fracs_DifferencePreference
#include <fracs/DifferencePreference.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_justPath_IPathContext
#include <justPath/IPathContext.h>
#endif
#ifndef INCLUDED_trilateral3_Trilateral
#include <trilateral3/Trilateral.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Contour
#include <trilateral3/drawing/Contour.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Pen
#include <trilateral3/drawing/Pen.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Sketch
#include <trilateral3/drawing/Sketch.h>
#endif
#ifndef INCLUDED_trilateral3_matrix_MatrixDozen
#include <trilateral3/matrix/MatrixDozen.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_6351d8d914bc61da_22_new,"trilateral3.drawing.Sketch","new",0x720a6595,"trilateral3.drawing.Sketch.new","trilateral3/drawing/Sketch.hx",22,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_38_tracerLine,"trilateral3.drawing.Sketch","tracerLine",0x0f56c04c,"trilateral3.drawing.Sketch.tracerLine","trilateral3/drawing/Sketch.hx",38,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_40_fillOnlyLine,"trilateral3.drawing.Sketch","fillOnlyLine",0x8ad9d14e,"trilateral3.drawing.Sketch.fillOnlyLine","trilateral3/drawing/Sketch.hx",40,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_42_baseLine,"trilateral3.drawing.Sketch","baseLine",0xf4387350,"trilateral3.drawing.Sketch.baseLine","trilateral3/drawing/Sketch.hx",42,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_47_crudeLine,"trilateral3.drawing.Sketch","crudeLine",0x9b1c8e70,"trilateral3.drawing.Sketch.crudeLine","trilateral3/drawing/Sketch.hx",47,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_50_roundEndLine,"trilateral3.drawing.Sketch","roundEndLine",0xcb0a62ec,"trilateral3.drawing.Sketch.roundEndLine","trilateral3/drawing/Sketch.hx",50,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_53_mediumLine,"trilateral3.drawing.Sketch","mediumLine",0x40d82274,"trilateral3.drawing.Sketch.mediumLine","trilateral3/drawing/Sketch.hx",53,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_56_mediumOverlapLine,"trilateral3.drawing.Sketch","mediumOverlapLine",0x6ebb9c9b,"trilateral3.drawing.Sketch.mediumOverlapLine","trilateral3/drawing/Sketch.hx",56,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_59_fineLine,"trilateral3.drawing.Sketch","fineLine",0x25e523f9,"trilateral3.drawing.Sketch.fineLine","trilateral3/drawing/Sketch.hx",59,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_62_fineOverlapLine,"trilateral3.drawing.Sketch","fineOverlapLine",0xdef605b6,"trilateral3.drawing.Sketch.fineOverlapLine","trilateral3/drawing/Sketch.hx",62,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_231_moveTo,"trilateral3.drawing.Sketch","moveTo",0x7089acd7,"trilateral3.drawing.Sketch.moveTo","trilateral3/drawing/Sketch.hx",231,0x5aa78a39)
namespace trilateral3{
namespace drawing{

void Sketch_obj::__construct( ::trilateral3::drawing::Pen pen_,int sketchForm_,::hx::Null< int >  __o_endLine_){
            		int endLine_ = __o_endLine_.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_6351d8d914bc61da_22_new)
HXLINE(  25)		this->width = ((Float)0.01);
HXLINE(  24)		this->y = ((Float)0.);
HXLINE(  23)		this->x = ((Float)0.);
HXLINE(  67)		this->contour =  ::trilateral3::drawing::Contour_obj::__alloc( HX_CTX ,pen_,endLine_);
HXLINE(  68)		this->pen = pen_;
HXLINE(  69)		this->endLine = endLine_;
HXLINE(  70)		this->sketchForm = sketchForm_;
HXLINE(  71)		switch((int)(sketchForm_)){
            			case (int)0: {
HXLINE(  72)				this->line = this->tracerLine_dyn();
            			}
            			break;
            			case (int)1: {
HXLINE(  73)				this->line = this->baseLine_dyn();
            			}
            			break;
            			case (int)2: {
HXLINE(  74)				this->line = this->crudeLine_dyn();
            			}
            			break;
            			case (int)3: {
HXLINE(  75)				this->line = this->fillOnlyLine_dyn();
            			}
            			break;
            			case (int)4: {
HXLINE(  76)				this->line = this->fineLine_dyn();
            			}
            			break;
            			case (int)5: {
HXLINE(  77)				this->line = this->fineOverlapLine_dyn();
            			}
            			break;
            			case (int)6: {
HXLINE(  78)				this->line = this->mediumLine_dyn();
            			}
            			break;
            			case (int)7: {
HXLINE(  79)				this->line = this->mediumOverlapLine_dyn();
            			}
            			break;
            			case (int)8: {
HXLINE(  80)				this->line = this->roundEndLine_dyn();
            			}
            			break;
            		}
HXLINE(  82)		this->points = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  83)		this->pointsClock = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  84)		this->pointsAnti = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  85)		this->points[0] = ::Array_obj< Float >::__new();
HXLINE(  86)		this->dim = ::Array_obj< ::Dynamic>::__new();
            	}

Dynamic Sketch_obj::__CreateEmpty() { return new Sketch_obj; }

void *Sketch_obj::_hx_vtable = 0;

Dynamic Sketch_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Sketch_obj > _hx_result = new Sketch_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool Sketch_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x100e59ef;
}

static ::justPath::IPathContext_obj _hx_trilateral3_drawing_Sketch__hx_justPath_IPathContext= {
};

void *Sketch_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0xed67b972: return &_hx_trilateral3_drawing_Sketch__hx_justPath_IPathContext;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void Sketch_obj::tracerLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_38_tracerLine)
HXDLIN(  38)		::haxe::Log_obj::trace(((((((((HX_("lineTo( ",47,6b,2a,8a) + this->x) + HX_(", ",74,26,00,00)) + this->y) + HX_(", ",74,26,00,00)) + x_) + HX_(", ",74,26,00,00)) + y_) + HX_(", width )",9b,2f,cd,98)),::hx::SourceInfo(HX_("trilateral3/drawing/Sketch.hx",39,8a,a7,5a),38,HX_("trilateral3.drawing.Sketch",23,f7,00,b3),HX_("tracerLine",e1,14,6f,0a)));
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,tracerLine,(void))

void Sketch_obj::fillOnlyLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_40_fillOnlyLine)
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,fillOnlyLine,(void))

void Sketch_obj::baseLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_42_baseLine)
HXLINE(  43)		::haxe::Log_obj::trace(((((((((HX_("lineTo( ",47,6b,2a,8a) + this->x) + HX_(", ",74,26,00,00)) + this->y) + HX_(", ",74,26,00,00)) + x_) + HX_(", ",74,26,00,00)) + y_) + HX_(", width )",9b,2f,cd,98)),::hx::SourceInfo(HX_("trilateral3/drawing/Sketch.hx",39,8a,a7,5a),38,HX_("trilateral3.drawing.Sketch",23,f7,00,b3),HX_("tracerLine",e1,14,6f,0a)));
HXLINE(  44)		{
HXLINE(  44)			 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  44)			Float ax_ = this->x;
HXDLIN(  44)			Float ay_ = this->y;
HXDLIN(  44)			Float width_ = this->width;
HXDLIN(  44)			_this->ax = x_;
HXDLIN(  44)			_this->ay = y_;
HXDLIN(  44)			_this->bx = ax_;
HXDLIN(  44)			_this->by = ay_;
HXDLIN(  44)			_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  44)			_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  44)			_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  44)			{
HXLINE(  44)				{
HXLINE(  44)					_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  44)					if ((_this->theta > 0)) {
HXLINE(  44)						if ((_this->halfA < 0)) {
HXLINE(  44)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            						else {
HXLINE(  44)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  44)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            					}
            					else {
HXLINE(  44)						if ((_this->halfA > 0)) {
HXLINE(  44)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  44)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            						else {
HXLINE(  44)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            					}
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dxPrev )) {
HXLINE(  44)					_this->dxOld = _this->dxPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dyPrev )) {
HXLINE(  44)					_this->dyOld = _this->dyPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->exPrev )) {
HXLINE(  44)					_this->exOld = _this->exPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->eyPrev )) {
HXLINE(  44)					_this->eyOld = _this->eyPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dx )) {
HXLINE(  44)					_this->dxPrev = _this->dx;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dy )) {
HXLINE(  44)					_this->dyPrev = _this->dy;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->ex )) {
HXLINE(  44)					_this->exPrev = _this->ex;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->ey )) {
HXLINE(  44)					_this->eyPrev = _this->ey;
            				}
HXDLIN(  44)				_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  44)				_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  44)				_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  44)				_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            			}
HXDLIN(  44)			 ::Dynamic dxPrev_ = _this->dx;
HXDLIN(  44)			 ::Dynamic dyPrev_ = _this->dy;
HXDLIN(  44)			 ::Dynamic exPrev_ = _this->ex;
HXDLIN(  44)			 ::Dynamic eyPrev_ = _this->ey;
HXDLIN(  44)			_this->ax = ax_;
HXDLIN(  44)			_this->ay = ay_;
HXDLIN(  44)			_this->bx = x_;
HXDLIN(  44)			_this->by = y_;
HXDLIN(  44)			{
HXLINE(  44)				{
HXLINE(  44)					_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  44)					if ((_this->theta > 0)) {
HXLINE(  44)						if ((_this->halfA < 0)) {
HXLINE(  44)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            						else {
HXLINE(  44)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  44)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            					}
            					else {
HXLINE(  44)						if ((_this->halfA > 0)) {
HXLINE(  44)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  44)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            						else {
HXLINE(  44)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            					}
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dxPrev )) {
HXLINE(  44)					_this->dxOld = _this->dxPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dyPrev )) {
HXLINE(  44)					_this->dyOld = _this->dyPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->exPrev )) {
HXLINE(  44)					_this->exOld = _this->exPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->eyPrev )) {
HXLINE(  44)					_this->eyOld = _this->eyPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dx )) {
HXLINE(  44)					_this->dxPrev = _this->dx;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dy )) {
HXLINE(  44)					_this->dyPrev = _this->dy;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->ex )) {
HXLINE(  44)					_this->exPrev = _this->ex;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->ey )) {
HXLINE(  44)					_this->eyPrev = _this->ey;
            				}
HXDLIN(  44)				_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  44)				_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  44)				_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  44)				_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            			}
HXDLIN(  44)			{
HXLINE(  44)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  44)				int color = -1;
HXDLIN(  44)				if ((color == -1)) {
HXLINE(  44)					color = _this1->currentColor;
            				}
HXDLIN(  44)				{
HXLINE(  44)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(exPrev_) ),( (Float)(eyPrev_) ),0);
HXDLIN(  44)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE(  44)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  44)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  44)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  44)			{
HXLINE(  44)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  44)				int color1 = -1;
HXDLIN(  44)				if ((color1 == -1)) {
HXLINE(  44)					color1 = _this2->currentColor;
            				}
HXDLIN(  44)				{
HXLINE(  44)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  44)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE(  44)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  44)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  44)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,baseLine,(void))

void Sketch_obj::crudeLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_47_crudeLine)
HXDLIN(  47)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  47)		Float ax_ = this->x;
HXDLIN(  47)		Float ay_ = this->y;
HXDLIN(  47)		Float width_ = this->width;
HXDLIN(  47)		_this->ax = x_;
HXDLIN(  47)		_this->ay = y_;
HXDLIN(  47)		_this->bx = ax_;
HXDLIN(  47)		_this->by = ay_;
HXDLIN(  47)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  47)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  47)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  47)		{
HXDLIN(  47)			{
HXDLIN(  47)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  47)				if ((_this->theta > 0)) {
HXDLIN(  47)					if ((_this->halfA < 0)) {
HXDLIN(  47)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  47)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  47)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  47)					if ((_this->halfA > 0)) {
HXDLIN(  47)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  47)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  47)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  47)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  47)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  47)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  47)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  47)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  47)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  47)				_this->exPrev = _this->ex;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  47)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  47)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  47)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  47)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  47)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  47)		 ::Dynamic dxPrev_ = _this->dx;
HXDLIN(  47)		 ::Dynamic dyPrev_ = _this->dy;
HXDLIN(  47)		 ::Dynamic exPrev_ = _this->ex;
HXDLIN(  47)		 ::Dynamic eyPrev_ = _this->ey;
HXDLIN(  47)		_this->ax = ax_;
HXDLIN(  47)		_this->ay = ay_;
HXDLIN(  47)		_this->bx = x_;
HXDLIN(  47)		_this->by = y_;
HXDLIN(  47)		{
HXDLIN(  47)			{
HXDLIN(  47)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  47)				if ((_this->theta > 0)) {
HXDLIN(  47)					if ((_this->halfA < 0)) {
HXDLIN(  47)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  47)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  47)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  47)					if ((_this->halfA > 0)) {
HXDLIN(  47)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  47)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  47)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  47)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  47)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  47)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  47)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  47)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  47)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  47)				_this->exPrev = _this->ex;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  47)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  47)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  47)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  47)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  47)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  47)		{
HXDLIN(  47)			 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  47)			int color = -1;
HXDLIN(  47)			if ((color == -1)) {
HXDLIN(  47)				color = _this1->currentColor;
            			}
HXDLIN(  47)			{
HXDLIN(  47)				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(exPrev_) ),( (Float)(eyPrev_) ),0);
HXDLIN(  47)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  47)					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN(  47)				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN(  47)			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            		}
HXDLIN(  47)		{
HXDLIN(  47)			 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  47)			int color1 = -1;
HXDLIN(  47)			if ((color1 == -1)) {
HXDLIN(  47)				color1 = _this2->currentColor;
            			}
HXDLIN(  47)			{
HXDLIN(  47)				_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  47)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  47)					_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN(  47)				_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN(  47)			_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,crudeLine,(void))

void Sketch_obj::roundEndLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_50_roundEndLine)
HXDLIN(  50)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  50)		Float ax_ = this->x;
HXDLIN(  50)		Float ay_ = this->y;
HXDLIN(  50)		Float width_ = this->width;
HXDLIN(  50)		 ::Dynamic endLineCurve = 3;
HXDLIN(  50)		if (::hx::IsNull( endLineCurve )) {
HXDLIN(  50)			endLineCurve = 0;
            		}
HXDLIN(  50)		_this->ax = x_;
HXDLIN(  50)		_this->ay = y_;
HXDLIN(  50)		_this->bx = ax_;
HXDLIN(  50)		_this->by = ay_;
HXDLIN(  50)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  50)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  50)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  50)		{
HXDLIN(  50)			{
HXDLIN(  50)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  50)				if ((_this->theta > 0)) {
HXDLIN(  50)					if ((_this->halfA < 0)) {
HXDLIN(  50)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  50)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  50)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  50)					if ((_this->halfA > 0)) {
HXDLIN(  50)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  50)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  50)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  50)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  50)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  50)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  50)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  50)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  50)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  50)				_this->exPrev = _this->ex;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  50)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  50)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  50)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  50)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  50)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  50)		 ::Dynamic dxPrev_ = _this->dx;
HXDLIN(  50)		 ::Dynamic dyPrev_ = _this->dy;
HXDLIN(  50)		 ::Dynamic exPrev_ = _this->ex;
HXDLIN(  50)		 ::Dynamic eyPrev_ = _this->ey;
HXDLIN(  50)		_this->ax = ax_;
HXDLIN(  50)		_this->ay = ay_;
HXDLIN(  50)		_this->bx = x_;
HXDLIN(  50)		_this->by = y_;
HXDLIN(  50)		{
HXDLIN(  50)			{
HXDLIN(  50)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  50)				if ((_this->theta > 0)) {
HXDLIN(  50)					if ((_this->halfA < 0)) {
HXDLIN(  50)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  50)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  50)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  50)					if ((_this->halfA > 0)) {
HXDLIN(  50)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  50)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  50)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  50)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  50)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  50)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  50)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  50)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  50)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  50)				_this->exPrev = _this->ex;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  50)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  50)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  50)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  50)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  50)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  50)		 ::Dynamic _hx_switch_0 = endLineCurve;
            		if (  (_hx_switch_0==0) ){
HXDLIN(  50)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==1) ){
HXDLIN(  50)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  50)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  50)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  50)			 ::Dynamic sides = 36;
HXDLIN(  50)			if (::hx::IsNull( sides )) {
HXDLIN(  50)				sides = 36;
            			}
HXDLIN(  50)			Float pi = ::Math_obj::PI;
HXDLIN(  50)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  50)			Float dif;
HXDLIN(  50)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if ((dif1 > 0)) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if ((dif1 < 0)) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if (smallest) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if (largest) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  50)			bool positive = (dif >= 0);
HXDLIN(  50)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  50)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  50)			Float angle = beta;
HXDLIN(  50)			Float cx;
HXDLIN(  50)			Float cy;
HXDLIN(  50)			Float bx = ( (Float)(0) );
HXDLIN(  50)			Float by = ( (Float)(0) );
HXDLIN(  50)			{
HXDLIN(  50)				int _g = 0;
HXDLIN(  50)				int _g1 = (totalSteps + 1);
HXDLIN(  50)				while((_g < _g1)){
HXDLIN(  50)					_g = (_g + 1);
HXDLIN(  50)					int i = (_g - 1);
HXDLIN(  50)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  50)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  50)					if ((i != 0)) {
HXDLIN(  50)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  50)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  50)						if (::hx::IsNotNull( m )) {
HXDLIN(  50)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  50)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  50)					angle = (angle + step1);
HXDLIN(  50)					bx = cx;
HXDLIN(  50)					by = cy;
            				}
            			}
HXDLIN(  50)			int len = totalSteps;
HXDLIN(  50)			{
HXDLIN(  50)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  50)				int color = 0;
HXDLIN(  50)				if ((color == -1)) {
HXDLIN(  50)					color = _this1->currentColor;
            				}
HXDLIN(  50)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  50)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==2) ){
HXDLIN(  50)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  50)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN(  50)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  50)			 ::Dynamic sides = 36;
HXDLIN(  50)			if (::hx::IsNull( sides )) {
HXDLIN(  50)				sides = 36;
            			}
HXDLIN(  50)			Float pi = ::Math_obj::PI;
HXDLIN(  50)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  50)			Float dif;
HXDLIN(  50)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if ((dif1 > 0)) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if ((dif1 < 0)) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if (smallest) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if (largest) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  50)			bool positive = (dif >= 0);
HXDLIN(  50)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  50)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  50)			Float angle = beta;
HXDLIN(  50)			Float cx;
HXDLIN(  50)			Float cy;
HXDLIN(  50)			Float bx = ( (Float)(0) );
HXDLIN(  50)			Float by = ( (Float)(0) );
HXDLIN(  50)			{
HXDLIN(  50)				int _g = 0;
HXDLIN(  50)				int _g1 = (totalSteps + 1);
HXDLIN(  50)				while((_g < _g1)){
HXDLIN(  50)					_g = (_g + 1);
HXDLIN(  50)					int i = (_g - 1);
HXDLIN(  50)					cx = (x_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  50)					cy = (y_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  50)					if ((i != 0)) {
HXDLIN(  50)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(x_,y_,0,bx,by,0,cx,cy,0);
HXDLIN(  50)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  50)						if (::hx::IsNotNull( m )) {
HXDLIN(  50)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  50)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  50)					angle = (angle + step1);
HXDLIN(  50)					bx = cx;
HXDLIN(  50)					by = cy;
            				}
            			}
HXDLIN(  50)			int len = totalSteps;
HXDLIN(  50)			{
HXDLIN(  50)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  50)				int color = 0;
HXDLIN(  50)				if ((color == -1)) {
HXDLIN(  50)					color = _this1->currentColor;
            				}
HXDLIN(  50)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  50)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==3) ){
HXDLIN(  50)			{
HXDLIN(  50)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  50)				Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)				Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  50)				 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  50)				 ::Dynamic sides = 36;
HXDLIN(  50)				if (::hx::IsNull( sides )) {
HXDLIN(  50)					sides = 36;
            				}
HXDLIN(  50)				Float pi = ::Math_obj::PI;
HXDLIN(  50)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  50)				Float dif;
HXDLIN(  50)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta >= 0)) {
HXDLIN(  50)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma >= 0)) {
HXDLIN(  50)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif1;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif1 = theta;
            						}
            						else {
HXDLIN(  50)							dif1 = -(theta);
            						}
HXDLIN(  50)						if ((dif1 > 0)) {
HXDLIN(  50)							dif = dif1;
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta >= 0)) {
HXDLIN(  50)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma >= 0)) {
HXDLIN(  50)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif1;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif1 = theta;
            						}
            						else {
HXDLIN(  50)							dif1 = -(theta);
            						}
HXDLIN(  50)						if ((dif1 < 0)) {
HXDLIN(  50)							dif = dif1;
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta >= 0)) {
HXDLIN(  50)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma >= 0)) {
HXDLIN(  50)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif1;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif1 = theta;
            						}
            						else {
HXDLIN(  50)							dif1 = -(theta);
            						}
HXDLIN(  50)						if (smallest) {
HXDLIN(  50)							dif = dif1;
            						}
            						else {
HXDLIN(  50)							if (clockwise) {
HXDLIN(  50)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  50)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta >= 0)) {
HXDLIN(  50)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma >= 0)) {
HXDLIN(  50)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif1;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif1 = theta;
            						}
            						else {
HXDLIN(  50)							dif1 = -(theta);
            						}
HXDLIN(  50)						if (largest) {
HXDLIN(  50)							dif = dif1;
            						}
            						else {
HXDLIN(  50)							if (clockwise) {
HXDLIN(  50)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  50)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  50)				bool positive = (dif >= 0);
HXDLIN(  50)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  50)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  50)				Float angle = beta;
HXDLIN(  50)				Float cx;
HXDLIN(  50)				Float cy;
HXDLIN(  50)				Float bx = ( (Float)(0) );
HXDLIN(  50)				Float by = ( (Float)(0) );
HXDLIN(  50)				{
HXDLIN(  50)					int _g = 0;
HXDLIN(  50)					int _g1 = (totalSteps + 1);
HXDLIN(  50)					while((_g < _g1)){
HXDLIN(  50)						_g = (_g + 1);
HXDLIN(  50)						int i = (_g - 1);
HXDLIN(  50)						cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  50)						cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  50)						if ((i != 0)) {
HXDLIN(  50)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  50)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  50)							if (::hx::IsNotNull( m )) {
HXDLIN(  50)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  50)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  50)						angle = (angle + step1);
HXDLIN(  50)						bx = cx;
HXDLIN(  50)						by = cy;
            					}
            				}
HXDLIN(  50)				int len = totalSteps;
HXDLIN(  50)				{
HXDLIN(  50)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  50)					int color = 0;
HXDLIN(  50)					if ((color == -1)) {
HXDLIN(  50)						color = _this1->currentColor;
            					}
HXDLIN(  50)					_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            				}
            			}
HXDLIN(  50)			{
HXDLIN(  50)				Float radius1 = (width_ / ( (Float)(2) ));
HXDLIN(  50)				Float beta1 = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)				Float gamma1 = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN(  50)				 ::Dynamic drawType1 = _this->pen->drawType;
HXDLIN(  50)				 ::Dynamic sides1 = 36;
HXDLIN(  50)				if (::hx::IsNull( sides1 )) {
HXDLIN(  50)					sides1 = 36;
            				}
HXDLIN(  50)				Float pi1 = ::Math_obj::PI;
HXDLIN(  50)				Float step2 = ((pi1 * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN(  50)				Float dif1;
HXDLIN(  50)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta1 >= 0)) {
HXDLIN(  50)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma1 >= 0)) {
HXDLIN(  50)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = theta;
            						}
            						else {
HXDLIN(  50)							dif = -(theta);
            						}
HXDLIN(  50)						if ((dif > 0)) {
HXDLIN(  50)							dif1 = dif;
            						}
            						else {
HXDLIN(  50)							dif1 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)1: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta1 >= 0)) {
HXDLIN(  50)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma1 >= 0)) {
HXDLIN(  50)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = theta;
            						}
            						else {
HXDLIN(  50)							dif = -(theta);
            						}
HXDLIN(  50)						if ((dif < 0)) {
HXDLIN(  50)							dif1 = dif;
            						}
            						else {
HXDLIN(  50)							dif1 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)2: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta1 >= 0)) {
HXDLIN(  50)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma1 >= 0)) {
HXDLIN(  50)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = theta;
            						}
            						else {
HXDLIN(  50)							dif = -(theta);
            						}
HXDLIN(  50)						if (smallest) {
HXDLIN(  50)							dif1 = dif;
            						}
            						else {
HXDLIN(  50)							if (clockwise) {
HXDLIN(  50)								dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  50)								dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta1 >= 0)) {
HXDLIN(  50)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma1 >= 0)) {
HXDLIN(  50)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = theta;
            						}
            						else {
HXDLIN(  50)							dif = -(theta);
            						}
HXDLIN(  50)						if (largest) {
HXDLIN(  50)							dif1 = dif;
            						}
            						else {
HXDLIN(  50)							if (clockwise) {
HXDLIN(  50)								dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  50)								dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  50)				bool positive1 = (dif1 >= 0);
HXDLIN(  50)				int totalSteps1 = ::Math_obj::ceil((::Math_obj::abs(dif1) / step2));
HXDLIN(  50)				Float step3 = (dif1 / ( (Float)(totalSteps1) ));
HXDLIN(  50)				Float angle1 = beta1;
HXDLIN(  50)				Float cx1;
HXDLIN(  50)				Float cy1;
HXDLIN(  50)				Float bx1 = ( (Float)(0) );
HXDLIN(  50)				Float by1 = ( (Float)(0) );
HXDLIN(  50)				{
HXDLIN(  50)					int _g2 = 0;
HXDLIN(  50)					int _g3 = (totalSteps1 + 1);
HXDLIN(  50)					while((_g2 < _g3)){
HXDLIN(  50)						_g2 = (_g2 + 1);
HXDLIN(  50)						int i = (_g2 - 1);
HXDLIN(  50)						cx1 = (x_ + (radius1 * ::Math_obj::sin(angle1)));
HXDLIN(  50)						cy1 = (y_ + (radius1 * ::Math_obj::cos(angle1)));
HXDLIN(  50)						if ((i != 0)) {
HXDLIN(  50)							drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(x_,y_,0,bx1,by1,0,cx1,cy1,0);
HXDLIN(  50)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  50)							if (::hx::IsNotNull( m )) {
HXDLIN(  50)								drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  50)							drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  50)						angle1 = (angle1 + step3);
HXDLIN(  50)						bx1 = cx1;
HXDLIN(  50)						by1 = cy1;
            					}
            				}
HXDLIN(  50)				int len1 = totalSteps1;
HXDLIN(  50)				{
HXDLIN(  50)					 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  50)					int color1 = 0;
HXDLIN(  50)					if ((color1 == -1)) {
HXDLIN(  50)						color1 = _this2->currentColor;
            					}
HXDLIN(  50)					_this2->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
            				}
            			}
HXDLIN(  50)			goto _hx_goto_5;
            		}
            		_hx_goto_5:;
HXDLIN(  50)		{
HXDLIN(  50)			 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  50)			int color = -1;
HXDLIN(  50)			if ((color == -1)) {
HXDLIN(  50)				color = _this1->currentColor;
            			}
HXDLIN(  50)			{
HXDLIN(  50)				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(exPrev_) ),( (Float)(eyPrev_) ),0);
HXDLIN(  50)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  50)					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN(  50)				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN(  50)			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            		}
HXDLIN(  50)		{
HXDLIN(  50)			 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  50)			int color1 = -1;
HXDLIN(  50)			if ((color1 == -1)) {
HXDLIN(  50)				color1 = _this2->currentColor;
            			}
HXDLIN(  50)			{
HXDLIN(  50)				_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  50)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  50)					_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN(  50)				_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN(  50)			_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,roundEndLine,(void))

void Sketch_obj::mediumLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_53_mediumLine)
HXDLIN(  53)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  53)		Float ax_ = this->x;
HXDLIN(  53)		Float ay_ = this->y;
HXDLIN(  53)		Float width_ = this->width;
HXDLIN(  53)		bool overlap = false;
HXDLIN(  53)		 ::Dynamic oldAngle;
HXDLIN(  53)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  53)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  53)			oldAngle = null();
            		}
HXDLIN(  53)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  53)		_this->ax = x_;
HXDLIN(  53)		_this->ay = y_;
HXDLIN(  53)		_this->bx = ax_;
HXDLIN(  53)		_this->by = ay_;
HXDLIN(  53)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  53)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  53)		{
HXDLIN(  53)			{
HXDLIN(  53)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  53)				if ((_this->theta > 0)) {
HXDLIN(  53)					if ((_this->halfA < 0)) {
HXDLIN(  53)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  53)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  53)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  53)					if ((_this->halfA > 0)) {
HXDLIN(  53)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  53)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  53)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  53)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  53)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  53)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  53)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  53)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  53)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  53)				_this->exPrev = _this->ex;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  53)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  53)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  53)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  53)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  53)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  53)		_this->ax = ax_;
HXDLIN(  53)		_this->ay = ay_;
HXDLIN(  53)		_this->bx = x_;
HXDLIN(  53)		_this->by = y_;
HXDLIN(  53)		{
HXDLIN(  53)			{
HXDLIN(  53)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  53)				if ((_this->theta > 0)) {
HXDLIN(  53)					if ((_this->halfA < 0)) {
HXDLIN(  53)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  53)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  53)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  53)					if ((_this->halfA > 0)) {
HXDLIN(  53)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  53)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  53)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  53)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  53)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  53)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  53)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  53)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  53)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  53)				_this->exPrev = _this->ex;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  53)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  53)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  53)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  53)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  53)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  53)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  53)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  53)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  53)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  53)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  53)		Float theta0;
HXDLIN(  53)		Float theta1;
HXDLIN(  53)		if (clockWise) {
HXDLIN(  53)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  53)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  53)		Float dif;
HXDLIN(  53)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  53)				Float f;
HXDLIN(  53)				bool f1;
HXDLIN(  53)				if ((theta0 >= 0)) {
HXDLIN(  53)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f1 = false;
            				}
HXDLIN(  53)				if (f1) {
HXDLIN(  53)					f = theta0;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f = a;
            					}
            					else {
HXDLIN(  53)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this1 = f;
HXDLIN(  53)				Float za = this1;
HXDLIN(  53)				Float f2;
HXDLIN(  53)				bool f3;
HXDLIN(  53)				if ((theta1 >= 0)) {
HXDLIN(  53)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f3 = false;
            				}
HXDLIN(  53)				if (f3) {
HXDLIN(  53)					f2 = theta1;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f2 = a;
            					}
            					else {
HXDLIN(  53)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this2 = f2;
HXDLIN(  53)				Float zb = this2;
HXDLIN(  53)				Float fa = za;
HXDLIN(  53)				Float fb = zb;
HXDLIN(  53)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)				bool clockwise = (fa < fb);
HXDLIN(  53)				Float dif1;
HXDLIN(  53)				if (clockwise) {
HXDLIN(  53)					dif1 = theta;
            				}
            				else {
HXDLIN(  53)					dif1 = -(theta);
            				}
HXDLIN(  53)				if ((dif1 > 0)) {
HXDLIN(  53)					dif = dif1;
            				}
            				else {
HXDLIN(  53)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  53)				Float f;
HXDLIN(  53)				bool f1;
HXDLIN(  53)				if ((theta0 >= 0)) {
HXDLIN(  53)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f1 = false;
            				}
HXDLIN(  53)				if (f1) {
HXDLIN(  53)					f = theta0;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f = a;
            					}
            					else {
HXDLIN(  53)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this1 = f;
HXDLIN(  53)				Float za = this1;
HXDLIN(  53)				Float f2;
HXDLIN(  53)				bool f3;
HXDLIN(  53)				if ((theta1 >= 0)) {
HXDLIN(  53)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f3 = false;
            				}
HXDLIN(  53)				if (f3) {
HXDLIN(  53)					f2 = theta1;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f2 = a;
            					}
            					else {
HXDLIN(  53)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this2 = f2;
HXDLIN(  53)				Float zb = this2;
HXDLIN(  53)				Float fa = za;
HXDLIN(  53)				Float fb = zb;
HXDLIN(  53)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)				bool clockwise = (fa < fb);
HXDLIN(  53)				Float dif1;
HXDLIN(  53)				if (clockwise) {
HXDLIN(  53)					dif1 = theta;
            				}
            				else {
HXDLIN(  53)					dif1 = -(theta);
            				}
HXDLIN(  53)				if ((dif1 < 0)) {
HXDLIN(  53)					dif = dif1;
            				}
            				else {
HXDLIN(  53)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  53)				Float f;
HXDLIN(  53)				bool f1;
HXDLIN(  53)				if ((theta0 >= 0)) {
HXDLIN(  53)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f1 = false;
            				}
HXDLIN(  53)				if (f1) {
HXDLIN(  53)					f = theta0;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f = a;
            					}
            					else {
HXDLIN(  53)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this1 = f;
HXDLIN(  53)				Float za = this1;
HXDLIN(  53)				Float f2;
HXDLIN(  53)				bool f3;
HXDLIN(  53)				if ((theta1 >= 0)) {
HXDLIN(  53)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f3 = false;
            				}
HXDLIN(  53)				if (f3) {
HXDLIN(  53)					f2 = theta1;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f2 = a;
            					}
            					else {
HXDLIN(  53)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this2 = f2;
HXDLIN(  53)				Float zb = this2;
HXDLIN(  53)				Float fa = za;
HXDLIN(  53)				Float fb = zb;
HXDLIN(  53)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  53)				bool clockwise = (fa < fb);
HXDLIN(  53)				Float dif1;
HXDLIN(  53)				if (clockwise) {
HXDLIN(  53)					dif1 = theta;
            				}
            				else {
HXDLIN(  53)					dif1 = -(theta);
            				}
HXDLIN(  53)				if (smallest) {
HXDLIN(  53)					dif = dif1;
            				}
            				else {
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  53)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  53)				Float f;
HXDLIN(  53)				bool f1;
HXDLIN(  53)				if ((theta0 >= 0)) {
HXDLIN(  53)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f1 = false;
            				}
HXDLIN(  53)				if (f1) {
HXDLIN(  53)					f = theta0;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f = a;
            					}
            					else {
HXDLIN(  53)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this1 = f;
HXDLIN(  53)				Float za = this1;
HXDLIN(  53)				Float f2;
HXDLIN(  53)				bool f3;
HXDLIN(  53)				if ((theta1 >= 0)) {
HXDLIN(  53)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f3 = false;
            				}
HXDLIN(  53)				if (f3) {
HXDLIN(  53)					f2 = theta1;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f2 = a;
            					}
            					else {
HXDLIN(  53)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this2 = f2;
HXDLIN(  53)				Float zb = this2;
HXDLIN(  53)				Float fa = za;
HXDLIN(  53)				Float fb = zb;
HXDLIN(  53)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  53)				bool clockwise = (fa < fb);
HXDLIN(  53)				Float dif1;
HXDLIN(  53)				if (clockwise) {
HXDLIN(  53)					dif1 = theta;
            				}
            				else {
HXDLIN(  53)					dif1 = -(theta);
            				}
HXDLIN(  53)				if (largest) {
HXDLIN(  53)					dif = dif1;
            				}
            				else {
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  53)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  53)		bool _hx_tmp;
HXDLIN(  53)		if (!(overlap)) {
HXDLIN(  53)			_hx_tmp = (_this->count != 0);
            		}
            		else {
HXDLIN(  53)			_hx_tmp = false;
            		}
HXDLIN(  53)		if (_hx_tmp) {
HXDLIN(  53)			Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
HXDLIN(  53)			Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
HXDLIN(  53)			Float f;
HXDLIN(  53)			bool f1;
HXDLIN(  53)			if ((theta0 <= ::Math_obj::PI)) {
HXDLIN(  53)				f1 = (theta0 > -(::Math_obj::PI));
            			}
            			else {
HXDLIN(  53)				f1 = false;
            			}
HXDLIN(  53)			if (f1) {
HXDLIN(  53)				f = theta0;
            			}
            			else {
HXDLIN(  53)				Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)				if ((a >= 0)) {
HXDLIN(  53)					f = (a - ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f = (a + ::Math_obj::PI);
            				}
            			}
HXDLIN(  53)			Float this1 = f;
HXDLIN(  53)			Float start = this1;
HXDLIN(  53)			Float start2 = start;
HXDLIN(  53)			Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  53)			_this->jx = (_this->ax + (h * ::Math_obj::sin(delta)));
HXDLIN(  53)			_this->jy = (_this->ay + (h * ::Math_obj::cos(delta)));
            		}
HXDLIN(  53)		bool _hx_tmp1;
HXDLIN(  53)		if ((_this->count == 0)) {
HXDLIN(  53)			if ((_this->endLine != 1)) {
HXDLIN(  53)				_hx_tmp1 = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  53)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXDLIN(  53)			_hx_tmp1 = false;
            		}
HXDLIN(  53)		if (_hx_tmp1) {
HXDLIN(  53)			Float ax = _this->ax;
HXDLIN(  53)			Float ay = _this->ay;
HXDLIN(  53)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  53)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  53)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  53)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  53)			 ::Dynamic sides = 36;
HXDLIN(  53)			if (::hx::IsNull( sides )) {
HXDLIN(  53)				sides = 36;
            			}
HXDLIN(  53)			Float pi = ::Math_obj::PI;
HXDLIN(  53)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  53)			Float dif;
HXDLIN(  53)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  53)					Float f;
HXDLIN(  53)					bool f1;
HXDLIN(  53)					if ((beta >= 0)) {
HXDLIN(  53)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f1 = false;
            					}
HXDLIN(  53)					if (f1) {
HXDLIN(  53)						f = beta;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f = a;
            						}
            						else {
HXDLIN(  53)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this1 = f;
HXDLIN(  53)					Float za = this1;
HXDLIN(  53)					Float f2;
HXDLIN(  53)					bool f3;
HXDLIN(  53)					if ((gamma >= 0)) {
HXDLIN(  53)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f3 = false;
            					}
HXDLIN(  53)					if (f3) {
HXDLIN(  53)						f2 = gamma;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f2 = a;
            						}
            						else {
HXDLIN(  53)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this2 = f2;
HXDLIN(  53)					Float zb = this2;
HXDLIN(  53)					Float fa = za;
HXDLIN(  53)					Float fb = zb;
HXDLIN(  53)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)					bool clockwise = (fa < fb);
HXDLIN(  53)					Float dif1;
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif1 = theta;
            					}
            					else {
HXDLIN(  53)						dif1 = -(theta);
            					}
HXDLIN(  53)					if ((dif1 > 0)) {
HXDLIN(  53)						dif = dif1;
            					}
            					else {
HXDLIN(  53)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  53)					Float f;
HXDLIN(  53)					bool f1;
HXDLIN(  53)					if ((beta >= 0)) {
HXDLIN(  53)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f1 = false;
            					}
HXDLIN(  53)					if (f1) {
HXDLIN(  53)						f = beta;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f = a;
            						}
            						else {
HXDLIN(  53)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this1 = f;
HXDLIN(  53)					Float za = this1;
HXDLIN(  53)					Float f2;
HXDLIN(  53)					bool f3;
HXDLIN(  53)					if ((gamma >= 0)) {
HXDLIN(  53)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f3 = false;
            					}
HXDLIN(  53)					if (f3) {
HXDLIN(  53)						f2 = gamma;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f2 = a;
            						}
            						else {
HXDLIN(  53)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this2 = f2;
HXDLIN(  53)					Float zb = this2;
HXDLIN(  53)					Float fa = za;
HXDLIN(  53)					Float fb = zb;
HXDLIN(  53)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)					bool clockwise = (fa < fb);
HXDLIN(  53)					Float dif1;
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif1 = theta;
            					}
            					else {
HXDLIN(  53)						dif1 = -(theta);
            					}
HXDLIN(  53)					if ((dif1 < 0)) {
HXDLIN(  53)						dif = dif1;
            					}
            					else {
HXDLIN(  53)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  53)					Float f;
HXDLIN(  53)					bool f1;
HXDLIN(  53)					if ((beta >= 0)) {
HXDLIN(  53)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f1 = false;
            					}
HXDLIN(  53)					if (f1) {
HXDLIN(  53)						f = beta;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f = a;
            						}
            						else {
HXDLIN(  53)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this1 = f;
HXDLIN(  53)					Float za = this1;
HXDLIN(  53)					Float f2;
HXDLIN(  53)					bool f3;
HXDLIN(  53)					if ((gamma >= 0)) {
HXDLIN(  53)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f3 = false;
            					}
HXDLIN(  53)					if (f3) {
HXDLIN(  53)						f2 = gamma;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f2 = a;
            						}
            						else {
HXDLIN(  53)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this2 = f2;
HXDLIN(  53)					Float zb = this2;
HXDLIN(  53)					Float fa = za;
HXDLIN(  53)					Float fb = zb;
HXDLIN(  53)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  53)					bool clockwise = (fa < fb);
HXDLIN(  53)					Float dif1;
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif1 = theta;
            					}
            					else {
HXDLIN(  53)						dif1 = -(theta);
            					}
HXDLIN(  53)					if (smallest) {
HXDLIN(  53)						dif = dif1;
            					}
            					else {
HXDLIN(  53)						if (clockwise) {
HXDLIN(  53)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  53)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  53)					Float f;
HXDLIN(  53)					bool f1;
HXDLIN(  53)					if ((beta >= 0)) {
HXDLIN(  53)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f1 = false;
            					}
HXDLIN(  53)					if (f1) {
HXDLIN(  53)						f = beta;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f = a;
            						}
            						else {
HXDLIN(  53)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this1 = f;
HXDLIN(  53)					Float za = this1;
HXDLIN(  53)					Float f2;
HXDLIN(  53)					bool f3;
HXDLIN(  53)					if ((gamma >= 0)) {
HXDLIN(  53)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f3 = false;
            					}
HXDLIN(  53)					if (f3) {
HXDLIN(  53)						f2 = gamma;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f2 = a;
            						}
            						else {
HXDLIN(  53)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this2 = f2;
HXDLIN(  53)					Float zb = this2;
HXDLIN(  53)					Float fa = za;
HXDLIN(  53)					Float fb = zb;
HXDLIN(  53)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  53)					bool clockwise = (fa < fb);
HXDLIN(  53)					Float dif1;
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif1 = theta;
            					}
            					else {
HXDLIN(  53)						dif1 = -(theta);
            					}
HXDLIN(  53)					if (largest) {
HXDLIN(  53)						dif = dif1;
            					}
            					else {
HXDLIN(  53)						if (clockwise) {
HXDLIN(  53)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  53)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  53)			bool positive = (dif >= 0);
HXDLIN(  53)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  53)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  53)			Float angle = beta;
HXDLIN(  53)			Float cx;
HXDLIN(  53)			Float cy;
HXDLIN(  53)			Float bx = ( (Float)(0) );
HXDLIN(  53)			Float by = ( (Float)(0) );
HXDLIN(  53)			int p2 = temp->length;
HXDLIN(  53)			{
HXDLIN(  53)				int _g = 0;
HXDLIN(  53)				int _g1 = (totalSteps + 1);
HXDLIN(  53)				while((_g < _g1)){
HXDLIN(  53)					_g = (_g + 1);
HXDLIN(  53)					int i = (_g - 1);
HXDLIN(  53)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  53)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  53)					p2 = (p2 + 1);
HXDLIN(  53)					temp[(p2 - 1)] = cx;
HXDLIN(  53)					p2 = (p2 + 1);
HXDLIN(  53)					temp[(p2 - 1)] = cy;
HXDLIN(  53)					if ((i != 0)) {
HXDLIN(  53)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  53)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  53)						if (::hx::IsNotNull( m )) {
HXDLIN(  53)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  53)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  53)					angle = (angle + step1);
HXDLIN(  53)					bx = cx;
HXDLIN(  53)					by = cy;
            				}
            			}
HXDLIN(  53)			int len = totalSteps;
HXDLIN(  53)			{
HXDLIN(  53)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)				int color = -1;
HXDLIN(  53)				if ((color == -1)) {
HXDLIN(  53)					color = _this1->currentColor;
            				}
HXDLIN(  53)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  53)			int pA = _this->pointsAnti->length;
HXDLIN(  53)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  53)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  53)			{
HXDLIN(  53)				int _g2 = 0;
HXDLIN(  53)				int _g3 = p4;
HXDLIN(  53)				while((_g2 < _g3)){
HXDLIN(  53)					_g2 = (_g2 + 1);
HXDLIN(  53)					int i = (_g2 - 1);
HXDLIN(  53)					pA = (pA + 1);
HXDLIN(  53)					_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXDLIN(  53)					pA = (pA + 1);
HXDLIN(  53)					_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            				}
            			}
HXDLIN(  53)			int pC = _this->pointsClock->length;
HXDLIN(  53)			{
HXDLIN(  53)				int _g4 = 0;
HXDLIN(  53)				int _g5 = p4;
HXDLIN(  53)				while((_g4 < _g5)){
HXDLIN(  53)					_g4 = (_g4 + 1);
HXDLIN(  53)					int i = (_g4 - 1);
HXDLIN(  53)					pC = (pC + 1);
HXDLIN(  53)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXDLIN(  53)					pC = (pC + 1);
HXDLIN(  53)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            				}
            			}
            		}
HXDLIN(  53)		if (overlap) {
HXDLIN(  53)			{
HXDLIN(  53)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)				int color = -1;
HXDLIN(  53)				if ((color == -1)) {
HXDLIN(  53)					color = _this1->currentColor;
            				}
HXDLIN(  53)				{
HXDLIN(  53)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  53)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  53)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  53)			{
HXDLIN(  53)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  53)				int color1 = -1;
HXDLIN(  53)				if ((color1 == -1)) {
HXDLIN(  53)					color1 = _this2->currentColor;
            				}
HXDLIN(  53)				{
HXDLIN(  53)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  53)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  53)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  53)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
            		else {
HXDLIN(  53)			if ((_this->count != 0)) {
HXDLIN(  53)				_this->addQuads(clockWise,width_);
            			}
HXDLIN(  53)			{
HXDLIN(  53)				_this->quadIndex = ( (Float)(_this->pen->drawType->__Field(HX_("get_pos",2b,26,ca,26),::hx::paccDynamic)()) );
HXDLIN(  53)				if ((_this->count == 0)) {
HXDLIN(  53)					_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  53)					_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  53)					_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  53)					_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  53)					_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  53)					_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  53)					_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  53)					_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  53)					{
HXDLIN(  53)						 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)						int color = -1;
HXDLIN(  53)						if ((color == -1)) {
HXDLIN(  53)							color = _this1->currentColor;
            						}
HXDLIN(  53)						{
HXDLIN(  53)							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN(  53)							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  53)						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            					}
HXDLIN(  53)					{
HXDLIN(  53)						 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  53)						int color1 = -1;
HXDLIN(  53)						if ((color1 == -1)) {
HXDLIN(  53)							color1 = _this2->currentColor;
            						}
HXDLIN(  53)						{
HXDLIN(  53)							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  53)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN(  53)							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  53)						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            					}
            				}
            				else {
HXDLIN(  53)					bool _hx_tmp;
HXDLIN(  53)					if (clockWise) {
HXDLIN(  53)						_hx_tmp = !(_this->lastClock);
            					}
            					else {
HXDLIN(  53)						_hx_tmp = false;
            					}
HXDLIN(  53)					if (_hx_tmp) {
HXDLIN(  53)						_this->penultimateAX = _this->jx;
HXDLIN(  53)						_this->penultimateAY = _this->jy;
HXDLIN(  53)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  53)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  53)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  53)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  53)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  53)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)							int color = -1;
HXDLIN(  53)							if ((color == -1)) {
HXDLIN(  53)								color = _this1->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  53)							int color1 = -1;
HXDLIN(  53)							if ((color1 == -1)) {
HXDLIN(  53)								color1 = _this2->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  53)					bool _hx_tmp1;
HXDLIN(  53)					if (clockWise) {
HXDLIN(  53)						_hx_tmp1 = _this->lastClock;
            					}
            					else {
HXDLIN(  53)						_hx_tmp1 = false;
            					}
HXDLIN(  53)					if (_hx_tmp1) {
HXDLIN(  53)						_this->penultimateAX = _this->jx;
HXDLIN(  53)						_this->penultimateAY = _this->jy;
HXDLIN(  53)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  53)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  53)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  53)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  53)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  53)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)							int color = -1;
HXDLIN(  53)							if ((color == -1)) {
HXDLIN(  53)								color = _this1->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  53)							int color1 = -1;
HXDLIN(  53)							if ((color1 == -1)) {
HXDLIN(  53)								color1 = _this2->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  53)					bool _hx_tmp2;
HXDLIN(  53)					if (!(clockWise)) {
HXDLIN(  53)						_hx_tmp2 = !(_this->lastClock);
            					}
            					else {
HXDLIN(  53)						_hx_tmp2 = false;
            					}
HXDLIN(  53)					if (_hx_tmp2) {
HXDLIN(  53)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  53)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  53)						_this->lastClockX = _this->jx;
HXDLIN(  53)						_this->lastClockY = _this->jy;
HXDLIN(  53)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  53)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  53)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  53)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)							int color = -1;
HXDLIN(  53)							if ((color == -1)) {
HXDLIN(  53)								color = _this1->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,_this->jx,_this->jy,0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  53)							int color1 = -1;
HXDLIN(  53)							if ((color1 == -1)) {
HXDLIN(  53)								color1 = _this2->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  53)					bool _hx_tmp3;
HXDLIN(  53)					if (!(clockWise)) {
HXDLIN(  53)						_hx_tmp3 = _this->lastClock;
            					}
            					else {
HXDLIN(  53)						_hx_tmp3 = false;
            					}
HXDLIN(  53)					if (_hx_tmp3) {
HXDLIN(  53)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  53)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  53)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  53)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  53)						_this->penultimateCX = _this->jx;
HXDLIN(  53)						_this->penultimateCY = _this->jy;
HXDLIN(  53)						_this->lastClockX = ( (Float)(_this->dx) );
HXDLIN(  53)						_this->lastClockY = ( (Float)(_this->dy) );
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)							int color = -1;
HXDLIN(  53)							if ((color == -1)) {
HXDLIN(  53)								color = _this1->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  53)							int color1 = -1;
HXDLIN(  53)							if ((color1 == -1)) {
HXDLIN(  53)								color1 = _this2->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
            				}
            			}
            		}
HXDLIN(  53)		if ((_this->count != 0)) {
HXDLIN(  53)			if (overlap) {
HXDLIN(  53)				if (clockWise) {
HXDLIN(  53)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)					int color = -1;
HXDLIN(  53)					if ((color == -1)) {
HXDLIN(  53)						color = _this1->currentColor;
            					}
HXDLIN(  53)					{
HXDLIN(  53)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->ax,_this->ay,0);
HXDLIN(  53)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  53)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  53)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            				else {
HXDLIN(  53)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)					int color = -1;
HXDLIN(  53)					if ((color == -1)) {
HXDLIN(  53)						color = _this1->currentColor;
            					}
HXDLIN(  53)					{
HXDLIN(  53)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->ax,_this->ay,0);
HXDLIN(  53)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  53)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  53)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            			}
            			else {
HXDLIN(  53)				if (clockWise) {
HXDLIN(  53)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)					int color = -1;
HXDLIN(  53)					if ((color == -1)) {
HXDLIN(  53)						color = _this1->currentColor;
            					}
HXDLIN(  53)					{
HXDLIN(  53)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->jx,_this->jy,0);
HXDLIN(  53)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  53)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  53)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            				else {
HXDLIN(  53)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)					int color = -1;
HXDLIN(  53)					if ((color == -1)) {
HXDLIN(  53)						color = _this1->currentColor;
            					}
HXDLIN(  53)					{
HXDLIN(  53)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0);
HXDLIN(  53)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  53)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  53)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            			}
            		}
HXDLIN(  53)		{
HXDLIN(  53)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  53)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  53)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  53)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  53)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  53)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  53)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  53)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  53)		_this->jxOld = _this->jx;
HXDLIN(  53)		_this->jyOld = _this->jy;
HXDLIN(  53)		_this->lastClock = clockWise;
HXDLIN(  53)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,mediumLine,(void))

void Sketch_obj::mediumOverlapLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_56_mediumOverlapLine)
HXDLIN(  56)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  56)		Float ax_ = this->x;
HXDLIN(  56)		Float ay_ = this->y;
HXDLIN(  56)		Float width_ = this->width;
HXDLIN(  56)		 ::Dynamic oldAngle;
HXDLIN(  56)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  56)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  56)			oldAngle = null();
            		}
HXDLIN(  56)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  56)		_this->ax = x_;
HXDLIN(  56)		_this->ay = y_;
HXDLIN(  56)		_this->bx = ax_;
HXDLIN(  56)		_this->by = ay_;
HXDLIN(  56)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  56)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  56)		{
HXDLIN(  56)			{
HXDLIN(  56)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  56)				if ((_this->theta > 0)) {
HXDLIN(  56)					if ((_this->halfA < 0)) {
HXDLIN(  56)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  56)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  56)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  56)					if ((_this->halfA > 0)) {
HXDLIN(  56)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  56)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  56)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  56)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  56)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  56)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  56)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  56)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  56)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  56)				_this->exPrev = _this->ex;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  56)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  56)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  56)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  56)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  56)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  56)		_this->ax = ax_;
HXDLIN(  56)		_this->ay = ay_;
HXDLIN(  56)		_this->bx = x_;
HXDLIN(  56)		_this->by = y_;
HXDLIN(  56)		{
HXDLIN(  56)			{
HXDLIN(  56)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  56)				if ((_this->theta > 0)) {
HXDLIN(  56)					if ((_this->halfA < 0)) {
HXDLIN(  56)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  56)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  56)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  56)					if ((_this->halfA > 0)) {
HXDLIN(  56)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  56)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  56)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  56)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  56)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  56)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  56)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  56)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  56)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  56)				_this->exPrev = _this->ex;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  56)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  56)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  56)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  56)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  56)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  56)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  56)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  56)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  56)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  56)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  56)		Float theta0;
HXDLIN(  56)		Float theta1;
HXDLIN(  56)		if (clockWise) {
HXDLIN(  56)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  56)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  56)		Float dif;
HXDLIN(  56)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  56)				Float f;
HXDLIN(  56)				bool f1;
HXDLIN(  56)				if ((theta0 >= 0)) {
HXDLIN(  56)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f1 = false;
            				}
HXDLIN(  56)				if (f1) {
HXDLIN(  56)					f = theta0;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f = a;
            					}
            					else {
HXDLIN(  56)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this1 = f;
HXDLIN(  56)				Float za = this1;
HXDLIN(  56)				Float f2;
HXDLIN(  56)				bool f3;
HXDLIN(  56)				if ((theta1 >= 0)) {
HXDLIN(  56)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f3 = false;
            				}
HXDLIN(  56)				if (f3) {
HXDLIN(  56)					f2 = theta1;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f2 = a;
            					}
            					else {
HXDLIN(  56)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this2 = f2;
HXDLIN(  56)				Float zb = this2;
HXDLIN(  56)				Float fa = za;
HXDLIN(  56)				Float fb = zb;
HXDLIN(  56)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)				bool clockwise = (fa < fb);
HXDLIN(  56)				Float dif1;
HXDLIN(  56)				if (clockwise) {
HXDLIN(  56)					dif1 = theta;
            				}
            				else {
HXDLIN(  56)					dif1 = -(theta);
            				}
HXDLIN(  56)				if ((dif1 > 0)) {
HXDLIN(  56)					dif = dif1;
            				}
            				else {
HXDLIN(  56)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  56)				Float f;
HXDLIN(  56)				bool f1;
HXDLIN(  56)				if ((theta0 >= 0)) {
HXDLIN(  56)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f1 = false;
            				}
HXDLIN(  56)				if (f1) {
HXDLIN(  56)					f = theta0;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f = a;
            					}
            					else {
HXDLIN(  56)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this1 = f;
HXDLIN(  56)				Float za = this1;
HXDLIN(  56)				Float f2;
HXDLIN(  56)				bool f3;
HXDLIN(  56)				if ((theta1 >= 0)) {
HXDLIN(  56)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f3 = false;
            				}
HXDLIN(  56)				if (f3) {
HXDLIN(  56)					f2 = theta1;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f2 = a;
            					}
            					else {
HXDLIN(  56)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this2 = f2;
HXDLIN(  56)				Float zb = this2;
HXDLIN(  56)				Float fa = za;
HXDLIN(  56)				Float fb = zb;
HXDLIN(  56)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)				bool clockwise = (fa < fb);
HXDLIN(  56)				Float dif1;
HXDLIN(  56)				if (clockwise) {
HXDLIN(  56)					dif1 = theta;
            				}
            				else {
HXDLIN(  56)					dif1 = -(theta);
            				}
HXDLIN(  56)				if ((dif1 < 0)) {
HXDLIN(  56)					dif = dif1;
            				}
            				else {
HXDLIN(  56)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  56)				Float f;
HXDLIN(  56)				bool f1;
HXDLIN(  56)				if ((theta0 >= 0)) {
HXDLIN(  56)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f1 = false;
            				}
HXDLIN(  56)				if (f1) {
HXDLIN(  56)					f = theta0;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f = a;
            					}
            					else {
HXDLIN(  56)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this1 = f;
HXDLIN(  56)				Float za = this1;
HXDLIN(  56)				Float f2;
HXDLIN(  56)				bool f3;
HXDLIN(  56)				if ((theta1 >= 0)) {
HXDLIN(  56)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f3 = false;
            				}
HXDLIN(  56)				if (f3) {
HXDLIN(  56)					f2 = theta1;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f2 = a;
            					}
            					else {
HXDLIN(  56)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this2 = f2;
HXDLIN(  56)				Float zb = this2;
HXDLIN(  56)				Float fa = za;
HXDLIN(  56)				Float fb = zb;
HXDLIN(  56)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  56)				bool clockwise = (fa < fb);
HXDLIN(  56)				Float dif1;
HXDLIN(  56)				if (clockwise) {
HXDLIN(  56)					dif1 = theta;
            				}
            				else {
HXDLIN(  56)					dif1 = -(theta);
            				}
HXDLIN(  56)				if (smallest) {
HXDLIN(  56)					dif = dif1;
            				}
            				else {
HXDLIN(  56)					if (clockwise) {
HXDLIN(  56)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  56)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  56)				Float f;
HXDLIN(  56)				bool f1;
HXDLIN(  56)				if ((theta0 >= 0)) {
HXDLIN(  56)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f1 = false;
            				}
HXDLIN(  56)				if (f1) {
HXDLIN(  56)					f = theta0;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f = a;
            					}
            					else {
HXDLIN(  56)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this1 = f;
HXDLIN(  56)				Float za = this1;
HXDLIN(  56)				Float f2;
HXDLIN(  56)				bool f3;
HXDLIN(  56)				if ((theta1 >= 0)) {
HXDLIN(  56)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f3 = false;
            				}
HXDLIN(  56)				if (f3) {
HXDLIN(  56)					f2 = theta1;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f2 = a;
            					}
            					else {
HXDLIN(  56)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this2 = f2;
HXDLIN(  56)				Float zb = this2;
HXDLIN(  56)				Float fa = za;
HXDLIN(  56)				Float fb = zb;
HXDLIN(  56)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  56)				bool clockwise = (fa < fb);
HXDLIN(  56)				Float dif1;
HXDLIN(  56)				if (clockwise) {
HXDLIN(  56)					dif1 = theta;
            				}
            				else {
HXDLIN(  56)					dif1 = -(theta);
            				}
HXDLIN(  56)				if (largest) {
HXDLIN(  56)					dif = dif1;
            				}
            				else {
HXDLIN(  56)					if (clockwise) {
HXDLIN(  56)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  56)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  56)		bool _hx_tmp;
HXDLIN(  56)		if ((_this->count == 0)) {
HXDLIN(  56)			if ((_this->endLine != 1)) {
HXDLIN(  56)				_hx_tmp = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  56)				_hx_tmp = true;
            			}
            		}
            		else {
HXDLIN(  56)			_hx_tmp = false;
            		}
HXDLIN(  56)		if (_hx_tmp) {
HXDLIN(  56)			Float ax = _this->ax;
HXDLIN(  56)			Float ay = _this->ay;
HXDLIN(  56)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  56)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  56)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  56)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  56)			 ::Dynamic sides = 36;
HXDLIN(  56)			if (::hx::IsNull( sides )) {
HXDLIN(  56)				sides = 36;
            			}
HXDLIN(  56)			Float pi = ::Math_obj::PI;
HXDLIN(  56)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  56)			Float dif;
HXDLIN(  56)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  56)					Float f;
HXDLIN(  56)					bool f1;
HXDLIN(  56)					if ((beta >= 0)) {
HXDLIN(  56)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f1 = false;
            					}
HXDLIN(  56)					if (f1) {
HXDLIN(  56)						f = beta;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f = a;
            						}
            						else {
HXDLIN(  56)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this1 = f;
HXDLIN(  56)					Float za = this1;
HXDLIN(  56)					Float f2;
HXDLIN(  56)					bool f3;
HXDLIN(  56)					if ((gamma >= 0)) {
HXDLIN(  56)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f3 = false;
            					}
HXDLIN(  56)					if (f3) {
HXDLIN(  56)						f2 = gamma;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f2 = a;
            						}
            						else {
HXDLIN(  56)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this2 = f2;
HXDLIN(  56)					Float zb = this2;
HXDLIN(  56)					Float fa = za;
HXDLIN(  56)					Float fb = zb;
HXDLIN(  56)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)					bool clockwise = (fa < fb);
HXDLIN(  56)					Float dif1;
HXDLIN(  56)					if (clockwise) {
HXDLIN(  56)						dif1 = theta;
            					}
            					else {
HXDLIN(  56)						dif1 = -(theta);
            					}
HXDLIN(  56)					if ((dif1 > 0)) {
HXDLIN(  56)						dif = dif1;
            					}
            					else {
HXDLIN(  56)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  56)					Float f;
HXDLIN(  56)					bool f1;
HXDLIN(  56)					if ((beta >= 0)) {
HXDLIN(  56)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f1 = false;
            					}
HXDLIN(  56)					if (f1) {
HXDLIN(  56)						f = beta;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f = a;
            						}
            						else {
HXDLIN(  56)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this1 = f;
HXDLIN(  56)					Float za = this1;
HXDLIN(  56)					Float f2;
HXDLIN(  56)					bool f3;
HXDLIN(  56)					if ((gamma >= 0)) {
HXDLIN(  56)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f3 = false;
            					}
HXDLIN(  56)					if (f3) {
HXDLIN(  56)						f2 = gamma;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f2 = a;
            						}
            						else {
HXDLIN(  56)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this2 = f2;
HXDLIN(  56)					Float zb = this2;
HXDLIN(  56)					Float fa = za;
HXDLIN(  56)					Float fb = zb;
HXDLIN(  56)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)					bool clockwise = (fa < fb);
HXDLIN(  56)					Float dif1;
HXDLIN(  56)					if (clockwise) {
HXDLIN(  56)						dif1 = theta;
            					}
            					else {
HXDLIN(  56)						dif1 = -(theta);
            					}
HXDLIN(  56)					if ((dif1 < 0)) {
HXDLIN(  56)						dif = dif1;
            					}
            					else {
HXDLIN(  56)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  56)					Float f;
HXDLIN(  56)					bool f1;
HXDLIN(  56)					if ((beta >= 0)) {
HXDLIN(  56)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f1 = false;
            					}
HXDLIN(  56)					if (f1) {
HXDLIN(  56)						f = beta;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f = a;
            						}
            						else {
HXDLIN(  56)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this1 = f;
HXDLIN(  56)					Float za = this1;
HXDLIN(  56)					Float f2;
HXDLIN(  56)					bool f3;
HXDLIN(  56)					if ((gamma >= 0)) {
HXDLIN(  56)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f3 = false;
            					}
HXDLIN(  56)					if (f3) {
HXDLIN(  56)						f2 = gamma;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f2 = a;
            						}
            						else {
HXDLIN(  56)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this2 = f2;
HXDLIN(  56)					Float zb = this2;
HXDLIN(  56)					Float fa = za;
HXDLIN(  56)					Float fb = zb;
HXDLIN(  56)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  56)					bool clockwise = (fa < fb);
HXDLIN(  56)					Float dif1;
HXDLIN(  56)					if (clockwise) {
HXDLIN(  56)						dif1 = theta;
            					}
            					else {
HXDLIN(  56)						dif1 = -(theta);
            					}
HXDLIN(  56)					if (smallest) {
HXDLIN(  56)						dif = dif1;
            					}
            					else {
HXDLIN(  56)						if (clockwise) {
HXDLIN(  56)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  56)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  56)					Float f;
HXDLIN(  56)					bool f1;
HXDLIN(  56)					if ((beta >= 0)) {
HXDLIN(  56)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f1 = false;
            					}
HXDLIN(  56)					if (f1) {
HXDLIN(  56)						f = beta;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f = a;
            						}
            						else {
HXDLIN(  56)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this1 = f;
HXDLIN(  56)					Float za = this1;
HXDLIN(  56)					Float f2;
HXDLIN(  56)					bool f3;
HXDLIN(  56)					if ((gamma >= 0)) {
HXDLIN(  56)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f3 = false;
            					}
HXDLIN(  56)					if (f3) {
HXDLIN(  56)						f2 = gamma;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f2 = a;
            						}
            						else {
HXDLIN(  56)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this2 = f2;
HXDLIN(  56)					Float zb = this2;
HXDLIN(  56)					Float fa = za;
HXDLIN(  56)					Float fb = zb;
HXDLIN(  56)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  56)					bool clockwise = (fa < fb);
HXDLIN(  56)					Float dif1;
HXDLIN(  56)					if (clockwise) {
HXDLIN(  56)						dif1 = theta;
            					}
            					else {
HXDLIN(  56)						dif1 = -(theta);
            					}
HXDLIN(  56)					if (largest) {
HXDLIN(  56)						dif = dif1;
            					}
            					else {
HXDLIN(  56)						if (clockwise) {
HXDLIN(  56)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  56)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  56)			bool positive = (dif >= 0);
HXDLIN(  56)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  56)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  56)			Float angle = beta;
HXDLIN(  56)			Float cx;
HXDLIN(  56)			Float cy;
HXDLIN(  56)			Float bx = ( (Float)(0) );
HXDLIN(  56)			Float by = ( (Float)(0) );
HXDLIN(  56)			int p2 = temp->length;
HXDLIN(  56)			{
HXDLIN(  56)				int _g = 0;
HXDLIN(  56)				int _g1 = (totalSteps + 1);
HXDLIN(  56)				while((_g < _g1)){
HXDLIN(  56)					_g = (_g + 1);
HXDLIN(  56)					int i = (_g - 1);
HXDLIN(  56)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  56)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  56)					p2 = (p2 + 1);
HXDLIN(  56)					temp[(p2 - 1)] = cx;
HXDLIN(  56)					p2 = (p2 + 1);
HXDLIN(  56)					temp[(p2 - 1)] = cy;
HXDLIN(  56)					if ((i != 0)) {
HXDLIN(  56)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  56)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  56)						if (::hx::IsNotNull( m )) {
HXDLIN(  56)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  56)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  56)					angle = (angle + step1);
HXDLIN(  56)					bx = cx;
HXDLIN(  56)					by = cy;
            				}
            			}
HXDLIN(  56)			int len = totalSteps;
HXDLIN(  56)			{
HXDLIN(  56)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  56)				int color = -1;
HXDLIN(  56)				if ((color == -1)) {
HXDLIN(  56)					color = _this1->currentColor;
            				}
HXDLIN(  56)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  56)			int pA = _this->pointsAnti->length;
HXDLIN(  56)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  56)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  56)			{
HXDLIN(  56)				int _g2 = 0;
HXDLIN(  56)				int _g3 = p4;
HXDLIN(  56)				while((_g2 < _g3)){
HXDLIN(  56)					_g2 = (_g2 + 1);
HXDLIN(  56)					int i = (_g2 - 1);
HXDLIN(  56)					pA = (pA + 1);
HXDLIN(  56)					_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXDLIN(  56)					pA = (pA + 1);
HXDLIN(  56)					_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            				}
            			}
HXDLIN(  56)			int pC = _this->pointsClock->length;
HXDLIN(  56)			{
HXDLIN(  56)				int _g4 = 0;
HXDLIN(  56)				int _g5 = p4;
HXDLIN(  56)				while((_g4 < _g5)){
HXDLIN(  56)					_g4 = (_g4 + 1);
HXDLIN(  56)					int i = (_g4 - 1);
HXDLIN(  56)					pC = (pC + 1);
HXDLIN(  56)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXDLIN(  56)					pC = (pC + 1);
HXDLIN(  56)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            				}
            			}
            		}
HXDLIN(  56)		{
HXDLIN(  56)			{
HXDLIN(  56)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  56)				int color = -1;
HXDLIN(  56)				if ((color == -1)) {
HXDLIN(  56)					color = _this1->currentColor;
            				}
HXDLIN(  56)				{
HXDLIN(  56)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  56)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  56)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  56)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  56)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  56)			{
HXDLIN(  56)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  56)				int color1 = -1;
HXDLIN(  56)				if ((color1 == -1)) {
HXDLIN(  56)					color1 = _this2->currentColor;
            				}
HXDLIN(  56)				{
HXDLIN(  56)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  56)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  56)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  56)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  56)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
HXDLIN(  56)		if ((_this->count != 0)) {
HXDLIN(  56)			if (clockWise) {
HXDLIN(  56)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  56)				int color = -1;
HXDLIN(  56)				if ((color == -1)) {
HXDLIN(  56)					color = _this1->currentColor;
            				}
HXDLIN(  56)				{
HXDLIN(  56)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->ax,_this->ay,0);
HXDLIN(  56)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  56)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  56)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  56)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
            			else {
HXDLIN(  56)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  56)				int color = -1;
HXDLIN(  56)				if ((color == -1)) {
HXDLIN(  56)					color = _this1->currentColor;
            				}
HXDLIN(  56)				{
HXDLIN(  56)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->ax,_this->ay,0);
HXDLIN(  56)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  56)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  56)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  56)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
            		}
HXDLIN(  56)		{
HXDLIN(  56)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  56)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  56)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  56)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  56)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  56)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  56)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  56)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  56)		_this->jxOld = _this->jx;
HXDLIN(  56)		_this->jyOld = _this->jy;
HXDLIN(  56)		_this->lastClock = clockWise;
HXDLIN(  56)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,mediumOverlapLine,(void))

void Sketch_obj::fineLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_59_fineLine)
HXDLIN(  59)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  59)		Float ax_ = this->x;
HXDLIN(  59)		Float ay_ = this->y;
HXDLIN(  59)		Float width_ = this->width;
HXDLIN(  59)		bool overlap = false;
HXDLIN(  59)		 ::Dynamic oldAngle;
HXDLIN(  59)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  59)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  59)			oldAngle = null();
            		}
HXDLIN(  59)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  59)		_this->ax = x_;
HXDLIN(  59)		_this->ay = y_;
HXDLIN(  59)		_this->bx = ax_;
HXDLIN(  59)		_this->by = ay_;
HXDLIN(  59)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  59)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  59)		{
HXDLIN(  59)			{
HXDLIN(  59)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  59)				if ((_this->theta > 0)) {
HXDLIN(  59)					if ((_this->halfA < 0)) {
HXDLIN(  59)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  59)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  59)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  59)					if ((_this->halfA > 0)) {
HXDLIN(  59)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  59)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  59)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  59)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  59)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  59)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  59)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  59)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  59)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  59)				_this->exPrev = _this->ex;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  59)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  59)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  59)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  59)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  59)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  59)		_this->ax = ax_;
HXDLIN(  59)		_this->ay = ay_;
HXDLIN(  59)		_this->bx = x_;
HXDLIN(  59)		_this->by = y_;
HXDLIN(  59)		{
HXDLIN(  59)			{
HXDLIN(  59)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  59)				if ((_this->theta > 0)) {
HXDLIN(  59)					if ((_this->halfA < 0)) {
HXDLIN(  59)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  59)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  59)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  59)					if ((_this->halfA > 0)) {
HXDLIN(  59)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  59)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  59)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  59)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  59)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  59)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  59)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  59)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  59)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  59)				_this->exPrev = _this->ex;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  59)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  59)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  59)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  59)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  59)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  59)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  59)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  59)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  59)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  59)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  59)		Float theta0;
HXDLIN(  59)		Float theta1;
HXDLIN(  59)		if (clockWise) {
HXDLIN(  59)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  59)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  59)		Float dif;
HXDLIN(  59)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  59)				Float f;
HXDLIN(  59)				bool f1;
HXDLIN(  59)				if ((theta0 >= 0)) {
HXDLIN(  59)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f1 = false;
            				}
HXDLIN(  59)				if (f1) {
HXDLIN(  59)					f = theta0;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f = a;
            					}
            					else {
HXDLIN(  59)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this1 = f;
HXDLIN(  59)				Float za = this1;
HXDLIN(  59)				Float f2;
HXDLIN(  59)				bool f3;
HXDLIN(  59)				if ((theta1 >= 0)) {
HXDLIN(  59)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f3 = false;
            				}
HXDLIN(  59)				if (f3) {
HXDLIN(  59)					f2 = theta1;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f2 = a;
            					}
            					else {
HXDLIN(  59)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this2 = f2;
HXDLIN(  59)				Float zb = this2;
HXDLIN(  59)				Float fa = za;
HXDLIN(  59)				Float fb = zb;
HXDLIN(  59)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)				bool clockwise = (fa < fb);
HXDLIN(  59)				Float dif1;
HXDLIN(  59)				if (clockwise) {
HXDLIN(  59)					dif1 = theta;
            				}
            				else {
HXDLIN(  59)					dif1 = -(theta);
            				}
HXDLIN(  59)				if ((dif1 > 0)) {
HXDLIN(  59)					dif = dif1;
            				}
            				else {
HXDLIN(  59)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  59)				Float f;
HXDLIN(  59)				bool f1;
HXDLIN(  59)				if ((theta0 >= 0)) {
HXDLIN(  59)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f1 = false;
            				}
HXDLIN(  59)				if (f1) {
HXDLIN(  59)					f = theta0;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f = a;
            					}
            					else {
HXDLIN(  59)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this1 = f;
HXDLIN(  59)				Float za = this1;
HXDLIN(  59)				Float f2;
HXDLIN(  59)				bool f3;
HXDLIN(  59)				if ((theta1 >= 0)) {
HXDLIN(  59)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f3 = false;
            				}
HXDLIN(  59)				if (f3) {
HXDLIN(  59)					f2 = theta1;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f2 = a;
            					}
            					else {
HXDLIN(  59)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this2 = f2;
HXDLIN(  59)				Float zb = this2;
HXDLIN(  59)				Float fa = za;
HXDLIN(  59)				Float fb = zb;
HXDLIN(  59)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)				bool clockwise = (fa < fb);
HXDLIN(  59)				Float dif1;
HXDLIN(  59)				if (clockwise) {
HXDLIN(  59)					dif1 = theta;
            				}
            				else {
HXDLIN(  59)					dif1 = -(theta);
            				}
HXDLIN(  59)				if ((dif1 < 0)) {
HXDLIN(  59)					dif = dif1;
            				}
            				else {
HXDLIN(  59)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  59)				Float f;
HXDLIN(  59)				bool f1;
HXDLIN(  59)				if ((theta0 >= 0)) {
HXDLIN(  59)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f1 = false;
            				}
HXDLIN(  59)				if (f1) {
HXDLIN(  59)					f = theta0;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f = a;
            					}
            					else {
HXDLIN(  59)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this1 = f;
HXDLIN(  59)				Float za = this1;
HXDLIN(  59)				Float f2;
HXDLIN(  59)				bool f3;
HXDLIN(  59)				if ((theta1 >= 0)) {
HXDLIN(  59)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f3 = false;
            				}
HXDLIN(  59)				if (f3) {
HXDLIN(  59)					f2 = theta1;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f2 = a;
            					}
            					else {
HXDLIN(  59)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this2 = f2;
HXDLIN(  59)				Float zb = this2;
HXDLIN(  59)				Float fa = za;
HXDLIN(  59)				Float fb = zb;
HXDLIN(  59)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  59)				bool clockwise = (fa < fb);
HXDLIN(  59)				Float dif1;
HXDLIN(  59)				if (clockwise) {
HXDLIN(  59)					dif1 = theta;
            				}
            				else {
HXDLIN(  59)					dif1 = -(theta);
            				}
HXDLIN(  59)				if (smallest) {
HXDLIN(  59)					dif = dif1;
            				}
            				else {
HXDLIN(  59)					if (clockwise) {
HXDLIN(  59)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  59)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  59)				Float f;
HXDLIN(  59)				bool f1;
HXDLIN(  59)				if ((theta0 >= 0)) {
HXDLIN(  59)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f1 = false;
            				}
HXDLIN(  59)				if (f1) {
HXDLIN(  59)					f = theta0;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f = a;
            					}
            					else {
HXDLIN(  59)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this1 = f;
HXDLIN(  59)				Float za = this1;
HXDLIN(  59)				Float f2;
HXDLIN(  59)				bool f3;
HXDLIN(  59)				if ((theta1 >= 0)) {
HXDLIN(  59)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f3 = false;
            				}
HXDLIN(  59)				if (f3) {
HXDLIN(  59)					f2 = theta1;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f2 = a;
            					}
            					else {
HXDLIN(  59)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this2 = f2;
HXDLIN(  59)				Float zb = this2;
HXDLIN(  59)				Float fa = za;
HXDLIN(  59)				Float fb = zb;
HXDLIN(  59)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  59)				bool clockwise = (fa < fb);
HXDLIN(  59)				Float dif1;
HXDLIN(  59)				if (clockwise) {
HXDLIN(  59)					dif1 = theta;
            				}
            				else {
HXDLIN(  59)					dif1 = -(theta);
            				}
HXDLIN(  59)				if (largest) {
HXDLIN(  59)					dif = dif1;
            				}
            				else {
HXDLIN(  59)					if (clockwise) {
HXDLIN(  59)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  59)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  59)		bool _hx_tmp;
HXDLIN(  59)		if (!(overlap)) {
HXDLIN(  59)			_hx_tmp = (_this->count != 0);
            		}
            		else {
HXDLIN(  59)			_hx_tmp = false;
            		}
HXDLIN(  59)		if (_hx_tmp) {
HXDLIN(  59)			Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
HXDLIN(  59)			Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
HXDLIN(  59)			Float f;
HXDLIN(  59)			bool f1;
HXDLIN(  59)			if ((theta0 <= ::Math_obj::PI)) {
HXDLIN(  59)				f1 = (theta0 > -(::Math_obj::PI));
            			}
            			else {
HXDLIN(  59)				f1 = false;
            			}
HXDLIN(  59)			if (f1) {
HXDLIN(  59)				f = theta0;
            			}
            			else {
HXDLIN(  59)				Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)				if ((a >= 0)) {
HXDLIN(  59)					f = (a - ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f = (a + ::Math_obj::PI);
            				}
            			}
HXDLIN(  59)			Float this1 = f;
HXDLIN(  59)			Float start = this1;
HXDLIN(  59)			Float start2 = start;
HXDLIN(  59)			Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  59)			_this->jx = (_this->ax + (h * ::Math_obj::sin(delta)));
HXDLIN(  59)			_this->jy = (_this->ay + (h * ::Math_obj::cos(delta)));
            		}
HXDLIN(  59)		bool _hx_tmp1;
HXDLIN(  59)		if ((_this->count == 0)) {
HXDLIN(  59)			if ((_this->endLine != 1)) {
HXDLIN(  59)				_hx_tmp1 = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  59)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXDLIN(  59)			_hx_tmp1 = false;
            		}
HXDLIN(  59)		if (_hx_tmp1) {
HXDLIN(  59)			Float ax = _this->ax;
HXDLIN(  59)			Float ay = _this->ay;
HXDLIN(  59)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  59)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  59)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  59)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  59)			 ::Dynamic sides = 36;
HXDLIN(  59)			if (::hx::IsNull( sides )) {
HXDLIN(  59)				sides = 36;
            			}
HXDLIN(  59)			Float pi = ::Math_obj::PI;
HXDLIN(  59)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  59)			Float dif;
HXDLIN(  59)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  59)					Float f;
HXDLIN(  59)					bool f1;
HXDLIN(  59)					if ((beta >= 0)) {
HXDLIN(  59)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f1 = false;
            					}
HXDLIN(  59)					if (f1) {
HXDLIN(  59)						f = beta;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f = a;
            						}
            						else {
HXDLIN(  59)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this1 = f;
HXDLIN(  59)					Float za = this1;
HXDLIN(  59)					Float f2;
HXDLIN(  59)					bool f3;
HXDLIN(  59)					if ((gamma >= 0)) {
HXDLIN(  59)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f3 = false;
            					}
HXDLIN(  59)					if (f3) {
HXDLIN(  59)						f2 = gamma;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f2 = a;
            						}
            						else {
HXDLIN(  59)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this2 = f2;
HXDLIN(  59)					Float zb = this2;
HXDLIN(  59)					Float fa = za;
HXDLIN(  59)					Float fb = zb;
HXDLIN(  59)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)					bool clockwise = (fa < fb);
HXDLIN(  59)					Float dif1;
HXDLIN(  59)					if (clockwise) {
HXDLIN(  59)						dif1 = theta;
            					}
            					else {
HXDLIN(  59)						dif1 = -(theta);
            					}
HXDLIN(  59)					if ((dif1 > 0)) {
HXDLIN(  59)						dif = dif1;
            					}
            					else {
HXDLIN(  59)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  59)					Float f;
HXDLIN(  59)					bool f1;
HXDLIN(  59)					if ((beta >= 0)) {
HXDLIN(  59)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f1 = false;
            					}
HXDLIN(  59)					if (f1) {
HXDLIN(  59)						f = beta;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f = a;
            						}
            						else {
HXDLIN(  59)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this1 = f;
HXDLIN(  59)					Float za = this1;
HXDLIN(  59)					Float f2;
HXDLIN(  59)					bool f3;
HXDLIN(  59)					if ((gamma >= 0)) {
HXDLIN(  59)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f3 = false;
            					}
HXDLIN(  59)					if (f3) {
HXDLIN(  59)						f2 = gamma;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f2 = a;
            						}
            						else {
HXDLIN(  59)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this2 = f2;
HXDLIN(  59)					Float zb = this2;
HXDLIN(  59)					Float fa = za;
HXDLIN(  59)					Float fb = zb;
HXDLIN(  59)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)					bool clockwise = (fa < fb);
HXDLIN(  59)					Float dif1;
HXDLIN(  59)					if (clockwise) {
HXDLIN(  59)						dif1 = theta;
            					}
            					else {
HXDLIN(  59)						dif1 = -(theta);
            					}
HXDLIN(  59)					if ((dif1 < 0)) {
HXDLIN(  59)						dif = dif1;
            					}
            					else {
HXDLIN(  59)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  59)					Float f;
HXDLIN(  59)					bool f1;
HXDLIN(  59)					if ((beta >= 0)) {
HXDLIN(  59)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f1 = false;
            					}
HXDLIN(  59)					if (f1) {
HXDLIN(  59)						f = beta;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f = a;
            						}
            						else {
HXDLIN(  59)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this1 = f;
HXDLIN(  59)					Float za = this1;
HXDLIN(  59)					Float f2;
HXDLIN(  59)					bool f3;
HXDLIN(  59)					if ((gamma >= 0)) {
HXDLIN(  59)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f3 = false;
            					}
HXDLIN(  59)					if (f3) {
HXDLIN(  59)						f2 = gamma;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f2 = a;
            						}
            						else {
HXDLIN(  59)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this2 = f2;
HXDLIN(  59)					Float zb = this2;
HXDLIN(  59)					Float fa = za;
HXDLIN(  59)					Float fb = zb;
HXDLIN(  59)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  59)					bool clockwise = (fa < fb);
HXDLIN(  59)					Float dif1;
HXDLIN(  59)					if (clockwise) {
HXDLIN(  59)						dif1 = theta;
            					}
            					else {
HXDLIN(  59)						dif1 = -(theta);
            					}
HXDLIN(  59)					if (smallest) {
HXDLIN(  59)						dif = dif1;
            					}
            					else {
HXDLIN(  59)						if (clockwise) {
HXDLIN(  59)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  59)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  59)					Float f;
HXDLIN(  59)					bool f1;
HXDLIN(  59)					if ((beta >= 0)) {
HXDLIN(  59)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f1 = false;
            					}
HXDLIN(  59)					if (f1) {
HXDLIN(  59)						f = beta;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f = a;
            						}
            						else {
HXDLIN(  59)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this1 = f;
HXDLIN(  59)					Float za = this1;
HXDLIN(  59)					Float f2;
HXDLIN(  59)					bool f3;
HXDLIN(  59)					if ((gamma >= 0)) {
HXDLIN(  59)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f3 = false;
            					}
HXDLIN(  59)					if (f3) {
HXDLIN(  59)						f2 = gamma;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f2 = a;
            						}
            						else {
HXDLIN(  59)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this2 = f2;
HXDLIN(  59)					Float zb = this2;
HXDLIN(  59)					Float fa = za;
HXDLIN(  59)					Float fb = zb;
HXDLIN(  59)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  59)					bool clockwise = (fa < fb);
HXDLIN(  59)					Float dif1;
HXDLIN(  59)					if (clockwise) {
HXDLIN(  59)						dif1 = theta;
            					}
            					else {
HXDLIN(  59)						dif1 = -(theta);
            					}
HXDLIN(  59)					if (largest) {
HXDLIN(  59)						dif = dif1;
            					}
            					else {
HXDLIN(  59)						if (clockwise) {
HXDLIN(  59)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  59)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  59)			bool positive = (dif >= 0);
HXDLIN(  59)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  59)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  59)			Float angle = beta;
HXDLIN(  59)			Float cx;
HXDLIN(  59)			Float cy;
HXDLIN(  59)			Float bx = ( (Float)(0) );
HXDLIN(  59)			Float by = ( (Float)(0) );
HXDLIN(  59)			int p2 = temp->length;
HXDLIN(  59)			{
HXDLIN(  59)				int _g = 0;
HXDLIN(  59)				int _g1 = (totalSteps + 1);
HXDLIN(  59)				while((_g < _g1)){
HXDLIN(  59)					_g = (_g + 1);
HXDLIN(  59)					int i = (_g - 1);
HXDLIN(  59)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  59)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  59)					p2 = (p2 + 1);
HXDLIN(  59)					temp[(p2 - 1)] = cx;
HXDLIN(  59)					p2 = (p2 + 1);
HXDLIN(  59)					temp[(p2 - 1)] = cy;
HXDLIN(  59)					if ((i != 0)) {
HXDLIN(  59)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  59)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  59)						if (::hx::IsNotNull( m )) {
HXDLIN(  59)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  59)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					angle = (angle + step1);
HXDLIN(  59)					bx = cx;
HXDLIN(  59)					by = cy;
            				}
            			}
HXDLIN(  59)			int len = totalSteps;
HXDLIN(  59)			{
HXDLIN(  59)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)				int color = -1;
HXDLIN(  59)				if ((color == -1)) {
HXDLIN(  59)					color = _this1->currentColor;
            				}
HXDLIN(  59)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  59)			int pA = _this->pointsAnti->length;
HXDLIN(  59)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  59)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  59)			{
HXDLIN(  59)				int _g2 = 0;
HXDLIN(  59)				int _g3 = p4;
HXDLIN(  59)				while((_g2 < _g3)){
HXDLIN(  59)					_g2 = (_g2 + 1);
HXDLIN(  59)					int i = (_g2 - 1);
HXDLIN(  59)					pA = (pA + 1);
HXDLIN(  59)					_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXDLIN(  59)					pA = (pA + 1);
HXDLIN(  59)					_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            				}
            			}
HXDLIN(  59)			int pC = _this->pointsClock->length;
HXDLIN(  59)			{
HXDLIN(  59)				int _g4 = 0;
HXDLIN(  59)				int _g5 = p4;
HXDLIN(  59)				while((_g4 < _g5)){
HXDLIN(  59)					_g4 = (_g4 + 1);
HXDLIN(  59)					int i = (_g4 - 1);
HXDLIN(  59)					pC = (pC + 1);
HXDLIN(  59)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXDLIN(  59)					pC = (pC + 1);
HXDLIN(  59)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            				}
            			}
            		}
HXDLIN(  59)		if (overlap) {
HXDLIN(  59)			{
HXDLIN(  59)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)				int color = -1;
HXDLIN(  59)				if ((color == -1)) {
HXDLIN(  59)					color = _this1->currentColor;
            				}
HXDLIN(  59)				{
HXDLIN(  59)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  59)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  59)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  59)			{
HXDLIN(  59)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)				int color1 = -1;
HXDLIN(  59)				if ((color1 == -1)) {
HXDLIN(  59)					color1 = _this2->currentColor;
            				}
HXDLIN(  59)				{
HXDLIN(  59)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  59)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  59)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  59)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
            		else {
HXDLIN(  59)			if ((_this->count != 0)) {
HXDLIN(  59)				_this->addQuads(clockWise,width_);
            			}
HXDLIN(  59)			{
HXDLIN(  59)				_this->quadIndex = ( (Float)(_this->pen->drawType->__Field(HX_("get_pos",2b,26,ca,26),::hx::paccDynamic)()) );
HXDLIN(  59)				if ((_this->count == 0)) {
HXDLIN(  59)					_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  59)					_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  59)					_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  59)					_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  59)					_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  59)					_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  59)					_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  59)					_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  59)					{
HXDLIN(  59)						 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)						int color = -1;
HXDLIN(  59)						if ((color == -1)) {
HXDLIN(  59)							color = _this1->currentColor;
            						}
HXDLIN(  59)						{
HXDLIN(  59)							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN(  59)							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  59)						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            					}
HXDLIN(  59)					{
HXDLIN(  59)						 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)						int color1 = -1;
HXDLIN(  59)						if ((color1 == -1)) {
HXDLIN(  59)							color1 = _this2->currentColor;
            						}
HXDLIN(  59)						{
HXDLIN(  59)							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  59)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN(  59)							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  59)						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            					}
            				}
            				else {
HXDLIN(  59)					bool _hx_tmp;
HXDLIN(  59)					if (clockWise) {
HXDLIN(  59)						_hx_tmp = !(_this->lastClock);
            					}
            					else {
HXDLIN(  59)						_hx_tmp = false;
            					}
HXDLIN(  59)					if (_hx_tmp) {
HXDLIN(  59)						_this->penultimateAX = _this->jx;
HXDLIN(  59)						_this->penultimateAY = _this->jy;
HXDLIN(  59)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  59)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  59)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  59)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  59)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  59)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)							int color = -1;
HXDLIN(  59)							if ((color == -1)) {
HXDLIN(  59)								color = _this1->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)							int color1 = -1;
HXDLIN(  59)							if ((color1 == -1)) {
HXDLIN(  59)								color1 = _this2->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  59)					bool _hx_tmp1;
HXDLIN(  59)					if (clockWise) {
HXDLIN(  59)						_hx_tmp1 = _this->lastClock;
            					}
            					else {
HXDLIN(  59)						_hx_tmp1 = false;
            					}
HXDLIN(  59)					if (_hx_tmp1) {
HXDLIN(  59)						_this->penultimateAX = _this->jx;
HXDLIN(  59)						_this->penultimateAY = _this->jy;
HXDLIN(  59)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  59)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  59)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  59)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  59)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  59)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)							int color = -1;
HXDLIN(  59)							if ((color == -1)) {
HXDLIN(  59)								color = _this1->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)							int color1 = -1;
HXDLIN(  59)							if ((color1 == -1)) {
HXDLIN(  59)								color1 = _this2->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  59)					bool _hx_tmp2;
HXDLIN(  59)					if (!(clockWise)) {
HXDLIN(  59)						_hx_tmp2 = !(_this->lastClock);
            					}
            					else {
HXDLIN(  59)						_hx_tmp2 = false;
            					}
HXDLIN(  59)					if (_hx_tmp2) {
HXDLIN(  59)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  59)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  59)						_this->lastClockX = _this->jx;
HXDLIN(  59)						_this->lastClockY = _this->jy;
HXDLIN(  59)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  59)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  59)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  59)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)							int color = -1;
HXDLIN(  59)							if ((color == -1)) {
HXDLIN(  59)								color = _this1->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,_this->jx,_this->jy,0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)							int color1 = -1;
HXDLIN(  59)							if ((color1 == -1)) {
HXDLIN(  59)								color1 = _this2->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  59)					bool _hx_tmp3;
HXDLIN(  59)					if (!(clockWise)) {
HXDLIN(  59)						_hx_tmp3 = _this->lastClock;
            					}
            					else {
HXDLIN(  59)						_hx_tmp3 = false;
            					}
HXDLIN(  59)					if (_hx_tmp3) {
HXDLIN(  59)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  59)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  59)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  59)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  59)						_this->penultimateCX = _this->jx;
HXDLIN(  59)						_this->penultimateCY = _this->jy;
HXDLIN(  59)						_this->lastClockX = ( (Float)(_this->dx) );
HXDLIN(  59)						_this->lastClockY = ( (Float)(_this->dy) );
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)							int color = -1;
HXDLIN(  59)							if ((color == -1)) {
HXDLIN(  59)								color = _this1->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)							int color1 = -1;
HXDLIN(  59)							if ((color1 == -1)) {
HXDLIN(  59)								color1 = _this2->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
            				}
            			}
            		}
HXDLIN(  59)		if (clockWise) {
HXDLIN(  59)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  59)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  59)			::Array< Float > edgePoly = _this->pointsClock;
HXDLIN(  59)			Float pi = ::Math_obj::PI;
HXDLIN(  59)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  59)			bool positive = (dif >= 0);
HXDLIN(  59)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  59)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  59)			Float angle = theta0;
HXDLIN(  59)			Float cx;
HXDLIN(  59)			Float cy;
HXDLIN(  59)			Float bx = ( (Float)(0) );
HXDLIN(  59)			Float by = ( (Float)(0) );
HXDLIN(  59)			int p2 = edgePoly->length;
HXDLIN(  59)			{
HXDLIN(  59)				int _g = 0;
HXDLIN(  59)				int _g1 = (totalSteps + 1);
HXDLIN(  59)				while((_g < _g1)){
HXDLIN(  59)					_g = (_g + 1);
HXDLIN(  59)					int i = (_g - 1);
HXDLIN(  59)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  59)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  59)					p2 = (p2 + 1);
HXDLIN(  59)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  59)					p2 = (p2 + 1);
HXDLIN(  59)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  59)					if ((i != 0)) {
HXDLIN(  59)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  59)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  59)						if (::hx::IsNotNull( m )) {
HXDLIN(  59)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  59)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					angle = (angle + step1);
HXDLIN(  59)					bx = cx;
HXDLIN(  59)					by = cy;
            				}
            			}
HXDLIN(  59)			int len = totalSteps;
HXDLIN(  59)			{
HXDLIN(  59)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)				int color = -1;
HXDLIN(  59)				if ((color == -1)) {
HXDLIN(  59)					color = _this1->currentColor;
            				}
HXDLIN(  59)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
            		else {
HXDLIN(  59)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  59)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  59)			::Array< Float > edgePoly = _this->pointsAnti;
HXDLIN(  59)			Float pi = ::Math_obj::PI;
HXDLIN(  59)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  59)			bool positive = (dif >= 0);
HXDLIN(  59)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  59)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  59)			Float angle = theta0;
HXDLIN(  59)			Float cx;
HXDLIN(  59)			Float cy;
HXDLIN(  59)			Float bx = ( (Float)(0) );
HXDLIN(  59)			Float by = ( (Float)(0) );
HXDLIN(  59)			int p2 = edgePoly->length;
HXDLIN(  59)			{
HXDLIN(  59)				int _g = 0;
HXDLIN(  59)				int _g1 = (totalSteps + 1);
HXDLIN(  59)				while((_g < _g1)){
HXDLIN(  59)					_g = (_g + 1);
HXDLIN(  59)					int i = (_g - 1);
HXDLIN(  59)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  59)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  59)					p2 = (p2 + 1);
HXDLIN(  59)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  59)					p2 = (p2 + 1);
HXDLIN(  59)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  59)					if ((i != 0)) {
HXDLIN(  59)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  59)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  59)						if (::hx::IsNotNull( m )) {
HXDLIN(  59)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  59)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					angle = (angle + step1);
HXDLIN(  59)					bx = cx;
HXDLIN(  59)					by = cy;
            				}
            			}
HXDLIN(  59)			int len = totalSteps;
HXDLIN(  59)			{
HXDLIN(  59)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)				int color = -1;
HXDLIN(  59)				if ((color == -1)) {
HXDLIN(  59)					color = _this1->currentColor;
            				}
HXDLIN(  59)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  59)		{
HXDLIN(  59)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  59)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  59)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  59)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  59)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  59)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  59)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  59)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  59)		bool _hx_tmp2;
HXDLIN(  59)		if (!(overlap)) {
HXDLIN(  59)			_hx_tmp2 = (_this->count != 0);
            		}
            		else {
HXDLIN(  59)			_hx_tmp2 = false;
            		}
HXDLIN(  59)		if (_hx_tmp2) {
HXDLIN(  59)			if (clockWise) {
HXDLIN(  59)				{
HXDLIN(  59)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)					int color = -1;
HXDLIN(  59)					if ((color == -1)) {
HXDLIN(  59)						color = _this1->currentColor;
            					}
HXDLIN(  59)					{
HXDLIN(  59)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,_this->jx,_this->jy,0);
HXDLIN(  59)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  59)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXDLIN(  59)				{
HXDLIN(  59)					 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)					int color1 = -1;
HXDLIN(  59)					if ((color1 == -1)) {
HXDLIN(  59)						color1 = _this2->currentColor;
            					}
HXDLIN(  59)					{
HXDLIN(  59)						_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->jx,_this->jy,0);
HXDLIN(  59)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)							_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  59)						_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
            			else {
HXDLIN(  59)				{
HXDLIN(  59)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)					int color = -1;
HXDLIN(  59)					if ((color == -1)) {
HXDLIN(  59)						color = _this1->currentColor;
            					}
HXDLIN(  59)					{
HXDLIN(  59)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,_this->jx,_this->jy,0);
HXDLIN(  59)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  59)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXDLIN(  59)				{
HXDLIN(  59)					 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)					int color1 = -1;
HXDLIN(  59)					if ((color1 == -1)) {
HXDLIN(  59)						color1 = _this2->currentColor;
            					}
HXDLIN(  59)					{
HXDLIN(  59)						_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0);
HXDLIN(  59)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)							_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  59)						_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
            		}
HXDLIN(  59)		_this->jxOld = _this->jx;
HXDLIN(  59)		_this->jyOld = _this->jy;
HXDLIN(  59)		_this->lastClock = clockWise;
HXDLIN(  59)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,fineLine,(void))

void Sketch_obj::fineOverlapLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_62_fineOverlapLine)
HXDLIN(  62)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  62)		Float ax_ = this->x;
HXDLIN(  62)		Float ay_ = this->y;
HXDLIN(  62)		Float width_ = this->width;
HXDLIN(  62)		 ::Dynamic oldAngle;
HXDLIN(  62)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  62)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  62)			oldAngle = null();
            		}
HXDLIN(  62)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  62)		_this->ax = x_;
HXDLIN(  62)		_this->ay = y_;
HXDLIN(  62)		_this->bx = ax_;
HXDLIN(  62)		_this->by = ay_;
HXDLIN(  62)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  62)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  62)		{
HXDLIN(  62)			{
HXDLIN(  62)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  62)				if ((_this->theta > 0)) {
HXDLIN(  62)					if ((_this->halfA < 0)) {
HXDLIN(  62)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  62)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  62)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  62)					if ((_this->halfA > 0)) {
HXDLIN(  62)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  62)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  62)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  62)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  62)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  62)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  62)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  62)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  62)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  62)				_this->exPrev = _this->ex;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  62)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  62)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  62)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  62)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  62)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  62)		_this->ax = ax_;
HXDLIN(  62)		_this->ay = ay_;
HXDLIN(  62)		_this->bx = x_;
HXDLIN(  62)		_this->by = y_;
HXDLIN(  62)		{
HXDLIN(  62)			{
HXDLIN(  62)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  62)				if ((_this->theta > 0)) {
HXDLIN(  62)					if ((_this->halfA < 0)) {
HXDLIN(  62)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  62)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  62)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  62)					if ((_this->halfA > 0)) {
HXDLIN(  62)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  62)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  62)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  62)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  62)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  62)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  62)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  62)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  62)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  62)				_this->exPrev = _this->ex;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  62)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  62)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  62)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  62)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  62)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  62)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  62)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  62)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  62)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  62)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  62)		Float theta0;
HXDLIN(  62)		Float theta1;
HXDLIN(  62)		if (clockWise) {
HXDLIN(  62)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  62)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  62)		Float dif;
HXDLIN(  62)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  62)				Float f;
HXDLIN(  62)				bool f1;
HXDLIN(  62)				if ((theta0 >= 0)) {
HXDLIN(  62)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f1 = false;
            				}
HXDLIN(  62)				if (f1) {
HXDLIN(  62)					f = theta0;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f = a;
            					}
            					else {
HXDLIN(  62)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this1 = f;
HXDLIN(  62)				Float za = this1;
HXDLIN(  62)				Float f2;
HXDLIN(  62)				bool f3;
HXDLIN(  62)				if ((theta1 >= 0)) {
HXDLIN(  62)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f3 = false;
            				}
HXDLIN(  62)				if (f3) {
HXDLIN(  62)					f2 = theta1;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f2 = a;
            					}
            					else {
HXDLIN(  62)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this2 = f2;
HXDLIN(  62)				Float zb = this2;
HXDLIN(  62)				Float fa = za;
HXDLIN(  62)				Float fb = zb;
HXDLIN(  62)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)				bool clockwise = (fa < fb);
HXDLIN(  62)				Float dif1;
HXDLIN(  62)				if (clockwise) {
HXDLIN(  62)					dif1 = theta;
            				}
            				else {
HXDLIN(  62)					dif1 = -(theta);
            				}
HXDLIN(  62)				if ((dif1 > 0)) {
HXDLIN(  62)					dif = dif1;
            				}
            				else {
HXDLIN(  62)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  62)				Float f;
HXDLIN(  62)				bool f1;
HXDLIN(  62)				if ((theta0 >= 0)) {
HXDLIN(  62)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f1 = false;
            				}
HXDLIN(  62)				if (f1) {
HXDLIN(  62)					f = theta0;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f = a;
            					}
            					else {
HXDLIN(  62)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this1 = f;
HXDLIN(  62)				Float za = this1;
HXDLIN(  62)				Float f2;
HXDLIN(  62)				bool f3;
HXDLIN(  62)				if ((theta1 >= 0)) {
HXDLIN(  62)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f3 = false;
            				}
HXDLIN(  62)				if (f3) {
HXDLIN(  62)					f2 = theta1;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f2 = a;
            					}
            					else {
HXDLIN(  62)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this2 = f2;
HXDLIN(  62)				Float zb = this2;
HXDLIN(  62)				Float fa = za;
HXDLIN(  62)				Float fb = zb;
HXDLIN(  62)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)				bool clockwise = (fa < fb);
HXDLIN(  62)				Float dif1;
HXDLIN(  62)				if (clockwise) {
HXDLIN(  62)					dif1 = theta;
            				}
            				else {
HXDLIN(  62)					dif1 = -(theta);
            				}
HXDLIN(  62)				if ((dif1 < 0)) {
HXDLIN(  62)					dif = dif1;
            				}
            				else {
HXDLIN(  62)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  62)				Float f;
HXDLIN(  62)				bool f1;
HXDLIN(  62)				if ((theta0 >= 0)) {
HXDLIN(  62)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f1 = false;
            				}
HXDLIN(  62)				if (f1) {
HXDLIN(  62)					f = theta0;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f = a;
            					}
            					else {
HXDLIN(  62)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this1 = f;
HXDLIN(  62)				Float za = this1;
HXDLIN(  62)				Float f2;
HXDLIN(  62)				bool f3;
HXDLIN(  62)				if ((theta1 >= 0)) {
HXDLIN(  62)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f3 = false;
            				}
HXDLIN(  62)				if (f3) {
HXDLIN(  62)					f2 = theta1;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f2 = a;
            					}
            					else {
HXDLIN(  62)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this2 = f2;
HXDLIN(  62)				Float zb = this2;
HXDLIN(  62)				Float fa = za;
HXDLIN(  62)				Float fb = zb;
HXDLIN(  62)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  62)				bool clockwise = (fa < fb);
HXDLIN(  62)				Float dif1;
HXDLIN(  62)				if (clockwise) {
HXDLIN(  62)					dif1 = theta;
            				}
            				else {
HXDLIN(  62)					dif1 = -(theta);
            				}
HXDLIN(  62)				if (smallest) {
HXDLIN(  62)					dif = dif1;
            				}
            				else {
HXDLIN(  62)					if (clockwise) {
HXDLIN(  62)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  62)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  62)				Float f;
HXDLIN(  62)				bool f1;
HXDLIN(  62)				if ((theta0 >= 0)) {
HXDLIN(  62)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f1 = false;
            				}
HXDLIN(  62)				if (f1) {
HXDLIN(  62)					f = theta0;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f = a;
            					}
            					else {
HXDLIN(  62)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this1 = f;
HXDLIN(  62)				Float za = this1;
HXDLIN(  62)				Float f2;
HXDLIN(  62)				bool f3;
HXDLIN(  62)				if ((theta1 >= 0)) {
HXDLIN(  62)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f3 = false;
            				}
HXDLIN(  62)				if (f3) {
HXDLIN(  62)					f2 = theta1;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f2 = a;
            					}
            					else {
HXDLIN(  62)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this2 = f2;
HXDLIN(  62)				Float zb = this2;
HXDLIN(  62)				Float fa = za;
HXDLIN(  62)				Float fb = zb;
HXDLIN(  62)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  62)				bool clockwise = (fa < fb);
HXDLIN(  62)				Float dif1;
HXDLIN(  62)				if (clockwise) {
HXDLIN(  62)					dif1 = theta;
            				}
            				else {
HXDLIN(  62)					dif1 = -(theta);
            				}
HXDLIN(  62)				if (largest) {
HXDLIN(  62)					dif = dif1;
            				}
            				else {
HXDLIN(  62)					if (clockwise) {
HXDLIN(  62)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  62)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  62)		bool _hx_tmp;
HXDLIN(  62)		if ((_this->count == 0)) {
HXDLIN(  62)			if ((_this->endLine != 1)) {
HXDLIN(  62)				_hx_tmp = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  62)				_hx_tmp = true;
            			}
            		}
            		else {
HXDLIN(  62)			_hx_tmp = false;
            		}
HXDLIN(  62)		if (_hx_tmp) {
HXDLIN(  62)			Float ax = _this->ax;
HXDLIN(  62)			Float ay = _this->ay;
HXDLIN(  62)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  62)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  62)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  62)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  62)			 ::Dynamic sides = 36;
HXDLIN(  62)			if (::hx::IsNull( sides )) {
HXDLIN(  62)				sides = 36;
            			}
HXDLIN(  62)			Float pi = ::Math_obj::PI;
HXDLIN(  62)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  62)			Float dif;
HXDLIN(  62)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  62)					Float f;
HXDLIN(  62)					bool f1;
HXDLIN(  62)					if ((beta >= 0)) {
HXDLIN(  62)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f1 = false;
            					}
HXDLIN(  62)					if (f1) {
HXDLIN(  62)						f = beta;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f = a;
            						}
            						else {
HXDLIN(  62)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this1 = f;
HXDLIN(  62)					Float za = this1;
HXDLIN(  62)					Float f2;
HXDLIN(  62)					bool f3;
HXDLIN(  62)					if ((gamma >= 0)) {
HXDLIN(  62)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f3 = false;
            					}
HXDLIN(  62)					if (f3) {
HXDLIN(  62)						f2 = gamma;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f2 = a;
            						}
            						else {
HXDLIN(  62)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this2 = f2;
HXDLIN(  62)					Float zb = this2;
HXDLIN(  62)					Float fa = za;
HXDLIN(  62)					Float fb = zb;
HXDLIN(  62)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)					bool clockwise = (fa < fb);
HXDLIN(  62)					Float dif1;
HXDLIN(  62)					if (clockwise) {
HXDLIN(  62)						dif1 = theta;
            					}
            					else {
HXDLIN(  62)						dif1 = -(theta);
            					}
HXDLIN(  62)					if ((dif1 > 0)) {
HXDLIN(  62)						dif = dif1;
            					}
            					else {
HXDLIN(  62)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  62)					Float f;
HXDLIN(  62)					bool f1;
HXDLIN(  62)					if ((beta >= 0)) {
HXDLIN(  62)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f1 = false;
            					}
HXDLIN(  62)					if (f1) {
HXDLIN(  62)						f = beta;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f = a;
            						}
            						else {
HXDLIN(  62)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this1 = f;
HXDLIN(  62)					Float za = this1;
HXDLIN(  62)					Float f2;
HXDLIN(  62)					bool f3;
HXDLIN(  62)					if ((gamma >= 0)) {
HXDLIN(  62)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f3 = false;
            					}
HXDLIN(  62)					if (f3) {
HXDLIN(  62)						f2 = gamma;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f2 = a;
            						}
            						else {
HXDLIN(  62)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this2 = f2;
HXDLIN(  62)					Float zb = this2;
HXDLIN(  62)					Float fa = za;
HXDLIN(  62)					Float fb = zb;
HXDLIN(  62)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)					bool clockwise = (fa < fb);
HXDLIN(  62)					Float dif1;
HXDLIN(  62)					if (clockwise) {
HXDLIN(  62)						dif1 = theta;
            					}
            					else {
HXDLIN(  62)						dif1 = -(theta);
            					}
HXDLIN(  62)					if ((dif1 < 0)) {
HXDLIN(  62)						dif = dif1;
            					}
            					else {
HXDLIN(  62)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  62)					Float f;
HXDLIN(  62)					bool f1;
HXDLIN(  62)					if ((beta >= 0)) {
HXDLIN(  62)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f1 = false;
            					}
HXDLIN(  62)					if (f1) {
HXDLIN(  62)						f = beta;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f = a;
            						}
            						else {
HXDLIN(  62)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this1 = f;
HXDLIN(  62)					Float za = this1;
HXDLIN(  62)					Float f2;
HXDLIN(  62)					bool f3;
HXDLIN(  62)					if ((gamma >= 0)) {
HXDLIN(  62)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f3 = false;
            					}
HXDLIN(  62)					if (f3) {
HXDLIN(  62)						f2 = gamma;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f2 = a;
            						}
            						else {
HXDLIN(  62)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this2 = f2;
HXDLIN(  62)					Float zb = this2;
HXDLIN(  62)					Float fa = za;
HXDLIN(  62)					Float fb = zb;
HXDLIN(  62)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  62)					bool clockwise = (fa < fb);
HXDLIN(  62)					Float dif1;
HXDLIN(  62)					if (clockwise) {
HXDLIN(  62)						dif1 = theta;
            					}
            					else {
HXDLIN(  62)						dif1 = -(theta);
            					}
HXDLIN(  62)					if (smallest) {
HXDLIN(  62)						dif = dif1;
            					}
            					else {
HXDLIN(  62)						if (clockwise) {
HXDLIN(  62)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  62)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  62)					Float f;
HXDLIN(  62)					bool f1;
HXDLIN(  62)					if ((beta >= 0)) {
HXDLIN(  62)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f1 = false;
            					}
HXDLIN(  62)					if (f1) {
HXDLIN(  62)						f = beta;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f = a;
            						}
            						else {
HXDLIN(  62)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this1 = f;
HXDLIN(  62)					Float za = this1;
HXDLIN(  62)					Float f2;
HXDLIN(  62)					bool f3;
HXDLIN(  62)					if ((gamma >= 0)) {
HXDLIN(  62)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f3 = false;
            					}
HXDLIN(  62)					if (f3) {
HXDLIN(  62)						f2 = gamma;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f2 = a;
            						}
            						else {
HXDLIN(  62)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this2 = f2;
HXDLIN(  62)					Float zb = this2;
HXDLIN(  62)					Float fa = za;
HXDLIN(  62)					Float fb = zb;
HXDLIN(  62)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  62)					bool clockwise = (fa < fb);
HXDLIN(  62)					Float dif1;
HXDLIN(  62)					if (clockwise) {
HXDLIN(  62)						dif1 = theta;
            					}
            					else {
HXDLIN(  62)						dif1 = -(theta);
            					}
HXDLIN(  62)					if (largest) {
HXDLIN(  62)						dif = dif1;
            					}
            					else {
HXDLIN(  62)						if (clockwise) {
HXDLIN(  62)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  62)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  62)			bool positive = (dif >= 0);
HXDLIN(  62)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  62)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  62)			Float angle = beta;
HXDLIN(  62)			Float cx;
HXDLIN(  62)			Float cy;
HXDLIN(  62)			Float bx = ( (Float)(0) );
HXDLIN(  62)			Float by = ( (Float)(0) );
HXDLIN(  62)			int p2 = temp->length;
HXDLIN(  62)			{
HXDLIN(  62)				int _g = 0;
HXDLIN(  62)				int _g1 = (totalSteps + 1);
HXDLIN(  62)				while((_g < _g1)){
HXDLIN(  62)					_g = (_g + 1);
HXDLIN(  62)					int i = (_g - 1);
HXDLIN(  62)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  62)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  62)					p2 = (p2 + 1);
HXDLIN(  62)					temp[(p2 - 1)] = cx;
HXDLIN(  62)					p2 = (p2 + 1);
HXDLIN(  62)					temp[(p2 - 1)] = cy;
HXDLIN(  62)					if ((i != 0)) {
HXDLIN(  62)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  62)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  62)						if (::hx::IsNotNull( m )) {
HXDLIN(  62)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  62)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  62)					angle = (angle + step1);
HXDLIN(  62)					bx = cx;
HXDLIN(  62)					by = cy;
            				}
            			}
HXDLIN(  62)			int len = totalSteps;
HXDLIN(  62)			{
HXDLIN(  62)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  62)				int color = -1;
HXDLIN(  62)				if ((color == -1)) {
HXDLIN(  62)					color = _this1->currentColor;
            				}
HXDLIN(  62)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  62)			int pA = _this->pointsAnti->length;
HXDLIN(  62)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  62)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  62)			{
HXDLIN(  62)				int _g2 = 0;
HXDLIN(  62)				int _g3 = p4;
HXDLIN(  62)				while((_g2 < _g3)){
HXDLIN(  62)					_g2 = (_g2 + 1);
HXDLIN(  62)					int i = (_g2 - 1);
HXDLIN(  62)					pA = (pA + 1);
HXDLIN(  62)					_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXDLIN(  62)					pA = (pA + 1);
HXDLIN(  62)					_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            				}
            			}
HXDLIN(  62)			int pC = _this->pointsClock->length;
HXDLIN(  62)			{
HXDLIN(  62)				int _g4 = 0;
HXDLIN(  62)				int _g5 = p4;
HXDLIN(  62)				while((_g4 < _g5)){
HXDLIN(  62)					_g4 = (_g4 + 1);
HXDLIN(  62)					int i = (_g4 - 1);
HXDLIN(  62)					pC = (pC + 1);
HXDLIN(  62)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXDLIN(  62)					pC = (pC + 1);
HXDLIN(  62)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            				}
            			}
            		}
HXDLIN(  62)		{
HXDLIN(  62)			{
HXDLIN(  62)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  62)				int color = -1;
HXDLIN(  62)				if ((color == -1)) {
HXDLIN(  62)					color = _this1->currentColor;
            				}
HXDLIN(  62)				{
HXDLIN(  62)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  62)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  62)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  62)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  62)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  62)			{
HXDLIN(  62)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  62)				int color1 = -1;
HXDLIN(  62)				if ((color1 == -1)) {
HXDLIN(  62)					color1 = _this2->currentColor;
            				}
HXDLIN(  62)				{
HXDLIN(  62)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  62)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  62)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  62)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  62)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
HXDLIN(  62)		if (clockWise) {
HXDLIN(  62)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  62)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  62)			::Array< Float > edgePoly = _this->pointsClock;
HXDLIN(  62)			Float pi = ::Math_obj::PI;
HXDLIN(  62)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  62)			bool positive = (dif >= 0);
HXDLIN(  62)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  62)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  62)			Float angle = theta0;
HXDLIN(  62)			Float cx;
HXDLIN(  62)			Float cy;
HXDLIN(  62)			Float bx = ( (Float)(0) );
HXDLIN(  62)			Float by = ( (Float)(0) );
HXDLIN(  62)			int p2 = edgePoly->length;
HXDLIN(  62)			{
HXDLIN(  62)				int _g = 0;
HXDLIN(  62)				int _g1 = (totalSteps + 1);
HXDLIN(  62)				while((_g < _g1)){
HXDLIN(  62)					_g = (_g + 1);
HXDLIN(  62)					int i = (_g - 1);
HXDLIN(  62)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  62)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  62)					p2 = (p2 + 1);
HXDLIN(  62)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  62)					p2 = (p2 + 1);
HXDLIN(  62)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  62)					if ((i != 0)) {
HXDLIN(  62)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  62)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  62)						if (::hx::IsNotNull( m )) {
HXDLIN(  62)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  62)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  62)					angle = (angle + step1);
HXDLIN(  62)					bx = cx;
HXDLIN(  62)					by = cy;
            				}
            			}
HXDLIN(  62)			int len = totalSteps;
HXDLIN(  62)			{
HXDLIN(  62)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  62)				int color = -1;
HXDLIN(  62)				if ((color == -1)) {
HXDLIN(  62)					color = _this1->currentColor;
            				}
HXDLIN(  62)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
            		else {
HXDLIN(  62)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  62)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  62)			::Array< Float > edgePoly = _this->pointsAnti;
HXDLIN(  62)			Float pi = ::Math_obj::PI;
HXDLIN(  62)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  62)			bool positive = (dif >= 0);
HXDLIN(  62)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  62)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  62)			Float angle = theta0;
HXDLIN(  62)			Float cx;
HXDLIN(  62)			Float cy;
HXDLIN(  62)			Float bx = ( (Float)(0) );
HXDLIN(  62)			Float by = ( (Float)(0) );
HXDLIN(  62)			int p2 = edgePoly->length;
HXDLIN(  62)			{
HXDLIN(  62)				int _g = 0;
HXDLIN(  62)				int _g1 = (totalSteps + 1);
HXDLIN(  62)				while((_g < _g1)){
HXDLIN(  62)					_g = (_g + 1);
HXDLIN(  62)					int i = (_g - 1);
HXDLIN(  62)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  62)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  62)					p2 = (p2 + 1);
HXDLIN(  62)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  62)					p2 = (p2 + 1);
HXDLIN(  62)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  62)					if ((i != 0)) {
HXDLIN(  62)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  62)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  62)						if (::hx::IsNotNull( m )) {
HXDLIN(  62)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  62)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  62)					angle = (angle + step1);
HXDLIN(  62)					bx = cx;
HXDLIN(  62)					by = cy;
            				}
            			}
HXDLIN(  62)			int len = totalSteps;
HXDLIN(  62)			{
HXDLIN(  62)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  62)				int color = -1;
HXDLIN(  62)				if ((color == -1)) {
HXDLIN(  62)					color = _this1->currentColor;
            				}
HXDLIN(  62)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  62)		{
HXDLIN(  62)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  62)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  62)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  62)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  62)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  62)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  62)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  62)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  62)		_this->jxOld = _this->jx;
HXDLIN(  62)		_this->jyOld = _this->jy;
HXDLIN(  62)		_this->lastClock = clockWise;
HXDLIN(  62)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,fineOverlapLine,(void))

void Sketch_obj::moveTo(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_231_moveTo)
HXLINE( 232)		bool _hx_tmp;
HXDLIN( 232)		if ((this->endLine != 2)) {
HXLINE( 232)			_hx_tmp = (this->endLine == 3);
            		}
            		else {
HXLINE( 232)			_hx_tmp = true;
            		}
HXDLIN( 232)		if (_hx_tmp) {
HXLINE( 232)			 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN( 232)			Float width_ = this->width;
HXDLIN( 232)			_this->endEdges();
HXDLIN( 232)			if ((_this->count != 0)) {
HXLINE( 232)				Float ax = _this->bx;
HXDLIN( 232)				Float ay = _this->by;
HXDLIN( 232)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 232)				Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 232)				Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 232)				::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN( 232)				 ::Dynamic drawType = _this->pen->drawType;
HXDLIN( 232)				 ::Dynamic sides = 36;
HXDLIN( 232)				if (::hx::IsNull( sides )) {
HXLINE( 232)					sides = 36;
            				}
HXDLIN( 232)				Float pi = ::Math_obj::PI;
HXDLIN( 232)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 232)				Float dif;
HXDLIN( 232)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXLINE( 232)						Float f;
HXDLIN( 232)						bool f1;
HXDLIN( 232)						if ((beta >= 0)) {
HXLINE( 232)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f1 = false;
            						}
HXDLIN( 232)						if (f1) {
HXLINE( 232)							f = beta;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f = a;
            							}
            							else {
HXLINE( 232)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this1 = f;
HXDLIN( 232)						Float za = this1;
HXDLIN( 232)						Float f2;
HXDLIN( 232)						bool f3;
HXDLIN( 232)						if ((gamma >= 0)) {
HXLINE( 232)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f3 = false;
            						}
HXDLIN( 232)						if (f3) {
HXLINE( 232)							f2 = gamma;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f2 = a;
            							}
            							else {
HXLINE( 232)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this2 = f2;
HXDLIN( 232)						Float zb = this2;
HXDLIN( 232)						Float fa = za;
HXDLIN( 232)						Float fb = zb;
HXDLIN( 232)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 232)						bool clockwise = (fa < fb);
HXDLIN( 232)						Float dif1;
HXDLIN( 232)						if (clockwise) {
HXLINE( 232)							dif1 = theta;
            						}
            						else {
HXLINE( 232)							dif1 = -(theta);
            						}
HXDLIN( 232)						if ((dif1 > 0)) {
HXLINE( 232)							dif = dif1;
            						}
            						else {
HXLINE( 232)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXLINE( 232)						Float f;
HXDLIN( 232)						bool f1;
HXDLIN( 232)						if ((beta >= 0)) {
HXLINE( 232)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f1 = false;
            						}
HXDLIN( 232)						if (f1) {
HXLINE( 232)							f = beta;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f = a;
            							}
            							else {
HXLINE( 232)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this1 = f;
HXDLIN( 232)						Float za = this1;
HXDLIN( 232)						Float f2;
HXDLIN( 232)						bool f3;
HXDLIN( 232)						if ((gamma >= 0)) {
HXLINE( 232)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f3 = false;
            						}
HXDLIN( 232)						if (f3) {
HXLINE( 232)							f2 = gamma;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f2 = a;
            							}
            							else {
HXLINE( 232)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this2 = f2;
HXDLIN( 232)						Float zb = this2;
HXDLIN( 232)						Float fa = za;
HXDLIN( 232)						Float fb = zb;
HXDLIN( 232)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 232)						bool clockwise = (fa < fb);
HXDLIN( 232)						Float dif1;
HXDLIN( 232)						if (clockwise) {
HXLINE( 232)							dif1 = theta;
            						}
            						else {
HXLINE( 232)							dif1 = -(theta);
            						}
HXDLIN( 232)						if ((dif1 < 0)) {
HXLINE( 232)							dif = dif1;
            						}
            						else {
HXLINE( 232)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXLINE( 232)						Float f;
HXDLIN( 232)						bool f1;
HXDLIN( 232)						if ((beta >= 0)) {
HXLINE( 232)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f1 = false;
            						}
HXDLIN( 232)						if (f1) {
HXLINE( 232)							f = beta;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f = a;
            							}
            							else {
HXLINE( 232)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this1 = f;
HXDLIN( 232)						Float za = this1;
HXDLIN( 232)						Float f2;
HXDLIN( 232)						bool f3;
HXDLIN( 232)						if ((gamma >= 0)) {
HXLINE( 232)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f3 = false;
            						}
HXDLIN( 232)						if (f3) {
HXLINE( 232)							f2 = gamma;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f2 = a;
            							}
            							else {
HXLINE( 232)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this2 = f2;
HXDLIN( 232)						Float zb = this2;
HXDLIN( 232)						Float fa = za;
HXDLIN( 232)						Float fb = zb;
HXDLIN( 232)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 232)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 232)						bool clockwise = (fa < fb);
HXDLIN( 232)						Float dif1;
HXDLIN( 232)						if (clockwise) {
HXLINE( 232)							dif1 = theta;
            						}
            						else {
HXLINE( 232)							dif1 = -(theta);
            						}
HXDLIN( 232)						if (smallest) {
HXLINE( 232)							dif = dif1;
            						}
            						else {
HXLINE( 232)							if (clockwise) {
HXLINE( 232)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 232)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXLINE( 232)						Float f;
HXDLIN( 232)						bool f1;
HXDLIN( 232)						if ((beta >= 0)) {
HXLINE( 232)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f1 = false;
            						}
HXDLIN( 232)						if (f1) {
HXLINE( 232)							f = beta;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f = a;
            							}
            							else {
HXLINE( 232)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this1 = f;
HXDLIN( 232)						Float za = this1;
HXDLIN( 232)						Float f2;
HXDLIN( 232)						bool f3;
HXDLIN( 232)						if ((gamma >= 0)) {
HXLINE( 232)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f3 = false;
            						}
HXDLIN( 232)						if (f3) {
HXLINE( 232)							f2 = gamma;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f2 = a;
            							}
            							else {
HXLINE( 232)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this2 = f2;
HXDLIN( 232)						Float zb = this2;
HXDLIN( 232)						Float fa = za;
HXDLIN( 232)						Float fb = zb;
HXDLIN( 232)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 232)						bool largest = (theta > ::Math_obj::PI);
HXDLIN( 232)						bool clockwise = (fa < fb);
HXDLIN( 232)						Float dif1;
HXDLIN( 232)						if (clockwise) {
HXLINE( 232)							dif1 = theta;
            						}
            						else {
HXLINE( 232)							dif1 = -(theta);
            						}
HXDLIN( 232)						if (largest) {
HXLINE( 232)							dif = dif1;
            						}
            						else {
HXLINE( 232)							if (clockwise) {
HXLINE( 232)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 232)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN( 232)				bool positive = (dif >= 0);
HXDLIN( 232)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 232)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 232)				Float angle = beta;
HXDLIN( 232)				Float cx;
HXDLIN( 232)				Float cy;
HXDLIN( 232)				Float bx = ( (Float)(0) );
HXDLIN( 232)				Float by = ( (Float)(0) );
HXDLIN( 232)				int p2 = temp->length;
HXDLIN( 232)				{
HXLINE( 232)					int _g = 0;
HXDLIN( 232)					int _g1 = (totalSteps + 1);
HXDLIN( 232)					while((_g < _g1)){
HXLINE( 232)						_g = (_g + 1);
HXDLIN( 232)						int i = (_g - 1);
HXDLIN( 232)						cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 232)						cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 232)						p2 = (p2 + 1);
HXDLIN( 232)						temp[(p2 - 1)] = cx;
HXDLIN( 232)						p2 = (p2 + 1);
HXDLIN( 232)						temp[(p2 - 1)] = cy;
HXDLIN( 232)						if ((i != 0)) {
HXLINE( 232)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 232)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 232)							if (::hx::IsNotNull( m )) {
HXLINE( 232)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN( 232)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 232)						angle = (angle + step1);
HXDLIN( 232)						bx = cx;
HXDLIN( 232)						by = cy;
            					}
            				}
HXDLIN( 232)				int len = totalSteps;
HXDLIN( 232)				{
HXLINE( 232)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN( 232)					int color = 0;
HXDLIN( 232)					if ((color == -1)) {
HXLINE( 232)						color = _this1->currentColor;
            					}
HXDLIN( 232)					_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            				}
HXDLIN( 232)				int pA = _this->pointsAnti->length;
HXDLIN( 232)				int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN( 232)				{
HXLINE( 232)					int _g2 = 0;
HXDLIN( 232)					int _g3 = (len1 + 2);
HXDLIN( 232)					while((_g2 < _g3)){
HXLINE( 232)						_g2 = (_g2 + 1);
HXDLIN( 232)						int i = (_g2 - 1);
HXDLIN( 232)						pA = (pA + 1);
HXDLIN( 232)						_this->pointsAnti[(pA - 1)] = temp->__get(i);
            					}
            				}
HXDLIN( 232)				int pC = _this->pointsClock->length;
HXDLIN( 232)				{
HXLINE( 232)					int _g4 = 1;
HXDLIN( 232)					int _g5 = ::Std_obj::_hx_int(((( (Float)(len1) ) / ( (Float)(2) )) + 1));
HXDLIN( 232)					while((_g4 < _g5)){
HXLINE( 232)						_g4 = (_g4 + 1);
HXDLIN( 232)						int i = (_g4 - 1);
HXDLIN( 232)						pC = (pC + 1);
HXDLIN( 232)						_this->pointsClock[(pC - 1)] = temp->__get((temp->length - (2 * i)));
HXDLIN( 232)						pC = (pC + 1);
HXDLIN( 232)						_this->pointsClock[(pC - 1)] = temp->__get(((temp->length - (2 * i)) - 1));
            					}
            				}
            			}
            		}
HXLINE( 233)		this->x = x_;
HXLINE( 234)		this->y = y_;
HXLINE( 235)		int l = this->points->length;
HXLINE( 236)		this->points[l] = ::Array_obj< Float >::__new();
HXLINE( 237)		this->points->__get(l).StaticCast< ::Array< Float > >()[0] = x_;
HXLINE( 238)		this->points->__get(l).StaticCast< ::Array< Float > >()[1] = y_;
HXLINE( 241)		this->pointsClock[this->pointsClock->length] = this->contour->pointsClock->copy();
HXLINE( 242)		this->pointsAnti[this->pointsAnti->length] = this->contour->pointsAnti->copy();
HXLINE( 244)		this->dim[this->dim->length] =  ::Dynamic(::hx::Anon_obj::Create(4)
            			->setFixed(0,HX_("maxX",34,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(1,HX_("maxY",35,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(2,HX_("minX",86,4e,5c,48),::Math_obj::POSITIVE_INFINITY)
            			->setFixed(3,HX_("minY",87,4e,5c,48),::Math_obj::POSITIVE_INFINITY));
HXLINE( 245)		{
HXLINE( 245)			 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 245)			if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 245)				d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            			}
HXDLIN( 245)			if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 245)				d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            			}
HXDLIN( 245)			if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 245)				d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            			}
HXDLIN( 245)			if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 245)				d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            			}
            		}
HXLINE( 246)		this->contour->reset();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,moveTo,(void))


::hx::ObjectPtr< Sketch_obj > Sketch_obj::__new( ::trilateral3::drawing::Pen pen_,int sketchForm_,::hx::Null< int >  __o_endLine_) {
	::hx::ObjectPtr< Sketch_obj > __this = new Sketch_obj();
	__this->__construct(pen_,sketchForm_,__o_endLine_);
	return __this;
}

::hx::ObjectPtr< Sketch_obj > Sketch_obj::__alloc(::hx::Ctx *_hx_ctx, ::trilateral3::drawing::Pen pen_,int sketchForm_,::hx::Null< int >  __o_endLine_) {
	Sketch_obj *__this = (Sketch_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Sketch_obj), true, "trilateral3.drawing.Sketch"));
	*(void **)__this = Sketch_obj::_hx_vtable;
	__this->__construct(pen_,sketchForm_,__o_endLine_);
	return __this;
}

Sketch_obj::Sketch_obj()
{
}

void Sketch_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Sketch);
	HX_MARK_MEMBER_NAME(x,"x");
	HX_MARK_MEMBER_NAME(y,"y");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(widthFunction,"widthFunction");
	HX_MARK_MEMBER_NAME(colourFunction,"colourFunction");
	HX_MARK_MEMBER_NAME(contour,"contour");
	HX_MARK_MEMBER_NAME(pen,"pen");
	HX_MARK_MEMBER_NAME(endLine,"endLine");
	HX_MARK_MEMBER_NAME(sketchForm,"sketchForm");
	HX_MARK_MEMBER_NAME(points,"points");
	HX_MARK_MEMBER_NAME(pointsClock,"pointsClock");
	HX_MARK_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_MARK_MEMBER_NAME(dim,"dim");
	HX_MARK_MEMBER_NAME(line,"line");
	HX_MARK_END_CLASS();
}

void Sketch_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(x,"x");
	HX_VISIT_MEMBER_NAME(y,"y");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(widthFunction,"widthFunction");
	HX_VISIT_MEMBER_NAME(colourFunction,"colourFunction");
	HX_VISIT_MEMBER_NAME(contour,"contour");
	HX_VISIT_MEMBER_NAME(pen,"pen");
	HX_VISIT_MEMBER_NAME(endLine,"endLine");
	HX_VISIT_MEMBER_NAME(sketchForm,"sketchForm");
	HX_VISIT_MEMBER_NAME(points,"points");
	HX_VISIT_MEMBER_NAME(pointsClock,"pointsClock");
	HX_VISIT_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_VISIT_MEMBER_NAME(dim,"dim");
	HX_VISIT_MEMBER_NAME(line,"line");
}

::hx::Val Sketch_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return ::hx::Val( x ); }
		if (HX_FIELD_EQ(inName,"y") ) { return ::hx::Val( y ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { return ::hx::Val( pen ); }
		if (HX_FIELD_EQ(inName,"dim") ) { return ::hx::Val( dim ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"line") ) { return ::hx::Val( line ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { return ::hx::Val( points ); }
		if (HX_FIELD_EQ(inName,"moveTo") ) { return ::hx::Val( moveTo_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"contour") ) { return ::hx::Val( contour ); }
		if (HX_FIELD_EQ(inName,"endLine") ) { return ::hx::Val( endLine ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"baseLine") ) { return ::hx::Val( baseLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"fineLine") ) { return ::hx::Val( fineLine_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"crudeLine") ) { return ::hx::Val( crudeLine_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sketchForm") ) { return ::hx::Val( sketchForm ); }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { return ::hx::Val( pointsAnti ); }
		if (HX_FIELD_EQ(inName,"tracerLine") ) { return ::hx::Val( tracerLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"mediumLine") ) { return ::hx::Val( mediumLine_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { return ::hx::Val( pointsClock ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"fillOnlyLine") ) { return ::hx::Val( fillOnlyLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"roundEndLine") ) { return ::hx::Val( roundEndLine_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"widthFunction") ) { return ::hx::Val( widthFunction ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colourFunction") ) { return ::hx::Val( colourFunction ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"fineOverlapLine") ) { return ::hx::Val( fineOverlapLine_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"mediumOverlapLine") ) { return ::hx::Val( mediumOverlapLine_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Sketch_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { y=inValue.Cast< Float >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { pen=inValue.Cast<  ::trilateral3::drawing::Pen >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dim") ) { dim=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"line") ) { line=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { points=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"contour") ) { contour=inValue.Cast<  ::trilateral3::drawing::Contour >(); return inValue; }
		if (HX_FIELD_EQ(inName,"endLine") ) { endLine=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sketchForm") ) { sketchForm=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { pointsAnti=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { pointsClock=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"widthFunction") ) { widthFunction=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colourFunction") ) { colourFunction=inValue.Cast<  ::Dynamic >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Sketch_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x",78,00,00,00));
	outFields->push(HX_("y",79,00,00,00));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("contour",da,29,7f,19));
	outFields->push(HX_("pen",d9,54,55,00));
	outFields->push(HX_("endLine",6f,d1,d7,29));
	outFields->push(HX_("sketchForm",d0,2c,96,9a));
	outFields->push(HX_("points",23,12,2e,f7));
	outFields->push(HX_("pointsClock",ab,c8,9e,88));
	outFields->push(HX_("pointsAnti",65,1b,f0,ae));
	outFields->push(HX_("dim",48,3d,4c,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Sketch_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(Sketch_obj,x),HX_("x",78,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Sketch_obj,y),HX_("y",79,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Sketch_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketch_obj,widthFunction),HX_("widthFunction",3e,93,b5,7c)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketch_obj,colourFunction),HX_("colourFunction",84,5b,3e,e4)},
	{::hx::fsObject /*  ::trilateral3::drawing::Contour */ ,(int)offsetof(Sketch_obj,contour),HX_("contour",da,29,7f,19)},
	{::hx::fsObject /*  ::trilateral3::drawing::Pen */ ,(int)offsetof(Sketch_obj,pen),HX_("pen",d9,54,55,00)},
	{::hx::fsInt,(int)offsetof(Sketch_obj,endLine),HX_("endLine",6f,d1,d7,29)},
	{::hx::fsInt,(int)offsetof(Sketch_obj,sketchForm),HX_("sketchForm",d0,2c,96,9a)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,points),HX_("points",23,12,2e,f7)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,pointsClock),HX_("pointsClock",ab,c8,9e,88)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,pointsAnti),HX_("pointsAnti",65,1b,f0,ae)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,dim),HX_("dim",48,3d,4c,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketch_obj,line),HX_("line",f4,17,b3,47)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Sketch_obj_sStaticStorageInfo = 0;
#endif

static ::String Sketch_obj_sMemberFields[] = {
	HX_("x",78,00,00,00),
	HX_("y",79,00,00,00),
	HX_("width",06,b6,62,ca),
	HX_("widthFunction",3e,93,b5,7c),
	HX_("colourFunction",84,5b,3e,e4),
	HX_("contour",da,29,7f,19),
	HX_("pen",d9,54,55,00),
	HX_("endLine",6f,d1,d7,29),
	HX_("sketchForm",d0,2c,96,9a),
	HX_("points",23,12,2e,f7),
	HX_("pointsClock",ab,c8,9e,88),
	HX_("pointsAnti",65,1b,f0,ae),
	HX_("dim",48,3d,4c,00),
	HX_("tracerLine",e1,14,6f,0a),
	HX_("fillOnlyLine",23,35,20,bc),
	HX_("baseLine",a5,08,01,fc),
	HX_("crudeLine",7b,a3,d6,62),
	HX_("roundEndLine",c1,c6,50,fc),
	HX_("mediumLine",09,77,f0,3b),
	HX_("mediumOverlapLine",a6,34,72,5e),
	HX_("fineLine",4e,b9,ad,2d),
	HX_("fineOverlapLine",01,f5,59,3a),
	HX_("line",f4,17,b3,47),
	HX_("moveTo",ec,d2,ac,cc),
	::String(null()) };

::hx::Class Sketch_obj::__mClass;

void Sketch_obj::__register()
{
	Sketch_obj _hx_dummy;
	Sketch_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("trilateral3.drawing.Sketch",23,f7,00,b3);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Sketch_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Sketch_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Sketch_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Sketch_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace trilateral3
} // end namespace drawing
