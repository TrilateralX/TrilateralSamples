// Generated by Haxe 4.2.0-rc.1+cb30bd580
#include <hxcpp.h>

#ifndef INCLUDED_66c800784bc86d2f
#define INCLUDED_66c800784bc86d2f
#include "linc_glfw.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_glfw_GLFWWindowSizeHandler
#include <glfw/GLFWWindowSizeHandler.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif

namespace glfw{

void GLFWWindowSizeHandler_obj::__construct() { }

Dynamic GLFWWindowSizeHandler_obj::__CreateEmpty() { return new GLFWWindowSizeHandler_obj; }

void *GLFWWindowSizeHandler_obj::_hx_vtable = 0;

Dynamic GLFWWindowSizeHandler_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< GLFWWindowSizeHandler_obj > _hx_result = new GLFWWindowSizeHandler_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool GLFWWindowSizeHandler_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x060cac25;
}

 ::haxe::ds::StringMap GLFWWindowSizeHandler_obj::listeners;

void GLFWWindowSizeHandler_obj::nativeCallack( GLFWwindow * win,int width,int height){
	::Dynamic this1 = ::glfw::GLFWWindowSizeHandler_obj::listeners;
	 ::Dynamic cb = ( ( ::haxe::ds::StringMap)(this1) )->get((HX_("win",1c,a8,5a,00) + ::Std_obj::string(( ( ::Dynamic)(( (::cpp::Pointer<  GLFWwindow >)(win) )) ))));
	if (::hx::IsNotNull( cb )) {
		::cpp::Pointer<  GLFWwindow > tmp = ( (::cpp::Pointer<  GLFWwindow >)(win) );
		cb(tmp,width,height);
	}
}


static ::Dynamic _hx_wrapGLFWWindowSizeHandler_obj_nativeCallack(  const Dynamic &a0,const Dynamic &a1,const Dynamic &a2) {
	GLFWWindowSizeHandler_obj::nativeCallack((cpp::Pointer< GLFWwindow >) a0,a1,a2);
	return null();
}
::Dynamic GLFWWindowSizeHandler_obj::nativeCallack_dyn() {
	return ::hx::CreateStaticFunction3("nativeCallack",_hx_wrapGLFWWindowSizeHandler_obj_nativeCallack);}
void GLFWWindowSizeHandler_obj::setCallback( GLFWwindow * win, ::Dynamic cb){
	::Dynamic this1 = ::glfw::GLFWWindowSizeHandler_obj::listeners;
	( ( ::haxe::ds::StringMap)(this1) )->set((HX_("win",1c,a8,5a,00) + ::Std_obj::string(( ( ::Dynamic)(( (::cpp::Pointer<  GLFWwindow >)(win) )) ))),cb);
}


static ::Dynamic _hx_wrapGLFWWindowSizeHandler_obj_setCallback(  const Dynamic &a0,const Dynamic &a1) {
	GLFWWindowSizeHandler_obj::setCallback((cpp::Pointer< GLFWwindow >) a0,a1);
	return null();
}
::Dynamic GLFWWindowSizeHandler_obj::setCallback_dyn() {
	return ::hx::CreateStaticFunction2("setCallback",_hx_wrapGLFWWindowSizeHandler_obj_setCallback);}

GLFWWindowSizeHandler_obj::GLFWWindowSizeHandler_obj()
{
}

bool GLFWWindowSizeHandler_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"listeners") ) { outValue = ( listeners ); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"setCallback") ) { outValue = setCallback_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"nativeCallack") ) { outValue = nativeCallack_dyn(); return true; }
	}
	return false;
}

bool GLFWWindowSizeHandler_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"listeners") ) { listeners=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *GLFWWindowSizeHandler_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo GLFWWindowSizeHandler_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &GLFWWindowSizeHandler_obj::listeners,HX_("listeners",7f,65,8e,f3)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void GLFWWindowSizeHandler_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(GLFWWindowSizeHandler_obj::listeners,"listeners");
};

#ifdef HXCPP_VISIT_ALLOCS
static void GLFWWindowSizeHandler_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(GLFWWindowSizeHandler_obj::listeners,"listeners");
};

#endif

::hx::Class GLFWWindowSizeHandler_obj::__mClass;

static ::String GLFWWindowSizeHandler_obj_sStaticFields[] = {
	HX_("listeners",7f,65,8e,f3),
	HX_("nativeCallack",94,5e,6f,13),
	HX_("setCallback",87,63,67,af),
	::String(null())
};

void GLFWWindowSizeHandler_obj::__register()
{
	GLFWWindowSizeHandler_obj _hx_dummy;
	GLFWWindowSizeHandler_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("glfw.GLFWWindowSizeHandler",ab,8b,50,08);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &GLFWWindowSizeHandler_obj::__GetStatic;
	__mClass->mSetStaticField = &GLFWWindowSizeHandler_obj::__SetStatic;
	__mClass->mMarkFunc = GLFWWindowSizeHandler_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(GLFWWindowSizeHandler_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< GLFWWindowSizeHandler_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = GLFWWindowSizeHandler_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GLFWWindowSizeHandler_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GLFWWindowSizeHandler_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void GLFWWindowSizeHandler_obj::__boot()
{
{
	HX_JUST_GC_STACKFRAME
	listeners =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
}
}

} // end namespace glfw
