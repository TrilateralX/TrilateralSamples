// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_fracs_DifferencePreference
#include <fracs/DifferencePreference.h>
#endif
#ifndef INCLUDED_trilateral3_Trilateral
#include <trilateral3/Trilateral.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Contour
#include <trilateral3/drawing/Contour.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Pen
#include <trilateral3/drawing/Pen.h>
#endif
#ifndef INCLUDED_trilateral3_matrix_MatrixDozen
#include <trilateral3/matrix/MatrixDozen.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_15_new,"trilateral3.drawing.Contour","new",0xd76c2ab5,"trilateral3.drawing.Contour.new","trilateral3/drawing/Contour.hx",15,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_97_reset,"trilateral3.drawing.Contour","reset",0xf86ba364,"trilateral3.drawing.Contour.reset","trilateral3/drawing/Contour.hx",97,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_140_computeDE,"trilateral3.drawing.Contour","computeDE",0x1b2ad6cd,"trilateral3.drawing.Contour.computeDE","trilateral3/drawing/Contour.hx",140,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_156_anglesCompute,"trilateral3.drawing.Contour","anglesCompute",0x836ff8ac,"trilateral3.drawing.Contour.anglesCompute","trilateral3/drawing/Contour.hx",156,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_178_thetaComputeAdj,"trilateral3.drawing.Contour","thetaComputeAdj",0xd7be4683,"trilateral3.drawing.Contour.thetaComputeAdj","trilateral3/drawing/Contour.hx",178,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_194_triangleJoin,"trilateral3.drawing.Contour","triangleJoin",0x5ca555dd,"trilateral3.drawing.Contour.triangleJoin","trilateral3/drawing/Contour.hx",194,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_299_overlapQuad,"trilateral3.drawing.Contour","overlapQuad",0xd313af43,"trilateral3.drawing.Contour.overlapQuad","trilateral3/drawing/Contour.hx",299,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_307_end,"trilateral3.drawing.Contour","end",0xd7655e30,"trilateral3.drawing.Contour.end","trilateral3/drawing/Contour.hx",307,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_314_triangle2DFill,"trilateral3.drawing.Contour","triangle2DFill",0x5f1ac808,"trilateral3.drawing.Contour.triangle2DFill","trilateral3/drawing/Contour.hx",314,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_317_addPieXstart,"trilateral3.drawing.Contour","addPieXstart",0x66d42300,"trilateral3.drawing.Contour.addPieXstart","trilateral3/drawing/Contour.hx",317,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_337_addPieX,"trilateral3.drawing.Contour","addPieX",0xcaf1d622,"trilateral3.drawing.Contour.addPieX","trilateral3/drawing/Contour.hx",337,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_357_addPie,"trilateral3.drawing.Contour","addPie",0xfc517176,"trilateral3.drawing.Contour.addPie","trilateral3/drawing/Contour.hx",357,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_363_computeJ,"trilateral3.drawing.Contour","computeJ",0x127d527e,"trilateral3.drawing.Contour.computeJ","trilateral3/drawing/Contour.hx",363,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_373_addDot,"trilateral3.drawing.Contour","addDot",0xfc485bb3,"trilateral3.drawing.Contour.addDot","trilateral3/drawing/Contour.hx",373,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_400_addSmallTriangles,"trilateral3.drawing.Contour","addSmallTriangles",0xf74ed1fa,"trilateral3.drawing.Contour.addSmallTriangles","trilateral3/drawing/Contour.hx",400,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_411_triangle2DFillangleCorners,"trilateral3.drawing.Contour","triangle2DFillangleCorners",0x9466a373,"trilateral3.drawing.Contour.triangle2DFillangleCorners","trilateral3/drawing/Contour.hx",411,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_423_triangle2DFillangleCornersLess,"trilateral3.drawing.Contour","triangle2DFillangleCornersLess",0x7992186c,"trilateral3.drawing.Contour.triangle2DFillangleCornersLess","trilateral3/drawing/Contour.hx",423,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_435_connectQuadsWhenQuadsOverlay,"trilateral3.drawing.Contour","connectQuadsWhenQuadsOverlay",0x2d809bab,"trilateral3.drawing.Contour.connectQuadsWhenQuadsOverlay","trilateral3/drawing/Contour.hx",435,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_450_connectQuads,"trilateral3.drawing.Contour","connectQuads",0x16276c8d,"trilateral3.drawing.Contour.connectQuads","trilateral3/drawing/Contour.hx",450,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_465_addInitialQuads,"trilateral3.drawing.Contour","addInitialQuads",0x9867e83e,"trilateral3.drawing.Contour.addInitialQuads","trilateral3/drawing/Contour.hx",465,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_548_endEdges,"trilateral3.drawing.Contour","endEdges",0xf4951146,"trilateral3.drawing.Contour.endEdges","trilateral3/drawing/Contour.hx",548,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_574_addQuads,"trilateral3.drawing.Contour","addQuads",0x63fbad76,"trilateral3.drawing.Contour.addQuads","trilateral3/drawing/Contour.hx",574,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_740_storeLastQuads,"trilateral3.drawing.Contour","storeLastQuads",0x0eebb740,"trilateral3.drawing.Contour.storeLastQuads","trilateral3/drawing/Contour.hx",740,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_751_isClockwise,"trilateral3.drawing.Contour","isClockwise",0xb34a6bfd,"trilateral3.drawing.Contour.isClockwise","trilateral3/drawing/Contour.hx",751,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_754_line,"trilateral3.drawing.Contour","line",0xa5e9c7ff,"trilateral3.drawing.Contour.line","trilateral3/drawing/Contour.hx",754,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_182_thetaCompute,"trilateral3.drawing.Contour","thetaCompute",0x218afe04,"trilateral3.drawing.Contour.thetaCompute","trilateral3/drawing/Contour.hx",182,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_185_dist,"trilateral3.drawing.Contour","dist",0xa0a01771,"trilateral3.drawing.Contour.dist","trilateral3/drawing/Contour.hx",185,0xb719e1dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1447c0490ddb3cc5_95_boot,"trilateral3.drawing.Contour","boot",0x9f52343d,"trilateral3.drawing.Contour.boot","trilateral3/drawing/Contour.hx",95,0xb719e1dd)
namespace trilateral3{
namespace drawing{

void Contour_obj::__construct( ::trilateral3::drawing::Pen pen_,::hx::Null< int >  __o_endLine_){
            		int endLine_ = __o_endLine_.Default(0);
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_15_new)
HXLINE( 571)		this->counter = 0;
HXLINE( 133)		this->count = 0;
HXLINE(  32)		this->pointsAnti = ::Array_obj< Float >::__new(0);
HXLINE(  31)		this->pointsClock = ::Array_obj< Float >::__new(0);
HXLINE(  30)		this->debugCol12 = -893376;
HXLINE(  29)		this->debugCol11 = -3986796;
HXLINE(  28)		this->debugCol10 = -9230154;
HXLINE(  27)		this->debugCol9 = -13354819;
HXLINE(  26)		this->debugCol8 = -12617788;
HXLINE(  25)		this->debugCol7 = -11686193;
HXLINE(  24)		this->debugCol6 = -11288539;
HXLINE(  23)		this->debugCol5 = -5778134;
HXLINE(  22)		this->debugCol4 = -211;
HXLINE(  21)		this->debugCol3 = -338891;
HXLINE(  20)		this->debugCol2 = -742865;
HXLINE(  19)		this->debugCol1 = -884166;
HXLINE(  18)		this->debugCol0 = -1098686;
HXLINE( 135)		this->pen = pen_;
HXLINE( 136)		this->endLine = endLine_;
            	}

Dynamic Contour_obj::__CreateEmpty() { return new Contour_obj; }

void *Contour_obj::_hx_vtable = 0;

Dynamic Contour_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Contour_obj > _hx_result = new Contour_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Contour_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x2f69a3a3;
}

void Contour_obj::reset(){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_97_reset)
HXLINE(  98)		this->angleA = ( (Float)(0) );
HXLINE(  99)		this->count = 0;
HXLINE( 100)		this->kax = ( (Float)(0) );
HXLINE( 101)		this->kay = ( (Float)(0) );
HXLINE( 102)		this->kbx = ( (Float)(0) );
HXLINE( 103)		this->kby = ( (Float)(0) );
HXLINE( 104)		this->kcx = ( (Float)(0) );
HXLINE( 105)		this->kcy = ( (Float)(0) );
HXLINE( 106)		this->ncx = ( (Float)(0) );
HXLINE( 107)		this->ncy = ( (Float)(0) );
HXLINE( 108)		this->ax = ( (Float)(0) );
HXLINE( 109)		this->ay = ( (Float)(0) );
HXLINE( 110)		this->bx = ( (Float)(0) );
HXLINE( 111)		this->by = ( (Float)(0) );
HXLINE( 112)		this->cx = ( (Float)(0) );
HXLINE( 113)		this->cy = ( (Float)(0) );
HXLINE( 115)		this->dx = null();
HXLINE( 116)		this->dy = null();
HXLINE( 117)		this->ex = null();
HXLINE( 118)		this->ey = null();
HXLINE( 128)		this->pointsClock->resize(0);
HXLINE( 129)		this->pointsAnti->resize(0);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Contour_obj,reset,(void))

void Contour_obj::computeDE(){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_140_computeDE)
HXLINE( 141)		{
HXLINE( 141)			this->theta = ::Math_obj::atan2((this->ay - this->by),(this->ax - this->bx));
HXDLIN( 141)			if ((this->theta > 0)) {
HXLINE( 141)				if ((this->halfA < 0)) {
HXLINE( 141)					this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 141)					this->angle1 = (this->theta - this->halfA);
            				}
            				else {
HXLINE( 141)					this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 141)					this->angle2 = (this->theta + this->halfA);
            				}
            			}
            			else {
HXLINE( 141)				if ((this->halfA > 0)) {
HXLINE( 141)					this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 141)					this->angle2 = (this->theta + this->halfA);
            				}
            				else {
HXLINE( 141)					this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 141)					this->angle1 = (this->theta - this->halfA);
            				}
            			}
            		}
HXLINE( 142)		if (::hx::IsNotNull( this->dxPrev )) {
HXLINE( 142)			this->dxOld = this->dxPrev;
            		}
HXLINE( 143)		if (::hx::IsNotNull( this->dyPrev )) {
HXLINE( 143)			this->dyOld = this->dyPrev;
            		}
HXLINE( 144)		if (::hx::IsNotNull( this->exPrev )) {
HXLINE( 144)			this->exOld = this->exPrev;
            		}
HXLINE( 145)		if (::hx::IsNotNull( this->eyPrev )) {
HXLINE( 145)			this->eyOld = this->eyPrev;
            		}
HXLINE( 146)		if (::hx::IsNotNull( this->dx )) {
HXLINE( 146)			this->dxPrev = this->dx;
            		}
HXLINE( 147)		if (::hx::IsNotNull( this->dy )) {
HXLINE( 147)			this->dyPrev = this->dy;
            		}
HXLINE( 148)		if (::hx::IsNotNull( this->ex )) {
HXLINE( 148)			this->exPrev = this->ex;
            		}
HXLINE( 149)		if (::hx::IsNotNull( this->ey )) {
HXLINE( 149)			this->eyPrev = this->ey;
            		}
HXLINE( 150)		this->dx = (this->bx + (this->r * ::Math_obj::cos(( (Float)(this->angle1) ))));
HXLINE( 151)		this->dy = (this->by + (this->r * ::Math_obj::sin(( (Float)(this->angle1) ))));
HXLINE( 152)		this->ex = (this->bx + (this->r * ::Math_obj::cos(this->angle2)));
HXLINE( 153)		this->ey = (this->by + (this->r * ::Math_obj::sin(this->angle2)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Contour_obj,computeDE,(void))

void Contour_obj::anglesCompute(){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_156_anglesCompute)
HXLINE( 157)		this->theta = ::Math_obj::atan2((this->ay - this->by),(this->ax - this->bx));
HXLINE( 158)		if ((this->theta > 0)) {
HXLINE( 159)			if ((this->halfA < 0)) {
HXLINE( 160)				this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXLINE( 161)				this->angle1 = (this->theta - this->halfA);
            			}
            			else {
HXLINE( 163)				this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXLINE( 164)				this->angle2 = (this->theta + this->halfA);
            			}
            		}
            		else {
HXLINE( 167)			if ((this->halfA > 0)) {
HXLINE( 168)				this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXLINE( 169)				this->angle2 = (this->theta + this->halfA);
            			}
            			else {
HXLINE( 171)				this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXLINE( 172)				this->angle1 = (this->theta - this->halfA);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Contour_obj,anglesCompute,(void))

Float Contour_obj::thetaComputeAdj(Float qx,Float qy){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_178_thetaComputeAdj)
HXDLIN( 178)		return (-(::Math_obj::atan2((this->ay - qy),(this->ax - qx))) - (::Math_obj::PI / ( (Float)(2) )));
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,thetaComputeAdj,return )

void Contour_obj::triangleJoin(Float ax_,Float ay_,Float bx_,Float by_,Float width_,::hx::Null< bool >  __o_curveEnds,::hx::Null< bool >  __o_overlap){
            		bool curveEnds = __o_curveEnds.Default(false);
            		bool overlap = __o_overlap.Default(false);
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_194_triangleJoin)
HXLINE( 195)		 ::Dynamic oldAngle;
HXDLIN( 195)		if (::hx::IsNotNull( this->dx )) {
HXLINE( 195)			oldAngle = this->angle1;
            		}
            		else {
HXLINE( 195)			oldAngle = null();
            		}
HXLINE( 196)		this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXLINE( 201)		this->ax = bx_;
HXLINE( 202)		this->ay = by_;
HXLINE( 203)		this->bx = ax_;
HXLINE( 204)		this->by = ay_;
HXLINE( 205)		this->beta = ((::Math_obj::PI / ( (Float)(2) )) - this->halfA);
HXLINE( 206)		this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(this->beta));
HXLINE( 207)		{
HXLINE( 207)			{
HXLINE( 207)				this->theta = ::Math_obj::atan2((this->ay - this->by),(this->ax - this->bx));
HXDLIN( 207)				if ((this->theta > 0)) {
HXLINE( 207)					if ((this->halfA < 0)) {
HXLINE( 207)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 207)						this->angle1 = (this->theta - this->halfA);
            					}
            					else {
HXLINE( 207)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 207)						this->angle2 = (this->theta + this->halfA);
            					}
            				}
            				else {
HXLINE( 207)					if ((this->halfA > 0)) {
HXLINE( 207)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 207)						this->angle2 = (this->theta + this->halfA);
            					}
            					else {
HXLINE( 207)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 207)						this->angle1 = (this->theta - this->halfA);
            					}
            				}
            			}
HXDLIN( 207)			if (::hx::IsNotNull( this->dxPrev )) {
HXLINE( 207)				this->dxOld = this->dxPrev;
            			}
HXDLIN( 207)			if (::hx::IsNotNull( this->dyPrev )) {
HXLINE( 207)				this->dyOld = this->dyPrev;
            			}
HXDLIN( 207)			if (::hx::IsNotNull( this->exPrev )) {
HXLINE( 207)				this->exOld = this->exPrev;
            			}
HXDLIN( 207)			if (::hx::IsNotNull( this->eyPrev )) {
HXLINE( 207)				this->eyOld = this->eyPrev;
            			}
HXDLIN( 207)			if (::hx::IsNotNull( this->dx )) {
HXLINE( 207)				this->dxPrev = this->dx;
            			}
HXDLIN( 207)			if (::hx::IsNotNull( this->dy )) {
HXLINE( 207)				this->dyPrev = this->dy;
            			}
HXDLIN( 207)			if (::hx::IsNotNull( this->ex )) {
HXLINE( 207)				this->exPrev = this->ex;
            			}
HXDLIN( 207)			if (::hx::IsNotNull( this->ey )) {
HXLINE( 207)				this->eyPrev = this->ey;
            			}
HXDLIN( 207)			this->dx = (this->bx + (this->r * ::Math_obj::cos(( (Float)(this->angle1) ))));
HXDLIN( 207)			this->dy = (this->by + (this->r * ::Math_obj::sin(( (Float)(this->angle1) ))));
HXDLIN( 207)			this->ex = (this->bx + (this->r * ::Math_obj::cos(this->angle2)));
HXDLIN( 207)			this->ey = (this->by + (this->r * ::Math_obj::sin(this->angle2)));
            		}
HXLINE( 210)		this->ax = ax_;
HXLINE( 211)		this->ay = ay_;
HXLINE( 212)		this->bx = bx_;
HXLINE( 213)		this->by = by_;
HXLINE( 214)		{
HXLINE( 214)			{
HXLINE( 214)				this->theta = ::Math_obj::atan2((this->ay - this->by),(this->ax - this->bx));
HXDLIN( 214)				if ((this->theta > 0)) {
HXLINE( 214)					if ((this->halfA < 0)) {
HXLINE( 214)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 214)						this->angle1 = (this->theta - this->halfA);
            					}
            					else {
HXLINE( 214)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 214)						this->angle2 = (this->theta + this->halfA);
            					}
            				}
            				else {
HXLINE( 214)					if ((this->halfA > 0)) {
HXLINE( 214)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 214)						this->angle2 = (this->theta + this->halfA);
            					}
            					else {
HXLINE( 214)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 214)						this->angle1 = (this->theta - this->halfA);
            					}
            				}
            			}
HXDLIN( 214)			if (::hx::IsNotNull( this->dxPrev )) {
HXLINE( 214)				this->dxOld = this->dxPrev;
            			}
HXDLIN( 214)			if (::hx::IsNotNull( this->dyPrev )) {
HXLINE( 214)				this->dyOld = this->dyPrev;
            			}
HXDLIN( 214)			if (::hx::IsNotNull( this->exPrev )) {
HXLINE( 214)				this->exOld = this->exPrev;
            			}
HXDLIN( 214)			if (::hx::IsNotNull( this->eyPrev )) {
HXLINE( 214)				this->eyOld = this->eyPrev;
            			}
HXDLIN( 214)			if (::hx::IsNotNull( this->dx )) {
HXLINE( 214)				this->dxPrev = this->dx;
            			}
HXDLIN( 214)			if (::hx::IsNotNull( this->dy )) {
HXLINE( 214)				this->dyPrev = this->dy;
            			}
HXDLIN( 214)			if (::hx::IsNotNull( this->ex )) {
HXLINE( 214)				this->exPrev = this->ex;
            			}
HXDLIN( 214)			if (::hx::IsNotNull( this->ey )) {
HXLINE( 214)				this->eyPrev = this->ey;
            			}
HXDLIN( 214)			this->dx = (this->bx + (this->r * ::Math_obj::cos(( (Float)(this->angle1) ))));
HXDLIN( 214)			this->dy = (this->by + (this->r * ::Math_obj::sin(( (Float)(this->angle1) ))));
HXDLIN( 214)			this->ex = (this->bx + (this->r * ::Math_obj::cos(this->angle2)));
HXDLIN( 214)			this->ey = (this->by + (this->r * ::Math_obj::sin(this->angle2)));
            		}
HXLINE( 216)		Float x = (( (Float)(this->dxOld) ) - bx_);
HXDLIN( 216)		Float y = (( (Float)(this->dyOld) ) - by_);
HXDLIN( 216)		Float x1 = (( (Float)(this->exOld) ) - bx_);
HXDLIN( 216)		Float y1 = (( (Float)(this->eyOld) ) - by_);
HXDLIN( 216)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXLINE( 217)		Float theta0;
HXLINE( 218)		Float theta1;
HXLINE( 219)		if (clockWise) {
HXLINE( 220)			theta0 = (-(::Math_obj::atan2((this->ay - ( (Float)(this->dyOld) )),(this->ax - ( (Float)(this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXLINE( 221)			theta1 = (-(::Math_obj::atan2((this->ay - ( (Float)(this->eyPrev) )),(this->ax - ( (Float)(this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXLINE( 223)			theta0 = (-(::Math_obj::atan2((this->ay - ( (Float)(this->eyOld) )),(this->ax - ( (Float)(this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXLINE( 224)			theta1 = (-(::Math_obj::atan2((this->ay - ( (Float)(this->dyPrev) )),(this->ax - ( (Float)(this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXLINE( 226)		Float dif;
HXDLIN( 226)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 226)				Float f;
HXDLIN( 226)				bool f1;
HXDLIN( 226)				if ((theta0 >= 0)) {
HXLINE( 226)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 226)					f1 = false;
            				}
HXDLIN( 226)				if (f1) {
HXLINE( 226)					f = theta0;
            				}
            				else {
HXLINE( 226)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 226)					if ((a >= 0)) {
HXLINE( 226)						f = a;
            					}
            					else {
HXLINE( 226)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 226)				Float this1 = f;
HXDLIN( 226)				Float za = this1;
HXDLIN( 226)				Float f2;
HXDLIN( 226)				bool f3;
HXDLIN( 226)				if ((theta1 >= 0)) {
HXLINE( 226)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 226)					f3 = false;
            				}
HXDLIN( 226)				if (f3) {
HXLINE( 226)					f2 = theta1;
            				}
            				else {
HXLINE( 226)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 226)					if ((a >= 0)) {
HXLINE( 226)						f2 = a;
            					}
            					else {
HXLINE( 226)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 226)				Float this2 = f2;
HXDLIN( 226)				Float zb = this2;
HXDLIN( 226)				Float fa = za;
HXDLIN( 226)				Float fb = zb;
HXDLIN( 226)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 226)				bool clockwise = (fa < fb);
HXDLIN( 226)				Float dif1;
HXDLIN( 226)				if (clockwise) {
HXLINE( 226)					dif1 = theta;
            				}
            				else {
HXLINE( 226)					dif1 = -(theta);
            				}
HXDLIN( 226)				if ((dif1 > 0)) {
HXLINE( 226)					dif = dif1;
            				}
            				else {
HXLINE( 226)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 226)				Float f;
HXDLIN( 226)				bool f1;
HXDLIN( 226)				if ((theta0 >= 0)) {
HXLINE( 226)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 226)					f1 = false;
            				}
HXDLIN( 226)				if (f1) {
HXLINE( 226)					f = theta0;
            				}
            				else {
HXLINE( 226)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 226)					if ((a >= 0)) {
HXLINE( 226)						f = a;
            					}
            					else {
HXLINE( 226)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 226)				Float this1 = f;
HXDLIN( 226)				Float za = this1;
HXDLIN( 226)				Float f2;
HXDLIN( 226)				bool f3;
HXDLIN( 226)				if ((theta1 >= 0)) {
HXLINE( 226)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 226)					f3 = false;
            				}
HXDLIN( 226)				if (f3) {
HXLINE( 226)					f2 = theta1;
            				}
            				else {
HXLINE( 226)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 226)					if ((a >= 0)) {
HXLINE( 226)						f2 = a;
            					}
            					else {
HXLINE( 226)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 226)				Float this2 = f2;
HXDLIN( 226)				Float zb = this2;
HXDLIN( 226)				Float fa = za;
HXDLIN( 226)				Float fb = zb;
HXDLIN( 226)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 226)				bool clockwise = (fa < fb);
HXDLIN( 226)				Float dif1;
HXDLIN( 226)				if (clockwise) {
HXLINE( 226)					dif1 = theta;
            				}
            				else {
HXLINE( 226)					dif1 = -(theta);
            				}
HXDLIN( 226)				if ((dif1 < 0)) {
HXLINE( 226)					dif = dif1;
            				}
            				else {
HXLINE( 226)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 226)				Float f;
HXDLIN( 226)				bool f1;
HXDLIN( 226)				if ((theta0 >= 0)) {
HXLINE( 226)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 226)					f1 = false;
            				}
HXDLIN( 226)				if (f1) {
HXLINE( 226)					f = theta0;
            				}
            				else {
HXLINE( 226)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 226)					if ((a >= 0)) {
HXLINE( 226)						f = a;
            					}
            					else {
HXLINE( 226)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 226)				Float this1 = f;
HXDLIN( 226)				Float za = this1;
HXDLIN( 226)				Float f2;
HXDLIN( 226)				bool f3;
HXDLIN( 226)				if ((theta1 >= 0)) {
HXLINE( 226)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 226)					f3 = false;
            				}
HXDLIN( 226)				if (f3) {
HXLINE( 226)					f2 = theta1;
            				}
            				else {
HXLINE( 226)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 226)					if ((a >= 0)) {
HXLINE( 226)						f2 = a;
            					}
            					else {
HXLINE( 226)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 226)				Float this2 = f2;
HXDLIN( 226)				Float zb = this2;
HXDLIN( 226)				Float fa = za;
HXDLIN( 226)				Float fb = zb;
HXDLIN( 226)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 226)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 226)				bool clockwise = (fa < fb);
HXDLIN( 226)				Float dif1;
HXDLIN( 226)				if (clockwise) {
HXLINE( 226)					dif1 = theta;
            				}
            				else {
HXLINE( 226)					dif1 = -(theta);
            				}
HXDLIN( 226)				if (smallest) {
HXLINE( 226)					dif = dif1;
            				}
            				else {
HXLINE( 226)					if (clockwise) {
HXLINE( 226)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 226)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 226)				Float f;
HXDLIN( 226)				bool f1;
HXDLIN( 226)				if ((theta0 >= 0)) {
HXLINE( 226)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 226)					f1 = false;
            				}
HXDLIN( 226)				if (f1) {
HXLINE( 226)					f = theta0;
            				}
            				else {
HXLINE( 226)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 226)					if ((a >= 0)) {
HXLINE( 226)						f = a;
            					}
            					else {
HXLINE( 226)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 226)				Float this1 = f;
HXDLIN( 226)				Float za = this1;
HXDLIN( 226)				Float f2;
HXDLIN( 226)				bool f3;
HXDLIN( 226)				if ((theta1 >= 0)) {
HXLINE( 226)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 226)					f3 = false;
            				}
HXDLIN( 226)				if (f3) {
HXLINE( 226)					f2 = theta1;
            				}
            				else {
HXLINE( 226)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 226)					if ((a >= 0)) {
HXLINE( 226)						f2 = a;
            					}
            					else {
HXLINE( 226)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 226)				Float this2 = f2;
HXDLIN( 226)				Float zb = this2;
HXDLIN( 226)				Float fa = za;
HXDLIN( 226)				Float fb = zb;
HXDLIN( 226)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 226)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 226)				bool clockwise = (fa < fb);
HXDLIN( 226)				Float dif1;
HXDLIN( 226)				if (clockwise) {
HXLINE( 226)					dif1 = theta;
            				}
            				else {
HXLINE( 226)					dif1 = -(theta);
            				}
HXDLIN( 226)				if (largest) {
HXLINE( 226)					dif = dif1;
            				}
            				else {
HXLINE( 226)					if (clockwise) {
HXLINE( 226)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 226)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXLINE( 227)		bool _hx_tmp;
HXDLIN( 227)		if (!(overlap)) {
HXLINE( 227)			_hx_tmp = (this->count != 0);
            		}
            		else {
HXLINE( 227)			_hx_tmp = false;
            		}
HXDLIN( 227)		if (_hx_tmp) {
HXLINE( 227)			Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
HXDLIN( 227)			Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
HXDLIN( 227)			Float f;
HXDLIN( 227)			bool f1;
HXDLIN( 227)			if ((theta0 <= ::Math_obj::PI)) {
HXLINE( 227)				f1 = (theta0 > -(::Math_obj::PI));
            			}
            			else {
HXLINE( 227)				f1 = false;
            			}
HXDLIN( 227)			if (f1) {
HXLINE( 227)				f = theta0;
            			}
            			else {
HXLINE( 227)				Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 227)				if ((a >= 0)) {
HXLINE( 227)					f = (a - ::Math_obj::PI);
            				}
            				else {
HXLINE( 227)					f = (a + ::Math_obj::PI);
            				}
            			}
HXDLIN( 227)			Float this1 = f;
HXDLIN( 227)			Float start = this1;
HXDLIN( 227)			Float start2 = start;
HXDLIN( 227)			Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN( 227)			this->jx = (this->ax + (h * ::Math_obj::sin(delta)));
HXDLIN( 227)			this->jy = (this->ay + (h * ::Math_obj::cos(delta)));
            		}
HXLINE( 229)		bool _hx_tmp1;
HXDLIN( 229)		if ((this->count == 0)) {
HXLINE( 229)			if ((this->endLine != 1)) {
HXLINE( 229)				_hx_tmp1 = (this->endLine == 3);
            			}
            			else {
HXLINE( 229)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXLINE( 229)			_hx_tmp1 = false;
            		}
HXDLIN( 229)		if (_hx_tmp1) {
HXLINE( 229)			Float ax = this->ax;
HXDLIN( 229)			Float ay = this->ay;
HXDLIN( 229)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 229)			Float beta = (-(this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 229)			Float gamma = ((-(this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN( 229)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN( 229)			 ::Dynamic drawType = this->pen->drawType;
HXDLIN( 229)			 ::Dynamic sides = 36;
HXDLIN( 229)			if (::hx::IsNull( sides )) {
HXLINE( 229)				sides = 36;
            			}
HXDLIN( 229)			Float pi = ::Math_obj::PI;
HXDLIN( 229)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 229)			Float dif;
HXDLIN( 229)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXLINE( 229)					Float f;
HXDLIN( 229)					bool f1;
HXDLIN( 229)					if ((beta >= 0)) {
HXLINE( 229)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 229)						f1 = false;
            					}
HXDLIN( 229)					if (f1) {
HXLINE( 229)						f = beta;
            					}
            					else {
HXLINE( 229)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 229)						if ((a >= 0)) {
HXLINE( 229)							f = a;
            						}
            						else {
HXLINE( 229)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 229)					Float this1 = f;
HXDLIN( 229)					Float za = this1;
HXDLIN( 229)					Float f2;
HXDLIN( 229)					bool f3;
HXDLIN( 229)					if ((gamma >= 0)) {
HXLINE( 229)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 229)						f3 = false;
            					}
HXDLIN( 229)					if (f3) {
HXLINE( 229)						f2 = gamma;
            					}
            					else {
HXLINE( 229)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 229)						if ((a >= 0)) {
HXLINE( 229)							f2 = a;
            						}
            						else {
HXLINE( 229)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 229)					Float this2 = f2;
HXDLIN( 229)					Float zb = this2;
HXDLIN( 229)					Float fa = za;
HXDLIN( 229)					Float fb = zb;
HXDLIN( 229)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 229)					bool clockwise = (fa < fb);
HXDLIN( 229)					Float dif1;
HXDLIN( 229)					if (clockwise) {
HXLINE( 229)						dif1 = theta;
            					}
            					else {
HXLINE( 229)						dif1 = -(theta);
            					}
HXDLIN( 229)					if ((dif1 > 0)) {
HXLINE( 229)						dif = dif1;
            					}
            					else {
HXLINE( 229)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXLINE( 229)					Float f;
HXDLIN( 229)					bool f1;
HXDLIN( 229)					if ((beta >= 0)) {
HXLINE( 229)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 229)						f1 = false;
            					}
HXDLIN( 229)					if (f1) {
HXLINE( 229)						f = beta;
            					}
            					else {
HXLINE( 229)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 229)						if ((a >= 0)) {
HXLINE( 229)							f = a;
            						}
            						else {
HXLINE( 229)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 229)					Float this1 = f;
HXDLIN( 229)					Float za = this1;
HXDLIN( 229)					Float f2;
HXDLIN( 229)					bool f3;
HXDLIN( 229)					if ((gamma >= 0)) {
HXLINE( 229)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 229)						f3 = false;
            					}
HXDLIN( 229)					if (f3) {
HXLINE( 229)						f2 = gamma;
            					}
            					else {
HXLINE( 229)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 229)						if ((a >= 0)) {
HXLINE( 229)							f2 = a;
            						}
            						else {
HXLINE( 229)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 229)					Float this2 = f2;
HXDLIN( 229)					Float zb = this2;
HXDLIN( 229)					Float fa = za;
HXDLIN( 229)					Float fb = zb;
HXDLIN( 229)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 229)					bool clockwise = (fa < fb);
HXDLIN( 229)					Float dif1;
HXDLIN( 229)					if (clockwise) {
HXLINE( 229)						dif1 = theta;
            					}
            					else {
HXLINE( 229)						dif1 = -(theta);
            					}
HXDLIN( 229)					if ((dif1 < 0)) {
HXLINE( 229)						dif = dif1;
            					}
            					else {
HXLINE( 229)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXLINE( 229)					Float f;
HXDLIN( 229)					bool f1;
HXDLIN( 229)					if ((beta >= 0)) {
HXLINE( 229)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 229)						f1 = false;
            					}
HXDLIN( 229)					if (f1) {
HXLINE( 229)						f = beta;
            					}
            					else {
HXLINE( 229)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 229)						if ((a >= 0)) {
HXLINE( 229)							f = a;
            						}
            						else {
HXLINE( 229)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 229)					Float this1 = f;
HXDLIN( 229)					Float za = this1;
HXDLIN( 229)					Float f2;
HXDLIN( 229)					bool f3;
HXDLIN( 229)					if ((gamma >= 0)) {
HXLINE( 229)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 229)						f3 = false;
            					}
HXDLIN( 229)					if (f3) {
HXLINE( 229)						f2 = gamma;
            					}
            					else {
HXLINE( 229)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 229)						if ((a >= 0)) {
HXLINE( 229)							f2 = a;
            						}
            						else {
HXLINE( 229)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 229)					Float this2 = f2;
HXDLIN( 229)					Float zb = this2;
HXDLIN( 229)					Float fa = za;
HXDLIN( 229)					Float fb = zb;
HXDLIN( 229)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 229)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 229)					bool clockwise = (fa < fb);
HXDLIN( 229)					Float dif1;
HXDLIN( 229)					if (clockwise) {
HXLINE( 229)						dif1 = theta;
            					}
            					else {
HXLINE( 229)						dif1 = -(theta);
            					}
HXDLIN( 229)					if (smallest) {
HXLINE( 229)						dif = dif1;
            					}
            					else {
HXLINE( 229)						if (clockwise) {
HXLINE( 229)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXLINE( 229)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXLINE( 229)					Float f;
HXDLIN( 229)					bool f1;
HXDLIN( 229)					if ((beta >= 0)) {
HXLINE( 229)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 229)						f1 = false;
            					}
HXDLIN( 229)					if (f1) {
HXLINE( 229)						f = beta;
            					}
            					else {
HXLINE( 229)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 229)						if ((a >= 0)) {
HXLINE( 229)							f = a;
            						}
            						else {
HXLINE( 229)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 229)					Float this1 = f;
HXDLIN( 229)					Float za = this1;
HXDLIN( 229)					Float f2;
HXDLIN( 229)					bool f3;
HXDLIN( 229)					if ((gamma >= 0)) {
HXLINE( 229)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 229)						f3 = false;
            					}
HXDLIN( 229)					if (f3) {
HXLINE( 229)						f2 = gamma;
            					}
            					else {
HXLINE( 229)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 229)						if ((a >= 0)) {
HXLINE( 229)							f2 = a;
            						}
            						else {
HXLINE( 229)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 229)					Float this2 = f2;
HXDLIN( 229)					Float zb = this2;
HXDLIN( 229)					Float fa = za;
HXDLIN( 229)					Float fb = zb;
HXDLIN( 229)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 229)					bool largest = (theta > ::Math_obj::PI);
HXDLIN( 229)					bool clockwise = (fa < fb);
HXDLIN( 229)					Float dif1;
HXDLIN( 229)					if (clockwise) {
HXLINE( 229)						dif1 = theta;
            					}
            					else {
HXLINE( 229)						dif1 = -(theta);
            					}
HXDLIN( 229)					if (largest) {
HXLINE( 229)						dif = dif1;
            					}
            					else {
HXLINE( 229)						if (clockwise) {
HXLINE( 229)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXLINE( 229)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN( 229)			bool positive = (dif >= 0);
HXDLIN( 229)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 229)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 229)			Float angle = beta;
HXDLIN( 229)			Float cx;
HXDLIN( 229)			Float cy;
HXDLIN( 229)			Float bx = ( (Float)(0) );
HXDLIN( 229)			Float by = ( (Float)(0) );
HXDLIN( 229)			int p2 = temp->length;
HXDLIN( 229)			{
HXLINE( 229)				int _g = 0;
HXDLIN( 229)				int _g1 = (totalSteps + 1);
HXDLIN( 229)				while((_g < _g1)){
HXLINE( 229)					_g = (_g + 1);
HXDLIN( 229)					int i = (_g - 1);
HXDLIN( 229)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 229)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 229)					p2 = (p2 + 1);
HXDLIN( 229)					temp[(p2 - 1)] = cx;
HXDLIN( 229)					p2 = (p2 + 1);
HXDLIN( 229)					temp[(p2 - 1)] = cy;
HXDLIN( 229)					if ((i != 0)) {
HXLINE( 229)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 229)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 229)						if (::hx::IsNotNull( m )) {
HXLINE( 229)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 229)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 229)					angle = (angle + step1);
HXDLIN( 229)					bx = cx;
HXDLIN( 229)					by = cy;
            				}
            			}
HXDLIN( 229)			int len = totalSteps;
HXDLIN( 229)			{
HXLINE( 229)				 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 229)				int color = -1;
HXDLIN( 229)				if ((color == -1)) {
HXLINE( 229)					color = _this->currentColor;
            				}
HXDLIN( 229)				_this->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN( 229)			int pA = this->pointsAnti->length;
HXDLIN( 229)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN( 229)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN( 229)			{
HXLINE( 229)				int _g2 = 0;
HXDLIN( 229)				int _g3 = p4;
HXDLIN( 229)				while((_g2 < _g3)){
HXLINE( 229)					_g2 = (_g2 + 1);
HXDLIN( 229)					int i = (_g2 - 1);
HXDLIN( 229)					pA = (pA + 1);
HXDLIN( 229)					this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXDLIN( 229)					pA = (pA + 1);
HXDLIN( 229)					this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            				}
            			}
HXDLIN( 229)			int pC = this->pointsClock->length;
HXDLIN( 229)			{
HXLINE( 229)				int _g4 = 0;
HXDLIN( 229)				int _g5 = p4;
HXDLIN( 229)				while((_g4 < _g5)){
HXLINE( 229)					_g4 = (_g4 + 1);
HXDLIN( 229)					int i = (_g4 - 1);
HXDLIN( 229)					pC = (pC + 1);
HXDLIN( 229)					this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXDLIN( 229)					pC = (pC + 1);
HXDLIN( 229)					this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            				}
            			}
            		}
HXLINE( 249)		if (overlap) {
HXLINE( 250)			{
HXLINE( 250)				 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 250)				int color = -1;
HXDLIN( 250)				if ((color == -1)) {
HXLINE( 250)					color = _this->currentColor;
            				}
HXDLIN( 250)				{
HXLINE( 250)					_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 250)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 250)						_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN( 250)					_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 250)				_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN( 250)			{
HXLINE( 250)				 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 250)				int color1 = -1;
HXDLIN( 250)				if ((color1 == -1)) {
HXLINE( 250)					color1 = _this1->currentColor;
            				}
HXDLIN( 250)				{
HXLINE( 250)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0);
HXDLIN( 250)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 250)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN( 250)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 250)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
            		else {
HXLINE( 252)			if ((this->count != 0)) {
HXLINE( 252)				this->addQuads(clockWise,width_);
            			}
HXLINE( 253)			{
HXLINE( 253)				this->quadIndex = ( (Float)(this->pen->drawType->__Field(HX_("get_pos",2b,26,ca,26),::hx::paccDynamic)()) );
HXDLIN( 253)				if ((this->count == 0)) {
HXLINE( 253)					this->penultimateAX = ( (Float)(this->dxPrev) );
HXDLIN( 253)					this->penultimateAY = ( (Float)(this->dyPrev) );
HXDLIN( 253)					this->lastAntiX = ( (Float)(this->ex) );
HXDLIN( 253)					this->lastAntiY = ( (Float)(this->ey) );
HXDLIN( 253)					this->penultimateCX = ( (Float)(this->dx) );
HXDLIN( 253)					this->penultimateCY = ( (Float)(this->dy) );
HXDLIN( 253)					this->lastClockX = ( (Float)(this->exPrev) );
HXDLIN( 253)					this->lastClockY = ( (Float)(this->eyPrev) );
HXDLIN( 253)					{
HXLINE( 253)						 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 253)						int color = -1;
HXDLIN( 253)						if ((color == -1)) {
HXLINE( 253)							color = _this->currentColor;
            						}
HXDLIN( 253)						{
HXLINE( 253)							_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 253)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 253)								_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN( 253)							_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 253)						_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            					}
HXDLIN( 253)					{
HXLINE( 253)						 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 253)						int color1 = -1;
HXDLIN( 253)						if ((color1 == -1)) {
HXLINE( 253)							color1 = _this1->currentColor;
            						}
HXDLIN( 253)						{
HXLINE( 253)							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0);
HXDLIN( 253)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 253)								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN( 253)							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 253)						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            					}
            				}
            				else {
HXLINE( 253)					bool _hx_tmp;
HXDLIN( 253)					if (clockWise) {
HXLINE( 253)						_hx_tmp = !(this->lastClock);
            					}
            					else {
HXLINE( 253)						_hx_tmp = false;
            					}
HXDLIN( 253)					if (_hx_tmp) {
HXLINE( 253)						this->penultimateAX = this->jx;
HXDLIN( 253)						this->penultimateAY = this->jy;
HXDLIN( 253)						this->lastAntiX = ( (Float)(this->ex) );
HXDLIN( 253)						this->lastAntiY = ( (Float)(this->ey) );
HXDLIN( 253)						this->penultimateCX = ( (Float)(this->dx) );
HXDLIN( 253)						this->penultimateCY = ( (Float)(this->dy) );
HXDLIN( 253)						this->lastClockX = ( (Float)(this->exPrev) );
HXDLIN( 253)						this->lastClockY = ( (Float)(this->eyPrev) );
HXDLIN( 253)						{
HXLINE( 253)							 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 253)							int color = -1;
HXDLIN( 253)							if ((color == -1)) {
HXLINE( 253)								color = _this->currentColor;
            							}
HXDLIN( 253)							{
HXLINE( 253)								_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jx,this->jy,0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 253)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 253)									_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN( 253)								_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN( 253)							_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN( 253)						{
HXLINE( 253)							 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 253)							int color1 = -1;
HXDLIN( 253)							if ((color1 == -1)) {
HXLINE( 253)								color1 = _this1->currentColor;
            							}
HXDLIN( 253)							{
HXLINE( 253)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jx,this->jy,0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0);
HXDLIN( 253)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 253)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN( 253)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN( 253)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN( 253)					bool _hx_tmp1;
HXDLIN( 253)					if (clockWise) {
HXLINE( 253)						_hx_tmp1 = this->lastClock;
            					}
            					else {
HXLINE( 253)						_hx_tmp1 = false;
            					}
HXDLIN( 253)					if (_hx_tmp1) {
HXLINE( 253)						this->penultimateAX = this->jx;
HXDLIN( 253)						this->penultimateAY = this->jy;
HXDLIN( 253)						this->lastAntiX = ( (Float)(this->ex) );
HXDLIN( 253)						this->lastAntiY = ( (Float)(this->ey) );
HXDLIN( 253)						this->penultimateCX = ( (Float)(this->dx) );
HXDLIN( 253)						this->penultimateCY = ( (Float)(this->dy) );
HXDLIN( 253)						this->lastClockX = ( (Float)(this->exPrev) );
HXDLIN( 253)						this->lastClockY = ( (Float)(this->eyPrev) );
HXDLIN( 253)						{
HXLINE( 253)							 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 253)							int color = -1;
HXDLIN( 253)							if ((color == -1)) {
HXLINE( 253)								color = _this->currentColor;
            							}
HXDLIN( 253)							{
HXLINE( 253)								_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jx,this->jy,0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 253)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 253)									_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN( 253)								_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN( 253)							_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN( 253)						{
HXLINE( 253)							 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 253)							int color1 = -1;
HXDLIN( 253)							if ((color1 == -1)) {
HXLINE( 253)								color1 = _this1->currentColor;
            							}
HXDLIN( 253)							{
HXLINE( 253)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jx,this->jy,0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0);
HXDLIN( 253)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 253)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN( 253)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN( 253)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN( 253)					bool _hx_tmp2;
HXDLIN( 253)					if (!(clockWise)) {
HXLINE( 253)						_hx_tmp2 = !(this->lastClock);
            					}
            					else {
HXLINE( 253)						_hx_tmp2 = false;
            					}
HXDLIN( 253)					if (_hx_tmp2) {
HXLINE( 253)						this->penultimateCX = ( (Float)(this->dx) );
HXDLIN( 253)						this->penultimateCY = ( (Float)(this->dy) );
HXDLIN( 253)						this->lastClockX = this->jx;
HXDLIN( 253)						this->lastClockY = this->jy;
HXDLIN( 253)						this->penultimateAX = ( (Float)(this->dxPrev) );
HXDLIN( 253)						this->penultimateAY = ( (Float)(this->dyPrev) );
HXDLIN( 253)						this->lastAntiX = ( (Float)(this->ex) );
HXDLIN( 253)						this->lastAntiY = ( (Float)(this->ey) );
HXDLIN( 253)						{
HXLINE( 253)							 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 253)							int color = -1;
HXDLIN( 253)							if ((color == -1)) {
HXLINE( 253)								color = _this->currentColor;
            							}
HXDLIN( 253)							{
HXLINE( 253)								_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,this->jx,this->jy,0);
HXDLIN( 253)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 253)									_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN( 253)								_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN( 253)							_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN( 253)						{
HXLINE( 253)							 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 253)							int color1 = -1;
HXDLIN( 253)							if ((color1 == -1)) {
HXLINE( 253)								color1 = _this1->currentColor;
            							}
HXDLIN( 253)							{
HXLINE( 253)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 253)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 253)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN( 253)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN( 253)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN( 253)					bool _hx_tmp3;
HXDLIN( 253)					if (!(clockWise)) {
HXLINE( 253)						_hx_tmp3 = this->lastClock;
            					}
            					else {
HXLINE( 253)						_hx_tmp3 = false;
            					}
HXDLIN( 253)					if (_hx_tmp3) {
HXLINE( 253)						this->penultimateAX = ( (Float)(this->dxPrev) );
HXDLIN( 253)						this->penultimateAY = ( (Float)(this->dyPrev) );
HXDLIN( 253)						this->lastAntiX = ( (Float)(this->ex) );
HXDLIN( 253)						this->lastAntiY = ( (Float)(this->ey) );
HXDLIN( 253)						this->penultimateCX = this->jx;
HXDLIN( 253)						this->penultimateCY = this->jy;
HXDLIN( 253)						this->lastClockX = ( (Float)(this->dx) );
HXDLIN( 253)						this->lastClockY = ( (Float)(this->dy) );
HXDLIN( 253)						{
HXLINE( 253)							 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 253)							int color = -1;
HXDLIN( 253)							if ((color == -1)) {
HXLINE( 253)								color = _this->currentColor;
            							}
HXDLIN( 253)							{
HXLINE( 253)								_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jx,this->jy,0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 253)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 253)									_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN( 253)								_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN( 253)							_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN( 253)						{
HXLINE( 253)							 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 253)							int color1 = -1;
HXDLIN( 253)							if ((color1 == -1)) {
HXLINE( 253)								color1 = _this1->currentColor;
            							}
HXDLIN( 253)							{
HXLINE( 253)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,this->jx,this->jy,0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 253)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 253)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN( 253)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN( 253)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
            				}
            			}
            		}
HXLINE( 256)		if (curveEnds) {
HXLINE( 258)			if (clockWise) {
HXLINE( 259)				 ::Dynamic drawType = this->pen->drawType;
HXDLIN( 259)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 259)				::Array< Float > edgePoly = this->pointsClock;
HXDLIN( 259)				Float pi = ::Math_obj::PI;
HXDLIN( 259)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 259)				bool positive = (dif >= 0);
HXDLIN( 259)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 259)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 259)				Float angle = theta0;
HXDLIN( 259)				Float cx;
HXDLIN( 259)				Float cy;
HXDLIN( 259)				Float bx = ( (Float)(0) );
HXDLIN( 259)				Float by = ( (Float)(0) );
HXDLIN( 259)				int p2 = edgePoly->length;
HXDLIN( 259)				{
HXLINE( 259)					int _g = 0;
HXDLIN( 259)					int _g1 = (totalSteps + 1);
HXDLIN( 259)					while((_g < _g1)){
HXLINE( 259)						_g = (_g + 1);
HXDLIN( 259)						int i = (_g - 1);
HXDLIN( 259)						cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN( 259)						cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN( 259)						p2 = (p2 + 1);
HXDLIN( 259)						edgePoly[(p2 - 1)] = cx;
HXDLIN( 259)						p2 = (p2 + 1);
HXDLIN( 259)						edgePoly[(p2 - 1)] = cy;
HXDLIN( 259)						if ((i != 0)) {
HXLINE( 259)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN( 259)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 259)							if (::hx::IsNotNull( m )) {
HXLINE( 259)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN( 259)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 259)						angle = (angle + step1);
HXDLIN( 259)						bx = cx;
HXDLIN( 259)						by = cy;
            					}
            				}
HXDLIN( 259)				int len = totalSteps;
HXLINE( 260)				{
HXLINE( 260)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 260)					int color = -1;
HXDLIN( 260)					if ((color == -1)) {
HXLINE( 260)						color = _this->currentColor;
            					}
HXDLIN( 260)					_this->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            				}
            			}
            			else {
HXLINE( 263)				 ::Dynamic drawType = this->pen->drawType;
HXDLIN( 263)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 263)				::Array< Float > edgePoly = this->pointsAnti;
HXDLIN( 263)				Float pi = ::Math_obj::PI;
HXDLIN( 263)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 263)				bool positive = (dif >= 0);
HXDLIN( 263)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 263)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 263)				Float angle = theta0;
HXDLIN( 263)				Float cx;
HXDLIN( 263)				Float cy;
HXDLIN( 263)				Float bx = ( (Float)(0) );
HXDLIN( 263)				Float by = ( (Float)(0) );
HXDLIN( 263)				int p2 = edgePoly->length;
HXDLIN( 263)				{
HXLINE( 263)					int _g = 0;
HXDLIN( 263)					int _g1 = (totalSteps + 1);
HXDLIN( 263)					while((_g < _g1)){
HXLINE( 263)						_g = (_g + 1);
HXDLIN( 263)						int i = (_g - 1);
HXDLIN( 263)						cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN( 263)						cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN( 263)						p2 = (p2 + 1);
HXDLIN( 263)						edgePoly[(p2 - 1)] = cx;
HXDLIN( 263)						p2 = (p2 + 1);
HXDLIN( 263)						edgePoly[(p2 - 1)] = cy;
HXDLIN( 263)						if ((i != 0)) {
HXLINE( 263)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN( 263)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 263)							if (::hx::IsNotNull( m )) {
HXLINE( 263)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN( 263)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 263)						angle = (angle + step1);
HXDLIN( 263)						bx = cx;
HXDLIN( 263)						by = cy;
            					}
            				}
HXDLIN( 263)				int len = totalSteps;
HXLINE( 264)				{
HXLINE( 264)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 264)					int color = -1;
HXDLIN( 264)					if ((color == -1)) {
HXLINE( 264)						color = _this->currentColor;
            					}
HXDLIN( 264)					_this->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            				}
            			}
            		}
            		else {
HXLINE( 269)			if ((this->count != 0)) {
HXLINE( 270)				if (overlap) {
HXLINE( 271)					if (clockWise) {
HXLINE( 271)						 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 271)						int color = -1;
HXDLIN( 271)						if ((color == -1)) {
HXLINE( 271)							color = _this->currentColor;
            						}
HXDLIN( 271)						{
HXLINE( 271)							_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxOld) ),( (Float)(this->dyOld) ),0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0,this->ax,this->ay,0);
HXDLIN( 271)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 271)								_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN( 271)							_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 271)						_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            					}
            					else {
HXLINE( 271)						 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 271)						int color = -1;
HXDLIN( 271)						if ((color == -1)) {
HXLINE( 271)							color = _this->currentColor;
            						}
HXDLIN( 271)						{
HXLINE( 271)							_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->exOld) ),( (Float)(this->eyOld) ),0,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,this->ax,this->ay,0);
HXDLIN( 271)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 271)								_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN( 271)							_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 271)						_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            					}
            				}
            				else {
HXLINE( 273)					if (clockWise) {
HXLINE( 273)						 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 273)						int color = -1;
HXDLIN( 273)						if ((color == -1)) {
HXLINE( 273)							color = _this->currentColor;
            						}
HXDLIN( 273)						{
HXLINE( 273)							_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxOld) ),( (Float)(this->dyOld) ),0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0,this->jx,this->jy,0);
HXDLIN( 273)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 273)								_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN( 273)							_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 273)						_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            					}
            					else {
HXLINE( 273)						 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 273)						int color = -1;
HXDLIN( 273)						if ((color == -1)) {
HXLINE( 273)							color = _this->currentColor;
            						}
HXDLIN( 273)						{
HXLINE( 273)							_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->exOld) ),( (Float)(this->eyOld) ),0,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,this->jx,this->jy,0);
HXDLIN( 273)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 273)								_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN( 273)							_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 273)						_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            					}
            				}
            			}
            		}
HXLINE( 279)		{
HXLINE( 279)			this->kax = ( (Float)(this->dxPrev) );
HXDLIN( 279)			this->kay = ( (Float)(this->dyPrev) );
HXDLIN( 279)			this->kbx = ( (Float)(this->dx) );
HXDLIN( 279)			this->kby = ( (Float)(this->dy) );
HXDLIN( 279)			this->ncx = ( (Float)(this->exPrev) );
HXDLIN( 279)			this->ncy = ( (Float)(this->eyPrev) );
HXDLIN( 279)			this->kcx = ( (Float)(this->ex) );
HXDLIN( 279)			this->kcy = ( (Float)(this->ey) );
            		}
HXLINE( 282)		bool _hx_tmp2;
HXDLIN( 282)		bool _hx_tmp3;
HXDLIN( 282)		if (curveEnds) {
HXLINE( 282)			_hx_tmp3 = !(overlap);
            		}
            		else {
HXLINE( 282)			_hx_tmp3 = false;
            		}
HXDLIN( 282)		if (_hx_tmp3) {
HXLINE( 282)			_hx_tmp2 = (this->count != 0);
            		}
            		else {
HXLINE( 282)			_hx_tmp2 = false;
            		}
HXDLIN( 282)		if (_hx_tmp2) {
HXLINE( 282)			if (clockWise) {
HXLINE( 282)				{
HXLINE( 282)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 282)					int color = -1;
HXDLIN( 282)					if ((color == -1)) {
HXLINE( 282)						color = _this->currentColor;
            					}
HXDLIN( 282)					{
HXLINE( 282)						_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->ax,this->ay,0,( (Float)(this->dxOld) ),( (Float)(this->dyOld) ),0,this->jx,this->jy,0);
HXDLIN( 282)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 282)							_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 282)						_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 282)					_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXDLIN( 282)				{
HXLINE( 282)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 282)					int color1 = -1;
HXDLIN( 282)					if ((color1 == -1)) {
HXLINE( 282)						color1 = _this1->currentColor;
            					}
HXDLIN( 282)					{
HXLINE( 282)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->ax,this->ay,0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0,this->jx,this->jy,0);
HXDLIN( 282)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 282)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 282)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 282)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
            			else {
HXLINE( 282)				{
HXLINE( 282)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 282)					int color = -1;
HXDLIN( 282)					if ((color == -1)) {
HXLINE( 282)						color = _this->currentColor;
            					}
HXDLIN( 282)					{
HXLINE( 282)						_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->ax,this->ay,0,( (Float)(this->exOld) ),( (Float)(this->eyOld) ),0,this->jx,this->jy,0);
HXDLIN( 282)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 282)							_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 282)						_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 282)					_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXDLIN( 282)				{
HXLINE( 282)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 282)					int color1 = -1;
HXDLIN( 282)					if ((color1 == -1)) {
HXLINE( 282)						color1 = _this1->currentColor;
            					}
HXDLIN( 282)					{
HXLINE( 282)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->ax,this->ay,0,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,this->jx,this->jy,0);
HXDLIN( 282)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 282)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 282)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 282)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
            		}
HXLINE( 292)		this->jxOld = this->jx;
HXLINE( 293)		this->jyOld = this->jy;
HXLINE( 294)		this->lastClock = clockWise;
HXLINE( 295)		this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC7(Contour_obj,triangleJoin,(void))

void Contour_obj::overlapQuad(){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_299_overlapQuad)
HXLINE( 300)		{
HXLINE( 300)			 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 300)			int color = -1;
HXDLIN( 300)			if ((color == -1)) {
HXLINE( 300)				color = _this->currentColor;
            			}
HXDLIN( 300)			{
HXLINE( 300)				_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 300)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 300)					_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN( 300)				_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 300)			_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            		}
HXLINE( 302)		{
HXLINE( 302)			 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 302)			int color1 = -1;
HXDLIN( 302)			if ((color1 == -1)) {
HXLINE( 302)				color1 = _this1->currentColor;
            			}
HXDLIN( 302)			{
HXLINE( 302)				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0);
HXDLIN( 302)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 302)					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN( 302)				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 302)			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Contour_obj,overlapQuad,(void))

void Contour_obj::end(Float width_){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_307_end)
HXLINE( 308)		this->endEdges();
HXLINE( 309)		if ((this->count != 0)) {
HXLINE( 309)			Float ax = this->bx;
HXDLIN( 309)			Float ay = this->by;
HXDLIN( 309)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 309)			Float beta = (-(this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 309)			Float gamma = ((-(this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 309)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN( 309)			 ::Dynamic drawType = this->pen->drawType;
HXDLIN( 309)			 ::Dynamic sides = 36;
HXDLIN( 309)			if (::hx::IsNull( sides )) {
HXLINE( 309)				sides = 36;
            			}
HXDLIN( 309)			Float pi = ::Math_obj::PI;
HXDLIN( 309)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 309)			Float dif;
HXDLIN( 309)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXLINE( 309)					Float f;
HXDLIN( 309)					bool f1;
HXDLIN( 309)					if ((beta >= 0)) {
HXLINE( 309)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 309)						f1 = false;
            					}
HXDLIN( 309)					if (f1) {
HXLINE( 309)						f = beta;
            					}
            					else {
HXLINE( 309)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 309)						if ((a >= 0)) {
HXLINE( 309)							f = a;
            						}
            						else {
HXLINE( 309)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 309)					Float this1 = f;
HXDLIN( 309)					Float za = this1;
HXDLIN( 309)					Float f2;
HXDLIN( 309)					bool f3;
HXDLIN( 309)					if ((gamma >= 0)) {
HXLINE( 309)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 309)						f3 = false;
            					}
HXDLIN( 309)					if (f3) {
HXLINE( 309)						f2 = gamma;
            					}
            					else {
HXLINE( 309)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 309)						if ((a >= 0)) {
HXLINE( 309)							f2 = a;
            						}
            						else {
HXLINE( 309)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 309)					Float this2 = f2;
HXDLIN( 309)					Float zb = this2;
HXDLIN( 309)					Float fa = za;
HXDLIN( 309)					Float fb = zb;
HXDLIN( 309)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 309)					bool clockwise = (fa < fb);
HXDLIN( 309)					Float dif1;
HXDLIN( 309)					if (clockwise) {
HXLINE( 309)						dif1 = theta;
            					}
            					else {
HXLINE( 309)						dif1 = -(theta);
            					}
HXDLIN( 309)					if ((dif1 > 0)) {
HXLINE( 309)						dif = dif1;
            					}
            					else {
HXLINE( 309)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXLINE( 309)					Float f;
HXDLIN( 309)					bool f1;
HXDLIN( 309)					if ((beta >= 0)) {
HXLINE( 309)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 309)						f1 = false;
            					}
HXDLIN( 309)					if (f1) {
HXLINE( 309)						f = beta;
            					}
            					else {
HXLINE( 309)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 309)						if ((a >= 0)) {
HXLINE( 309)							f = a;
            						}
            						else {
HXLINE( 309)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 309)					Float this1 = f;
HXDLIN( 309)					Float za = this1;
HXDLIN( 309)					Float f2;
HXDLIN( 309)					bool f3;
HXDLIN( 309)					if ((gamma >= 0)) {
HXLINE( 309)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 309)						f3 = false;
            					}
HXDLIN( 309)					if (f3) {
HXLINE( 309)						f2 = gamma;
            					}
            					else {
HXLINE( 309)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 309)						if ((a >= 0)) {
HXLINE( 309)							f2 = a;
            						}
            						else {
HXLINE( 309)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 309)					Float this2 = f2;
HXDLIN( 309)					Float zb = this2;
HXDLIN( 309)					Float fa = za;
HXDLIN( 309)					Float fb = zb;
HXDLIN( 309)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 309)					bool clockwise = (fa < fb);
HXDLIN( 309)					Float dif1;
HXDLIN( 309)					if (clockwise) {
HXLINE( 309)						dif1 = theta;
            					}
            					else {
HXLINE( 309)						dif1 = -(theta);
            					}
HXDLIN( 309)					if ((dif1 < 0)) {
HXLINE( 309)						dif = dif1;
            					}
            					else {
HXLINE( 309)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXLINE( 309)					Float f;
HXDLIN( 309)					bool f1;
HXDLIN( 309)					if ((beta >= 0)) {
HXLINE( 309)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 309)						f1 = false;
            					}
HXDLIN( 309)					if (f1) {
HXLINE( 309)						f = beta;
            					}
            					else {
HXLINE( 309)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 309)						if ((a >= 0)) {
HXLINE( 309)							f = a;
            						}
            						else {
HXLINE( 309)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 309)					Float this1 = f;
HXDLIN( 309)					Float za = this1;
HXDLIN( 309)					Float f2;
HXDLIN( 309)					bool f3;
HXDLIN( 309)					if ((gamma >= 0)) {
HXLINE( 309)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 309)						f3 = false;
            					}
HXDLIN( 309)					if (f3) {
HXLINE( 309)						f2 = gamma;
            					}
            					else {
HXLINE( 309)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 309)						if ((a >= 0)) {
HXLINE( 309)							f2 = a;
            						}
            						else {
HXLINE( 309)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 309)					Float this2 = f2;
HXDLIN( 309)					Float zb = this2;
HXDLIN( 309)					Float fa = za;
HXDLIN( 309)					Float fb = zb;
HXDLIN( 309)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 309)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 309)					bool clockwise = (fa < fb);
HXDLIN( 309)					Float dif1;
HXDLIN( 309)					if (clockwise) {
HXLINE( 309)						dif1 = theta;
            					}
            					else {
HXLINE( 309)						dif1 = -(theta);
            					}
HXDLIN( 309)					if (smallest) {
HXLINE( 309)						dif = dif1;
            					}
            					else {
HXLINE( 309)						if (clockwise) {
HXLINE( 309)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXLINE( 309)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXLINE( 309)					Float f;
HXDLIN( 309)					bool f1;
HXDLIN( 309)					if ((beta >= 0)) {
HXLINE( 309)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 309)						f1 = false;
            					}
HXDLIN( 309)					if (f1) {
HXLINE( 309)						f = beta;
            					}
            					else {
HXLINE( 309)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 309)						if ((a >= 0)) {
HXLINE( 309)							f = a;
            						}
            						else {
HXLINE( 309)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 309)					Float this1 = f;
HXDLIN( 309)					Float za = this1;
HXDLIN( 309)					Float f2;
HXDLIN( 309)					bool f3;
HXDLIN( 309)					if ((gamma >= 0)) {
HXLINE( 309)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 309)						f3 = false;
            					}
HXDLIN( 309)					if (f3) {
HXLINE( 309)						f2 = gamma;
            					}
            					else {
HXLINE( 309)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 309)						if ((a >= 0)) {
HXLINE( 309)							f2 = a;
            						}
            						else {
HXLINE( 309)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 309)					Float this2 = f2;
HXDLIN( 309)					Float zb = this2;
HXDLIN( 309)					Float fa = za;
HXDLIN( 309)					Float fb = zb;
HXDLIN( 309)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 309)					bool largest = (theta > ::Math_obj::PI);
HXDLIN( 309)					bool clockwise = (fa < fb);
HXDLIN( 309)					Float dif1;
HXDLIN( 309)					if (clockwise) {
HXLINE( 309)						dif1 = theta;
            					}
            					else {
HXLINE( 309)						dif1 = -(theta);
            					}
HXDLIN( 309)					if (largest) {
HXLINE( 309)						dif = dif1;
            					}
            					else {
HXLINE( 309)						if (clockwise) {
HXLINE( 309)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXLINE( 309)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN( 309)			bool positive = (dif >= 0);
HXDLIN( 309)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 309)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 309)			Float angle = beta;
HXDLIN( 309)			Float cx;
HXDLIN( 309)			Float cy;
HXDLIN( 309)			Float bx = ( (Float)(0) );
HXDLIN( 309)			Float by = ( (Float)(0) );
HXDLIN( 309)			int p2 = temp->length;
HXDLIN( 309)			{
HXLINE( 309)				int _g = 0;
HXDLIN( 309)				int _g1 = (totalSteps + 1);
HXDLIN( 309)				while((_g < _g1)){
HXLINE( 309)					_g = (_g + 1);
HXDLIN( 309)					int i = (_g - 1);
HXDLIN( 309)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 309)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 309)					p2 = (p2 + 1);
HXDLIN( 309)					temp[(p2 - 1)] = cx;
HXDLIN( 309)					p2 = (p2 + 1);
HXDLIN( 309)					temp[(p2 - 1)] = cy;
HXDLIN( 309)					if ((i != 0)) {
HXLINE( 309)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 309)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 309)						if (::hx::IsNotNull( m )) {
HXLINE( 309)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 309)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 309)					angle = (angle + step1);
HXDLIN( 309)					bx = cx;
HXDLIN( 309)					by = cy;
            				}
            			}
HXDLIN( 309)			int len = totalSteps;
HXDLIN( 309)			{
HXLINE( 309)				 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 309)				int color = 0;
HXDLIN( 309)				if ((color == -1)) {
HXLINE( 309)					color = _this->currentColor;
            				}
HXDLIN( 309)				_this->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN( 309)			int pA = this->pointsAnti->length;
HXDLIN( 309)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN( 309)			{
HXLINE( 309)				int _g2 = 0;
HXDLIN( 309)				int _g3 = (len1 + 2);
HXDLIN( 309)				while((_g2 < _g3)){
HXLINE( 309)					_g2 = (_g2 + 1);
HXDLIN( 309)					int i = (_g2 - 1);
HXDLIN( 309)					pA = (pA + 1);
HXDLIN( 309)					this->pointsAnti[(pA - 1)] = temp->__get(i);
            				}
            			}
HXDLIN( 309)			int pC = this->pointsClock->length;
HXDLIN( 309)			{
HXLINE( 309)				int _g4 = 1;
HXDLIN( 309)				int _g5 = ::Std_obj::_hx_int(((( (Float)(len1) ) / ( (Float)(2) )) + 1));
HXDLIN( 309)				while((_g4 < _g5)){
HXLINE( 309)					_g4 = (_g4 + 1);
HXDLIN( 309)					int i = (_g4 - 1);
HXDLIN( 309)					pC = (pC + 1);
HXDLIN( 309)					this->pointsClock[(pC - 1)] = temp->__get((temp->length - (2 * i)));
HXDLIN( 309)					pC = (pC + 1);
HXDLIN( 309)					this->pointsClock[(pC - 1)] = temp->__get(((temp->length - (2 * i)) - 1));
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Contour_obj,end,(void))

void Contour_obj::triangle2DFill(Float ax_,Float ay_,Float bx_,Float by_,Float cx_,Float cy_,::hx::Null< int >  __o_color_){
            		int color_ = __o_color_.Default(-1);
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_314_triangle2DFill)
HXDLIN( 314)		 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 314)		int color = color_;
HXDLIN( 314)		if ((color == -1)) {
HXDLIN( 314)			color = _this->currentColor;
            		}
HXDLIN( 314)		{
HXDLIN( 314)			_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx_,by_,0,cx_,cy_,0);
HXDLIN( 314)			if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN( 314)				_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            			}
HXDLIN( 314)			_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 314)		_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            	}


HX_DEFINE_DYNAMIC_FUNC7(Contour_obj,triangle2DFill,(void))

void Contour_obj::addPieXstart(Float ax,Float ay,Float radius,Float beta,Float gamma, ::fracs::DifferencePreference prefer, ::Dynamic __o_mark, ::Dynamic __o_sides){
            		 ::Dynamic mark = __o_mark;
            		if (::hx::IsNull(__o_mark)) mark = -1;
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_317_addPieXstart)
HXLINE( 318)		::Array< Float > temp = ::Array_obj< Float >::__new();
HXLINE( 320)		 ::Dynamic drawType = this->pen->drawType;
HXDLIN( 320)		 ::Dynamic sides1 = sides;
HXDLIN( 320)		if (::hx::IsNull( sides1 )) {
HXLINE( 320)			sides1 = 36;
            		}
HXDLIN( 320)		Float pi = ::Math_obj::PI;
HXDLIN( 320)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 320)		Float dif;
HXDLIN( 320)		switch((int)(prefer->_hx_getIndex())){
            			case (int)0: {
HXLINE( 320)				Float f;
HXDLIN( 320)				bool f1;
HXDLIN( 320)				if ((beta >= 0)) {
HXLINE( 320)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 320)					f1 = false;
            				}
HXDLIN( 320)				if (f1) {
HXLINE( 320)					f = beta;
            				}
            				else {
HXLINE( 320)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 320)					if ((a >= 0)) {
HXLINE( 320)						f = a;
            					}
            					else {
HXLINE( 320)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 320)				Float this1 = f;
HXDLIN( 320)				Float za = this1;
HXDLIN( 320)				Float f2;
HXDLIN( 320)				bool f3;
HXDLIN( 320)				if ((gamma >= 0)) {
HXLINE( 320)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 320)					f3 = false;
            				}
HXDLIN( 320)				if (f3) {
HXLINE( 320)					f2 = gamma;
            				}
            				else {
HXLINE( 320)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 320)					if ((a >= 0)) {
HXLINE( 320)						f2 = a;
            					}
            					else {
HXLINE( 320)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 320)				Float this2 = f2;
HXDLIN( 320)				Float zb = this2;
HXDLIN( 320)				Float fa = za;
HXDLIN( 320)				Float fb = zb;
HXDLIN( 320)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 320)				bool clockwise = (fa < fb);
HXDLIN( 320)				Float dif1;
HXDLIN( 320)				if (clockwise) {
HXLINE( 320)					dif1 = theta;
            				}
            				else {
HXLINE( 320)					dif1 = -(theta);
            				}
HXDLIN( 320)				if ((dif1 > 0)) {
HXLINE( 320)					dif = dif1;
            				}
            				else {
HXLINE( 320)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 320)				Float f;
HXDLIN( 320)				bool f1;
HXDLIN( 320)				if ((beta >= 0)) {
HXLINE( 320)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 320)					f1 = false;
            				}
HXDLIN( 320)				if (f1) {
HXLINE( 320)					f = beta;
            				}
            				else {
HXLINE( 320)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 320)					if ((a >= 0)) {
HXLINE( 320)						f = a;
            					}
            					else {
HXLINE( 320)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 320)				Float this1 = f;
HXDLIN( 320)				Float za = this1;
HXDLIN( 320)				Float f2;
HXDLIN( 320)				bool f3;
HXDLIN( 320)				if ((gamma >= 0)) {
HXLINE( 320)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 320)					f3 = false;
            				}
HXDLIN( 320)				if (f3) {
HXLINE( 320)					f2 = gamma;
            				}
            				else {
HXLINE( 320)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 320)					if ((a >= 0)) {
HXLINE( 320)						f2 = a;
            					}
            					else {
HXLINE( 320)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 320)				Float this2 = f2;
HXDLIN( 320)				Float zb = this2;
HXDLIN( 320)				Float fa = za;
HXDLIN( 320)				Float fb = zb;
HXDLIN( 320)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 320)				bool clockwise = (fa < fb);
HXDLIN( 320)				Float dif1;
HXDLIN( 320)				if (clockwise) {
HXLINE( 320)					dif1 = theta;
            				}
            				else {
HXLINE( 320)					dif1 = -(theta);
            				}
HXDLIN( 320)				if ((dif1 < 0)) {
HXLINE( 320)					dif = dif1;
            				}
            				else {
HXLINE( 320)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 320)				Float f;
HXDLIN( 320)				bool f1;
HXDLIN( 320)				if ((beta >= 0)) {
HXLINE( 320)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 320)					f1 = false;
            				}
HXDLIN( 320)				if (f1) {
HXLINE( 320)					f = beta;
            				}
            				else {
HXLINE( 320)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 320)					if ((a >= 0)) {
HXLINE( 320)						f = a;
            					}
            					else {
HXLINE( 320)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 320)				Float this1 = f;
HXDLIN( 320)				Float za = this1;
HXDLIN( 320)				Float f2;
HXDLIN( 320)				bool f3;
HXDLIN( 320)				if ((gamma >= 0)) {
HXLINE( 320)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 320)					f3 = false;
            				}
HXDLIN( 320)				if (f3) {
HXLINE( 320)					f2 = gamma;
            				}
            				else {
HXLINE( 320)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 320)					if ((a >= 0)) {
HXLINE( 320)						f2 = a;
            					}
            					else {
HXLINE( 320)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 320)				Float this2 = f2;
HXDLIN( 320)				Float zb = this2;
HXDLIN( 320)				Float fa = za;
HXDLIN( 320)				Float fb = zb;
HXDLIN( 320)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 320)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 320)				bool clockwise = (fa < fb);
HXDLIN( 320)				Float dif1;
HXDLIN( 320)				if (clockwise) {
HXLINE( 320)					dif1 = theta;
            				}
            				else {
HXLINE( 320)					dif1 = -(theta);
            				}
HXDLIN( 320)				if (smallest) {
HXLINE( 320)					dif = dif1;
            				}
            				else {
HXLINE( 320)					if (clockwise) {
HXLINE( 320)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 320)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 320)				Float f;
HXDLIN( 320)				bool f1;
HXDLIN( 320)				if ((beta >= 0)) {
HXLINE( 320)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 320)					f1 = false;
            				}
HXDLIN( 320)				if (f1) {
HXLINE( 320)					f = beta;
            				}
            				else {
HXLINE( 320)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 320)					if ((a >= 0)) {
HXLINE( 320)						f = a;
            					}
            					else {
HXLINE( 320)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 320)				Float this1 = f;
HXDLIN( 320)				Float za = this1;
HXDLIN( 320)				Float f2;
HXDLIN( 320)				bool f3;
HXDLIN( 320)				if ((gamma >= 0)) {
HXLINE( 320)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 320)					f3 = false;
            				}
HXDLIN( 320)				if (f3) {
HXLINE( 320)					f2 = gamma;
            				}
            				else {
HXLINE( 320)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 320)					if ((a >= 0)) {
HXLINE( 320)						f2 = a;
            					}
            					else {
HXLINE( 320)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 320)				Float this2 = f2;
HXDLIN( 320)				Float zb = this2;
HXDLIN( 320)				Float fa = za;
HXDLIN( 320)				Float fb = zb;
HXDLIN( 320)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 320)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 320)				bool clockwise = (fa < fb);
HXDLIN( 320)				Float dif1;
HXDLIN( 320)				if (clockwise) {
HXLINE( 320)					dif1 = theta;
            				}
            				else {
HXLINE( 320)					dif1 = -(theta);
            				}
HXDLIN( 320)				if (largest) {
HXLINE( 320)					dif = dif1;
            				}
            				else {
HXLINE( 320)					if (clockwise) {
HXLINE( 320)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 320)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 320)		bool positive = (dif >= 0);
HXDLIN( 320)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 320)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 320)		Float angle = beta;
HXDLIN( 320)		Float cx;
HXDLIN( 320)		Float cy;
HXDLIN( 320)		Float bx = ( (Float)(0) );
HXDLIN( 320)		Float by = ( (Float)(0) );
HXDLIN( 320)		int p2 = temp->length;
HXDLIN( 320)		{
HXLINE( 320)			int _g = 0;
HXDLIN( 320)			int _g1 = (totalSteps + 1);
HXDLIN( 320)			while((_g < _g1)){
HXLINE( 320)				_g = (_g + 1);
HXDLIN( 320)				int i = (_g - 1);
HXDLIN( 320)				cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 320)				cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 320)				p2 = (p2 + 1);
HXDLIN( 320)				temp[(p2 - 1)] = cx;
HXDLIN( 320)				p2 = (p2 + 1);
HXDLIN( 320)				temp[(p2 - 1)] = cy;
HXDLIN( 320)				if ((i != 0)) {
HXLINE( 320)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 320)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 320)					if (::hx::IsNotNull( m )) {
HXLINE( 320)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 320)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 320)				angle = (angle + step1);
HXDLIN( 320)				bx = cx;
HXDLIN( 320)				by = cy;
            			}
            		}
HXDLIN( 320)		int len = totalSteps;
HXLINE( 321)		{
HXLINE( 321)			 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 321)			int color = ( (int)(mark) );
HXDLIN( 321)			if ((color == -1)) {
HXLINE( 321)				color = _this->currentColor;
            			}
HXDLIN( 321)			_this->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            		}
HXLINE( 322)		int pA = this->pointsAnti->length;
HXLINE( 323)		int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXLINE( 324)		int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXLINE( 325)		{
HXLINE( 325)			int _g2 = 0;
HXDLIN( 325)			int _g3 = p4;
HXDLIN( 325)			while((_g2 < _g3)){
HXLINE( 325)				_g2 = (_g2 + 1);
HXDLIN( 325)				int i = (_g2 - 1);
HXLINE( 326)				pA = (pA + 1);
HXDLIN( 326)				this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXLINE( 327)				pA = (pA + 1);
HXDLIN( 327)				this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            			}
            		}
HXLINE( 329)		int pC = this->pointsClock->length;
HXLINE( 330)		{
HXLINE( 330)			int _g4 = 0;
HXDLIN( 330)			int _g5 = p4;
HXDLIN( 330)			while((_g4 < _g5)){
HXLINE( 330)				_g4 = (_g4 + 1);
HXDLIN( 330)				int i = (_g4 - 1);
HXLINE( 331)				pC = (pC + 1);
HXDLIN( 331)				this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXLINE( 332)				pC = (pC + 1);
HXDLIN( 332)				this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC8(Contour_obj,addPieXstart,(void))

void Contour_obj::addPieX(Float ax,Float ay,Float radius,Float beta,Float gamma, ::fracs::DifferencePreference prefer, ::Dynamic __o_mark, ::Dynamic __o_sides){
            		 ::Dynamic mark = __o_mark;
            		if (::hx::IsNull(__o_mark)) mark = 0;
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_337_addPieX)
HXLINE( 338)		::Array< Float > temp = ::Array_obj< Float >::__new();
HXLINE( 339)		 ::Dynamic drawType = this->pen->drawType;
HXDLIN( 339)		 ::Dynamic sides1 = sides;
HXLINE( 340)		if (::hx::IsNull( sides1 )) {
HXLINE( 340)			sides1 = 36;
            		}
HXLINE( 339)		Float pi = ::Math_obj::PI;
HXDLIN( 339)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 339)		Float dif;
HXDLIN( 339)		switch((int)(prefer->_hx_getIndex())){
            			case (int)0: {
HXLINE( 339)				Float f;
HXDLIN( 339)				bool f1;
HXDLIN( 339)				if ((beta >= 0)) {
HXLINE( 339)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 339)					f1 = false;
            				}
HXDLIN( 339)				if (f1) {
HXLINE( 339)					f = beta;
            				}
            				else {
HXLINE( 339)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 339)					if ((a >= 0)) {
HXLINE( 339)						f = a;
            					}
            					else {
HXLINE( 339)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 339)				Float this1 = f;
HXDLIN( 339)				Float za = this1;
HXDLIN( 339)				Float f2;
HXDLIN( 339)				bool f3;
HXDLIN( 339)				if ((gamma >= 0)) {
HXLINE( 339)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 339)					f3 = false;
            				}
HXDLIN( 339)				if (f3) {
HXLINE( 339)					f2 = gamma;
            				}
            				else {
HXLINE( 339)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 339)					if ((a >= 0)) {
HXLINE( 339)						f2 = a;
            					}
            					else {
HXLINE( 339)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 339)				Float this2 = f2;
HXDLIN( 339)				Float zb = this2;
HXDLIN( 339)				Float fa = za;
HXDLIN( 339)				Float fb = zb;
HXDLIN( 339)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 339)				bool clockwise = (fa < fb);
HXDLIN( 339)				Float dif1;
HXDLIN( 339)				if (clockwise) {
HXLINE( 339)					dif1 = theta;
            				}
            				else {
HXLINE( 339)					dif1 = -(theta);
            				}
HXDLIN( 339)				if ((dif1 > 0)) {
HXLINE( 339)					dif = dif1;
            				}
            				else {
HXLINE( 339)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 339)				Float f;
HXDLIN( 339)				bool f1;
HXDLIN( 339)				if ((beta >= 0)) {
HXLINE( 339)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 339)					f1 = false;
            				}
HXDLIN( 339)				if (f1) {
HXLINE( 339)					f = beta;
            				}
            				else {
HXLINE( 339)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 339)					if ((a >= 0)) {
HXLINE( 339)						f = a;
            					}
            					else {
HXLINE( 339)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 339)				Float this1 = f;
HXDLIN( 339)				Float za = this1;
HXDLIN( 339)				Float f2;
HXDLIN( 339)				bool f3;
HXDLIN( 339)				if ((gamma >= 0)) {
HXLINE( 339)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 339)					f3 = false;
            				}
HXDLIN( 339)				if (f3) {
HXLINE( 339)					f2 = gamma;
            				}
            				else {
HXLINE( 339)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 339)					if ((a >= 0)) {
HXLINE( 339)						f2 = a;
            					}
            					else {
HXLINE( 339)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 339)				Float this2 = f2;
HXDLIN( 339)				Float zb = this2;
HXDLIN( 339)				Float fa = za;
HXDLIN( 339)				Float fb = zb;
HXDLIN( 339)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 339)				bool clockwise = (fa < fb);
HXDLIN( 339)				Float dif1;
HXDLIN( 339)				if (clockwise) {
HXLINE( 339)					dif1 = theta;
            				}
            				else {
HXLINE( 339)					dif1 = -(theta);
            				}
HXDLIN( 339)				if ((dif1 < 0)) {
HXLINE( 339)					dif = dif1;
            				}
            				else {
HXLINE( 339)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 339)				Float f;
HXDLIN( 339)				bool f1;
HXDLIN( 339)				if ((beta >= 0)) {
HXLINE( 339)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 339)					f1 = false;
            				}
HXDLIN( 339)				if (f1) {
HXLINE( 339)					f = beta;
            				}
            				else {
HXLINE( 339)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 339)					if ((a >= 0)) {
HXLINE( 339)						f = a;
            					}
            					else {
HXLINE( 339)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 339)				Float this1 = f;
HXDLIN( 339)				Float za = this1;
HXDLIN( 339)				Float f2;
HXDLIN( 339)				bool f3;
HXDLIN( 339)				if ((gamma >= 0)) {
HXLINE( 339)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 339)					f3 = false;
            				}
HXDLIN( 339)				if (f3) {
HXLINE( 339)					f2 = gamma;
            				}
            				else {
HXLINE( 339)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 339)					if ((a >= 0)) {
HXLINE( 339)						f2 = a;
            					}
            					else {
HXLINE( 339)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 339)				Float this2 = f2;
HXDLIN( 339)				Float zb = this2;
HXDLIN( 339)				Float fa = za;
HXDLIN( 339)				Float fb = zb;
HXDLIN( 339)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 339)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 339)				bool clockwise = (fa < fb);
HXDLIN( 339)				Float dif1;
HXDLIN( 339)				if (clockwise) {
HXLINE( 339)					dif1 = theta;
            				}
            				else {
HXLINE( 339)					dif1 = -(theta);
            				}
HXDLIN( 339)				if (smallest) {
HXLINE( 339)					dif = dif1;
            				}
            				else {
HXLINE( 339)					if (clockwise) {
HXLINE( 339)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 339)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 339)				Float f;
HXDLIN( 339)				bool f1;
HXDLIN( 339)				if ((beta >= 0)) {
HXLINE( 339)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 339)					f1 = false;
            				}
HXDLIN( 339)				if (f1) {
HXLINE( 339)					f = beta;
            				}
            				else {
HXLINE( 339)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 339)					if ((a >= 0)) {
HXLINE( 339)						f = a;
            					}
            					else {
HXLINE( 339)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 339)				Float this1 = f;
HXDLIN( 339)				Float za = this1;
HXDLIN( 339)				Float f2;
HXDLIN( 339)				bool f3;
HXDLIN( 339)				if ((gamma >= 0)) {
HXLINE( 339)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 339)					f3 = false;
            				}
HXDLIN( 339)				if (f3) {
HXLINE( 339)					f2 = gamma;
            				}
            				else {
HXLINE( 339)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 339)					if ((a >= 0)) {
HXLINE( 339)						f2 = a;
            					}
            					else {
HXLINE( 339)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 339)				Float this2 = f2;
HXDLIN( 339)				Float zb = this2;
HXDLIN( 339)				Float fa = za;
HXDLIN( 339)				Float fb = zb;
HXDLIN( 339)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 339)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 339)				bool clockwise = (fa < fb);
HXDLIN( 339)				Float dif1;
HXDLIN( 339)				if (clockwise) {
HXLINE( 339)					dif1 = theta;
            				}
            				else {
HXLINE( 339)					dif1 = -(theta);
            				}
HXDLIN( 339)				if (largest) {
HXLINE( 339)					dif = dif1;
            				}
            				else {
HXLINE( 339)					if (clockwise) {
HXLINE( 339)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 339)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 339)		bool positive = (dif >= 0);
HXDLIN( 339)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 339)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 339)		Float angle = beta;
HXDLIN( 339)		Float cx;
HXDLIN( 339)		Float cy;
HXDLIN( 339)		Float bx = ( (Float)(0) );
HXDLIN( 339)		Float by = ( (Float)(0) );
HXDLIN( 339)		int p2 = temp->length;
HXDLIN( 339)		{
HXLINE( 339)			int _g = 0;
HXDLIN( 339)			int _g1 = (totalSteps + 1);
HXDLIN( 339)			while((_g < _g1)){
HXLINE( 339)				_g = (_g + 1);
HXDLIN( 339)				int i = (_g - 1);
HXDLIN( 339)				cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 339)				cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 339)				p2 = (p2 + 1);
HXDLIN( 339)				temp[(p2 - 1)] = cx;
HXDLIN( 339)				p2 = (p2 + 1);
HXDLIN( 339)				temp[(p2 - 1)] = cy;
HXDLIN( 339)				if ((i != 0)) {
HXLINE( 339)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 339)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 339)					if (::hx::IsNotNull( m )) {
HXLINE( 339)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 339)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 339)				angle = (angle + step1);
HXDLIN( 339)				bx = cx;
HXDLIN( 339)				by = cy;
            			}
            		}
HXDLIN( 339)		int len = totalSteps;
HXLINE( 341)		{
HXLINE( 341)			 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 341)			int color = ( (int)(mark) );
HXDLIN( 341)			if ((color == -1)) {
HXLINE( 341)				color = _this->currentColor;
            			}
HXDLIN( 341)			_this->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            		}
HXLINE( 344)		int pA = this->pointsAnti->length;
HXLINE( 345)		int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXLINE( 346)		{
HXLINE( 346)			int _g2 = 0;
HXDLIN( 346)			int _g3 = (len1 + 2);
HXDLIN( 346)			while((_g2 < _g3)){
HXLINE( 346)				_g2 = (_g2 + 1);
HXDLIN( 346)				int i = (_g2 - 1);
HXLINE( 347)				pA = (pA + 1);
HXDLIN( 347)				this->pointsAnti[(pA - 1)] = temp->__get(i);
            			}
            		}
HXLINE( 349)		int pC = this->pointsClock->length;
HXLINE( 350)		{
HXLINE( 350)			int _g4 = 1;
HXDLIN( 350)			int _g5 = ::Std_obj::_hx_int(((( (Float)(len1) ) / ( (Float)(2) )) + 1));
HXDLIN( 350)			while((_g4 < _g5)){
HXLINE( 350)				_g4 = (_g4 + 1);
HXDLIN( 350)				int i = (_g4 - 1);
HXLINE( 351)				pC = (pC + 1);
HXDLIN( 351)				this->pointsClock[(pC - 1)] = temp->__get((temp->length - (2 * i)));
HXLINE( 352)				pC = (pC + 1);
HXDLIN( 352)				this->pointsClock[(pC - 1)] = temp->__get(((temp->length - (2 * i)) - 1));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC8(Contour_obj,addPieX,(void))

void Contour_obj::addPie(Float ax,Float ay,Float radius,Float beta,Float gamma, ::fracs::DifferencePreference prefer, ::Dynamic __o_mark, ::Dynamic __o_sides){
            		 ::Dynamic mark = __o_mark;
            		if (::hx::IsNull(__o_mark)) mark = 0;
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_357_addPie)
HXLINE( 358)		 ::Dynamic drawType = this->pen->drawType;
HXDLIN( 358)		 ::Dynamic sides1 = sides;
HXLINE( 359)		if (::hx::IsNull( sides1 )) {
HXLINE( 359)			sides1 = 36;
            		}
HXLINE( 358)		Float pi = ::Math_obj::PI;
HXDLIN( 358)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 358)		Float dif;
HXDLIN( 358)		switch((int)(prefer->_hx_getIndex())){
            			case (int)0: {
HXLINE( 358)				Float f;
HXDLIN( 358)				bool f1;
HXDLIN( 358)				if ((beta >= 0)) {
HXLINE( 358)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 358)					f1 = false;
            				}
HXDLIN( 358)				if (f1) {
HXLINE( 358)					f = beta;
            				}
            				else {
HXLINE( 358)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 358)					if ((a >= 0)) {
HXLINE( 358)						f = a;
            					}
            					else {
HXLINE( 358)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 358)				Float this1 = f;
HXDLIN( 358)				Float za = this1;
HXDLIN( 358)				Float f2;
HXDLIN( 358)				bool f3;
HXDLIN( 358)				if ((gamma >= 0)) {
HXLINE( 358)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 358)					f3 = false;
            				}
HXDLIN( 358)				if (f3) {
HXLINE( 358)					f2 = gamma;
            				}
            				else {
HXLINE( 358)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 358)					if ((a >= 0)) {
HXLINE( 358)						f2 = a;
            					}
            					else {
HXLINE( 358)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 358)				Float this2 = f2;
HXDLIN( 358)				Float zb = this2;
HXDLIN( 358)				Float fa = za;
HXDLIN( 358)				Float fb = zb;
HXDLIN( 358)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 358)				bool clockwise = (fa < fb);
HXDLIN( 358)				Float dif1;
HXDLIN( 358)				if (clockwise) {
HXLINE( 358)					dif1 = theta;
            				}
            				else {
HXLINE( 358)					dif1 = -(theta);
            				}
HXDLIN( 358)				if ((dif1 > 0)) {
HXLINE( 358)					dif = dif1;
            				}
            				else {
HXLINE( 358)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 358)				Float f;
HXDLIN( 358)				bool f1;
HXDLIN( 358)				if ((beta >= 0)) {
HXLINE( 358)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 358)					f1 = false;
            				}
HXDLIN( 358)				if (f1) {
HXLINE( 358)					f = beta;
            				}
            				else {
HXLINE( 358)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 358)					if ((a >= 0)) {
HXLINE( 358)						f = a;
            					}
            					else {
HXLINE( 358)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 358)				Float this1 = f;
HXDLIN( 358)				Float za = this1;
HXDLIN( 358)				Float f2;
HXDLIN( 358)				bool f3;
HXDLIN( 358)				if ((gamma >= 0)) {
HXLINE( 358)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 358)					f3 = false;
            				}
HXDLIN( 358)				if (f3) {
HXLINE( 358)					f2 = gamma;
            				}
            				else {
HXLINE( 358)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 358)					if ((a >= 0)) {
HXLINE( 358)						f2 = a;
            					}
            					else {
HXLINE( 358)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 358)				Float this2 = f2;
HXDLIN( 358)				Float zb = this2;
HXDLIN( 358)				Float fa = za;
HXDLIN( 358)				Float fb = zb;
HXDLIN( 358)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 358)				bool clockwise = (fa < fb);
HXDLIN( 358)				Float dif1;
HXDLIN( 358)				if (clockwise) {
HXLINE( 358)					dif1 = theta;
            				}
            				else {
HXLINE( 358)					dif1 = -(theta);
            				}
HXDLIN( 358)				if ((dif1 < 0)) {
HXLINE( 358)					dif = dif1;
            				}
            				else {
HXLINE( 358)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 358)				Float f;
HXDLIN( 358)				bool f1;
HXDLIN( 358)				if ((beta >= 0)) {
HXLINE( 358)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 358)					f1 = false;
            				}
HXDLIN( 358)				if (f1) {
HXLINE( 358)					f = beta;
            				}
            				else {
HXLINE( 358)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 358)					if ((a >= 0)) {
HXLINE( 358)						f = a;
            					}
            					else {
HXLINE( 358)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 358)				Float this1 = f;
HXDLIN( 358)				Float za = this1;
HXDLIN( 358)				Float f2;
HXDLIN( 358)				bool f3;
HXDLIN( 358)				if ((gamma >= 0)) {
HXLINE( 358)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 358)					f3 = false;
            				}
HXDLIN( 358)				if (f3) {
HXLINE( 358)					f2 = gamma;
            				}
            				else {
HXLINE( 358)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 358)					if ((a >= 0)) {
HXLINE( 358)						f2 = a;
            					}
            					else {
HXLINE( 358)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 358)				Float this2 = f2;
HXDLIN( 358)				Float zb = this2;
HXDLIN( 358)				Float fa = za;
HXDLIN( 358)				Float fb = zb;
HXDLIN( 358)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 358)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 358)				bool clockwise = (fa < fb);
HXDLIN( 358)				Float dif1;
HXDLIN( 358)				if (clockwise) {
HXLINE( 358)					dif1 = theta;
            				}
            				else {
HXLINE( 358)					dif1 = -(theta);
            				}
HXDLIN( 358)				if (smallest) {
HXLINE( 358)					dif = dif1;
            				}
            				else {
HXLINE( 358)					if (clockwise) {
HXLINE( 358)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 358)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 358)				Float f;
HXDLIN( 358)				bool f1;
HXDLIN( 358)				if ((beta >= 0)) {
HXLINE( 358)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 358)					f1 = false;
            				}
HXDLIN( 358)				if (f1) {
HXLINE( 358)					f = beta;
            				}
            				else {
HXLINE( 358)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 358)					if ((a >= 0)) {
HXLINE( 358)						f = a;
            					}
            					else {
HXLINE( 358)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 358)				Float this1 = f;
HXDLIN( 358)				Float za = this1;
HXDLIN( 358)				Float f2;
HXDLIN( 358)				bool f3;
HXDLIN( 358)				if ((gamma >= 0)) {
HXLINE( 358)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 358)					f3 = false;
            				}
HXDLIN( 358)				if (f3) {
HXLINE( 358)					f2 = gamma;
            				}
            				else {
HXLINE( 358)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 358)					if ((a >= 0)) {
HXLINE( 358)						f2 = a;
            					}
            					else {
HXLINE( 358)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 358)				Float this2 = f2;
HXDLIN( 358)				Float zb = this2;
HXDLIN( 358)				Float fa = za;
HXDLIN( 358)				Float fb = zb;
HXDLIN( 358)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 358)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 358)				bool clockwise = (fa < fb);
HXDLIN( 358)				Float dif1;
HXDLIN( 358)				if (clockwise) {
HXLINE( 358)					dif1 = theta;
            				}
            				else {
HXLINE( 358)					dif1 = -(theta);
            				}
HXDLIN( 358)				if (largest) {
HXLINE( 358)					dif = dif1;
            				}
            				else {
HXLINE( 358)					if (clockwise) {
HXLINE( 358)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 358)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 358)		bool positive = (dif >= 0);
HXDLIN( 358)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 358)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 358)		Float angle = beta;
HXDLIN( 358)		Float cx;
HXDLIN( 358)		Float cy;
HXDLIN( 358)		Float bx = ( (Float)(0) );
HXDLIN( 358)		Float by = ( (Float)(0) );
HXDLIN( 358)		{
HXLINE( 358)			int _g = 0;
HXDLIN( 358)			int _g1 = (totalSteps + 1);
HXDLIN( 358)			while((_g < _g1)){
HXLINE( 358)				_g = (_g + 1);
HXDLIN( 358)				int i = (_g - 1);
HXDLIN( 358)				cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 358)				cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 358)				if ((i != 0)) {
HXLINE( 358)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 358)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 358)					if (::hx::IsNotNull( m )) {
HXLINE( 358)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 358)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 358)				angle = (angle + step1);
HXDLIN( 358)				bx = cx;
HXDLIN( 358)				by = cy;
            			}
            		}
HXDLIN( 358)		int len = totalSteps;
HXLINE( 360)		{
HXLINE( 360)			 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 360)			int color = ( (int)(mark) );
HXDLIN( 360)			if ((color == -1)) {
HXLINE( 360)				color = _this->currentColor;
            			}
HXDLIN( 360)			_this->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC8(Contour_obj,addPie,(void))

void Contour_obj::computeJ(Float width_,Float theta0,Float dif){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_363_computeJ)
HXLINE( 364)		Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
HXLINE( 365)		Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
HXLINE( 366)		Float f;
HXDLIN( 366)		bool f1;
HXDLIN( 366)		if ((theta0 <= ::Math_obj::PI)) {
HXLINE( 366)			f1 = (theta0 > -(::Math_obj::PI));
            		}
            		else {
HXLINE( 366)			f1 = false;
            		}
HXDLIN( 366)		if (f1) {
HXLINE( 366)			f = theta0;
            		}
            		else {
HXLINE( 366)			Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 366)			if ((a >= 0)) {
HXLINE( 366)				f = (a - ::Math_obj::PI);
            			}
            			else {
HXLINE( 366)				f = (a + ::Math_obj::PI);
            			}
            		}
HXDLIN( 366)		Float this1 = f;
HXDLIN( 366)		Float start = this1;
HXLINE( 367)		Float start2 = start;
HXLINE( 368)		Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
HXLINE( 369)		this->jx = (this->ax + (h * ::Math_obj::sin(delta)));
HXLINE( 370)		this->jy = (this->ay + (h * ::Math_obj::cos(delta)));
            	}


HX_DEFINE_DYNAMIC_FUNC3(Contour_obj,computeJ,(void))

void Contour_obj::addDot(Float x,Float y,int color,Float width_){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_373_addDot)
HXLINE( 374)		Float w = (width_ * ((Float)0.07));
HXLINE( 375)		 ::Dynamic drawType = this->pen->drawType;
HXDLIN( 375)		Float pi = ::Math_obj::PI;
HXDLIN( 375)		Float theta = (pi / ( (Float)(2) ));
HXDLIN( 375)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 375)		Float bx;
HXDLIN( 375)		Float by;
HXDLIN( 375)		Float cx;
HXDLIN( 375)		Float cy;
HXDLIN( 375)		{
HXLINE( 375)			int _g = 0;
HXDLIN( 375)			 ::Dynamic _g1 = 36;
HXDLIN( 375)			while(::hx::IsLess( _g,_g1 )){
HXLINE( 375)				_g = (_g + 1);
HXDLIN( 375)				int i = (_g - 1);
HXDLIN( 375)				bx = (x + (w * ::Math_obj::sin(theta)));
HXDLIN( 375)				by = (y + (w * ::Math_obj::cos(theta)));
HXDLIN( 375)				theta = (theta + step);
HXDLIN( 375)				cx = (x + (w * ::Math_obj::sin(theta)));
HXDLIN( 375)				cy = (y + (w * ::Math_obj::cos(theta)));
HXDLIN( 375)				{
HXLINE( 375)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(x,y,0,bx,by,0,cx,cy,0);
HXDLIN( 375)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 375)					if (::hx::IsNotNull( m )) {
HXLINE( 375)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 375)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN( 375)		int len = 36;
HXLINE( 376)		{
HXLINE( 376)			 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 376)			int color1 = color;
HXDLIN( 376)			if ((color1 == -1)) {
HXLINE( 376)				color1 = _this->currentColor;
            			}
HXDLIN( 376)			_this->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Contour_obj,addDot,(void))

void Contour_obj::addSmallTriangles(bool clockWise,Float width_){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_400_addSmallTriangles)
HXDLIN( 400)		if (clockWise) {
HXLINE( 401)			{
HXLINE( 401)				 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 401)				int color = -1;
HXDLIN( 401)				if ((color == -1)) {
HXLINE( 401)					color = _this->currentColor;
            				}
HXDLIN( 401)				{
HXLINE( 401)					_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->ax,this->ay,0,( (Float)(this->dxOld) ),( (Float)(this->dyOld) ),0,this->jx,this->jy,0);
HXDLIN( 401)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 401)						_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN( 401)					_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 401)				_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXLINE( 402)			{
HXLINE( 402)				 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 402)				int color1 = -1;
HXDLIN( 402)				if ((color1 == -1)) {
HXLINE( 402)					color1 = _this1->currentColor;
            				}
HXDLIN( 402)				{
HXLINE( 402)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->ax,this->ay,0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0,this->jx,this->jy,0);
HXDLIN( 402)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 402)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN( 402)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 402)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
            		else {
HXLINE( 405)			{
HXLINE( 405)				 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 405)				int color = -1;
HXDLIN( 405)				if ((color == -1)) {
HXLINE( 405)					color = _this->currentColor;
            				}
HXDLIN( 405)				{
HXLINE( 405)					_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->ax,this->ay,0,( (Float)(this->exOld) ),( (Float)(this->eyOld) ),0,this->jx,this->jy,0);
HXDLIN( 405)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 405)						_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN( 405)					_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 405)				_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXLINE( 406)			{
HXLINE( 406)				 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 406)				int color1 = -1;
HXDLIN( 406)				if ((color1 == -1)) {
HXLINE( 406)					color1 = _this1->currentColor;
            				}
HXDLIN( 406)				{
HXLINE( 406)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->ax,this->ay,0,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,this->jx,this->jy,0);
HXDLIN( 406)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 406)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN( 406)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 406)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,addSmallTriangles,(void))

void Contour_obj::triangle2DFillangleCorners(Float oldx_,Float oldy_,Float prevx_,Float prevy_,Float width_){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_411_triangle2DFillangleCorners)
HXLINE( 412)		Float w = (width_ * ((Float)0.07));
HXLINE( 413)		 ::Dynamic drawType = this->pen->drawType;
HXDLIN( 413)		Float pi = ::Math_obj::PI;
HXDLIN( 413)		Float theta = (pi / ( (Float)(2) ));
HXDLIN( 413)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 413)		Float bx;
HXDLIN( 413)		Float by;
HXDLIN( 413)		Float cx;
HXDLIN( 413)		Float cy;
HXDLIN( 413)		{
HXLINE( 413)			int _g = 0;
HXDLIN( 413)			 ::Dynamic _g1 = 36;
HXDLIN( 413)			while(::hx::IsLess( _g,_g1 )){
HXLINE( 413)				_g = (_g + 1);
HXDLIN( 413)				int i = (_g - 1);
HXDLIN( 413)				bx = (oldx_ + (w * ::Math_obj::sin(theta)));
HXDLIN( 413)				by = (oldy_ + (w * ::Math_obj::cos(theta)));
HXDLIN( 413)				theta = (theta + step);
HXDLIN( 413)				cx = (oldx_ + (w * ::Math_obj::sin(theta)));
HXDLIN( 413)				cy = (oldy_ + (w * ::Math_obj::cos(theta)));
HXDLIN( 413)				{
HXLINE( 413)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(oldx_,oldy_,0,bx,by,0,cx,cy,0);
HXDLIN( 413)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 413)					if (::hx::IsNotNull( m )) {
HXLINE( 413)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 413)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN( 413)		int len = 36;
HXLINE( 414)		{
HXLINE( 414)			 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 414)			int color = this->debugCol4;
HXDLIN( 414)			if ((color == -1)) {
HXLINE( 414)				color = _this->currentColor;
            			}
HXDLIN( 414)			_this->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            		}
HXLINE( 415)		 ::Dynamic drawType1 = this->pen->drawType;
HXDLIN( 415)		Float pi1 = ::Math_obj::PI;
HXDLIN( 415)		Float theta1 = (pi1 / ( (Float)(2) ));
HXDLIN( 415)		Float step1 = ((pi1 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 415)		Float bx1;
HXDLIN( 415)		Float by1;
HXDLIN( 415)		Float cx1;
HXDLIN( 415)		Float cy1;
HXDLIN( 415)		{
HXLINE( 415)			int _g2 = 0;
HXDLIN( 415)			 ::Dynamic _g3 = 36;
HXDLIN( 415)			while(::hx::IsLess( _g2,_g3 )){
HXLINE( 415)				_g2 = (_g2 + 1);
HXDLIN( 415)				int i = (_g2 - 1);
HXDLIN( 415)				bx1 = (prevx_ + (w * ::Math_obj::sin(theta1)));
HXDLIN( 415)				by1 = (prevy_ + (w * ::Math_obj::cos(theta1)));
HXDLIN( 415)				theta1 = (theta1 + step1);
HXDLIN( 415)				cx1 = (prevx_ + (w * ::Math_obj::sin(theta1)));
HXDLIN( 415)				cy1 = (prevy_ + (w * ::Math_obj::cos(theta1)));
HXDLIN( 415)				{
HXLINE( 415)					drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(prevx_,prevy_,0,bx1,by1,0,cx1,cy1,0);
HXDLIN( 415)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 415)					if (::hx::IsNotNull( m )) {
HXLINE( 415)						drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 415)					drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN( 415)		len = 36;
HXLINE( 416)		{
HXLINE( 416)			 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 416)			int color1 = this->debugCol3;
HXDLIN( 416)			if ((color1 == -1)) {
HXLINE( 416)				color1 = _this1->currentColor;
            			}
HXDLIN( 416)			_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len);
            		}
HXLINE( 417)		 ::Dynamic drawType2 = this->pen->drawType;
HXDLIN( 417)		Float ax = this->ax;
HXDLIN( 417)		Float ay = this->ay;
HXDLIN( 417)		Float pi2 = ::Math_obj::PI;
HXDLIN( 417)		Float theta2 = (pi2 / ( (Float)(2) ));
HXDLIN( 417)		Float step2 = ((pi2 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 417)		Float bx2;
HXDLIN( 417)		Float by2;
HXDLIN( 417)		Float cx2;
HXDLIN( 417)		Float cy2;
HXDLIN( 417)		{
HXLINE( 417)			int _g4 = 0;
HXDLIN( 417)			 ::Dynamic _g5 = 36;
HXDLIN( 417)			while(::hx::IsLess( _g4,_g5 )){
HXLINE( 417)				_g4 = (_g4 + 1);
HXDLIN( 417)				int i = (_g4 - 1);
HXDLIN( 417)				bx2 = (ax + (w * ::Math_obj::sin(theta2)));
HXDLIN( 417)				by2 = (ay + (w * ::Math_obj::cos(theta2)));
HXDLIN( 417)				theta2 = (theta2 + step2);
HXDLIN( 417)				cx2 = (ax + (w * ::Math_obj::sin(theta2)));
HXDLIN( 417)				cy2 = (ay + (w * ::Math_obj::cos(theta2)));
HXDLIN( 417)				{
HXLINE( 417)					drawType2->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx2,by2,0,cx2,cy2,0);
HXDLIN( 417)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 417)					if (::hx::IsNotNull( m )) {
HXLINE( 417)						drawType2->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 417)					drawType2->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN( 417)		len = 36;
HXLINE( 418)		{
HXLINE( 418)			 ::trilateral3::drawing::Pen _this2 = this->pen;
HXDLIN( 418)			int color2 = this->debugCol10;
HXDLIN( 418)			if ((color2 == -1)) {
HXLINE( 418)				color2 = _this2->currentColor;
            			}
HXDLIN( 418)			_this2->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color2,len);
            		}
HXLINE( 419)		 ::Dynamic drawType3 = this->pen->drawType;
HXDLIN( 419)		Float ax1 = this->jx;
HXDLIN( 419)		Float ay1 = this->jy;
HXDLIN( 419)		Float pi3 = ::Math_obj::PI;
HXDLIN( 419)		Float theta3 = (pi3 / ( (Float)(2) ));
HXDLIN( 419)		Float step3 = ((pi3 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 419)		Float bx3;
HXDLIN( 419)		Float by3;
HXDLIN( 419)		Float cx3;
HXDLIN( 419)		Float cy3;
HXDLIN( 419)		{
HXLINE( 419)			int _g6 = 0;
HXDLIN( 419)			 ::Dynamic _g7 = 36;
HXDLIN( 419)			while(::hx::IsLess( _g6,_g7 )){
HXLINE( 419)				_g6 = (_g6 + 1);
HXDLIN( 419)				int i = (_g6 - 1);
HXDLIN( 419)				bx3 = (ax1 + (w * ::Math_obj::sin(theta3)));
HXDLIN( 419)				by3 = (ay1 + (w * ::Math_obj::cos(theta3)));
HXDLIN( 419)				theta3 = (theta3 + step3);
HXDLIN( 419)				cx3 = (ax1 + (w * ::Math_obj::sin(theta3)));
HXDLIN( 419)				cy3 = (ay1 + (w * ::Math_obj::cos(theta3)));
HXDLIN( 419)				{
HXLINE( 419)					drawType3->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax1,ay1,0,bx3,by3,0,cx3,cy3,0);
HXDLIN( 419)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 419)					if (::hx::IsNotNull( m )) {
HXLINE( 419)						drawType3->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 419)					drawType3->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN( 419)		len = 36;
HXLINE( 420)		{
HXLINE( 420)			 ::trilateral3::drawing::Pen _this3 = this->pen;
HXDLIN( 420)			int color3 = this->debugCol5;
HXDLIN( 420)			if ((color3 == -1)) {
HXLINE( 420)				color3 = _this3->currentColor;
            			}
HXDLIN( 420)			_this3->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color3,len);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(Contour_obj,triangle2DFillangleCorners,(void))

void Contour_obj::triangle2DFillangleCornersLess(Float oldx_,Float oldy_,Float prevx_,Float prevy_,Float width_){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_423_triangle2DFillangleCornersLess)
HXLINE( 424)		Float w = (width_ * ((Float)0.07));
HXLINE( 425)		 ::Dynamic drawType = this->pen->drawType;
HXDLIN( 425)		Float pi = ::Math_obj::PI;
HXDLIN( 425)		Float theta = (pi / ( (Float)(2) ));
HXDLIN( 425)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 425)		Float bx;
HXDLIN( 425)		Float by;
HXDLIN( 425)		Float cx;
HXDLIN( 425)		Float cy;
HXDLIN( 425)		{
HXLINE( 425)			int _g = 0;
HXDLIN( 425)			 ::Dynamic _g1 = 36;
HXDLIN( 425)			while(::hx::IsLess( _g,_g1 )){
HXLINE( 425)				_g = (_g + 1);
HXDLIN( 425)				int i = (_g - 1);
HXDLIN( 425)				bx = (oldx_ + (w * ::Math_obj::sin(theta)));
HXDLIN( 425)				by = (oldy_ + (w * ::Math_obj::cos(theta)));
HXDLIN( 425)				theta = (theta + step);
HXDLIN( 425)				cx = (oldx_ + (w * ::Math_obj::sin(theta)));
HXDLIN( 425)				cy = (oldy_ + (w * ::Math_obj::cos(theta)));
HXDLIN( 425)				{
HXLINE( 425)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(oldx_,oldy_,0,bx,by,0,cx,cy,0);
HXDLIN( 425)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 425)					if (::hx::IsNotNull( m )) {
HXLINE( 425)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 425)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN( 425)		int len = 36;
HXLINE( 426)		{
HXLINE( 426)			 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 426)			int color = this->debugCol4;
HXDLIN( 426)			if ((color == -1)) {
HXLINE( 426)				color = _this->currentColor;
            			}
HXDLIN( 426)			_this->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            		}
HXLINE( 427)		 ::Dynamic drawType1 = this->pen->drawType;
HXDLIN( 427)		Float pi1 = ::Math_obj::PI;
HXDLIN( 427)		Float theta1 = (pi1 / ( (Float)(2) ));
HXDLIN( 427)		Float step1 = ((pi1 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 427)		Float bx1;
HXDLIN( 427)		Float by1;
HXDLIN( 427)		Float cx1;
HXDLIN( 427)		Float cy1;
HXDLIN( 427)		{
HXLINE( 427)			int _g2 = 0;
HXDLIN( 427)			 ::Dynamic _g3 = 36;
HXDLIN( 427)			while(::hx::IsLess( _g2,_g3 )){
HXLINE( 427)				_g2 = (_g2 + 1);
HXDLIN( 427)				int i = (_g2 - 1);
HXDLIN( 427)				bx1 = (prevx_ + (w * ::Math_obj::sin(theta1)));
HXDLIN( 427)				by1 = (prevy_ + (w * ::Math_obj::cos(theta1)));
HXDLIN( 427)				theta1 = (theta1 + step1);
HXDLIN( 427)				cx1 = (prevx_ + (w * ::Math_obj::sin(theta1)));
HXDLIN( 427)				cy1 = (prevy_ + (w * ::Math_obj::cos(theta1)));
HXDLIN( 427)				{
HXLINE( 427)					drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(prevx_,prevy_,0,bx1,by1,0,cx1,cy1,0);
HXDLIN( 427)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 427)					if (::hx::IsNotNull( m )) {
HXLINE( 427)						drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 427)					drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN( 427)		len = 36;
HXLINE( 428)		{
HXLINE( 428)			 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 428)			int color1 = this->debugCol3;
HXDLIN( 428)			if ((color1 == -1)) {
HXLINE( 428)				color1 = _this1->currentColor;
            			}
HXDLIN( 428)			_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len);
            		}
HXLINE( 429)		 ::Dynamic drawType2 = this->pen->drawType;
HXDLIN( 429)		Float ax = this->jx;
HXDLIN( 429)		Float ay = this->jy;
HXDLIN( 429)		Float pi2 = ::Math_obj::PI;
HXDLIN( 429)		Float theta2 = (pi2 / ( (Float)(2) ));
HXDLIN( 429)		Float step2 = ((pi2 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 429)		Float bx2;
HXDLIN( 429)		Float by2;
HXDLIN( 429)		Float cx2;
HXDLIN( 429)		Float cy2;
HXDLIN( 429)		{
HXLINE( 429)			int _g4 = 0;
HXDLIN( 429)			 ::Dynamic _g5 = 36;
HXDLIN( 429)			while(::hx::IsLess( _g4,_g5 )){
HXLINE( 429)				_g4 = (_g4 + 1);
HXDLIN( 429)				int i = (_g4 - 1);
HXDLIN( 429)				bx2 = (ax + (w * ::Math_obj::sin(theta2)));
HXDLIN( 429)				by2 = (ay + (w * ::Math_obj::cos(theta2)));
HXDLIN( 429)				theta2 = (theta2 + step2);
HXDLIN( 429)				cx2 = (ax + (w * ::Math_obj::sin(theta2)));
HXDLIN( 429)				cy2 = (ay + (w * ::Math_obj::cos(theta2)));
HXDLIN( 429)				{
HXLINE( 429)					drawType2->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx2,by2,0,cx2,cy2,0);
HXDLIN( 429)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 429)					if (::hx::IsNotNull( m )) {
HXLINE( 429)						drawType2->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 429)					drawType2->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN( 429)		len = 36;
HXLINE( 430)		{
HXLINE( 430)			 ::trilateral3::drawing::Pen _this2 = this->pen;
HXDLIN( 430)			int color2 = this->debugCol5;
HXDLIN( 430)			if ((color2 == -1)) {
HXLINE( 430)				color2 = _this2->currentColor;
            			}
HXDLIN( 430)			_this2->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color2,len);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(Contour_obj,triangle2DFillangleCornersLess,(void))

void Contour_obj::connectQuadsWhenQuadsOverlay(bool clockWise,Float width_){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_435_connectQuadsWhenQuadsOverlay)
HXDLIN( 435)		if (clockWise) {
HXLINE( 436)			 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 436)			int color = -1;
HXDLIN( 436)			if ((color == -1)) {
HXLINE( 436)				color = _this->currentColor;
            			}
HXDLIN( 436)			{
HXLINE( 436)				_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxOld) ),( (Float)(this->dyOld) ),0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0,this->ax,this->ay,0);
HXDLIN( 436)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 436)					_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN( 436)				_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 436)			_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            		}
            		else {
HXLINE( 441)			 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 441)			int color = -1;
HXDLIN( 441)			if ((color == -1)) {
HXLINE( 441)				color = _this->currentColor;
            			}
HXDLIN( 441)			{
HXLINE( 441)				_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->exOld) ),( (Float)(this->eyOld) ),0,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,this->ax,this->ay,0);
HXDLIN( 441)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 441)					_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN( 441)				_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 441)			_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,connectQuadsWhenQuadsOverlay,(void))

void Contour_obj::connectQuads(bool clockWise,Float width_){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_450_connectQuads)
HXDLIN( 450)		if (clockWise) {
HXLINE( 451)			 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 451)			int color = -1;
HXDLIN( 451)			if ((color == -1)) {
HXLINE( 451)				color = _this->currentColor;
            			}
HXDLIN( 451)			{
HXLINE( 451)				_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxOld) ),( (Float)(this->dyOld) ),0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0,this->jx,this->jy,0);
HXDLIN( 451)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 451)					_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN( 451)				_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 451)			_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            		}
            		else {
HXLINE( 456)			 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 456)			int color = -1;
HXDLIN( 456)			if ((color == -1)) {
HXLINE( 456)				color = _this->currentColor;
            			}
HXDLIN( 456)			{
HXLINE( 456)				_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->exOld) ),( (Float)(this->eyOld) ),0,( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,this->jx,this->jy,0);
HXDLIN( 456)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 456)					_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN( 456)				_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 456)			_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,connectQuads,(void))

void Contour_obj::addInitialQuads(bool clockWise,Float width_){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_465_addInitialQuads)
HXLINE( 468)		this->quadIndex = ( (Float)(this->pen->drawType->__Field(HX_("get_pos",2b,26,ca,26),::hx::paccDynamic)()) );
HXLINE( 470)		if ((this->count == 0)) {
HXLINE( 471)			this->penultimateAX = ( (Float)(this->dxPrev) );
HXLINE( 472)			this->penultimateAY = ( (Float)(this->dyPrev) );
HXLINE( 473)			this->lastAntiX = ( (Float)(this->ex) );
HXLINE( 474)			this->lastAntiY = ( (Float)(this->ey) );
HXLINE( 475)			this->penultimateCX = ( (Float)(this->dx) );
HXLINE( 476)			this->penultimateCY = ( (Float)(this->dy) );
HXLINE( 477)			this->lastClockX = ( (Float)(this->exPrev) );
HXLINE( 478)			this->lastClockY = ( (Float)(this->eyPrev) );
HXLINE( 479)			{
HXLINE( 479)				 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 479)				int color = -1;
HXDLIN( 479)				if ((color == -1)) {
HXLINE( 479)					color = _this->currentColor;
            				}
HXDLIN( 479)				{
HXLINE( 479)					_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 479)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 479)						_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN( 479)					_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 479)				_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXLINE( 481)			{
HXLINE( 481)				 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 481)				int color1 = -1;
HXDLIN( 481)				if ((color1 == -1)) {
HXLINE( 481)					color1 = _this1->currentColor;
            				}
HXDLIN( 481)				{
HXLINE( 481)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0);
HXDLIN( 481)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 481)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN( 481)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 481)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
            		else {
HXLINE( 484)			bool _hx_tmp;
HXDLIN( 484)			if (clockWise) {
HXLINE( 484)				_hx_tmp = !(this->lastClock);
            			}
            			else {
HXLINE( 484)				_hx_tmp = false;
            			}
HXDLIN( 484)			if (_hx_tmp) {
HXLINE( 485)				this->penultimateAX = this->jx;
HXLINE( 486)				this->penultimateAY = this->jy;
HXLINE( 487)				this->lastAntiX = ( (Float)(this->ex) );
HXLINE( 488)				this->lastAntiY = ( (Float)(this->ey) );
HXLINE( 489)				this->penultimateCX = ( (Float)(this->dx) );
HXLINE( 490)				this->penultimateCY = ( (Float)(this->dy) );
HXLINE( 491)				this->lastClockX = ( (Float)(this->exPrev) );
HXLINE( 492)				this->lastClockY = ( (Float)(this->eyPrev) );
HXLINE( 494)				{
HXLINE( 494)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 494)					int color = -1;
HXDLIN( 494)					if ((color == -1)) {
HXLINE( 494)						color = _this->currentColor;
            					}
HXDLIN( 494)					{
HXLINE( 494)						_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jx,this->jy,0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 494)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 494)							_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 494)						_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 494)					_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXLINE( 496)				{
HXLINE( 496)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 496)					int color1 = -1;
HXDLIN( 496)					if ((color1 == -1)) {
HXLINE( 496)						color1 = _this1->currentColor;
            					}
HXDLIN( 496)					{
HXLINE( 496)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jx,this->jy,0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0);
HXDLIN( 496)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 496)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 496)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 496)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
HXLINE( 499)			bool _hx_tmp1;
HXDLIN( 499)			if (clockWise) {
HXLINE( 499)				_hx_tmp1 = this->lastClock;
            			}
            			else {
HXLINE( 499)				_hx_tmp1 = false;
            			}
HXDLIN( 499)			if (_hx_tmp1) {
HXLINE( 500)				this->penultimateAX = this->jx;
HXLINE( 501)				this->penultimateAY = this->jy;
HXLINE( 502)				this->lastAntiX = ( (Float)(this->ex) );
HXLINE( 503)				this->lastAntiY = ( (Float)(this->ey) );
HXLINE( 504)				this->penultimateCX = ( (Float)(this->dx) );
HXLINE( 505)				this->penultimateCY = ( (Float)(this->dy) );
HXLINE( 506)				this->lastClockX = ( (Float)(this->exPrev) );
HXLINE( 507)				this->lastClockY = ( (Float)(this->eyPrev) );
HXLINE( 509)				{
HXLINE( 509)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 509)					int color = -1;
HXDLIN( 509)					if ((color == -1)) {
HXLINE( 509)						color = _this->currentColor;
            					}
HXDLIN( 509)					{
HXLINE( 509)						_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jx,this->jy,0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 509)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 509)							_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 509)						_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 509)					_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXLINE( 511)				{
HXLINE( 511)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 511)					int color1 = -1;
HXDLIN( 511)					if ((color1 == -1)) {
HXLINE( 511)						color1 = _this1->currentColor;
            					}
HXDLIN( 511)					{
HXLINE( 511)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jx,this->jy,0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->exPrev) ),( (Float)(this->eyPrev) ),0);
HXDLIN( 511)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 511)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 511)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 511)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
HXLINE( 514)			bool _hx_tmp2;
HXDLIN( 514)			if (!(clockWise)) {
HXLINE( 514)				_hx_tmp2 = !(this->lastClock);
            			}
            			else {
HXLINE( 514)				_hx_tmp2 = false;
            			}
HXDLIN( 514)			if (_hx_tmp2) {
HXLINE( 515)				this->penultimateCX = ( (Float)(this->dx) );
HXLINE( 516)				this->penultimateCY = ( (Float)(this->dy) );
HXLINE( 517)				this->lastClockX = this->jx;
HXLINE( 518)				this->lastClockY = this->jy;
HXLINE( 519)				this->penultimateAX = ( (Float)(this->dxPrev) );
HXLINE( 520)				this->penultimateAY = ( (Float)(this->dyPrev) );
HXLINE( 521)				this->lastAntiX = ( (Float)(this->ex) );
HXLINE( 522)				this->lastAntiY = ( (Float)(this->ey) );
HXLINE( 524)				{
HXLINE( 524)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 524)					int color = -1;
HXDLIN( 524)					if ((color == -1)) {
HXLINE( 524)						color = _this->currentColor;
            					}
HXDLIN( 524)					{
HXLINE( 524)						_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,this->jx,this->jy,0);
HXDLIN( 524)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 524)							_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 524)						_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 524)					_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXLINE( 526)				{
HXLINE( 526)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 526)					int color1 = -1;
HXDLIN( 526)					if ((color1 == -1)) {
HXLINE( 526)						color1 = _this1->currentColor;
            					}
HXDLIN( 526)					{
HXLINE( 526)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 526)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 526)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 526)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 526)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
HXLINE( 529)			bool _hx_tmp3;
HXDLIN( 529)			if (!(clockWise)) {
HXLINE( 529)				_hx_tmp3 = this->lastClock;
            			}
            			else {
HXLINE( 529)				_hx_tmp3 = false;
            			}
HXDLIN( 529)			if (_hx_tmp3) {
HXLINE( 530)				this->penultimateAX = ( (Float)(this->dxPrev) );
HXLINE( 531)				this->penultimateAY = ( (Float)(this->dyPrev) );
HXLINE( 532)				this->lastAntiX = ( (Float)(this->ex) );
HXLINE( 533)				this->lastAntiY = ( (Float)(this->ey) );
HXLINE( 535)				this->penultimateCX = this->jx;
HXLINE( 536)				this->penultimateCY = this->jy;
HXLINE( 537)				this->lastClockX = ( (Float)(this->dx) );
HXLINE( 538)				this->lastClockY = ( (Float)(this->dy) );
HXLINE( 540)				{
HXLINE( 540)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 540)					int color = -1;
HXDLIN( 540)					if ((color == -1)) {
HXLINE( 540)						color = _this->currentColor;
            					}
HXDLIN( 540)					{
HXLINE( 540)						_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jx,this->jy,0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 540)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 540)							_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 540)						_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 540)					_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXLINE( 542)				{
HXLINE( 542)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 542)					int color1 = -1;
HXDLIN( 542)					if ((color1 == -1)) {
HXLINE( 542)						color1 = _this1->currentColor;
            					}
HXDLIN( 542)					{
HXLINE( 542)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(this->dxPrev) ),( (Float)(this->dyPrev) ),0,this->jx,this->jy,0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 542)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 542)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 542)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 542)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,addInitialQuads,(void))

void Contour_obj::endEdges(){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_548_endEdges)
HXLINE( 549)		int pC = this->pointsClock->length;
HXLINE( 550)		int pA = this->pointsAnti->length;
HXLINE( 551)		pC = (pC + 1);
HXDLIN( 551)		this->pointsClock[(pC - 1)] = this->penultimateCX;
HXLINE( 552)		pC = (pC + 1);
HXDLIN( 552)		this->pointsClock[(pC - 1)] = this->penultimateCY;
HXLINE( 553)		pC = (pC + 1);
HXDLIN( 553)		this->pointsClock[(pC - 1)] = this->lastClockX;
HXLINE( 554)		pC = (pC + 1);
HXDLIN( 554)		this->pointsClock[(pC - 1)] = this->lastClockY;
HXLINE( 555)		pA = (pA + 1);
HXDLIN( 555)		this->pointsAnti[(pA - 1)] = this->penultimateAX;
HXLINE( 556)		pA = (pA + 1);
HXDLIN( 556)		this->pointsAnti[(pA - 1)] = this->penultimateAY;
HXLINE( 557)		pA = (pA + 1);
HXDLIN( 557)		this->pointsAnti[(pA - 1)] = this->lastAntiX;
HXLINE( 558)		pA = (pA + 1);
HXDLIN( 558)		this->pointsAnti[(pA - 1)] = this->lastAntiY;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Contour_obj,endEdges,(void))

void Contour_obj::addQuads(bool clockWise,Float width_){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_574_addQuads)
HXLINE( 580)		Float currQuadIndex = ( (Float)(this->pen->drawType->__Field(HX_("get_pos",2b,26,ca,26),::hx::paccDynamic)()) );
HXLINE( 582)		int pC = 0;
HXLINE( 583)		int pA = 0;
HXLINE( 584)		bool _hx_tmp;
HXDLIN( 584)		if (clockWise) {
HXLINE( 584)			_hx_tmp = !(this->lastClock);
            		}
            		else {
HXLINE( 584)			_hx_tmp = false;
            		}
HXDLIN( 584)		if (_hx_tmp) {
HXLINE( 585)			if ((this->count == 1)) {
HXLINE( 586)				pA = this->pointsAnti->length;
HXLINE( 587)				pA = (pA + 1);
HXDLIN( 587)				this->pointsAnti[(pA - 1)] = this->kax;
HXLINE( 588)				pA = (pA + 1);
HXDLIN( 588)				this->pointsAnti[(pA - 1)] = this->kay;
HXLINE( 589)				pA = (pA + 1);
HXDLIN( 589)				this->pointsAnti[(pA - 1)] = this->jx;
HXLINE( 590)				pA = (pA + 1);
HXDLIN( 590)				this->pointsAnti[(pA - 1)] = this->jy;
HXLINE( 591)				pC = this->pointsClock->length;
HXLINE( 592)				pC = (pC + 1);
HXDLIN( 592)				this->pointsClock[(pC - 1)] = this->kbx;
HXLINE( 593)				pC = (pC + 1);
HXDLIN( 593)				this->pointsClock[(pC - 1)] = this->kby;
HXLINE( 594)				pC = (pC + 1);
HXDLIN( 594)				this->pointsClock[(pC - 1)] = this->ncx;
HXLINE( 595)				pC = (pC + 1);
HXDLIN( 595)				this->pointsClock[(pC - 1)] = this->ncy;
HXLINE( 597)				{
HXLINE( 597)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 597)					Float v = (this->quadIndex + 1);
HXDLIN( 597)					_this->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
HXDLIN( 597)					_this->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
            				}
HXLINE( 598)				{
HXLINE( 598)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 598)					int color = -1;
HXDLIN( 598)					if ((color == -1)) {
HXLINE( 598)						color = _this1->currentColor;
            					}
HXDLIN( 598)					{
HXLINE( 598)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->kax,this->kay,0,this->kbx,this->kby,0,this->ncx,this->ncy,0);
HXDLIN( 598)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 598)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 598)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 598)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            			}
            			else {
HXLINE( 602)				pA = this->pointsAnti->length;
HXLINE( 603)				pA = (pA + 1);
HXDLIN( 603)				this->pointsAnti[(pA - 1)] = this->kax;
HXLINE( 604)				pA = (pA + 1);
HXDLIN( 604)				this->pointsAnti[(pA - 1)] = this->kay;
HXLINE( 605)				pA = (pA + 1);
HXDLIN( 605)				this->pointsAnti[(pA - 1)] = this->jx;
HXLINE( 606)				pA = (pA + 1);
HXDLIN( 606)				this->pointsAnti[(pA - 1)] = this->jy;
HXLINE( 607)				pC = this->pointsClock->length;
HXLINE( 608)				pC = (pC + 1);
HXDLIN( 608)				this->pointsClock[(pC - 1)] = this->jxOld;
HXLINE( 609)				pC = (pC + 1);
HXDLIN( 609)				this->pointsClock[(pC - 1)] = this->jyOld;
HXLINE( 610)				pC = (pC + 1);
HXDLIN( 610)				this->pointsClock[(pC - 1)] = this->kbx;
HXLINE( 611)				pC = (pC + 1);
HXDLIN( 611)				this->pointsClock[(pC - 1)] = this->kby;
HXLINE( 613)				{
HXLINE( 613)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 613)					Float v = (this->quadIndex + 1);
HXDLIN( 613)					_this->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
HXDLIN( 613)					_this->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
            				}
HXLINE( 614)				{
HXLINE( 614)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 614)					int color = -1;
HXDLIN( 614)					if ((color == -1)) {
HXLINE( 614)						color = _this1->currentColor;
            					}
HXDLIN( 614)					{
HXLINE( 614)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->kax,this->kay,0,this->kbx,this->kby,0,this->jxOld,this->jyOld,0);
HXDLIN( 614)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 614)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 614)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 614)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            			}
HXLINE( 618)			{
HXLINE( 618)				 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 618)				Float v = this->quadIndex;
HXDLIN( 618)				_this->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
HXDLIN( 618)				_this->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
            			}
HXLINE( 619)			{
HXLINE( 619)				 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 619)				int color = -1;
HXDLIN( 619)				if ((color == -1)) {
HXLINE( 619)					color = _this1->currentColor;
            				}
HXDLIN( 619)				{
HXLINE( 619)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->kax,this->kay,0,this->kbx,this->kby,0,this->jx,this->jy,0);
HXDLIN( 619)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 619)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN( 619)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 619)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
            		}
HXLINE( 623)		bool _hx_tmp1;
HXDLIN( 623)		if (clockWise) {
HXLINE( 623)			_hx_tmp1 = this->lastClock;
            		}
            		else {
HXLINE( 623)			_hx_tmp1 = false;
            		}
HXDLIN( 623)		if (_hx_tmp1) {
HXLINE( 624)			if ((this->count == 1)) {
HXLINE( 626)				pA = this->pointsAnti->length;
HXLINE( 627)				pA = (pA + 1);
HXDLIN( 627)				this->pointsAnti[(pA - 1)] = this->jx;
HXLINE( 628)				pA = (pA + 1);
HXDLIN( 628)				this->pointsAnti[(pA - 1)] = this->jy;
HXLINE( 629)				pA = (pA + 1);
HXDLIN( 629)				this->pointsAnti[(pA - 1)] = this->kbx;
HXLINE( 630)				pA = (pA + 1);
HXDLIN( 630)				this->pointsAnti[(pA - 1)] = this->kby;
HXLINE( 631)				pC = this->pointsClock->length;
HXLINE( 632)				pC = (pC + 1);
HXDLIN( 632)				this->pointsClock[(pC - 1)] = this->kax;
HXLINE( 633)				pC = (pC + 1);
HXDLIN( 633)				this->pointsClock[(pC - 1)] = this->kay;
HXLINE( 634)				pC = (pC + 1);
HXDLIN( 634)				this->pointsClock[(pC - 1)] = this->kbx;
HXLINE( 635)				pC = (pC + 1);
HXDLIN( 635)				this->pointsClock[(pC - 1)] = this->kby;
HXLINE( 637)				{
HXLINE( 637)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 637)					Float v = this->quadIndex;
HXDLIN( 637)					_this->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
HXDLIN( 637)					_this->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
            				}
HXLINE( 638)				{
HXLINE( 638)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 638)					int color = -1;
HXDLIN( 638)					if ((color == -1)) {
HXLINE( 638)						color = _this1->currentColor;
            					}
HXDLIN( 638)					{
HXLINE( 638)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->kax,this->kay,0,this->kbx,this->kby,0,this->jx,this->jy,0);
HXDLIN( 638)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 638)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 638)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 638)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXLINE( 639)				{
HXLINE( 639)					 ::trilateral3::drawing::Pen _this2 = this->pen;
HXDLIN( 639)					Float v1 = (this->quadIndex + 1);
HXDLIN( 639)					_this2->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v1);
HXDLIN( 639)					_this2->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v1);
            				}
HXLINE( 640)				{
HXLINE( 640)					 ::trilateral3::drawing::Pen _this3 = this->pen;
HXDLIN( 640)					int color1 = -1;
HXDLIN( 640)					if ((color1 == -1)) {
HXLINE( 640)						color1 = _this3->currentColor;
            					}
HXDLIN( 640)					{
HXLINE( 640)						_this3->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->kax,this->kay,0,this->kbx,this->kby,0,this->ncx,this->ncy,0);
HXDLIN( 640)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 640)							_this3->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 640)						_this3->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 640)					_this3->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
            			else {
HXLINE( 643)				pA = this->pointsAnti->length;
HXLINE( 644)				pA = (pA + 1);
HXDLIN( 644)				this->pointsAnti[(pA - 1)] = this->jxOld;
HXLINE( 645)				pA = (pA + 1);
HXDLIN( 645)				this->pointsAnti[(pA - 1)] = this->jyOld;
HXLINE( 646)				pA = (pA + 1);
HXDLIN( 646)				this->pointsAnti[(pA - 1)] = this->jx;
HXLINE( 647)				pA = (pA + 1);
HXDLIN( 647)				this->pointsAnti[(pA - 1)] = this->jy;
HXLINE( 648)				pC = this->pointsClock->length;
HXLINE( 649)				pC = (pC + 1);
HXDLIN( 649)				this->pointsClock[(pC - 1)] = this->ncx;
HXLINE( 650)				pC = (pC + 1);
HXDLIN( 650)				this->pointsClock[(pC - 1)] = this->ncy;
HXLINE( 651)				pC = (pC + 1);
HXDLIN( 651)				this->pointsClock[(pC - 1)] = this->kbx;
HXLINE( 652)				pC = (pC + 1);
HXDLIN( 652)				this->pointsClock[(pC - 1)] = this->kby;
HXLINE( 654)				{
HXLINE( 654)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 654)					Float v = this->quadIndex;
HXDLIN( 654)					_this->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
HXDLIN( 654)					_this->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
            				}
HXLINE( 655)				{
HXLINE( 655)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 655)					int color = -1;
HXDLIN( 655)					if ((color == -1)) {
HXLINE( 655)						color = _this1->currentColor;
            					}
HXDLIN( 655)					{
HXLINE( 655)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jxOld,this->jyOld,0,this->kbx,this->kby,0,this->jx,this->jy,0);
HXDLIN( 655)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 655)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 655)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 655)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXLINE( 657)				{
HXLINE( 657)					 ::trilateral3::drawing::Pen _this2 = this->pen;
HXDLIN( 657)					Float v1 = (this->quadIndex + 1);
HXDLIN( 657)					_this2->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v1);
HXDLIN( 657)					_this2->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v1);
            				}
HXLINE( 658)				{
HXLINE( 658)					 ::trilateral3::drawing::Pen _this3 = this->pen;
HXDLIN( 658)					int color1 = -1;
HXDLIN( 658)					if ((color1 == -1)) {
HXLINE( 658)						color1 = _this3->currentColor;
            					}
HXDLIN( 658)					{
HXLINE( 658)						_this3->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jxOld,this->jyOld,0,this->kbx,this->kby,0,this->ncx,this->ncy,0);
HXDLIN( 658)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 658)							_this3->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 658)						_this3->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 658)					_this3->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
            		}
HXLINE( 666)		bool _hx_tmp2;
HXDLIN( 666)		if (!(clockWise)) {
HXLINE( 666)			_hx_tmp2 = !(this->lastClock);
            		}
            		else {
HXLINE( 666)			_hx_tmp2 = false;
            		}
HXDLIN( 666)		if (_hx_tmp2) {
HXLINE( 668)			{
HXLINE( 668)				 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 668)				Float v = this->quadIndex;
HXDLIN( 668)				_this->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
HXDLIN( 668)				_this->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
            			}
HXLINE( 669)			{
HXLINE( 669)				 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 669)				int color = -1;
HXDLIN( 669)				if ((color == -1)) {
HXLINE( 669)					color = _this1->currentColor;
            				}
HXDLIN( 669)				{
HXLINE( 669)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->kax,this->kay,0,this->jx,this->jy,0,this->kcx,this->kcy,0);
HXDLIN( 669)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 669)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN( 669)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 669)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXLINE( 672)			if ((this->count == 1)) {
HXLINE( 673)				pA = this->pointsAnti->length;
HXLINE( 674)				pA = (pA + 1);
HXDLIN( 674)				this->pointsAnti[(pA - 1)] = this->kax;
HXLINE( 675)				pA = (pA + 1);
HXDLIN( 675)				this->pointsAnti[(pA - 1)] = this->kay;
HXLINE( 676)				pA = (pA + 1);
HXDLIN( 676)				this->pointsAnti[(pA - 1)] = this->kcx;
HXLINE( 677)				pA = (pA + 1);
HXDLIN( 677)				this->pointsAnti[(pA - 1)] = this->kcy;
HXLINE( 678)				pC = this->pointsClock->length;
HXLINE( 679)				pC = (pC + 1);
HXDLIN( 679)				this->pointsClock[(pC - 1)] = this->ncx;
HXLINE( 680)				pC = (pC + 1);
HXDLIN( 680)				this->pointsClock[(pC - 1)] = this->ncy;
HXLINE( 681)				pC = (pC + 1);
HXDLIN( 681)				this->pointsClock[(pC - 1)] = this->jx;
HXLINE( 682)				pC = (pC + 1);
HXDLIN( 682)				this->pointsClock[(pC - 1)] = this->jy;
HXLINE( 683)				{
HXLINE( 683)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 683)					Float v = (this->quadIndex + 1);
HXDLIN( 683)					_this->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
HXDLIN( 683)					_this->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
            				}
HXLINE( 684)				{
HXLINE( 684)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 684)					int color = -1;
HXDLIN( 684)					if ((color == -1)) {
HXLINE( 684)						color = _this1->currentColor;
            					}
HXDLIN( 684)					{
HXLINE( 684)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->kax,this->kay,0,this->jx,this->jy,0,this->ncx,this->ncy,0);
HXDLIN( 684)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 684)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 684)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 684)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            			}
            			else {
HXLINE( 687)				pA = this->pointsAnti->length;
HXLINE( 688)				pA = (pA + 1);
HXDLIN( 688)				this->pointsAnti[(pA - 1)] = this->kax;
HXLINE( 689)				pA = (pA + 1);
HXDLIN( 689)				this->pointsAnti[(pA - 1)] = this->kay;
HXLINE( 690)				pA = (pA + 1);
HXDLIN( 690)				this->pointsAnti[(pA - 1)] = this->kcx;
HXLINE( 691)				pA = (pA + 1);
HXDLIN( 691)				this->pointsAnti[(pA - 1)] = this->kcy;
HXLINE( 692)				pC = this->pointsClock->length;
HXLINE( 693)				pC = (pC + 1);
HXDLIN( 693)				this->pointsClock[(pC - 1)] = this->jxOld;
HXLINE( 694)				pC = (pC + 1);
HXDLIN( 694)				this->pointsClock[(pC - 1)] = this->jyOld;
HXLINE( 695)				pC = (pC + 1);
HXDLIN( 695)				this->pointsClock[(pC - 1)] = this->jx;
HXLINE( 696)				pC = (pC + 1);
HXDLIN( 696)				this->pointsClock[(pC - 1)] = this->jy;
HXLINE( 697)				{
HXLINE( 697)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 697)					Float v = (this->quadIndex + 1);
HXDLIN( 697)					_this->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
HXDLIN( 697)					_this->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
            				}
HXLINE( 698)				{
HXLINE( 698)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 698)					int color = -1;
HXDLIN( 698)					if ((color == -1)) {
HXLINE( 698)						color = _this1->currentColor;
            					}
HXDLIN( 698)					{
HXLINE( 698)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->kax,this->kay,0,this->jx,this->jy,0,this->jxOld,this->jyOld,0);
HXDLIN( 698)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 698)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 698)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 698)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            			}
            		}
HXLINE( 703)		bool _hx_tmp3;
HXDLIN( 703)		if (!(clockWise)) {
HXLINE( 703)			_hx_tmp3 = this->lastClock;
            		}
            		else {
HXLINE( 703)			_hx_tmp3 = false;
            		}
HXDLIN( 703)		if (_hx_tmp3) {
HXLINE( 704)			if ((this->count == 1)) {
HXLINE( 705)				pA = this->pointsAnti->length;
HXLINE( 706)				pA = (pA + 1);
HXDLIN( 706)				this->pointsAnti[(pA - 1)] = this->kay;
HXLINE( 707)				pA = (pA + 1);
HXDLIN( 707)				this->pointsAnti[(pA - 1)] = this->kax;
HXLINE( 708)				pA = (pA + 1);
HXDLIN( 708)				this->pointsAnti[(pA - 1)] = this->kcx;
HXLINE( 709)				pA = (pA + 1);
HXDLIN( 709)				this->pointsAnti[(pA - 1)] = this->kcy;
HXLINE( 710)				pC = this->pointsClock->length;
HXLINE( 711)				pC = (pC + 1);
HXDLIN( 711)				this->pointsClock[(pC - 1)] = this->jx;
HXLINE( 712)				pC = (pC + 1);
HXDLIN( 712)				this->pointsClock[(pC - 1)] = this->jy;
HXLINE( 713)				pC = (pC + 1);
HXDLIN( 713)				this->pointsClock[(pC - 1)] = this->ncx;
HXLINE( 714)				pC = (pC + 1);
HXDLIN( 714)				this->pointsClock[(pC - 1)] = this->ncy;
HXLINE( 715)				{
HXLINE( 715)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 715)					Float v = this->quadIndex;
HXDLIN( 715)					_this->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
HXDLIN( 715)					_this->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
            				}
HXLINE( 716)				{
HXLINE( 716)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 716)					int color = -1;
HXDLIN( 716)					if ((color == -1)) {
HXLINE( 716)						color = _this1->currentColor;
            					}
HXDLIN( 716)					{
HXLINE( 716)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->kax,this->kay,0,this->jx,this->jy,0,this->kcx,this->kcy,0);
HXDLIN( 716)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 716)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 716)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 716)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXLINE( 717)				{
HXLINE( 717)					 ::trilateral3::drawing::Pen _this2 = this->pen;
HXDLIN( 717)					Float v1 = (this->quadIndex + 1);
HXDLIN( 717)					_this2->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v1);
HXDLIN( 717)					_this2->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v1);
            				}
HXLINE( 718)				{
HXLINE( 718)					 ::trilateral3::drawing::Pen _this3 = this->pen;
HXDLIN( 718)					int color1 = -1;
HXDLIN( 718)					if ((color1 == -1)) {
HXLINE( 718)						color1 = _this3->currentColor;
            					}
HXDLIN( 718)					{
HXLINE( 718)						_this3->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->kax,this->kay,0,this->jx,this->jy,0,this->ncx,this->ncy,0);
HXDLIN( 718)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 718)							_this3->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 718)						_this3->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 718)					_this3->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
            			else {
HXLINE( 720)				pA = this->pointsAnti->length;
HXLINE( 721)				pA = (pA + 1);
HXDLIN( 721)				this->pointsAnti[(pA - 1)] = this->jxOld;
HXLINE( 722)				pA = (pA + 1);
HXDLIN( 722)				this->pointsAnti[(pA - 1)] = this->jyOld;
HXLINE( 723)				pA = (pA + 1);
HXDLIN( 723)				this->pointsAnti[(pA - 1)] = this->kcx;
HXLINE( 724)				pA = (pA + 1);
HXDLIN( 724)				this->pointsAnti[(pA - 1)] = this->kcy;
HXLINE( 725)				pC = this->pointsClock->length;
HXLINE( 726)				pC = (pC + 1);
HXDLIN( 726)				this->pointsClock[(pC - 1)] = this->jx;
HXLINE( 727)				pC = (pC + 1);
HXDLIN( 727)				this->pointsClock[(pC - 1)] = this->jy;
HXLINE( 728)				pC = (pC + 1);
HXDLIN( 728)				this->pointsClock[(pC - 1)] = this->ncx;
HXLINE( 729)				pC = (pC + 1);
HXDLIN( 729)				this->pointsClock[(pC - 1)] = this->ncy;
HXLINE( 730)				{
HXLINE( 730)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 730)					Float v = this->quadIndex;
HXDLIN( 730)					_this->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
HXDLIN( 730)					_this->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v);
            				}
HXLINE( 731)				{
HXLINE( 731)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 731)					int color = -1;
HXDLIN( 731)					if ((color == -1)) {
HXLINE( 731)						color = _this1->currentColor;
            					}
HXDLIN( 731)					{
HXLINE( 731)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jxOld,this->jyOld,0,this->jx,this->jy,0,this->kcx,this->kcy,0);
HXDLIN( 731)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 731)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 731)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 731)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXLINE( 732)				{
HXLINE( 732)					 ::trilateral3::drawing::Pen _this2 = this->pen;
HXDLIN( 732)					Float v1 = (this->quadIndex + 1);
HXDLIN( 732)					_this2->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v1);
HXDLIN( 732)					_this2->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(v1);
            				}
HXLINE( 733)				{
HXLINE( 733)					 ::trilateral3::drawing::Pen _this3 = this->pen;
HXDLIN( 733)					int color1 = -1;
HXDLIN( 733)					if ((color1 == -1)) {
HXLINE( 733)						color1 = _this3->currentColor;
            					}
HXDLIN( 733)					{
HXLINE( 733)						_this3->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(this->jxOld,this->jyOld,0,this->jx,this->jy,0,this->ncx,this->ncy,0);
HXDLIN( 733)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 733)							_this3->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN( 733)						_this3->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 733)					_this3->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
            		}
HXLINE( 737)		{
HXLINE( 737)			 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 737)			_this->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(currQuadIndex);
HXDLIN( 737)			_this->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(currQuadIndex);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,addQuads,(void))

void Contour_obj::storeLastQuads(){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_740_storeLastQuads)
HXLINE( 741)		this->kax = ( (Float)(this->dxPrev) );
HXLINE( 742)		this->kay = ( (Float)(this->dyPrev) );
HXLINE( 743)		this->kbx = ( (Float)(this->dx) );
HXLINE( 744)		this->kby = ( (Float)(this->dy) );
HXLINE( 745)		this->ncx = ( (Float)(this->exPrev) );
HXLINE( 746)		this->ncy = ( (Float)(this->eyPrev) );
HXLINE( 747)		this->kcx = ( (Float)(this->ex) );
HXLINE( 748)		this->kcy = ( (Float)(this->ey) );
            	}


HX_DEFINE_DYNAMIC_FUNC0(Contour_obj,storeLastQuads,(void))

bool Contour_obj::isClockwise(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_751_isClockwise)
HXDLIN( 751)		Float x1 = (( (Float)(this->dxOld) ) - x);
HXDLIN( 751)		Float y1 = (( (Float)(this->dyOld) ) - y);
HXDLIN( 751)		Float x2 = (( (Float)(this->exOld) ) - x);
HXDLIN( 751)		Float y2 = (( (Float)(this->eyOld) ) - y);
HXDLIN( 751)		return (((x1 * x1) + (y1 * y1)) > ((x2 * x2) + (y2 * y2)));
            	}


HX_DEFINE_DYNAMIC_FUNC2(Contour_obj,isClockwise,return )

void Contour_obj::line(Float ax_,Float ay_,Float bx_,Float by_,Float width_, ::Dynamic __o_endLineCurve){
            		 ::Dynamic endLineCurve = __o_endLineCurve;
            		if (::hx::IsNull(__o_endLineCurve)) endLineCurve = 0;
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_754_line)
HXLINE( 756)		this->ax = bx_;
HXLINE( 757)		this->ay = by_;
HXLINE( 758)		this->bx = ax_;
HXLINE( 759)		this->by = ay_;
HXLINE( 760)		this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXLINE( 762)		this->beta = ((::Math_obj::PI / ( (Float)(2) )) - this->halfA);
HXLINE( 763)		this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(this->beta));
HXLINE( 765)		{
HXLINE( 765)			{
HXLINE( 765)				this->theta = ::Math_obj::atan2((this->ay - this->by),(this->ax - this->bx));
HXDLIN( 765)				if ((this->theta > 0)) {
HXLINE( 765)					if ((this->halfA < 0)) {
HXLINE( 765)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 765)						this->angle1 = (this->theta - this->halfA);
            					}
            					else {
HXLINE( 765)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 765)						this->angle2 = (this->theta + this->halfA);
            					}
            				}
            				else {
HXLINE( 765)					if ((this->halfA > 0)) {
HXLINE( 765)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 765)						this->angle2 = (this->theta + this->halfA);
            					}
            					else {
HXLINE( 765)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 765)						this->angle1 = (this->theta - this->halfA);
            					}
            				}
            			}
HXDLIN( 765)			if (::hx::IsNotNull( this->dxPrev )) {
HXLINE( 765)				this->dxOld = this->dxPrev;
            			}
HXDLIN( 765)			if (::hx::IsNotNull( this->dyPrev )) {
HXLINE( 765)				this->dyOld = this->dyPrev;
            			}
HXDLIN( 765)			if (::hx::IsNotNull( this->exPrev )) {
HXLINE( 765)				this->exOld = this->exPrev;
            			}
HXDLIN( 765)			if (::hx::IsNotNull( this->eyPrev )) {
HXLINE( 765)				this->eyOld = this->eyPrev;
            			}
HXDLIN( 765)			if (::hx::IsNotNull( this->dx )) {
HXLINE( 765)				this->dxPrev = this->dx;
            			}
HXDLIN( 765)			if (::hx::IsNotNull( this->dy )) {
HXLINE( 765)				this->dyPrev = this->dy;
            			}
HXDLIN( 765)			if (::hx::IsNotNull( this->ex )) {
HXLINE( 765)				this->exPrev = this->ex;
            			}
HXDLIN( 765)			if (::hx::IsNotNull( this->ey )) {
HXLINE( 765)				this->eyPrev = this->ey;
            			}
HXDLIN( 765)			this->dx = (this->bx + (this->r * ::Math_obj::cos(( (Float)(this->angle1) ))));
HXDLIN( 765)			this->dy = (this->by + (this->r * ::Math_obj::sin(( (Float)(this->angle1) ))));
HXDLIN( 765)			this->ex = (this->bx + (this->r * ::Math_obj::cos(this->angle2)));
HXDLIN( 765)			this->ey = (this->by + (this->r * ::Math_obj::sin(this->angle2)));
            		}
HXLINE( 766)		 ::Dynamic dxPrev_ = this->dx;
HXLINE( 767)		 ::Dynamic dyPrev_ = this->dy;
HXLINE( 768)		 ::Dynamic exPrev_ = this->ex;
HXLINE( 769)		 ::Dynamic eyPrev_ = this->ey;
HXLINE( 771)		this->ax = ax_;
HXLINE( 772)		this->ay = ay_;
HXLINE( 773)		this->bx = bx_;
HXLINE( 774)		this->by = by_;
HXLINE( 775)		{
HXLINE( 775)			{
HXLINE( 775)				this->theta = ::Math_obj::atan2((this->ay - this->by),(this->ax - this->bx));
HXDLIN( 775)				if ((this->theta > 0)) {
HXLINE( 775)					if ((this->halfA < 0)) {
HXLINE( 775)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 775)						this->angle1 = (this->theta - this->halfA);
            					}
            					else {
HXLINE( 775)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 775)						this->angle2 = (this->theta + this->halfA);
            					}
            				}
            				else {
HXLINE( 775)					if ((this->halfA > 0)) {
HXLINE( 775)						this->angle1 = ((this->theta + this->halfA) - ::Math_obj::PI);
HXDLIN( 775)						this->angle2 = (this->theta + this->halfA);
            					}
            					else {
HXLINE( 775)						this->angle2 = ((this->theta + this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 775)						this->angle1 = (this->theta - this->halfA);
            					}
            				}
            			}
HXDLIN( 775)			if (::hx::IsNotNull( this->dxPrev )) {
HXLINE( 775)				this->dxOld = this->dxPrev;
            			}
HXDLIN( 775)			if (::hx::IsNotNull( this->dyPrev )) {
HXLINE( 775)				this->dyOld = this->dyPrev;
            			}
HXDLIN( 775)			if (::hx::IsNotNull( this->exPrev )) {
HXLINE( 775)				this->exOld = this->exPrev;
            			}
HXDLIN( 775)			if (::hx::IsNotNull( this->eyPrev )) {
HXLINE( 775)				this->eyOld = this->eyPrev;
            			}
HXDLIN( 775)			if (::hx::IsNotNull( this->dx )) {
HXLINE( 775)				this->dxPrev = this->dx;
            			}
HXDLIN( 775)			if (::hx::IsNotNull( this->dy )) {
HXLINE( 775)				this->dyPrev = this->dy;
            			}
HXDLIN( 775)			if (::hx::IsNotNull( this->ex )) {
HXLINE( 775)				this->exPrev = this->ex;
            			}
HXDLIN( 775)			if (::hx::IsNotNull( this->ey )) {
HXLINE( 775)				this->eyPrev = this->ey;
            			}
HXDLIN( 775)			this->dx = (this->bx + (this->r * ::Math_obj::cos(( (Float)(this->angle1) ))));
HXDLIN( 775)			this->dy = (this->by + (this->r * ::Math_obj::sin(( (Float)(this->angle1) ))));
HXDLIN( 775)			this->ex = (this->bx + (this->r * ::Math_obj::cos(this->angle2)));
HXDLIN( 775)			this->ey = (this->by + (this->r * ::Math_obj::sin(this->angle2)));
            		}
HXLINE( 776)		 ::Dynamic _hx_switch_0 = endLineCurve;
            		if (  (_hx_switch_0==0) ){
HXLINE( 777)			goto _hx_goto_47;
            		}
            		if (  (_hx_switch_0==1) ){
HXLINE( 780)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 780)			Float beta = (-(this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 780)			Float gamma = ((-(this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN( 780)			 ::Dynamic drawType = this->pen->drawType;
HXDLIN( 780)			 ::Dynamic sides = 36;
HXDLIN( 780)			if (::hx::IsNull( sides )) {
HXLINE( 780)				sides = 36;
            			}
HXDLIN( 780)			Float pi = ::Math_obj::PI;
HXDLIN( 780)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 780)			Float dif;
HXDLIN( 780)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXLINE( 780)					Float f;
HXDLIN( 780)					bool f1;
HXDLIN( 780)					if ((beta >= 0)) {
HXLINE( 780)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 780)						f1 = false;
            					}
HXDLIN( 780)					if (f1) {
HXLINE( 780)						f = beta;
            					}
            					else {
HXLINE( 780)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 780)						if ((a >= 0)) {
HXLINE( 780)							f = a;
            						}
            						else {
HXLINE( 780)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 780)					Float this1 = f;
HXDLIN( 780)					Float za = this1;
HXDLIN( 780)					Float f2;
HXDLIN( 780)					bool f3;
HXDLIN( 780)					if ((gamma >= 0)) {
HXLINE( 780)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 780)						f3 = false;
            					}
HXDLIN( 780)					if (f3) {
HXLINE( 780)						f2 = gamma;
            					}
            					else {
HXLINE( 780)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 780)						if ((a >= 0)) {
HXLINE( 780)							f2 = a;
            						}
            						else {
HXLINE( 780)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 780)					Float this2 = f2;
HXDLIN( 780)					Float zb = this2;
HXDLIN( 780)					Float fa = za;
HXDLIN( 780)					Float fb = zb;
HXDLIN( 780)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 780)					bool clockwise = (fa < fb);
HXDLIN( 780)					Float dif1;
HXDLIN( 780)					if (clockwise) {
HXLINE( 780)						dif1 = theta;
            					}
            					else {
HXLINE( 780)						dif1 = -(theta);
            					}
HXDLIN( 780)					if ((dif1 > 0)) {
HXLINE( 780)						dif = dif1;
            					}
            					else {
HXLINE( 780)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXLINE( 780)					Float f;
HXDLIN( 780)					bool f1;
HXDLIN( 780)					if ((beta >= 0)) {
HXLINE( 780)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 780)						f1 = false;
            					}
HXDLIN( 780)					if (f1) {
HXLINE( 780)						f = beta;
            					}
            					else {
HXLINE( 780)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 780)						if ((a >= 0)) {
HXLINE( 780)							f = a;
            						}
            						else {
HXLINE( 780)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 780)					Float this1 = f;
HXDLIN( 780)					Float za = this1;
HXDLIN( 780)					Float f2;
HXDLIN( 780)					bool f3;
HXDLIN( 780)					if ((gamma >= 0)) {
HXLINE( 780)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 780)						f3 = false;
            					}
HXDLIN( 780)					if (f3) {
HXLINE( 780)						f2 = gamma;
            					}
            					else {
HXLINE( 780)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 780)						if ((a >= 0)) {
HXLINE( 780)							f2 = a;
            						}
            						else {
HXLINE( 780)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 780)					Float this2 = f2;
HXDLIN( 780)					Float zb = this2;
HXDLIN( 780)					Float fa = za;
HXDLIN( 780)					Float fb = zb;
HXDLIN( 780)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 780)					bool clockwise = (fa < fb);
HXDLIN( 780)					Float dif1;
HXDLIN( 780)					if (clockwise) {
HXLINE( 780)						dif1 = theta;
            					}
            					else {
HXLINE( 780)						dif1 = -(theta);
            					}
HXDLIN( 780)					if ((dif1 < 0)) {
HXLINE( 780)						dif = dif1;
            					}
            					else {
HXLINE( 780)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXLINE( 780)					Float f;
HXDLIN( 780)					bool f1;
HXDLIN( 780)					if ((beta >= 0)) {
HXLINE( 780)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 780)						f1 = false;
            					}
HXDLIN( 780)					if (f1) {
HXLINE( 780)						f = beta;
            					}
            					else {
HXLINE( 780)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 780)						if ((a >= 0)) {
HXLINE( 780)							f = a;
            						}
            						else {
HXLINE( 780)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 780)					Float this1 = f;
HXDLIN( 780)					Float za = this1;
HXDLIN( 780)					Float f2;
HXDLIN( 780)					bool f3;
HXDLIN( 780)					if ((gamma >= 0)) {
HXLINE( 780)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 780)						f3 = false;
            					}
HXDLIN( 780)					if (f3) {
HXLINE( 780)						f2 = gamma;
            					}
            					else {
HXLINE( 780)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 780)						if ((a >= 0)) {
HXLINE( 780)							f2 = a;
            						}
            						else {
HXLINE( 780)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 780)					Float this2 = f2;
HXDLIN( 780)					Float zb = this2;
HXDLIN( 780)					Float fa = za;
HXDLIN( 780)					Float fb = zb;
HXDLIN( 780)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 780)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 780)					bool clockwise = (fa < fb);
HXDLIN( 780)					Float dif1;
HXDLIN( 780)					if (clockwise) {
HXLINE( 780)						dif1 = theta;
            					}
            					else {
HXLINE( 780)						dif1 = -(theta);
            					}
HXDLIN( 780)					if (smallest) {
HXLINE( 780)						dif = dif1;
            					}
            					else {
HXLINE( 780)						if (clockwise) {
HXLINE( 780)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXLINE( 780)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXLINE( 780)					Float f;
HXDLIN( 780)					bool f1;
HXDLIN( 780)					if ((beta >= 0)) {
HXLINE( 780)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 780)						f1 = false;
            					}
HXDLIN( 780)					if (f1) {
HXLINE( 780)						f = beta;
            					}
            					else {
HXLINE( 780)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 780)						if ((a >= 0)) {
HXLINE( 780)							f = a;
            						}
            						else {
HXLINE( 780)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 780)					Float this1 = f;
HXDLIN( 780)					Float za = this1;
HXDLIN( 780)					Float f2;
HXDLIN( 780)					bool f3;
HXDLIN( 780)					if ((gamma >= 0)) {
HXLINE( 780)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 780)						f3 = false;
            					}
HXDLIN( 780)					if (f3) {
HXLINE( 780)						f2 = gamma;
            					}
            					else {
HXLINE( 780)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 780)						if ((a >= 0)) {
HXLINE( 780)							f2 = a;
            						}
            						else {
HXLINE( 780)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 780)					Float this2 = f2;
HXDLIN( 780)					Float zb = this2;
HXDLIN( 780)					Float fa = za;
HXDLIN( 780)					Float fb = zb;
HXDLIN( 780)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 780)					bool largest = (theta > ::Math_obj::PI);
HXDLIN( 780)					bool clockwise = (fa < fb);
HXDLIN( 780)					Float dif1;
HXDLIN( 780)					if (clockwise) {
HXLINE( 780)						dif1 = theta;
            					}
            					else {
HXLINE( 780)						dif1 = -(theta);
            					}
HXDLIN( 780)					if (largest) {
HXLINE( 780)						dif = dif1;
            					}
            					else {
HXLINE( 780)						if (clockwise) {
HXLINE( 780)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXLINE( 780)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN( 780)			bool positive = (dif >= 0);
HXDLIN( 780)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 780)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 780)			Float angle = beta;
HXDLIN( 780)			Float cx;
HXDLIN( 780)			Float cy;
HXDLIN( 780)			Float bx = ( (Float)(0) );
HXDLIN( 780)			Float by = ( (Float)(0) );
HXDLIN( 780)			{
HXLINE( 780)				int _g = 0;
HXDLIN( 780)				int _g1 = (totalSteps + 1);
HXDLIN( 780)				while((_g < _g1)){
HXLINE( 780)					_g = (_g + 1);
HXDLIN( 780)					int i = (_g - 1);
HXDLIN( 780)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN( 780)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN( 780)					if ((i != 0)) {
HXLINE( 780)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN( 780)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 780)						if (::hx::IsNotNull( m )) {
HXLINE( 780)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 780)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 780)					angle = (angle + step1);
HXDLIN( 780)					bx = cx;
HXDLIN( 780)					by = cy;
            				}
            			}
HXDLIN( 780)			int len = totalSteps;
HXDLIN( 780)			{
HXLINE( 780)				 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 780)				int color = 0;
HXDLIN( 780)				if ((color == -1)) {
HXLINE( 780)					color = _this->currentColor;
            				}
HXDLIN( 780)				_this->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN( 780)			goto _hx_goto_47;
            		}
            		if (  (_hx_switch_0==2) ){
HXLINE( 782)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 782)			Float beta = (-(this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 782)			Float gamma = ((-(this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 782)			 ::Dynamic drawType = this->pen->drawType;
HXDLIN( 782)			 ::Dynamic sides = 36;
HXDLIN( 782)			if (::hx::IsNull( sides )) {
HXLINE( 782)				sides = 36;
            			}
HXDLIN( 782)			Float pi = ::Math_obj::PI;
HXDLIN( 782)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 782)			Float dif;
HXDLIN( 782)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXLINE( 782)					Float f;
HXDLIN( 782)					bool f1;
HXDLIN( 782)					if ((beta >= 0)) {
HXLINE( 782)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 782)						f1 = false;
            					}
HXDLIN( 782)					if (f1) {
HXLINE( 782)						f = beta;
            					}
            					else {
HXLINE( 782)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 782)						if ((a >= 0)) {
HXLINE( 782)							f = a;
            						}
            						else {
HXLINE( 782)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 782)					Float this1 = f;
HXDLIN( 782)					Float za = this1;
HXDLIN( 782)					Float f2;
HXDLIN( 782)					bool f3;
HXDLIN( 782)					if ((gamma >= 0)) {
HXLINE( 782)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 782)						f3 = false;
            					}
HXDLIN( 782)					if (f3) {
HXLINE( 782)						f2 = gamma;
            					}
            					else {
HXLINE( 782)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 782)						if ((a >= 0)) {
HXLINE( 782)							f2 = a;
            						}
            						else {
HXLINE( 782)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 782)					Float this2 = f2;
HXDLIN( 782)					Float zb = this2;
HXDLIN( 782)					Float fa = za;
HXDLIN( 782)					Float fb = zb;
HXDLIN( 782)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 782)					bool clockwise = (fa < fb);
HXDLIN( 782)					Float dif1;
HXDLIN( 782)					if (clockwise) {
HXLINE( 782)						dif1 = theta;
            					}
            					else {
HXLINE( 782)						dif1 = -(theta);
            					}
HXDLIN( 782)					if ((dif1 > 0)) {
HXLINE( 782)						dif = dif1;
            					}
            					else {
HXLINE( 782)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXLINE( 782)					Float f;
HXDLIN( 782)					bool f1;
HXDLIN( 782)					if ((beta >= 0)) {
HXLINE( 782)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 782)						f1 = false;
            					}
HXDLIN( 782)					if (f1) {
HXLINE( 782)						f = beta;
            					}
            					else {
HXLINE( 782)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 782)						if ((a >= 0)) {
HXLINE( 782)							f = a;
            						}
            						else {
HXLINE( 782)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 782)					Float this1 = f;
HXDLIN( 782)					Float za = this1;
HXDLIN( 782)					Float f2;
HXDLIN( 782)					bool f3;
HXDLIN( 782)					if ((gamma >= 0)) {
HXLINE( 782)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 782)						f3 = false;
            					}
HXDLIN( 782)					if (f3) {
HXLINE( 782)						f2 = gamma;
            					}
            					else {
HXLINE( 782)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 782)						if ((a >= 0)) {
HXLINE( 782)							f2 = a;
            						}
            						else {
HXLINE( 782)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 782)					Float this2 = f2;
HXDLIN( 782)					Float zb = this2;
HXDLIN( 782)					Float fa = za;
HXDLIN( 782)					Float fb = zb;
HXDLIN( 782)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 782)					bool clockwise = (fa < fb);
HXDLIN( 782)					Float dif1;
HXDLIN( 782)					if (clockwise) {
HXLINE( 782)						dif1 = theta;
            					}
            					else {
HXLINE( 782)						dif1 = -(theta);
            					}
HXDLIN( 782)					if ((dif1 < 0)) {
HXLINE( 782)						dif = dif1;
            					}
            					else {
HXLINE( 782)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXLINE( 782)					Float f;
HXDLIN( 782)					bool f1;
HXDLIN( 782)					if ((beta >= 0)) {
HXLINE( 782)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 782)						f1 = false;
            					}
HXDLIN( 782)					if (f1) {
HXLINE( 782)						f = beta;
            					}
            					else {
HXLINE( 782)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 782)						if ((a >= 0)) {
HXLINE( 782)							f = a;
            						}
            						else {
HXLINE( 782)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 782)					Float this1 = f;
HXDLIN( 782)					Float za = this1;
HXDLIN( 782)					Float f2;
HXDLIN( 782)					bool f3;
HXDLIN( 782)					if ((gamma >= 0)) {
HXLINE( 782)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 782)						f3 = false;
            					}
HXDLIN( 782)					if (f3) {
HXLINE( 782)						f2 = gamma;
            					}
            					else {
HXLINE( 782)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 782)						if ((a >= 0)) {
HXLINE( 782)							f2 = a;
            						}
            						else {
HXLINE( 782)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 782)					Float this2 = f2;
HXDLIN( 782)					Float zb = this2;
HXDLIN( 782)					Float fa = za;
HXDLIN( 782)					Float fb = zb;
HXDLIN( 782)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 782)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 782)					bool clockwise = (fa < fb);
HXDLIN( 782)					Float dif1;
HXDLIN( 782)					if (clockwise) {
HXLINE( 782)						dif1 = theta;
            					}
            					else {
HXLINE( 782)						dif1 = -(theta);
            					}
HXDLIN( 782)					if (smallest) {
HXLINE( 782)						dif = dif1;
            					}
            					else {
HXLINE( 782)						if (clockwise) {
HXLINE( 782)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXLINE( 782)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXLINE( 782)					Float f;
HXDLIN( 782)					bool f1;
HXDLIN( 782)					if ((beta >= 0)) {
HXLINE( 782)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXLINE( 782)						f1 = false;
            					}
HXDLIN( 782)					if (f1) {
HXLINE( 782)						f = beta;
            					}
            					else {
HXLINE( 782)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 782)						if ((a >= 0)) {
HXLINE( 782)							f = a;
            						}
            						else {
HXLINE( 782)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 782)					Float this1 = f;
HXDLIN( 782)					Float za = this1;
HXDLIN( 782)					Float f2;
HXDLIN( 782)					bool f3;
HXDLIN( 782)					if ((gamma >= 0)) {
HXLINE( 782)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXLINE( 782)						f3 = false;
            					}
HXDLIN( 782)					if (f3) {
HXLINE( 782)						f2 = gamma;
            					}
            					else {
HXLINE( 782)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 782)						if ((a >= 0)) {
HXLINE( 782)							f2 = a;
            						}
            						else {
HXLINE( 782)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN( 782)					Float this2 = f2;
HXDLIN( 782)					Float zb = this2;
HXDLIN( 782)					Float fa = za;
HXDLIN( 782)					Float fb = zb;
HXDLIN( 782)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 782)					bool largest = (theta > ::Math_obj::PI);
HXDLIN( 782)					bool clockwise = (fa < fb);
HXDLIN( 782)					Float dif1;
HXDLIN( 782)					if (clockwise) {
HXLINE( 782)						dif1 = theta;
            					}
            					else {
HXLINE( 782)						dif1 = -(theta);
            					}
HXDLIN( 782)					if (largest) {
HXLINE( 782)						dif = dif1;
            					}
            					else {
HXLINE( 782)						if (clockwise) {
HXLINE( 782)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXLINE( 782)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN( 782)			bool positive = (dif >= 0);
HXDLIN( 782)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 782)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 782)			Float angle = beta;
HXDLIN( 782)			Float cx;
HXDLIN( 782)			Float cy;
HXDLIN( 782)			Float bx = ( (Float)(0) );
HXDLIN( 782)			Float by = ( (Float)(0) );
HXDLIN( 782)			{
HXLINE( 782)				int _g = 0;
HXDLIN( 782)				int _g1 = (totalSteps + 1);
HXDLIN( 782)				while((_g < _g1)){
HXLINE( 782)					_g = (_g + 1);
HXDLIN( 782)					int i = (_g - 1);
HXDLIN( 782)					cx = (bx_ + (radius * ::Math_obj::sin(angle)));
HXDLIN( 782)					cy = (by_ + (radius * ::Math_obj::cos(angle)));
HXDLIN( 782)					if ((i != 0)) {
HXLINE( 782)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx_,by_,0,bx,by,0,cx,cy,0);
HXDLIN( 782)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 782)						if (::hx::IsNotNull( m )) {
HXLINE( 782)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 782)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 782)					angle = (angle + step1);
HXDLIN( 782)					bx = cx;
HXDLIN( 782)					by = cy;
            				}
            			}
HXDLIN( 782)			int len = totalSteps;
HXDLIN( 782)			{
HXLINE( 782)				 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 782)				int color = 0;
HXDLIN( 782)				if ((color == -1)) {
HXLINE( 782)					color = _this->currentColor;
            				}
HXDLIN( 782)				_this->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN( 782)			goto _hx_goto_47;
            		}
            		if (  (_hx_switch_0==3) ){
HXLINE( 784)			{
HXLINE( 784)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 784)				Float beta = (-(this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 784)				Float gamma = ((-(this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN( 784)				 ::Dynamic drawType = this->pen->drawType;
HXDLIN( 784)				 ::Dynamic sides = 36;
HXDLIN( 784)				if (::hx::IsNull( sides )) {
HXLINE( 784)					sides = 36;
            				}
HXDLIN( 784)				Float pi = ::Math_obj::PI;
HXDLIN( 784)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 784)				Float dif;
HXDLIN( 784)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXLINE( 784)						Float f;
HXDLIN( 784)						bool f1;
HXDLIN( 784)						if ((beta >= 0)) {
HXLINE( 784)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 784)							f1 = false;
            						}
HXDLIN( 784)						if (f1) {
HXLINE( 784)							f = beta;
            						}
            						else {
HXLINE( 784)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 784)							if ((a >= 0)) {
HXLINE( 784)								f = a;
            							}
            							else {
HXLINE( 784)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 784)						Float this1 = f;
HXDLIN( 784)						Float za = this1;
HXDLIN( 784)						Float f2;
HXDLIN( 784)						bool f3;
HXDLIN( 784)						if ((gamma >= 0)) {
HXLINE( 784)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 784)							f3 = false;
            						}
HXDLIN( 784)						if (f3) {
HXLINE( 784)							f2 = gamma;
            						}
            						else {
HXLINE( 784)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 784)							if ((a >= 0)) {
HXLINE( 784)								f2 = a;
            							}
            							else {
HXLINE( 784)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 784)						Float this2 = f2;
HXDLIN( 784)						Float zb = this2;
HXDLIN( 784)						Float fa = za;
HXDLIN( 784)						Float fb = zb;
HXDLIN( 784)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 784)						bool clockwise = (fa < fb);
HXDLIN( 784)						Float dif1;
HXDLIN( 784)						if (clockwise) {
HXLINE( 784)							dif1 = theta;
            						}
            						else {
HXLINE( 784)							dif1 = -(theta);
            						}
HXDLIN( 784)						if ((dif1 > 0)) {
HXLINE( 784)							dif = dif1;
            						}
            						else {
HXLINE( 784)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXLINE( 784)						Float f;
HXDLIN( 784)						bool f1;
HXDLIN( 784)						if ((beta >= 0)) {
HXLINE( 784)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 784)							f1 = false;
            						}
HXDLIN( 784)						if (f1) {
HXLINE( 784)							f = beta;
            						}
            						else {
HXLINE( 784)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 784)							if ((a >= 0)) {
HXLINE( 784)								f = a;
            							}
            							else {
HXLINE( 784)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 784)						Float this1 = f;
HXDLIN( 784)						Float za = this1;
HXDLIN( 784)						Float f2;
HXDLIN( 784)						bool f3;
HXDLIN( 784)						if ((gamma >= 0)) {
HXLINE( 784)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 784)							f3 = false;
            						}
HXDLIN( 784)						if (f3) {
HXLINE( 784)							f2 = gamma;
            						}
            						else {
HXLINE( 784)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 784)							if ((a >= 0)) {
HXLINE( 784)								f2 = a;
            							}
            							else {
HXLINE( 784)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 784)						Float this2 = f2;
HXDLIN( 784)						Float zb = this2;
HXDLIN( 784)						Float fa = za;
HXDLIN( 784)						Float fb = zb;
HXDLIN( 784)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 784)						bool clockwise = (fa < fb);
HXDLIN( 784)						Float dif1;
HXDLIN( 784)						if (clockwise) {
HXLINE( 784)							dif1 = theta;
            						}
            						else {
HXLINE( 784)							dif1 = -(theta);
            						}
HXDLIN( 784)						if ((dif1 < 0)) {
HXLINE( 784)							dif = dif1;
            						}
            						else {
HXLINE( 784)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXLINE( 784)						Float f;
HXDLIN( 784)						bool f1;
HXDLIN( 784)						if ((beta >= 0)) {
HXLINE( 784)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 784)							f1 = false;
            						}
HXDLIN( 784)						if (f1) {
HXLINE( 784)							f = beta;
            						}
            						else {
HXLINE( 784)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 784)							if ((a >= 0)) {
HXLINE( 784)								f = a;
            							}
            							else {
HXLINE( 784)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 784)						Float this1 = f;
HXDLIN( 784)						Float za = this1;
HXDLIN( 784)						Float f2;
HXDLIN( 784)						bool f3;
HXDLIN( 784)						if ((gamma >= 0)) {
HXLINE( 784)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 784)							f3 = false;
            						}
HXDLIN( 784)						if (f3) {
HXLINE( 784)							f2 = gamma;
            						}
            						else {
HXLINE( 784)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 784)							if ((a >= 0)) {
HXLINE( 784)								f2 = a;
            							}
            							else {
HXLINE( 784)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 784)						Float this2 = f2;
HXDLIN( 784)						Float zb = this2;
HXDLIN( 784)						Float fa = za;
HXDLIN( 784)						Float fb = zb;
HXDLIN( 784)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 784)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 784)						bool clockwise = (fa < fb);
HXDLIN( 784)						Float dif1;
HXDLIN( 784)						if (clockwise) {
HXLINE( 784)							dif1 = theta;
            						}
            						else {
HXLINE( 784)							dif1 = -(theta);
            						}
HXDLIN( 784)						if (smallest) {
HXLINE( 784)							dif = dif1;
            						}
            						else {
HXLINE( 784)							if (clockwise) {
HXLINE( 784)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 784)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXLINE( 784)						Float f;
HXDLIN( 784)						bool f1;
HXDLIN( 784)						if ((beta >= 0)) {
HXLINE( 784)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 784)							f1 = false;
            						}
HXDLIN( 784)						if (f1) {
HXLINE( 784)							f = beta;
            						}
            						else {
HXLINE( 784)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 784)							if ((a >= 0)) {
HXLINE( 784)								f = a;
            							}
            							else {
HXLINE( 784)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 784)						Float this1 = f;
HXDLIN( 784)						Float za = this1;
HXDLIN( 784)						Float f2;
HXDLIN( 784)						bool f3;
HXDLIN( 784)						if ((gamma >= 0)) {
HXLINE( 784)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 784)							f3 = false;
            						}
HXDLIN( 784)						if (f3) {
HXLINE( 784)							f2 = gamma;
            						}
            						else {
HXLINE( 784)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 784)							if ((a >= 0)) {
HXLINE( 784)								f2 = a;
            							}
            							else {
HXLINE( 784)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 784)						Float this2 = f2;
HXDLIN( 784)						Float zb = this2;
HXDLIN( 784)						Float fa = za;
HXDLIN( 784)						Float fb = zb;
HXDLIN( 784)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 784)						bool largest = (theta > ::Math_obj::PI);
HXDLIN( 784)						bool clockwise = (fa < fb);
HXDLIN( 784)						Float dif1;
HXDLIN( 784)						if (clockwise) {
HXLINE( 784)							dif1 = theta;
            						}
            						else {
HXLINE( 784)							dif1 = -(theta);
            						}
HXDLIN( 784)						if (largest) {
HXLINE( 784)							dif = dif1;
            						}
            						else {
HXLINE( 784)							if (clockwise) {
HXLINE( 784)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 784)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN( 784)				bool positive = (dif >= 0);
HXDLIN( 784)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 784)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 784)				Float angle = beta;
HXDLIN( 784)				Float cx;
HXDLIN( 784)				Float cy;
HXDLIN( 784)				Float bx = ( (Float)(0) );
HXDLIN( 784)				Float by = ( (Float)(0) );
HXDLIN( 784)				{
HXLINE( 784)					int _g = 0;
HXDLIN( 784)					int _g1 = (totalSteps + 1);
HXDLIN( 784)					while((_g < _g1)){
HXLINE( 784)						_g = (_g + 1);
HXDLIN( 784)						int i = (_g - 1);
HXDLIN( 784)						cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN( 784)						cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN( 784)						if ((i != 0)) {
HXLINE( 784)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN( 784)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 784)							if (::hx::IsNotNull( m )) {
HXLINE( 784)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN( 784)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 784)						angle = (angle + step1);
HXDLIN( 784)						bx = cx;
HXDLIN( 784)						by = cy;
            					}
            				}
HXDLIN( 784)				int len = totalSteps;
HXDLIN( 784)				{
HXLINE( 784)					 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 784)					int color = 0;
HXDLIN( 784)					if ((color == -1)) {
HXLINE( 784)						color = _this->currentColor;
            					}
HXDLIN( 784)					_this->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            				}
            			}
HXLINE( 785)			{
HXLINE( 785)				Float radius1 = (width_ / ( (Float)(2) ));
HXDLIN( 785)				Float beta1 = (-(this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 785)				Float gamma1 = ((-(this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 785)				 ::Dynamic drawType1 = this->pen->drawType;
HXDLIN( 785)				 ::Dynamic sides1 = 36;
HXDLIN( 785)				if (::hx::IsNull( sides1 )) {
HXLINE( 785)					sides1 = 36;
            				}
HXDLIN( 785)				Float pi1 = ::Math_obj::PI;
HXDLIN( 785)				Float step2 = ((pi1 * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 785)				Float dif1;
HXDLIN( 785)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXLINE( 785)						Float f;
HXDLIN( 785)						bool f1;
HXDLIN( 785)						if ((beta1 >= 0)) {
HXLINE( 785)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXLINE( 785)							f1 = false;
            						}
HXDLIN( 785)						if (f1) {
HXLINE( 785)							f = beta1;
            						}
            						else {
HXLINE( 785)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 785)							if ((a >= 0)) {
HXLINE( 785)								f = a;
            							}
            							else {
HXLINE( 785)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 785)						Float this1 = f;
HXDLIN( 785)						Float za = this1;
HXDLIN( 785)						Float f2;
HXDLIN( 785)						bool f3;
HXDLIN( 785)						if ((gamma1 >= 0)) {
HXLINE( 785)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXLINE( 785)							f3 = false;
            						}
HXDLIN( 785)						if (f3) {
HXLINE( 785)							f2 = gamma1;
            						}
            						else {
HXLINE( 785)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 785)							if ((a >= 0)) {
HXLINE( 785)								f2 = a;
            							}
            							else {
HXLINE( 785)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 785)						Float this2 = f2;
HXDLIN( 785)						Float zb = this2;
HXDLIN( 785)						Float fa = za;
HXDLIN( 785)						Float fb = zb;
HXDLIN( 785)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 785)						bool clockwise = (fa < fb);
HXDLIN( 785)						Float dif;
HXDLIN( 785)						if (clockwise) {
HXLINE( 785)							dif = theta;
            						}
            						else {
HXLINE( 785)							dif = -(theta);
            						}
HXDLIN( 785)						if ((dif > 0)) {
HXLINE( 785)							dif1 = dif;
            						}
            						else {
HXLINE( 785)							dif1 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)1: {
HXLINE( 785)						Float f;
HXDLIN( 785)						bool f1;
HXDLIN( 785)						if ((beta1 >= 0)) {
HXLINE( 785)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXLINE( 785)							f1 = false;
            						}
HXDLIN( 785)						if (f1) {
HXLINE( 785)							f = beta1;
            						}
            						else {
HXLINE( 785)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 785)							if ((a >= 0)) {
HXLINE( 785)								f = a;
            							}
            							else {
HXLINE( 785)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 785)						Float this1 = f;
HXDLIN( 785)						Float za = this1;
HXDLIN( 785)						Float f2;
HXDLIN( 785)						bool f3;
HXDLIN( 785)						if ((gamma1 >= 0)) {
HXLINE( 785)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXLINE( 785)							f3 = false;
            						}
HXDLIN( 785)						if (f3) {
HXLINE( 785)							f2 = gamma1;
            						}
            						else {
HXLINE( 785)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 785)							if ((a >= 0)) {
HXLINE( 785)								f2 = a;
            							}
            							else {
HXLINE( 785)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 785)						Float this2 = f2;
HXDLIN( 785)						Float zb = this2;
HXDLIN( 785)						Float fa = za;
HXDLIN( 785)						Float fb = zb;
HXDLIN( 785)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 785)						bool clockwise = (fa < fb);
HXDLIN( 785)						Float dif;
HXDLIN( 785)						if (clockwise) {
HXLINE( 785)							dif = theta;
            						}
            						else {
HXLINE( 785)							dif = -(theta);
            						}
HXDLIN( 785)						if ((dif < 0)) {
HXLINE( 785)							dif1 = dif;
            						}
            						else {
HXLINE( 785)							dif1 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)2: {
HXLINE( 785)						Float f;
HXDLIN( 785)						bool f1;
HXDLIN( 785)						if ((beta1 >= 0)) {
HXLINE( 785)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXLINE( 785)							f1 = false;
            						}
HXDLIN( 785)						if (f1) {
HXLINE( 785)							f = beta1;
            						}
            						else {
HXLINE( 785)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 785)							if ((a >= 0)) {
HXLINE( 785)								f = a;
            							}
            							else {
HXLINE( 785)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 785)						Float this1 = f;
HXDLIN( 785)						Float za = this1;
HXDLIN( 785)						Float f2;
HXDLIN( 785)						bool f3;
HXDLIN( 785)						if ((gamma1 >= 0)) {
HXLINE( 785)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXLINE( 785)							f3 = false;
            						}
HXDLIN( 785)						if (f3) {
HXLINE( 785)							f2 = gamma1;
            						}
            						else {
HXLINE( 785)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 785)							if ((a >= 0)) {
HXLINE( 785)								f2 = a;
            							}
            							else {
HXLINE( 785)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 785)						Float this2 = f2;
HXDLIN( 785)						Float zb = this2;
HXDLIN( 785)						Float fa = za;
HXDLIN( 785)						Float fb = zb;
HXDLIN( 785)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 785)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 785)						bool clockwise = (fa < fb);
HXDLIN( 785)						Float dif;
HXDLIN( 785)						if (clockwise) {
HXLINE( 785)							dif = theta;
            						}
            						else {
HXLINE( 785)							dif = -(theta);
            						}
HXDLIN( 785)						if (smallest) {
HXLINE( 785)							dif1 = dif;
            						}
            						else {
HXLINE( 785)							if (clockwise) {
HXLINE( 785)								dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 785)								dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXLINE( 785)						Float f;
HXDLIN( 785)						bool f1;
HXDLIN( 785)						if ((beta1 >= 0)) {
HXLINE( 785)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXLINE( 785)							f1 = false;
            						}
HXDLIN( 785)						if (f1) {
HXLINE( 785)							f = beta1;
            						}
            						else {
HXLINE( 785)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 785)							if ((a >= 0)) {
HXLINE( 785)								f = a;
            							}
            							else {
HXLINE( 785)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 785)						Float this1 = f;
HXDLIN( 785)						Float za = this1;
HXDLIN( 785)						Float f2;
HXDLIN( 785)						bool f3;
HXDLIN( 785)						if ((gamma1 >= 0)) {
HXLINE( 785)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXLINE( 785)							f3 = false;
            						}
HXDLIN( 785)						if (f3) {
HXLINE( 785)							f2 = gamma1;
            						}
            						else {
HXLINE( 785)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 785)							if ((a >= 0)) {
HXLINE( 785)								f2 = a;
            							}
            							else {
HXLINE( 785)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 785)						Float this2 = f2;
HXDLIN( 785)						Float zb = this2;
HXDLIN( 785)						Float fa = za;
HXDLIN( 785)						Float fb = zb;
HXDLIN( 785)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 785)						bool largest = (theta > ::Math_obj::PI);
HXDLIN( 785)						bool clockwise = (fa < fb);
HXDLIN( 785)						Float dif;
HXDLIN( 785)						if (clockwise) {
HXLINE( 785)							dif = theta;
            						}
            						else {
HXLINE( 785)							dif = -(theta);
            						}
HXDLIN( 785)						if (largest) {
HXLINE( 785)							dif1 = dif;
            						}
            						else {
HXLINE( 785)							if (clockwise) {
HXLINE( 785)								dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 785)								dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN( 785)				bool positive1 = (dif1 >= 0);
HXDLIN( 785)				int totalSteps1 = ::Math_obj::ceil((::Math_obj::abs(dif1) / step2));
HXDLIN( 785)				Float step3 = (dif1 / ( (Float)(totalSteps1) ));
HXDLIN( 785)				Float angle1 = beta1;
HXDLIN( 785)				Float cx1;
HXDLIN( 785)				Float cy1;
HXDLIN( 785)				Float bx1 = ( (Float)(0) );
HXDLIN( 785)				Float by1 = ( (Float)(0) );
HXDLIN( 785)				{
HXLINE( 785)					int _g2 = 0;
HXDLIN( 785)					int _g3 = (totalSteps1 + 1);
HXDLIN( 785)					while((_g2 < _g3)){
HXLINE( 785)						_g2 = (_g2 + 1);
HXDLIN( 785)						int i = (_g2 - 1);
HXDLIN( 785)						cx1 = (bx_ + (radius1 * ::Math_obj::sin(angle1)));
HXDLIN( 785)						cy1 = (by_ + (radius1 * ::Math_obj::cos(angle1)));
HXDLIN( 785)						if ((i != 0)) {
HXLINE( 785)							drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx_,by_,0,bx1,by1,0,cx1,cy1,0);
HXDLIN( 785)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 785)							if (::hx::IsNotNull( m )) {
HXLINE( 785)								drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN( 785)							drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 785)						angle1 = (angle1 + step3);
HXDLIN( 785)						bx1 = cx1;
HXDLIN( 785)						by1 = cy1;
            					}
            				}
HXDLIN( 785)				int len1 = totalSteps1;
HXDLIN( 785)				{
HXLINE( 785)					 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 785)					int color1 = 0;
HXDLIN( 785)					if ((color1 == -1)) {
HXLINE( 785)						color1 = _this1->currentColor;
            					}
HXDLIN( 785)					_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
            				}
            			}
HXLINE( 783)			goto _hx_goto_47;
            		}
            		_hx_goto_47:;
HXLINE( 787)		{
HXLINE( 787)			 ::trilateral3::drawing::Pen _this = this->pen;
HXDLIN( 787)			int color = -1;
HXDLIN( 787)			if ((color == -1)) {
HXLINE( 787)				color = _this->currentColor;
            			}
HXDLIN( 787)			{
HXLINE( 787)				_this->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(exPrev_) ),( (Float)(eyPrev_) ),0);
HXDLIN( 787)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 787)					_this->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN( 787)				_this->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 787)			_this->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            		}
HXLINE( 788)		{
HXLINE( 788)			 ::trilateral3::drawing::Pen _this1 = this->pen;
HXDLIN( 788)			int color1 = -1;
HXDLIN( 788)			if ((color1 == -1)) {
HXLINE( 788)				color1 = _this1->currentColor;
            			}
HXDLIN( 788)			{
HXLINE( 788)				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(this->dx) ),( (Float)(this->dy) ),0,( (Float)(this->ex) ),( (Float)(this->ey) ),0);
HXDLIN( 788)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE( 788)					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN( 788)				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 788)			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC6(Contour_obj,line,(void))

Float Contour_obj::smallDotScale;

Float Contour_obj::thetaCompute(Float px,Float py,Float qx,Float qy){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_182_thetaCompute)
HXDLIN( 182)		return ::Math_obj::atan2((py - qy),(px - qx));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Contour_obj,thetaCompute,return )

Float Contour_obj::dist(Float px,Float py,Float qx,Float qy){
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_185_dist)
HXLINE( 186)		Float x = (px - qx);
HXLINE( 187)		Float y = (py - qy);
HXLINE( 188)		return ((x * x) + (y * y));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Contour_obj,dist,return )


::hx::ObjectPtr< Contour_obj > Contour_obj::__new( ::trilateral3::drawing::Pen pen_,::hx::Null< int >  __o_endLine_) {
	::hx::ObjectPtr< Contour_obj > __this = new Contour_obj();
	__this->__construct(pen_,__o_endLine_);
	return __this;
}

::hx::ObjectPtr< Contour_obj > Contour_obj::__alloc(::hx::Ctx *_hx_ctx, ::trilateral3::drawing::Pen pen_,::hx::Null< int >  __o_endLine_) {
	Contour_obj *__this = (Contour_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Contour_obj), true, "trilateral3.drawing.Contour"));
	*(void **)__this = Contour_obj::_hx_vtable;
	__this->__construct(pen_,__o_endLine_);
	return __this;
}

Contour_obj::Contour_obj()
{
}

void Contour_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Contour);
	HX_MARK_MEMBER_NAME(debugCol0,"debugCol0");
	HX_MARK_MEMBER_NAME(debugCol1,"debugCol1");
	HX_MARK_MEMBER_NAME(debugCol2,"debugCol2");
	HX_MARK_MEMBER_NAME(debugCol3,"debugCol3");
	HX_MARK_MEMBER_NAME(debugCol4,"debugCol4");
	HX_MARK_MEMBER_NAME(debugCol5,"debugCol5");
	HX_MARK_MEMBER_NAME(debugCol6,"debugCol6");
	HX_MARK_MEMBER_NAME(debugCol7,"debugCol7");
	HX_MARK_MEMBER_NAME(debugCol8,"debugCol8");
	HX_MARK_MEMBER_NAME(debugCol9,"debugCol9");
	HX_MARK_MEMBER_NAME(debugCol10,"debugCol10");
	HX_MARK_MEMBER_NAME(debugCol11,"debugCol11");
	HX_MARK_MEMBER_NAME(debugCol12,"debugCol12");
	HX_MARK_MEMBER_NAME(pointsClock,"pointsClock");
	HX_MARK_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_MARK_MEMBER_NAME(penultimateCX,"penultimateCX");
	HX_MARK_MEMBER_NAME(penultimateCY,"penultimateCY");
	HX_MARK_MEMBER_NAME(lastClockX,"lastClockX");
	HX_MARK_MEMBER_NAME(lastClockY,"lastClockY");
	HX_MARK_MEMBER_NAME(penultimateAX,"penultimateAX");
	HX_MARK_MEMBER_NAME(penultimateAY,"penultimateAY");
	HX_MARK_MEMBER_NAME(lastAntiX,"lastAntiX");
	HX_MARK_MEMBER_NAME(lastAntiY,"lastAntiY");
	HX_MARK_MEMBER_NAME(pen,"pen");
	HX_MARK_MEMBER_NAME(endLine,"endLine");
	HX_MARK_MEMBER_NAME(ax,"ax");
	HX_MARK_MEMBER_NAME(ay,"ay");
	HX_MARK_MEMBER_NAME(bx,"bx");
	HX_MARK_MEMBER_NAME(by,"by");
	HX_MARK_MEMBER_NAME(cx,"cx");
	HX_MARK_MEMBER_NAME(cy,"cy");
	HX_MARK_MEMBER_NAME(dx,"dx");
	HX_MARK_MEMBER_NAME(dy,"dy");
	HX_MARK_MEMBER_NAME(ex,"ex");
	HX_MARK_MEMBER_NAME(ey,"ey");
	HX_MARK_MEMBER_NAME(dxPrev,"dxPrev");
	HX_MARK_MEMBER_NAME(dyPrev,"dyPrev");
	HX_MARK_MEMBER_NAME(exPrev,"exPrev");
	HX_MARK_MEMBER_NAME(eyPrev,"eyPrev");
	HX_MARK_MEMBER_NAME(dxOld,"dxOld");
	HX_MARK_MEMBER_NAME(dyOld,"dyOld");
	HX_MARK_MEMBER_NAME(exOld,"exOld");
	HX_MARK_MEMBER_NAME(eyOld,"eyOld");
	HX_MARK_MEMBER_NAME(jx,"jx");
	HX_MARK_MEMBER_NAME(jy,"jy");
	HX_MARK_MEMBER_NAME(lastClock,"lastClock");
	HX_MARK_MEMBER_NAME(jxOld,"jxOld");
	HX_MARK_MEMBER_NAME(jyOld,"jyOld");
	HX_MARK_MEMBER_NAME(kax,"kax");
	HX_MARK_MEMBER_NAME(kay,"kay");
	HX_MARK_MEMBER_NAME(kbx,"kbx");
	HX_MARK_MEMBER_NAME(kby,"kby");
	HX_MARK_MEMBER_NAME(kcx,"kcx");
	HX_MARK_MEMBER_NAME(kcy,"kcy");
	HX_MARK_MEMBER_NAME(ncx,"ncx");
	HX_MARK_MEMBER_NAME(ncy,"ncy");
	HX_MARK_MEMBER_NAME(quadIndex,"quadIndex");
	HX_MARK_MEMBER_NAME(angleA,"angleA");
	HX_MARK_MEMBER_NAME(halfA,"halfA");
	HX_MARK_MEMBER_NAME(beta,"beta");
	HX_MARK_MEMBER_NAME(r,"r");
	HX_MARK_MEMBER_NAME(theta,"theta");
	HX_MARK_MEMBER_NAME(angle1,"angle1");
	HX_MARK_MEMBER_NAME(angle2,"angle2");
	HX_MARK_MEMBER_NAME(count,"count");
	HX_MARK_MEMBER_NAME(counter,"counter");
	HX_MARK_END_CLASS();
}

void Contour_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(debugCol0,"debugCol0");
	HX_VISIT_MEMBER_NAME(debugCol1,"debugCol1");
	HX_VISIT_MEMBER_NAME(debugCol2,"debugCol2");
	HX_VISIT_MEMBER_NAME(debugCol3,"debugCol3");
	HX_VISIT_MEMBER_NAME(debugCol4,"debugCol4");
	HX_VISIT_MEMBER_NAME(debugCol5,"debugCol5");
	HX_VISIT_MEMBER_NAME(debugCol6,"debugCol6");
	HX_VISIT_MEMBER_NAME(debugCol7,"debugCol7");
	HX_VISIT_MEMBER_NAME(debugCol8,"debugCol8");
	HX_VISIT_MEMBER_NAME(debugCol9,"debugCol9");
	HX_VISIT_MEMBER_NAME(debugCol10,"debugCol10");
	HX_VISIT_MEMBER_NAME(debugCol11,"debugCol11");
	HX_VISIT_MEMBER_NAME(debugCol12,"debugCol12");
	HX_VISIT_MEMBER_NAME(pointsClock,"pointsClock");
	HX_VISIT_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_VISIT_MEMBER_NAME(penultimateCX,"penultimateCX");
	HX_VISIT_MEMBER_NAME(penultimateCY,"penultimateCY");
	HX_VISIT_MEMBER_NAME(lastClockX,"lastClockX");
	HX_VISIT_MEMBER_NAME(lastClockY,"lastClockY");
	HX_VISIT_MEMBER_NAME(penultimateAX,"penultimateAX");
	HX_VISIT_MEMBER_NAME(penultimateAY,"penultimateAY");
	HX_VISIT_MEMBER_NAME(lastAntiX,"lastAntiX");
	HX_VISIT_MEMBER_NAME(lastAntiY,"lastAntiY");
	HX_VISIT_MEMBER_NAME(pen,"pen");
	HX_VISIT_MEMBER_NAME(endLine,"endLine");
	HX_VISIT_MEMBER_NAME(ax,"ax");
	HX_VISIT_MEMBER_NAME(ay,"ay");
	HX_VISIT_MEMBER_NAME(bx,"bx");
	HX_VISIT_MEMBER_NAME(by,"by");
	HX_VISIT_MEMBER_NAME(cx,"cx");
	HX_VISIT_MEMBER_NAME(cy,"cy");
	HX_VISIT_MEMBER_NAME(dx,"dx");
	HX_VISIT_MEMBER_NAME(dy,"dy");
	HX_VISIT_MEMBER_NAME(ex,"ex");
	HX_VISIT_MEMBER_NAME(ey,"ey");
	HX_VISIT_MEMBER_NAME(dxPrev,"dxPrev");
	HX_VISIT_MEMBER_NAME(dyPrev,"dyPrev");
	HX_VISIT_MEMBER_NAME(exPrev,"exPrev");
	HX_VISIT_MEMBER_NAME(eyPrev,"eyPrev");
	HX_VISIT_MEMBER_NAME(dxOld,"dxOld");
	HX_VISIT_MEMBER_NAME(dyOld,"dyOld");
	HX_VISIT_MEMBER_NAME(exOld,"exOld");
	HX_VISIT_MEMBER_NAME(eyOld,"eyOld");
	HX_VISIT_MEMBER_NAME(jx,"jx");
	HX_VISIT_MEMBER_NAME(jy,"jy");
	HX_VISIT_MEMBER_NAME(lastClock,"lastClock");
	HX_VISIT_MEMBER_NAME(jxOld,"jxOld");
	HX_VISIT_MEMBER_NAME(jyOld,"jyOld");
	HX_VISIT_MEMBER_NAME(kax,"kax");
	HX_VISIT_MEMBER_NAME(kay,"kay");
	HX_VISIT_MEMBER_NAME(kbx,"kbx");
	HX_VISIT_MEMBER_NAME(kby,"kby");
	HX_VISIT_MEMBER_NAME(kcx,"kcx");
	HX_VISIT_MEMBER_NAME(kcy,"kcy");
	HX_VISIT_MEMBER_NAME(ncx,"ncx");
	HX_VISIT_MEMBER_NAME(ncy,"ncy");
	HX_VISIT_MEMBER_NAME(quadIndex,"quadIndex");
	HX_VISIT_MEMBER_NAME(angleA,"angleA");
	HX_VISIT_MEMBER_NAME(halfA,"halfA");
	HX_VISIT_MEMBER_NAME(beta,"beta");
	HX_VISIT_MEMBER_NAME(r,"r");
	HX_VISIT_MEMBER_NAME(theta,"theta");
	HX_VISIT_MEMBER_NAME(angle1,"angle1");
	HX_VISIT_MEMBER_NAME(angle2,"angle2");
	HX_VISIT_MEMBER_NAME(count,"count");
	HX_VISIT_MEMBER_NAME(counter,"counter");
}

::hx::Val Contour_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"r") ) { return ::hx::Val( r ); }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"ax") ) { return ::hx::Val( ax ); }
		if (HX_FIELD_EQ(inName,"ay") ) { return ::hx::Val( ay ); }
		if (HX_FIELD_EQ(inName,"bx") ) { return ::hx::Val( bx ); }
		if (HX_FIELD_EQ(inName,"by") ) { return ::hx::Val( by ); }
		if (HX_FIELD_EQ(inName,"cx") ) { return ::hx::Val( cx ); }
		if (HX_FIELD_EQ(inName,"cy") ) { return ::hx::Val( cy ); }
		if (HX_FIELD_EQ(inName,"dx") ) { return ::hx::Val( dx ); }
		if (HX_FIELD_EQ(inName,"dy") ) { return ::hx::Val( dy ); }
		if (HX_FIELD_EQ(inName,"ex") ) { return ::hx::Val( ex ); }
		if (HX_FIELD_EQ(inName,"ey") ) { return ::hx::Val( ey ); }
		if (HX_FIELD_EQ(inName,"jx") ) { return ::hx::Val( jx ); }
		if (HX_FIELD_EQ(inName,"jy") ) { return ::hx::Val( jy ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { return ::hx::Val( pen ); }
		if (HX_FIELD_EQ(inName,"kax") ) { return ::hx::Val( kax ); }
		if (HX_FIELD_EQ(inName,"kay") ) { return ::hx::Val( kay ); }
		if (HX_FIELD_EQ(inName,"kbx") ) { return ::hx::Val( kbx ); }
		if (HX_FIELD_EQ(inName,"kby") ) { return ::hx::Val( kby ); }
		if (HX_FIELD_EQ(inName,"kcx") ) { return ::hx::Val( kcx ); }
		if (HX_FIELD_EQ(inName,"kcy") ) { return ::hx::Val( kcy ); }
		if (HX_FIELD_EQ(inName,"ncx") ) { return ::hx::Val( ncx ); }
		if (HX_FIELD_EQ(inName,"ncy") ) { return ::hx::Val( ncy ); }
		if (HX_FIELD_EQ(inName,"end") ) { return ::hx::Val( end_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"beta") ) { return ::hx::Val( beta ); }
		if (HX_FIELD_EQ(inName,"line") ) { return ::hx::Val( line_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"dxOld") ) { return ::hx::Val( dxOld ); }
		if (HX_FIELD_EQ(inName,"dyOld") ) { return ::hx::Val( dyOld ); }
		if (HX_FIELD_EQ(inName,"exOld") ) { return ::hx::Val( exOld ); }
		if (HX_FIELD_EQ(inName,"eyOld") ) { return ::hx::Val( eyOld ); }
		if (HX_FIELD_EQ(inName,"jxOld") ) { return ::hx::Val( jxOld ); }
		if (HX_FIELD_EQ(inName,"jyOld") ) { return ::hx::Val( jyOld ); }
		if (HX_FIELD_EQ(inName,"halfA") ) { return ::hx::Val( halfA ); }
		if (HX_FIELD_EQ(inName,"theta") ) { return ::hx::Val( theta ); }
		if (HX_FIELD_EQ(inName,"reset") ) { return ::hx::Val( reset_dyn() ); }
		if (HX_FIELD_EQ(inName,"count") ) { return ::hx::Val( count ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"dxPrev") ) { return ::hx::Val( dxPrev ); }
		if (HX_FIELD_EQ(inName,"dyPrev") ) { return ::hx::Val( dyPrev ); }
		if (HX_FIELD_EQ(inName,"exPrev") ) { return ::hx::Val( exPrev ); }
		if (HX_FIELD_EQ(inName,"eyPrev") ) { return ::hx::Val( eyPrev ); }
		if (HX_FIELD_EQ(inName,"angleA") ) { return ::hx::Val( angleA ); }
		if (HX_FIELD_EQ(inName,"angle1") ) { return ::hx::Val( angle1 ); }
		if (HX_FIELD_EQ(inName,"angle2") ) { return ::hx::Val( angle2 ); }
		if (HX_FIELD_EQ(inName,"addPie") ) { return ::hx::Val( addPie_dyn() ); }
		if (HX_FIELD_EQ(inName,"addDot") ) { return ::hx::Val( addDot_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"endLine") ) { return ::hx::Val( endLine ); }
		if (HX_FIELD_EQ(inName,"addPieX") ) { return ::hx::Val( addPieX_dyn() ); }
		if (HX_FIELD_EQ(inName,"counter") ) { return ::hx::Val( counter ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"computeJ") ) { return ::hx::Val( computeJ_dyn() ); }
		if (HX_FIELD_EQ(inName,"endEdges") ) { return ::hx::Val( endEdges_dyn() ); }
		if (HX_FIELD_EQ(inName,"addQuads") ) { return ::hx::Val( addQuads_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"debugCol0") ) { return ::hx::Val( debugCol0 ); }
		if (HX_FIELD_EQ(inName,"debugCol1") ) { return ::hx::Val( debugCol1 ); }
		if (HX_FIELD_EQ(inName,"debugCol2") ) { return ::hx::Val( debugCol2 ); }
		if (HX_FIELD_EQ(inName,"debugCol3") ) { return ::hx::Val( debugCol3 ); }
		if (HX_FIELD_EQ(inName,"debugCol4") ) { return ::hx::Val( debugCol4 ); }
		if (HX_FIELD_EQ(inName,"debugCol5") ) { return ::hx::Val( debugCol5 ); }
		if (HX_FIELD_EQ(inName,"debugCol6") ) { return ::hx::Val( debugCol6 ); }
		if (HX_FIELD_EQ(inName,"debugCol7") ) { return ::hx::Val( debugCol7 ); }
		if (HX_FIELD_EQ(inName,"debugCol8") ) { return ::hx::Val( debugCol8 ); }
		if (HX_FIELD_EQ(inName,"debugCol9") ) { return ::hx::Val( debugCol9 ); }
		if (HX_FIELD_EQ(inName,"lastAntiX") ) { return ::hx::Val( lastAntiX ); }
		if (HX_FIELD_EQ(inName,"lastAntiY") ) { return ::hx::Val( lastAntiY ); }
		if (HX_FIELD_EQ(inName,"lastClock") ) { return ::hx::Val( lastClock ); }
		if (HX_FIELD_EQ(inName,"quadIndex") ) { return ::hx::Val( quadIndex ); }
		if (HX_FIELD_EQ(inName,"computeDE") ) { return ::hx::Val( computeDE_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"debugCol10") ) { return ::hx::Val( debugCol10 ); }
		if (HX_FIELD_EQ(inName,"debugCol11") ) { return ::hx::Val( debugCol11 ); }
		if (HX_FIELD_EQ(inName,"debugCol12") ) { return ::hx::Val( debugCol12 ); }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { return ::hx::Val( pointsAnti ); }
		if (HX_FIELD_EQ(inName,"lastClockX") ) { return ::hx::Val( lastClockX ); }
		if (HX_FIELD_EQ(inName,"lastClockY") ) { return ::hx::Val( lastClockY ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { return ::hx::Val( pointsClock ); }
		if (HX_FIELD_EQ(inName,"overlapQuad") ) { return ::hx::Val( overlapQuad_dyn() ); }
		if (HX_FIELD_EQ(inName,"isClockwise") ) { return ::hx::Val( isClockwise_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"triangleJoin") ) { return ::hx::Val( triangleJoin_dyn() ); }
		if (HX_FIELD_EQ(inName,"addPieXstart") ) { return ::hx::Val( addPieXstart_dyn() ); }
		if (HX_FIELD_EQ(inName,"connectQuads") ) { return ::hx::Val( connectQuads_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"penultimateCX") ) { return ::hx::Val( penultimateCX ); }
		if (HX_FIELD_EQ(inName,"penultimateCY") ) { return ::hx::Val( penultimateCY ); }
		if (HX_FIELD_EQ(inName,"penultimateAX") ) { return ::hx::Val( penultimateAX ); }
		if (HX_FIELD_EQ(inName,"penultimateAY") ) { return ::hx::Val( penultimateAY ); }
		if (HX_FIELD_EQ(inName,"anglesCompute") ) { return ::hx::Val( anglesCompute_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"triangle2DFill") ) { return ::hx::Val( triangle2DFill_dyn() ); }
		if (HX_FIELD_EQ(inName,"storeLastQuads") ) { return ::hx::Val( storeLastQuads_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"thetaComputeAdj") ) { return ::hx::Val( thetaComputeAdj_dyn() ); }
		if (HX_FIELD_EQ(inName,"addInitialQuads") ) { return ::hx::Val( addInitialQuads_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"addSmallTriangles") ) { return ::hx::Val( addSmallTriangles_dyn() ); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"triangle2DFillangleCorners") ) { return ::hx::Val( triangle2DFillangleCorners_dyn() ); }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"connectQuadsWhenQuadsOverlay") ) { return ::hx::Val( connectQuadsWhenQuadsOverlay_dyn() ); }
		break;
	case 30:
		if (HX_FIELD_EQ(inName,"triangle2DFillangleCornersLess") ) { return ::hx::Val( triangle2DFillangleCornersLess_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Contour_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"dist") ) { outValue = dist_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"thetaCompute") ) { outValue = thetaCompute_dyn(); return true; }
	}
	return false;
}

::hx::Val Contour_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"r") ) { r=inValue.Cast< Float >(); return inValue; }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"ax") ) { ax=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ay") ) { ay=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bx") ) { bx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"by") ) { by=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cx") ) { cx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cy") ) { cy=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dx") ) { dx=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dy") ) { dy=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ex") ) { ex=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ey") ) { ey=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"jx") ) { jx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"jy") ) { jy=inValue.Cast< Float >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { pen=inValue.Cast<  ::trilateral3::drawing::Pen >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kax") ) { kax=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kay") ) { kay=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kbx") ) { kbx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kby") ) { kby=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kcx") ) { kcx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kcy") ) { kcy=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ncx") ) { ncx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ncy") ) { ncy=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"beta") ) { beta=inValue.Cast< Float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"dxOld") ) { dxOld=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dyOld") ) { dyOld=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"exOld") ) { exOld=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"eyOld") ) { eyOld=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"jxOld") ) { jxOld=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"jyOld") ) { jyOld=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"halfA") ) { halfA=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"theta") ) { theta=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"count") ) { count=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"dxPrev") ) { dxPrev=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dyPrev") ) { dyPrev=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"exPrev") ) { exPrev=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"eyPrev") ) { eyPrev=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"angleA") ) { angleA=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"angle1") ) { angle1=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"angle2") ) { angle2=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"endLine") ) { endLine=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"counter") ) { counter=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"debugCol0") ) { debugCol0=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol1") ) { debugCol1=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol2") ) { debugCol2=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol3") ) { debugCol3=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol4") ) { debugCol4=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol5") ) { debugCol5=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol6") ) { debugCol6=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol7") ) { debugCol7=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol8") ) { debugCol8=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol9") ) { debugCol9=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastAntiX") ) { lastAntiX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastAntiY") ) { lastAntiY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastClock") ) { lastClock=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"quadIndex") ) { quadIndex=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"debugCol10") ) { debugCol10=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol11") ) { debugCol11=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugCol12") ) { debugCol12=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { pointsAnti=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastClockX") ) { lastClockX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastClockY") ) { lastClockY=inValue.Cast< Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { pointsClock=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"penultimateCX") ) { penultimateCX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"penultimateCY") ) { penultimateCY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"penultimateAX") ) { penultimateAX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"penultimateAY") ) { penultimateAY=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Contour_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("debugCol0",e3,5b,10,25));
	outFields->push(HX_("debugCol1",e4,5b,10,25));
	outFields->push(HX_("debugCol2",e5,5b,10,25));
	outFields->push(HX_("debugCol3",e6,5b,10,25));
	outFields->push(HX_("debugCol4",e7,5b,10,25));
	outFields->push(HX_("debugCol5",e8,5b,10,25));
	outFields->push(HX_("debugCol6",e9,5b,10,25));
	outFields->push(HX_("debugCol7",ea,5b,10,25));
	outFields->push(HX_("debugCol8",eb,5b,10,25));
	outFields->push(HX_("debugCol9",ec,5b,10,25));
	outFields->push(HX_("debugCol10",cc,0b,40,49));
	outFields->push(HX_("debugCol11",cd,0b,40,49));
	outFields->push(HX_("debugCol12",ce,0b,40,49));
	outFields->push(HX_("pointsClock",ab,c8,9e,88));
	outFields->push(HX_("pointsAnti",65,1b,f0,ae));
	outFields->push(HX_("penultimateCX",5f,f6,17,69));
	outFields->push(HX_("penultimateCY",60,f6,17,69));
	outFields->push(HX_("lastClockX",c0,6d,20,d9));
	outFields->push(HX_("lastClockY",c1,6d,20,d9));
	outFields->push(HX_("penultimateAX",a1,f4,17,69));
	outFields->push(HX_("penultimateAY",a2,f4,17,69));
	outFields->push(HX_("lastAntiX",40,4c,99,6f));
	outFields->push(HX_("lastAntiY",41,4c,99,6f));
	outFields->push(HX_("pen",d9,54,55,00));
	outFields->push(HX_("endLine",6f,d1,d7,29));
	outFields->push(HX_("ax",f7,54,00,00));
	outFields->push(HX_("ay",f8,54,00,00));
	outFields->push(HX_("bx",d6,55,00,00));
	outFields->push(HX_("by",d7,55,00,00));
	outFields->push(HX_("cx",b5,56,00,00));
	outFields->push(HX_("cy",b6,56,00,00));
	outFields->push(HX_("dx",94,57,00,00));
	outFields->push(HX_("dy",95,57,00,00));
	outFields->push(HX_("ex",73,58,00,00));
	outFields->push(HX_("ey",74,58,00,00));
	outFields->push(HX_("dxPrev",a7,9c,fd,48));
	outFields->push(HX_("dyPrev",28,31,64,dc));
	outFields->push(HX_("exPrev",06,f9,58,af));
	outFields->push(HX_("eyPrev",87,8d,bf,42));
	outFields->push(HX_("dxOld",73,ed,9f,e3));
	outFields->push(HX_("dyOld",12,24,49,e4));
	outFields->push(HX_("exOld",f4,81,06,77));
	outFields->push(HX_("eyOld",93,b8,af,77));
	outFields->push(HX_("jx",ce,5c,00,00));
	outFields->push(HX_("jy",cf,5c,00,00));
	outFields->push(HX_("lastClock",98,37,10,95));
	outFields->push(HX_("jxOld",79,68,07,58));
	outFields->push(HX_("jyOld",18,9f,b0,58));
	outFields->push(HX_("kax",22,86,51,00));
	outFields->push(HX_("kay",23,86,51,00));
	outFields->push(HX_("kbx",01,87,51,00));
	outFields->push(HX_("kby",02,87,51,00));
	outFields->push(HX_("kcx",e0,87,51,00));
	outFields->push(HX_("kcy",e1,87,51,00));
	outFields->push(HX_("ncx",a3,ce,53,00));
	outFields->push(HX_("ncy",a4,ce,53,00));
	outFields->push(HX_("quadIndex",cb,a0,31,4f));
	outFields->push(HX_("angleA",0e,15,19,63));
	outFields->push(HX_("halfA",2e,53,1c,22));
	outFields->push(HX_("beta",f0,f1,13,41));
	outFields->push(HX_("r",72,00,00,00));
	outFields->push(HX_("theta",1e,84,86,0f));
	outFields->push(HX_("angle1",fe,14,19,63));
	outFields->push(HX_("angle2",ff,14,19,63));
	outFields->push(HX_("count",cf,44,63,4a));
	outFields->push(HX_("counter",fc,ae,59,1d));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Contour_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol0),HX_("debugCol0",e3,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol1),HX_("debugCol1",e4,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol2),HX_("debugCol2",e5,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol3),HX_("debugCol3",e6,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol4),HX_("debugCol4",e7,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol5),HX_("debugCol5",e8,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol6),HX_("debugCol6",e9,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol7),HX_("debugCol7",ea,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol8),HX_("debugCol8",eb,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol9),HX_("debugCol9",ec,5b,10,25)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol10),HX_("debugCol10",cc,0b,40,49)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol11),HX_("debugCol11",cd,0b,40,49)},
	{::hx::fsInt,(int)offsetof(Contour_obj,debugCol12),HX_("debugCol12",ce,0b,40,49)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(Contour_obj,pointsClock),HX_("pointsClock",ab,c8,9e,88)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(Contour_obj,pointsAnti),HX_("pointsAnti",65,1b,f0,ae)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,penultimateCX),HX_("penultimateCX",5f,f6,17,69)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,penultimateCY),HX_("penultimateCY",60,f6,17,69)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,lastClockX),HX_("lastClockX",c0,6d,20,d9)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,lastClockY),HX_("lastClockY",c1,6d,20,d9)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,penultimateAX),HX_("penultimateAX",a1,f4,17,69)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,penultimateAY),HX_("penultimateAY",a2,f4,17,69)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,lastAntiX),HX_("lastAntiX",40,4c,99,6f)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,lastAntiY),HX_("lastAntiY",41,4c,99,6f)},
	{::hx::fsObject /*  ::trilateral3::drawing::Pen */ ,(int)offsetof(Contour_obj,pen),HX_("pen",d9,54,55,00)},
	{::hx::fsInt,(int)offsetof(Contour_obj,endLine),HX_("endLine",6f,d1,d7,29)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,ax),HX_("ax",f7,54,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,ay),HX_("ay",f8,54,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,bx),HX_("bx",d6,55,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,by),HX_("by",d7,55,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,cx),HX_("cx",b5,56,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,cy),HX_("cy",b6,56,00,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,dx),HX_("dx",94,57,00,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,dy),HX_("dy",95,57,00,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,ex),HX_("ex",73,58,00,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,ey),HX_("ey",74,58,00,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,dxPrev),HX_("dxPrev",a7,9c,fd,48)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,dyPrev),HX_("dyPrev",28,31,64,dc)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,exPrev),HX_("exPrev",06,f9,58,af)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,eyPrev),HX_("eyPrev",87,8d,bf,42)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,dxOld),HX_("dxOld",73,ed,9f,e3)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,dyOld),HX_("dyOld",12,24,49,e4)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,exOld),HX_("exOld",f4,81,06,77)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,eyOld),HX_("eyOld",93,b8,af,77)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,jx),HX_("jx",ce,5c,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,jy),HX_("jy",cf,5c,00,00)},
	{::hx::fsBool,(int)offsetof(Contour_obj,lastClock),HX_("lastClock",98,37,10,95)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,jxOld),HX_("jxOld",79,68,07,58)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,jyOld),HX_("jyOld",18,9f,b0,58)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,kax),HX_("kax",22,86,51,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,kay),HX_("kay",23,86,51,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,kbx),HX_("kbx",01,87,51,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,kby),HX_("kby",02,87,51,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,kcx),HX_("kcx",e0,87,51,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,kcy),HX_("kcy",e1,87,51,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,ncx),HX_("ncx",a3,ce,53,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,ncy),HX_("ncy",a4,ce,53,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,quadIndex),HX_("quadIndex",cb,a0,31,4f)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,angleA),HX_("angleA",0e,15,19,63)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,halfA),HX_("halfA",2e,53,1c,22)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,beta),HX_("beta",f0,f1,13,41)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,r),HX_("r",72,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,theta),HX_("theta",1e,84,86,0f)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Contour_obj,angle1),HX_("angle1",fe,14,19,63)},
	{::hx::fsFloat,(int)offsetof(Contour_obj,angle2),HX_("angle2",ff,14,19,63)},
	{::hx::fsInt,(int)offsetof(Contour_obj,count),HX_("count",cf,44,63,4a)},
	{::hx::fsInt,(int)offsetof(Contour_obj,counter),HX_("counter",fc,ae,59,1d)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo Contour_obj_sStaticStorageInfo[] = {
	{::hx::fsFloat,(void *) &Contour_obj::smallDotScale,HX_("smallDotScale",28,77,1a,ec)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String Contour_obj_sMemberFields[] = {
	HX_("debugCol0",e3,5b,10,25),
	HX_("debugCol1",e4,5b,10,25),
	HX_("debugCol2",e5,5b,10,25),
	HX_("debugCol3",e6,5b,10,25),
	HX_("debugCol4",e7,5b,10,25),
	HX_("debugCol5",e8,5b,10,25),
	HX_("debugCol6",e9,5b,10,25),
	HX_("debugCol7",ea,5b,10,25),
	HX_("debugCol8",eb,5b,10,25),
	HX_("debugCol9",ec,5b,10,25),
	HX_("debugCol10",cc,0b,40,49),
	HX_("debugCol11",cd,0b,40,49),
	HX_("debugCol12",ce,0b,40,49),
	HX_("pointsClock",ab,c8,9e,88),
	HX_("pointsAnti",65,1b,f0,ae),
	HX_("penultimateCX",5f,f6,17,69),
	HX_("penultimateCY",60,f6,17,69),
	HX_("lastClockX",c0,6d,20,d9),
	HX_("lastClockY",c1,6d,20,d9),
	HX_("penultimateAX",a1,f4,17,69),
	HX_("penultimateAY",a2,f4,17,69),
	HX_("lastAntiX",40,4c,99,6f),
	HX_("lastAntiY",41,4c,99,6f),
	HX_("pen",d9,54,55,00),
	HX_("endLine",6f,d1,d7,29),
	HX_("ax",f7,54,00,00),
	HX_("ay",f8,54,00,00),
	HX_("bx",d6,55,00,00),
	HX_("by",d7,55,00,00),
	HX_("cx",b5,56,00,00),
	HX_("cy",b6,56,00,00),
	HX_("dx",94,57,00,00),
	HX_("dy",95,57,00,00),
	HX_("ex",73,58,00,00),
	HX_("ey",74,58,00,00),
	HX_("dxPrev",a7,9c,fd,48),
	HX_("dyPrev",28,31,64,dc),
	HX_("exPrev",06,f9,58,af),
	HX_("eyPrev",87,8d,bf,42),
	HX_("dxOld",73,ed,9f,e3),
	HX_("dyOld",12,24,49,e4),
	HX_("exOld",f4,81,06,77),
	HX_("eyOld",93,b8,af,77),
	HX_("jx",ce,5c,00,00),
	HX_("jy",cf,5c,00,00),
	HX_("lastClock",98,37,10,95),
	HX_("jxOld",79,68,07,58),
	HX_("jyOld",18,9f,b0,58),
	HX_("kax",22,86,51,00),
	HX_("kay",23,86,51,00),
	HX_("kbx",01,87,51,00),
	HX_("kby",02,87,51,00),
	HX_("kcx",e0,87,51,00),
	HX_("kcy",e1,87,51,00),
	HX_("ncx",a3,ce,53,00),
	HX_("ncy",a4,ce,53,00),
	HX_("quadIndex",cb,a0,31,4f),
	HX_("angleA",0e,15,19,63),
	HX_("halfA",2e,53,1c,22),
	HX_("beta",f0,f1,13,41),
	HX_("r",72,00,00,00),
	HX_("theta",1e,84,86,0f),
	HX_("angle1",fe,14,19,63),
	HX_("angle2",ff,14,19,63),
	HX_("reset",cf,49,c8,e6),
	HX_("count",cf,44,63,4a),
	HX_("computeDE",b8,8e,b2,87),
	HX_("anglesCompute",17,82,c9,e2),
	HX_("thetaComputeAdj",ae,40,9d,e7),
	HX_("triangleJoin",d2,22,df,cf),
	HX_("overlapQuad",ee,77,e9,3a),
	HX_("end",db,03,4d,00),
	HX_("triangle2DFill",3d,7c,19,6e),
	HX_("addPieXstart",f5,ef,0d,da),
	HX_("addPieX",4d,2d,95,86),
	HX_("addPie",ab,68,06,9f),
	HX_("computeJ",f3,40,c6,85),
	HX_("addDot",e8,52,fd,9e),
	HX_("addSmallTriangles",e5,ec,80,f8),
	HX_("triangle2DFillangleCorners",28,53,7d,f1),
	HX_("triangle2DFillangleCornersLess",a1,46,b3,70),
	HX_("connectQuadsWhenQuadsOverlay",a0,62,6a,01),
	HX_("connectQuads",82,39,61,89),
	HX_("addInitialQuads",69,e2,46,a8),
	HX_("endEdges",bb,ff,dd,67),
	HX_("counter",fc,ae,59,1d),
	HX_("addQuads",eb,9b,44,d7),
	HX_("storeLastQuads",75,6b,ea,1d),
	HX_("isClockwise",a8,34,20,1b),
	HX_("line",f4,17,b3,47),
	::String(null()) };

static void Contour_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Contour_obj::smallDotScale,"smallDotScale");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Contour_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Contour_obj::smallDotScale,"smallDotScale");
};

#endif

::hx::Class Contour_obj::__mClass;

static ::String Contour_obj_sStaticFields[] = {
	HX_("smallDotScale",28,77,1a,ec),
	HX_("thetaCompute",f9,ca,c4,94),
	HX_("dist",66,67,69,42),
	::String(null())
};

void Contour_obj::__register()
{
	Contour_obj _hx_dummy;
	Contour_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("trilateral3.drawing.Contour",43,ac,91,1c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Contour_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Contour_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Contour_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Contour_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Contour_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Contour_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Contour_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Contour_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Contour_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_1447c0490ddb3cc5_95_boot)
HXDLIN(  95)		smallDotScale = ((Float)0.07);
            	}
}

} // end namespace trilateral3
} // end namespace drawing
