// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_fracs_Angles
#include <fracs/Angles.h>
#endif
#ifndef INCLUDED_fracs_DifferencePreference
#include <fracs/DifferencePreference.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_710ae48b590d25bc_12_pi2pi,"fracs.Angles","pi2pi",0x8a462b4d,"fracs.Angles.pi2pi","fracs/Angles.hx",12,0x9a43bf14)
HX_LOCAL_STACK_FRAME(_hx_pos_710ae48b590d25bc_20_zeroto2pi,"fracs.Angles","zeroto2pi",0xaca65e63,"fracs.Angles.zeroto2pi","fracs/Angles.hx",20,0x9a43bf14)
HX_LOCAL_STACK_FRAME(_hx_pos_710ae48b590d25bc_28_zerotoMinus2pi,"fracs.Angles","zerotoMinus2pi",0x69e9eda3,"fracs.Angles.zerotoMinus2pi","fracs/Angles.hx",28,0x9a43bf14)
HX_LOCAL_STACK_FRAME(_hx_pos_710ae48b590d25bc_37_differencePrefer,"fracs.Angles","differencePrefer",0x5fd584d2,"fracs.Angles.differencePrefer","fracs/Angles.hx",37,0x9a43bf14)
HX_LOCAL_STACK_FRAME(_hx_pos_710ae48b590d25bc_48_difference,"fracs.Angles","difference",0xe23ab522,"fracs.Angles.difference","fracs/Angles.hx",48,0x9a43bf14)
HX_LOCAL_STACK_FRAME(_hx_pos_710ae48b590d25bc_57_differenceClockWise,"fracs.Angles","differenceClockWise",0x00762090,"fracs.Angles.differenceClockWise","fracs/Angles.hx",57,0x9a43bf14)
HX_LOCAL_STACK_FRAME(_hx_pos_710ae48b590d25bc_61_differenceAntiClockwise,"fracs.Angles","differenceAntiClockwise",0x4064576e,"fracs.Angles.differenceAntiClockwise","fracs/Angles.hx",61,0x9a43bf14)
HX_LOCAL_STACK_FRAME(_hx_pos_710ae48b590d25bc_65_differenceSmall,"fracs.Angles","differenceSmall",0x0e8fd045,"fracs.Angles.differenceSmall","fracs/Angles.hx",65,0x9a43bf14)
HX_LOCAL_STACK_FRAME(_hx_pos_710ae48b590d25bc_80_differenceLarge,"fracs.Angles","differenceLarge",0xfee01339,"fracs.Angles.differenceLarge","fracs/Angles.hx",80,0x9a43bf14)
HX_LOCAL_STACK_FRAME(_hx_pos_710ae48b590d25bc_95_differenceSmallLarge,"fracs.Angles","differenceSmallLarge",0x9fa6b936,"fracs.Angles.differenceSmallLarge","fracs/Angles.hx",95,0x9a43bf14)
namespace fracs{

void Angles_obj::__construct() { }

Dynamic Angles_obj::__CreateEmpty() { return new Angles_obj; }

void *Angles_obj::_hx_vtable = 0;

Dynamic Angles_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Angles_obj > _hx_result = new Angles_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Angles_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x78557e1d;
}

Float Angles_obj::pi2pi(Float angle){
            	HX_STACKFRAME(&_hx_pos_710ae48b590d25bc_12_pi2pi)
HXDLIN(  12)		bool _hx_tmp;
HXDLIN(  12)		if ((angle <= ::Math_obj::PI)) {
HXDLIN(  12)			_hx_tmp = (angle > -(::Math_obj::PI));
            		}
            		else {
HXDLIN(  12)			_hx_tmp = false;
            		}
HXDLIN(  12)		if (_hx_tmp) {
HXLINE(  13)			return angle;
            		}
            		else {
HXLINE(  15)			Float a = ::hx::Mod((angle + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXLINE(  16)			if ((a >= 0)) {
HXLINE(  16)				return (a - ::Math_obj::PI);
            			}
            			else {
HXLINE(  16)				return (a + ::Math_obj::PI);
            			}
            		}
HXLINE(  12)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Angles_obj,pi2pi,return )

Float Angles_obj::zeroto2pi(Float angle){
            	HX_STACKFRAME(&_hx_pos_710ae48b590d25bc_20_zeroto2pi)
HXDLIN(  20)		bool _hx_tmp;
HXDLIN(  20)		if ((angle >= 0)) {
HXDLIN(  20)			_hx_tmp = (angle > ::Math_obj::PI);
            		}
            		else {
HXDLIN(  20)			_hx_tmp = false;
            		}
HXDLIN(  20)		if (_hx_tmp) {
HXLINE(  21)			return angle;
            		}
            		else {
HXLINE(  23)			Float a = ::hx::Mod(angle,(( (Float)(2) ) * ::Math_obj::PI));
HXLINE(  24)			if ((a >= 0)) {
HXLINE(  24)				return a;
            			}
            			else {
HXLINE(  24)				return (a + (( (Float)(2) ) * ::Math_obj::PI));
            			}
            		}
HXLINE(  20)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Angles_obj,zeroto2pi,return )

Float Angles_obj::zerotoMinus2pi(Float angle){
            	HX_STACKFRAME(&_hx_pos_710ae48b590d25bc_28_zerotoMinus2pi)
HXDLIN(  28)		bool _hx_tmp;
HXDLIN(  28)		if ((angle <= 0)) {
HXDLIN(  28)			_hx_tmp = (angle > -(::Math_obj::PI));
            		}
            		else {
HXDLIN(  28)			_hx_tmp = false;
            		}
HXDLIN(  28)		if (_hx_tmp) {
HXLINE(  29)			return angle;
            		}
            		else {
HXLINE(  31)			Float a = ::hx::Mod(angle,(( (Float)(2) ) * ::Math_obj::PI));
HXLINE(  32)			Float a1;
HXDLIN(  32)			if ((a >= 0)) {
HXLINE(  32)				a1 = a;
            			}
            			else {
HXLINE(  32)				a1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            			}
HXLINE(  33)			return -(((::Math_obj::PI * ( (Float)(2) )) - a1));
            		}
HXLINE(  28)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Angles_obj,zerotoMinus2pi,return )

Float Angles_obj::differencePrefer(Float a,Float b, ::fracs::DifferencePreference prefer){
            	HX_STACKFRAME(&_hx_pos_710ae48b590d25bc_37_differencePrefer)
HXDLIN(  37)		switch((int)(prefer->_hx_getIndex())){
            			case (int)0: {
HXLINE(  39)				Float f;
HXDLIN(  39)				bool f1;
HXDLIN(  39)				if ((a >= 0)) {
HXLINE(  39)					f1 = (a > ::Math_obj::PI);
            				}
            				else {
HXLINE(  39)					f1 = false;
            				}
HXDLIN(  39)				if (f1) {
HXLINE(  39)					f = a;
            				}
            				else {
HXLINE(  39)					Float a1 = ::hx::Mod(a,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  39)					if ((a1 >= 0)) {
HXLINE(  39)						f = a1;
            					}
            					else {
HXLINE(  39)						f = (a1 + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  39)				Float this1 = f;
HXDLIN(  39)				Float za = this1;
HXDLIN(  39)				Float f2;
HXDLIN(  39)				bool f3;
HXDLIN(  39)				if ((b >= 0)) {
HXLINE(  39)					f3 = (b > ::Math_obj::PI);
            				}
            				else {
HXLINE(  39)					f3 = false;
            				}
HXDLIN(  39)				if (f3) {
HXLINE(  39)					f2 = b;
            				}
            				else {
HXLINE(  39)					Float a = ::hx::Mod(b,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  39)					if ((a >= 0)) {
HXLINE(  39)						f2 = a;
            					}
            					else {
HXLINE(  39)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  39)				Float this2 = f2;
HXDLIN(  39)				Float zb = this2;
HXDLIN(  39)				Float fa = za;
HXDLIN(  39)				Float fb = zb;
HXDLIN(  39)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  39)				bool clockwise = (fa < fb);
HXDLIN(  39)				Float dif;
HXDLIN(  39)				if (clockwise) {
HXLINE(  39)					dif = theta;
            				}
            				else {
HXLINE(  39)					dif = -(theta);
            				}
HXDLIN(  39)				if ((dif > 0)) {
HXLINE(  39)					return dif;
            				}
            				else {
HXLINE(  39)					return ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE(  41)				Float f;
HXDLIN(  41)				bool f1;
HXDLIN(  41)				if ((a >= 0)) {
HXLINE(  41)					f1 = (a > ::Math_obj::PI);
            				}
            				else {
HXLINE(  41)					f1 = false;
            				}
HXDLIN(  41)				if (f1) {
HXLINE(  41)					f = a;
            				}
            				else {
HXLINE(  41)					Float a1 = ::hx::Mod(a,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)					if ((a1 >= 0)) {
HXLINE(  41)						f = a1;
            					}
            					else {
HXLINE(  41)						f = (a1 + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  41)				Float this1 = f;
HXDLIN(  41)				Float za = this1;
HXDLIN(  41)				Float f2;
HXDLIN(  41)				bool f3;
HXDLIN(  41)				if ((b >= 0)) {
HXLINE(  41)					f3 = (b > ::Math_obj::PI);
            				}
            				else {
HXLINE(  41)					f3 = false;
            				}
HXDLIN(  41)				if (f3) {
HXLINE(  41)					f2 = b;
            				}
            				else {
HXLINE(  41)					Float a = ::hx::Mod(b,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)					if ((a >= 0)) {
HXLINE(  41)						f2 = a;
            					}
            					else {
HXLINE(  41)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  41)				Float this2 = f2;
HXDLIN(  41)				Float zb = this2;
HXDLIN(  41)				Float fa = za;
HXDLIN(  41)				Float fb = zb;
HXDLIN(  41)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  41)				bool clockwise = (fa < fb);
HXDLIN(  41)				Float dif;
HXDLIN(  41)				if (clockwise) {
HXLINE(  41)					dif = theta;
            				}
            				else {
HXLINE(  41)					dif = -(theta);
            				}
HXDLIN(  41)				if ((dif < 0)) {
HXLINE(  41)					return dif;
            				}
            				else {
HXLINE(  41)					return ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE(  43)				Float f;
HXDLIN(  43)				bool f1;
HXDLIN(  43)				if ((a >= 0)) {
HXLINE(  43)					f1 = (a > ::Math_obj::PI);
            				}
            				else {
HXLINE(  43)					f1 = false;
            				}
HXDLIN(  43)				if (f1) {
HXLINE(  43)					f = a;
            				}
            				else {
HXLINE(  43)					Float a1 = ::hx::Mod(a,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  43)					if ((a1 >= 0)) {
HXLINE(  43)						f = a1;
            					}
            					else {
HXLINE(  43)						f = (a1 + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  43)				Float this1 = f;
HXDLIN(  43)				Float za = this1;
HXDLIN(  43)				Float f2;
HXDLIN(  43)				bool f3;
HXDLIN(  43)				if ((b >= 0)) {
HXLINE(  43)					f3 = (b > ::Math_obj::PI);
            				}
            				else {
HXLINE(  43)					f3 = false;
            				}
HXDLIN(  43)				if (f3) {
HXLINE(  43)					f2 = b;
            				}
            				else {
HXLINE(  43)					Float a = ::hx::Mod(b,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  43)					if ((a >= 0)) {
HXLINE(  43)						f2 = a;
            					}
            					else {
HXLINE(  43)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  43)				Float this2 = f2;
HXDLIN(  43)				Float zb = this2;
HXDLIN(  43)				Float fa = za;
HXDLIN(  43)				Float fb = zb;
HXDLIN(  43)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  43)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  43)				bool clockwise = (fa < fb);
HXDLIN(  43)				Float dif;
HXDLIN(  43)				if (clockwise) {
HXLINE(  43)					dif = theta;
            				}
            				else {
HXLINE(  43)					dif = -(theta);
            				}
HXDLIN(  43)				if (smallest) {
HXLINE(  43)					return dif;
            				}
            				else {
HXLINE(  43)					if (clockwise) {
HXLINE(  43)						return -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE(  43)						return ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE(  45)				Float f;
HXDLIN(  45)				bool f1;
HXDLIN(  45)				if ((a >= 0)) {
HXLINE(  45)					f1 = (a > ::Math_obj::PI);
            				}
            				else {
HXLINE(  45)					f1 = false;
            				}
HXDLIN(  45)				if (f1) {
HXLINE(  45)					f = a;
            				}
            				else {
HXLINE(  45)					Float a1 = ::hx::Mod(a,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)					if ((a1 >= 0)) {
HXLINE(  45)						f = a1;
            					}
            					else {
HXLINE(  45)						f = (a1 + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  45)				Float this1 = f;
HXDLIN(  45)				Float za = this1;
HXDLIN(  45)				Float f2;
HXDLIN(  45)				bool f3;
HXDLIN(  45)				if ((b >= 0)) {
HXLINE(  45)					f3 = (b > ::Math_obj::PI);
            				}
            				else {
HXLINE(  45)					f3 = false;
            				}
HXDLIN(  45)				if (f3) {
HXLINE(  45)					f2 = b;
            				}
            				else {
HXLINE(  45)					Float a = ::hx::Mod(b,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)					if ((a >= 0)) {
HXLINE(  45)						f2 = a;
            					}
            					else {
HXLINE(  45)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  45)				Float this2 = f2;
HXDLIN(  45)				Float zb = this2;
HXDLIN(  45)				Float fa = za;
HXDLIN(  45)				Float fb = zb;
HXDLIN(  45)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  45)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  45)				bool clockwise = (fa < fb);
HXDLIN(  45)				Float dif;
HXDLIN(  45)				if (clockwise) {
HXLINE(  45)					dif = theta;
            				}
            				else {
HXLINE(  45)					dif = -(theta);
            				}
HXDLIN(  45)				if (largest) {
HXLINE(  45)					return dif;
            				}
            				else {
HXLINE(  45)					if (clockwise) {
HXLINE(  45)						return -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE(  45)						return ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXLINE(  37)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Angles_obj,differencePrefer,return )

Float Angles_obj::difference(Float a,Float b){
            	HX_STACKFRAME(&_hx_pos_710ae48b590d25bc_48_difference)
HXLINE(  49)		Float f;
HXDLIN(  49)		bool f1;
HXDLIN(  49)		if ((a >= 0)) {
HXLINE(  49)			f1 = (a > ::Math_obj::PI);
            		}
            		else {
HXLINE(  49)			f1 = false;
            		}
HXDLIN(  49)		if (f1) {
HXLINE(  49)			f = a;
            		}
            		else {
HXLINE(  49)			Float a1 = ::hx::Mod(a,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  49)			if ((a1 >= 0)) {
HXLINE(  49)				f = a1;
            			}
            			else {
HXLINE(  49)				f = (a1 + (( (Float)(2) ) * ::Math_obj::PI));
            			}
            		}
HXDLIN(  49)		Float this1 = f;
HXDLIN(  49)		Float za = this1;
HXLINE(  50)		Float f2;
HXDLIN(  50)		bool f3;
HXDLIN(  50)		if ((b >= 0)) {
HXLINE(  50)			f3 = (b > ::Math_obj::PI);
            		}
            		else {
HXLINE(  50)			f3 = false;
            		}
HXDLIN(  50)		if (f3) {
HXLINE(  50)			f2 = b;
            		}
            		else {
HXLINE(  50)			Float a = ::hx::Mod(b,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)			if ((a >= 0)) {
HXLINE(  50)				f2 = a;
            			}
            			else {
HXLINE(  50)				f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            			}
            		}
HXDLIN(  50)		Float this2 = f2;
HXDLIN(  50)		Float zb = this2;
HXLINE(  51)		Float fa = za;
HXLINE(  52)		Float fb = zb;
HXLINE(  53)		Float theta = ::Math_obj::abs((fa - fb));
HXLINE(  54)		bool clockwise = (fa < fb);
HXLINE(  55)		if (clockwise) {
HXLINE(  55)			return theta;
            		}
            		else {
HXLINE(  55)			return -(theta);
            		}
HXDLIN(  55)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Angles_obj,difference,return )

Float Angles_obj::differenceClockWise(Float a,Float b){
            	HX_STACKFRAME(&_hx_pos_710ae48b590d25bc_57_differenceClockWise)
HXLINE(  58)		Float f;
HXDLIN(  58)		bool f1;
HXDLIN(  58)		if ((a >= 0)) {
HXLINE(  58)			f1 = (a > ::Math_obj::PI);
            		}
            		else {
HXLINE(  58)			f1 = false;
            		}
HXDLIN(  58)		if (f1) {
HXLINE(  58)			f = a;
            		}
            		else {
HXLINE(  58)			Float a1 = ::hx::Mod(a,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  58)			if ((a1 >= 0)) {
HXLINE(  58)				f = a1;
            			}
            			else {
HXLINE(  58)				f = (a1 + (( (Float)(2) ) * ::Math_obj::PI));
            			}
            		}
HXDLIN(  58)		Float this1 = f;
HXDLIN(  58)		Float za = this1;
HXDLIN(  58)		Float f2;
HXDLIN(  58)		bool f3;
HXDLIN(  58)		if ((b >= 0)) {
HXLINE(  58)			f3 = (b > ::Math_obj::PI);
            		}
            		else {
HXLINE(  58)			f3 = false;
            		}
HXDLIN(  58)		if (f3) {
HXLINE(  58)			f2 = b;
            		}
            		else {
HXLINE(  58)			Float a = ::hx::Mod(b,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  58)			if ((a >= 0)) {
HXLINE(  58)				f2 = a;
            			}
            			else {
HXLINE(  58)				f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            			}
            		}
HXDLIN(  58)		Float this2 = f2;
HXDLIN(  58)		Float zb = this2;
HXDLIN(  58)		Float fa = za;
HXDLIN(  58)		Float fb = zb;
HXDLIN(  58)		Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  58)		bool clockwise = (fa < fb);
HXDLIN(  58)		Float dif;
HXDLIN(  58)		if (clockwise) {
HXLINE(  58)			dif = theta;
            		}
            		else {
HXLINE(  58)			dif = -(theta);
            		}
HXLINE(  59)		if ((dif > 0)) {
HXLINE(  59)			return dif;
            		}
            		else {
HXLINE(  59)			return ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            		}
HXDLIN(  59)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Angles_obj,differenceClockWise,return )

Float Angles_obj::differenceAntiClockwise(Float a,Float b){
            	HX_STACKFRAME(&_hx_pos_710ae48b590d25bc_61_differenceAntiClockwise)
HXLINE(  62)		Float f;
HXDLIN(  62)		bool f1;
HXDLIN(  62)		if ((a >= 0)) {
HXLINE(  62)			f1 = (a > ::Math_obj::PI);
            		}
            		else {
HXLINE(  62)			f1 = false;
            		}
HXDLIN(  62)		if (f1) {
HXLINE(  62)			f = a;
            		}
            		else {
HXLINE(  62)			Float a1 = ::hx::Mod(a,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)			if ((a1 >= 0)) {
HXLINE(  62)				f = a1;
            			}
            			else {
HXLINE(  62)				f = (a1 + (( (Float)(2) ) * ::Math_obj::PI));
            			}
            		}
HXDLIN(  62)		Float this1 = f;
HXDLIN(  62)		Float za = this1;
HXDLIN(  62)		Float f2;
HXDLIN(  62)		bool f3;
HXDLIN(  62)		if ((b >= 0)) {
HXLINE(  62)			f3 = (b > ::Math_obj::PI);
            		}
            		else {
HXLINE(  62)			f3 = false;
            		}
HXDLIN(  62)		if (f3) {
HXLINE(  62)			f2 = b;
            		}
            		else {
HXLINE(  62)			Float a = ::hx::Mod(b,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)			if ((a >= 0)) {
HXLINE(  62)				f2 = a;
            			}
            			else {
HXLINE(  62)				f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            			}
            		}
HXDLIN(  62)		Float this2 = f2;
HXDLIN(  62)		Float zb = this2;
HXDLIN(  62)		Float fa = za;
HXDLIN(  62)		Float fb = zb;
HXDLIN(  62)		Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)		bool clockwise = (fa < fb);
HXDLIN(  62)		Float dif;
HXDLIN(  62)		if (clockwise) {
HXLINE(  62)			dif = theta;
            		}
            		else {
HXLINE(  62)			dif = -(theta);
            		}
HXLINE(  63)		if ((dif < 0)) {
HXLINE(  63)			return dif;
            		}
            		else {
HXLINE(  63)			return ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            		}
HXDLIN(  63)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Angles_obj,differenceAntiClockwise,return )

Float Angles_obj::differenceSmall(Float a,Float b){
            	HX_STACKFRAME(&_hx_pos_710ae48b590d25bc_65_differenceSmall)
HXLINE(  66)		Float f;
HXDLIN(  66)		bool f1;
HXDLIN(  66)		if ((a >= 0)) {
HXLINE(  66)			f1 = (a > ::Math_obj::PI);
            		}
            		else {
HXLINE(  66)			f1 = false;
            		}
HXDLIN(  66)		if (f1) {
HXLINE(  66)			f = a;
            		}
            		else {
HXLINE(  66)			Float a1 = ::hx::Mod(a,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  66)			if ((a1 >= 0)) {
HXLINE(  66)				f = a1;
            			}
            			else {
HXLINE(  66)				f = (a1 + (( (Float)(2) ) * ::Math_obj::PI));
            			}
            		}
HXDLIN(  66)		Float this1 = f;
HXDLIN(  66)		Float za = this1;
HXLINE(  67)		Float f2;
HXDLIN(  67)		bool f3;
HXDLIN(  67)		if ((b >= 0)) {
HXLINE(  67)			f3 = (b > ::Math_obj::PI);
            		}
            		else {
HXLINE(  67)			f3 = false;
            		}
HXDLIN(  67)		if (f3) {
HXLINE(  67)			f2 = b;
            		}
            		else {
HXLINE(  67)			Float a = ::hx::Mod(b,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  67)			if ((a >= 0)) {
HXLINE(  67)				f2 = a;
            			}
            			else {
HXLINE(  67)				f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            			}
            		}
HXDLIN(  67)		Float this2 = f2;
HXDLIN(  67)		Float zb = this2;
HXLINE(  68)		Float fa = za;
HXLINE(  69)		Float fb = zb;
HXLINE(  70)		Float theta = ::Math_obj::abs((fa - fb));
HXLINE(  71)		bool smallest = (theta <= ::Math_obj::PI);
HXLINE(  72)		bool clockwise = (fa < fb);
HXLINE(  73)		Float dif;
HXDLIN(  73)		if (clockwise) {
HXLINE(  73)			dif = theta;
            		}
            		else {
HXLINE(  73)			dif = -(theta);
            		}
HXLINE(  74)		if (smallest) {
HXLINE(  75)			return dif;
            		}
            		else {
HXLINE(  77)			if (clockwise) {
HXLINE(  77)				return -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            			}
            			else {
HXLINE(  77)				return ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            			}
            		}
HXLINE(  74)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Angles_obj,differenceSmall,return )

Float Angles_obj::differenceLarge(Float a,Float b){
            	HX_STACKFRAME(&_hx_pos_710ae48b590d25bc_80_differenceLarge)
HXLINE(  81)		Float f;
HXDLIN(  81)		bool f1;
HXDLIN(  81)		if ((a >= 0)) {
HXLINE(  81)			f1 = (a > ::Math_obj::PI);
            		}
            		else {
HXLINE(  81)			f1 = false;
            		}
HXDLIN(  81)		if (f1) {
HXLINE(  81)			f = a;
            		}
            		else {
HXLINE(  81)			Float a1 = ::hx::Mod(a,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  81)			if ((a1 >= 0)) {
HXLINE(  81)				f = a1;
            			}
            			else {
HXLINE(  81)				f = (a1 + (( (Float)(2) ) * ::Math_obj::PI));
            			}
            		}
HXDLIN(  81)		Float this1 = f;
HXDLIN(  81)		Float za = this1;
HXLINE(  82)		Float f2;
HXDLIN(  82)		bool f3;
HXDLIN(  82)		if ((b >= 0)) {
HXLINE(  82)			f3 = (b > ::Math_obj::PI);
            		}
            		else {
HXLINE(  82)			f3 = false;
            		}
HXDLIN(  82)		if (f3) {
HXLINE(  82)			f2 = b;
            		}
            		else {
HXLINE(  82)			Float a = ::hx::Mod(b,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  82)			if ((a >= 0)) {
HXLINE(  82)				f2 = a;
            			}
            			else {
HXLINE(  82)				f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            			}
            		}
HXDLIN(  82)		Float this2 = f2;
HXDLIN(  82)		Float zb = this2;
HXLINE(  83)		Float fa = za;
HXLINE(  84)		Float fb = zb;
HXLINE(  85)		Float theta = ::Math_obj::abs((fa - fb));
HXLINE(  86)		bool largest = (theta > ::Math_obj::PI);
HXLINE(  87)		bool clockwise = (fa < fb);
HXLINE(  88)		Float dif;
HXDLIN(  88)		if (clockwise) {
HXLINE(  88)			dif = theta;
            		}
            		else {
HXLINE(  88)			dif = -(theta);
            		}
HXLINE(  89)		if (largest) {
HXLINE(  90)			return dif;
            		}
            		else {
HXLINE(  92)			if (clockwise) {
HXLINE(  92)				return -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            			}
            			else {
HXLINE(  92)				return ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            			}
            		}
HXLINE(  89)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Angles_obj,differenceLarge,return )

 ::Dynamic Angles_obj::differenceSmallLarge(Float a,Float b){
            	HX_STACKFRAME(&_hx_pos_710ae48b590d25bc_95_differenceSmallLarge)
HXLINE(  96)		Float f;
HXDLIN(  96)		bool f1;
HXDLIN(  96)		if ((a >= 0)) {
HXLINE(  96)			f1 = (a > ::Math_obj::PI);
            		}
            		else {
HXLINE(  96)			f1 = false;
            		}
HXDLIN(  96)		if (f1) {
HXLINE(  96)			f = a;
            		}
            		else {
HXLINE(  96)			Float a1 = ::hx::Mod(a,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  96)			if ((a1 >= 0)) {
HXLINE(  96)				f = a1;
            			}
            			else {
HXLINE(  96)				f = (a1 + (( (Float)(2) ) * ::Math_obj::PI));
            			}
            		}
HXDLIN(  96)		Float this1 = f;
HXDLIN(  96)		Float za = this1;
HXLINE(  97)		Float f2;
HXDLIN(  97)		bool f3;
HXDLIN(  97)		if ((b >= 0)) {
HXLINE(  97)			f3 = (b > ::Math_obj::PI);
            		}
            		else {
HXLINE(  97)			f3 = false;
            		}
HXDLIN(  97)		if (f3) {
HXLINE(  97)			f2 = b;
            		}
            		else {
HXLINE(  97)			Float a = ::hx::Mod(b,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  97)			if ((a >= 0)) {
HXLINE(  97)				f2 = a;
            			}
            			else {
HXLINE(  97)				f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            			}
            		}
HXDLIN(  97)		Float this2 = f2;
HXDLIN(  97)		Float zb = this2;
HXLINE(  98)		Float fa = za;
HXLINE(  99)		Float fb = zb;
HXLINE( 100)		Float theta = ::Math_obj::abs((fa - fb));
HXLINE( 101)		bool smallest = (theta <= ::Math_obj::PI);
HXLINE( 102)		bool clockwise = (fa < fb);
HXLINE( 103)		Float dif;
HXDLIN( 103)		if (clockwise) {
HXLINE( 103)			dif = theta;
            		}
            		else {
HXLINE( 103)			dif = -(theta);
            		}
HXLINE( 104)		Float other;
HXDLIN( 104)		if (clockwise) {
HXLINE( 104)			other = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            		}
            		else {
HXLINE( 104)			other = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            		}
HXLINE( 105)		if (smallest) {
HXLINE( 106)			return  ::Dynamic(::hx::Anon_obj::Create(2)
            				->setFixed(0,HX_("large",bb,33,bb,6f),other)
            				->setFixed(1,HX_("small",c7,f0,6a,7f),dif));
            		}
            		else {
HXLINE( 108)			return  ::Dynamic(::hx::Anon_obj::Create(2)
            				->setFixed(0,HX_("large",bb,33,bb,6f),dif)
            				->setFixed(1,HX_("small",c7,f0,6a,7f),other));
            		}
HXLINE( 105)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Angles_obj,differenceSmallLarge,return )


Angles_obj::Angles_obj()
{
}

bool Angles_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"pi2pi") ) { outValue = pi2pi_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"zeroto2pi") ) { outValue = zeroto2pi_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"difference") ) { outValue = difference_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"zerotoMinus2pi") ) { outValue = zerotoMinus2pi_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"differenceSmall") ) { outValue = differenceSmall_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"differenceLarge") ) { outValue = differenceLarge_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"differencePrefer") ) { outValue = differencePrefer_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"differenceClockWise") ) { outValue = differenceClockWise_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"differenceSmallLarge") ) { outValue = differenceSmallLarge_dyn(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"differenceAntiClockwise") ) { outValue = differenceAntiClockwise_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Angles_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Angles_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Angles_obj::__mClass;

static ::String Angles_obj_sStaticFields[] = {
	HX_("pi2pi",52,b2,6e,c2),
	HX_("zeroto2pi",e8,4b,1f,12),
	HX_("zerotoMinus2pi",fe,dd,6c,f3),
	HX_("differencePrefer",ed,81,39,84),
	HX_("difference",fd,9b,91,46),
	HX_("differenceClockWise",55,06,c7,c8),
	HX_("differenceAntiClockwise",b3,03,7c,a1),
	HX_("differenceSmall",8a,2f,9f,d7),
	HX_("differenceLarge",7e,72,ef,c7),
	HX_("differenceSmallLarge",d1,df,1e,1e),
	::String(null())
};

void Angles_obj::__register()
{
	Angles_obj _hx_dummy;
	Angles_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("fracs.Angles",29,9b,16,c7);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Angles_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Angles_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Angles_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Angles_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Angles_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace fracs
