// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_dsHelper_iterArr__ArrayPairs_ArrayPairs_Impl_
#include <dsHelper/iterArr/_ArrayPairs/ArrayPairs_Impl_.h>
#endif
#ifndef INCLUDED_dsHelper_iterArr__ArrayTriple_ArrayTriple_Impl_
#include <dsHelper/iterArr/_ArrayTriple/ArrayTriple_Impl_.h>
#endif
#ifndef INCLUDED_justPath_IPathContext
#include <justPath/IPathContext.h>
#endif
#ifndef INCLUDED_org_poly2tri_Point
#include <org/poly2tri/Point.h>
#endif
#ifndef INCLUDED_org_poly2tri_VisiblePolygon
#include <org/poly2tri/VisiblePolygon.h>
#endif
#ifndef INCLUDED_trilateral3_Trilateral
#include <trilateral3/Trilateral.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Pen
#include <trilateral3/drawing/Pen.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Sketch
#include <trilateral3/drawing/Sketch.h>
#endif
#ifndef INCLUDED_trilateral3_drawing__Fill_Fill_Fields_
#include <trilateral3/drawing/_Fill/Fill_Fields_.h>
#endif
#ifndef INCLUDED_trilateral3_matrix_MatrixDozen
#include <trilateral3/matrix/MatrixDozen.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_16358b2120f7b686_11_triangulate,"trilateral3.drawing._Fill.Fill_Fields_","triangulate",0xe806e78b,"trilateral3.drawing._Fill.Fill_Fields_.triangulate","trilateral3/drawing/Fill.hx",11,0x074845c2)
namespace trilateral3{
namespace drawing{
namespace _Fill{

void Fill_Fields__obj::__construct() { }

Dynamic Fill_Fields__obj::__CreateEmpty() { return new Fill_Fields__obj; }

void *Fill_Fields__obj::_hx_vtable = 0;

Dynamic Fill_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Fill_Fields__obj > _hx_result = new Fill_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Fill_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0c9686f5;
}

void Fill_Fields__obj::triangulate( ::trilateral3::drawing::Pen pen, ::trilateral3::drawing::Sketch sketch,int fillForm){
            	HX_GC_STACKFRAME(&_hx_pos_16358b2120f7b686_11_triangulate)
HXLINE(  12)		::Array< Float > vert;
HXLINE(  13)		::Array< int > tri;
HXLINE(  14)		::Array< ::Dynamic> p;
HXLINE(  15)		switch((int)(fillForm)){
            			case (int)0: {
            			}
            			break;
            			case (int)1: {
HXLINE(  71)				p = sketch->points;
HXLINE(  72)				int l = p->length;
HXLINE(  73)				int count = 0;
HXLINE(  74)				vert = ::Array_obj< Float >::__new();
HXLINE(  75)				tri = ::Array_obj< int >::__new();
HXLINE(  76)				{
HXLINE(  76)					int _g = 0;
HXDLIN(  76)					int _g1 = l;
HXDLIN(  76)					while((_g < _g1)){
HXLINE(  76)						_g = (_g + 1);
HXDLIN(  76)						int i = (_g - 1);
HXDLIN(  76)						if ((p->__get(i).StaticCast< ::Array< Float > >()->length != 0)) {
HXLINE(  77)							::Array< Float > poly = p->__get(i).StaticCast< ::Array< Float > >();
HXLINE(  78)							int n = (poly->length >> 1);
HXDLIN(  78)							::Array< Float > tgs;
HXDLIN(  78)							if ((n < 3)) {
HXLINE(  78)								tgs = ::Array_obj< Float >::__new(0);
            							}
            							else {
HXLINE(  78)								::Array< Float > tgs1 = ::Array_obj< Float >::__new();
HXDLIN(  78)								::Array< int > avl = ::Array_obj< int >::__new(0);
HXDLIN(  78)								{
HXLINE(  78)									int _g = 0;
HXDLIN(  78)									int _g1 = n;
HXDLIN(  78)									while((_g < _g1)){
HXLINE(  78)										_g = (_g + 1);
HXDLIN(  78)										int i = (_g - 1);
HXDLIN(  78)										avl->push(i);
            									}
            								}
HXDLIN(  78)								int i = 0;
HXDLIN(  78)								int al = n;
HXDLIN(  78)								int i0;
HXDLIN(  78)								int i1;
HXDLIN(  78)								int i2;
HXDLIN(  78)								Float ax;
HXDLIN(  78)								Float ay;
HXDLIN(  78)								Float bx;
HXDLIN(  78)								Float by;
HXDLIN(  78)								Float cx;
HXDLIN(  78)								Float cy;
HXDLIN(  78)								bool earFound;
HXDLIN(  78)								while((al > 3)){
HXLINE( 221)									i0 = avl->__get(::hx::Mod(i,al));
HXLINE( 222)									i1 = avl->__get(::hx::Mod((i + 1),al));
HXLINE( 223)									i2 = avl->__get(::hx::Mod((i + 2),al));
HXLINE( 224)									ax = poly->__get((2 * i0));
HXLINE( 225)									ay = poly->__get(((2 * i0) + 1));
HXLINE( 226)									bx = poly->__get((2 * i1));
HXLINE( 227)									by = poly->__get(((2 * i1) + 1));
HXLINE( 228)									cx = poly->__get((2 * i2));
HXLINE( 229)									cy = poly->__get(((2 * i2) + 1));
HXLINE( 230)									earFound = false;
HXLINE(  78)									if (((((ay - by) * (cx - bx)) + ((bx - ax) * (cy - by))) >= 0)) {
HXLINE( 232)										earFound = true;
HXLINE(  78)										{
HXLINE(  78)											int _g = 0;
HXDLIN(  78)											int _g1 = al;
HXDLIN(  78)											while((_g < _g1)){
HXLINE(  78)												_g = (_g + 1);
HXDLIN(  78)												int j = (_g - 1);
HXDLIN(  78)												int vi = avl->__get(j);
HXDLIN(  78)												bool tgs;
HXDLIN(  78)												bool tgs1;
HXDLIN(  78)												if ((vi != i0)) {
HXLINE(  78)													tgs1 = (vi == i1);
            												}
            												else {
HXLINE(  78)													tgs1 = true;
            												}
HXDLIN(  78)												if (!(tgs1)) {
HXLINE(  78)													tgs = (vi == i2);
            												}
            												else {
HXLINE(  78)													tgs = true;
            												}
HXDLIN(  78)												if (tgs) {
HXLINE(  78)													continue;
            												}
HXDLIN(  78)												Float v0x = (cx - ax);
HXDLIN(  78)												Float v0y = (cy - ay);
HXDLIN(  78)												Float v1x = (bx - ax);
HXDLIN(  78)												Float v1y = (by - ay);
HXDLIN(  78)												Float v2x = (poly->__get((2 * vi)) - ax);
HXDLIN(  78)												Float v2y = (poly->__get(((2 * vi) + 1)) - ay);
HXDLIN(  78)												Float dot00 = ((v0x * v0x) + (v0y * v0y));
HXDLIN(  78)												Float dot01 = ((v0x * v1x) + (v0y * v1y));
HXDLIN(  78)												Float dot02 = ((v0x * v2x) + (v0y * v2y));
HXDLIN(  78)												Float dot11 = ((v1x * v1x) + (v1y * v1y));
HXDLIN(  78)												Float dot12 = ((v1x * v2x) + (v1y * v2y));
HXDLIN(  78)												Float invDenom = (( (Float)(1) ) / ((dot00 * dot11) - (dot01 * dot01)));
HXDLIN(  78)												Float u = (((dot11 * dot02) - (dot01 * dot12)) * invDenom);
HXDLIN(  78)												Float v = (((dot00 * dot12) - (dot01 * dot02)) * invDenom);
HXDLIN(  78)												bool tgs2;
HXDLIN(  78)												bool tgs3;
HXDLIN(  78)												if ((u >= 0)) {
HXLINE(  78)													tgs3 = (v >= 0);
            												}
            												else {
HXLINE(  78)													tgs3 = false;
            												}
HXDLIN(  78)												if (tgs3) {
HXLINE(  78)													tgs2 = ((u + v) < 1);
            												}
            												else {
HXLINE(  78)													tgs2 = false;
            												}
HXDLIN(  78)												if (tgs2) {
HXLINE( 237)													earFound = false;
HXLINE(  78)													goto _hx_goto_3;
            												}
            											}
            											_hx_goto_3:;
            										}
            									}
HXDLIN(  78)									if (earFound) {
HXLINE(  78)										tgs1->push(i0);
HXDLIN(  78)										tgs1->push(i1);
HXDLIN(  78)										tgs1->push(i2);
HXDLIN(  78)										avl->removeRange(::hx::Mod((i + 1),al),1);
HXDLIN(  78)										al = (al - 1);
HXLINE( 248)										i = 0;
            									}
            									else {
HXLINE(  78)										i = (i + 1);
HXDLIN(  78)										if (((i - 1) > (3 * al))) {
HXLINE(  78)											goto _hx_goto_2;
            										}
            									}
            								}
            								_hx_goto_2:;
HXDLIN(  78)								tgs1->push(avl->__get(0));
HXDLIN(  78)								tgs1->push(avl->__get(1));
HXDLIN(  78)								tgs1->push(avl->__get(2));
HXDLIN(  78)								tgs = tgs1;
            							}
HXLINE(  79)							::Array< Float > triples = ::dsHelper::iterArr::_ArrayTriple::ArrayTriple_Impl__obj::_new(tgs);
HXLINE(  80)							{
HXLINE(  80)								int _g = 0;
HXDLIN(  80)								while((_g < ::Std_obj::_hx_int((( (Float)(triples->length) ) / ( (Float)(3) ))))){
HXLINE(  80)									int i = ::Std_obj::_hx_int(( (Float)((_g * 3)) ));
HXDLIN(  80)									Float tri__a = triples->__get(i);
HXDLIN(  80)									Float tri__b = triples->__get((i + 1));
HXDLIN(  80)									Float tri__c = triples->__get((i + 2));
HXDLIN(  80)									_g = (_g + 1);
HXLINE(  81)									int a = ::Std_obj::_hx_int((tri__a * ( (Float)(2) )));
HXLINE(  82)									int b = ::Std_obj::_hx_int((tri__b * ( (Float)(2) )));
HXLINE(  83)									int c = ::Std_obj::_hx_int((tri__c * ( (Float)(2) )));
HXLINE(  84)									{
HXLINE(  84)										int color = -1;
HXDLIN(  84)										if ((color == -1)) {
HXLINE( 132)											color = pen->currentColor;
            										}
HXLINE(  84)										{
HXLINE(  84)											pen->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(poly->__get(a),poly->__get((a + 1)),0,poly->__get(b),poly->__get((b + 1)),0,poly->__get(c),poly->__get((c + 1)),0);
HXDLIN(  84)											if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE(  84)												pen->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            											}
HXDLIN(  84)											pen->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            										}
HXDLIN(  84)										pen->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            			break;
            			case (int)2: {
HXLINE(  35)				sketch->pointsNoEndOverlap();
HXLINE(  36)				p = sketch->points;
HXLINE(  37)				 ::org::poly2tri::VisiblePolygon vp =  ::org::poly2tri::VisiblePolygon_obj::__alloc( HX_CTX );
HXLINE(  38)				int l = p->length;
HXLINE(  39)				::Array< Float > p_;
HXLINE(  40)				{
HXLINE(  40)					int _g = 0;
HXDLIN(  40)					int _g1 = l;
HXDLIN(  40)					while((_g < _g1)){
HXLINE(  40)						_g = (_g + 1);
HXDLIN(  40)						int i = (_g - 1);
HXLINE(  41)						p_ = p->__get(i).StaticCast< ::Array< Float > >();
HXLINE(  42)						if ((p_->length != 0)) {
HXLINE(  43)							::Array< ::Dynamic> p2t = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  44)							::Array< Float > pairs = ::dsHelper::iterArr::_ArrayPairs::ArrayPairs_Impl__obj::_new(p_);
HXLINE(  45)							int i = 0;
HXDLIN(  45)							Float inlobj_x = pairs->__get(i);
HXDLIN(  45)							Float inlobj_y = pairs->__get((i + 1));
HXDLIN(  45)							Float p0 = inlobj_x;
HXLINE(  46)							int i1 = 0;
HXDLIN(  46)							Float inlobj_x1 = pairs->__get(i1);
HXDLIN(  46)							Float inlobj_y1 = pairs->__get((i1 + 1));
HXDLIN(  46)							Float p1 = inlobj_y1;
HXLINE(  47)							{
HXLINE(  47)								int _g = 0;
HXDLIN(  47)								while((_g < ::Std_obj::_hx_int((( (Float)(pairs->length) ) / ( (Float)(2) ))))){
HXLINE(  47)									int i = ::Std_obj::_hx_int(( (Float)((_g * 2)) ));
HXDLIN(  47)									Float pair_x = pairs->__get(i);
HXDLIN(  47)									Float pair_y = pairs->__get((i + 1));
HXDLIN(  47)									_g = (_g + 1);
HXDLIN(  47)									p2t->push( ::org::poly2tri::Point_obj::__alloc( HX_CTX ,pair_x,pair_y));
            								}
            							}
HXLINE(  48)							int l2 = p2t->length;
HXLINE(  49)							bool _hx_tmp;
HXDLIN(  49)							if ((p0 == p2t->__get((l2 - 1)).StaticCast<  ::org::poly2tri::Point >()->x)) {
HXLINE(  49)								_hx_tmp = (p1 == p2t->__get((l2 - 1)).StaticCast<  ::org::poly2tri::Point >()->y);
            							}
            							else {
HXLINE(  49)								_hx_tmp = false;
            							}
HXDLIN(  49)							if (_hx_tmp) {
HXLINE(  50)								p2t->pop().StaticCast<  ::org::poly2tri::Point >();
            							}
HXLINE(  52)							vp->addPolyline(p2t);
            						}
            					}
            				}
HXLINE(  55)				vp->performTriangulationOnce();
HXLINE(  56)				 ::Dynamic pt = vp->getVerticesAndTriangles();
HXLINE(  57)				tri = ( (::Array< int >)(pt->__Field(HX_("triangles",ab,30,41,7f),::hx::paccDynamic)) );
HXLINE(  58)				vert = ( (::Array< Float >)(pt->__Field(HX_("vertices",f9,bf,15,6a),::hx::paccDynamic)) );
HXLINE(  59)				::Array< int > triples = ::dsHelper::iterArr::_ArrayTriple::ArrayTriple_Impl__obj::_new(tri);
HXLINE(  61)				{
HXLINE(  61)					int _g2 = 0;
HXDLIN(  61)					while((_g2 < ::Std_obj::_hx_int((( (Float)(triples->length) ) / ( (Float)(3) ))))){
HXLINE(  61)						int i = ::Std_obj::_hx_int(( (Float)((_g2 * 3)) ));
HXDLIN(  61)						int tri__a = triples->__get(i);
HXDLIN(  61)						int tri__b = triples->__get((i + 1));
HXDLIN(  61)						int tri__c = triples->__get((i + 2));
HXDLIN(  61)						_g2 = (_g2 + 1);
HXLINE(  62)						int a = ::Std_obj::_hx_int(( (Float)((tri__a * 3)) ));
HXLINE(  63)						int b = ::Std_obj::_hx_int(( (Float)((tri__b * 3)) ));
HXLINE(  64)						int c = ::Std_obj::_hx_int(( (Float)((tri__c * 3)) ));
HXLINE(  65)						{
HXLINE(  65)							int color = -1;
HXDLIN(  65)							if ((color == -1)) {
HXLINE( 132)								color = pen->currentColor;
            							}
HXLINE(  65)							{
HXLINE(  65)								pen->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(vert->__get(a),vert->__get((a + 1)),0,vert->__get(b),vert->__get((b + 1)),0,vert->__get(c),vert->__get((c + 1)),0);
HXDLIN(  65)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE(  65)									pen->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  65)								pen->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  65)							pen->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
            					}
            				}
            			}
            			break;
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Fill_Fields__obj,triangulate,(void))


Fill_Fields__obj::Fill_Fields__obj()
{
}

bool Fill_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"triangulate") ) { outValue = triangulate_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Fill_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Fill_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class Fill_Fields__obj::__mClass;

static ::String Fill_Fields__obj_sStaticFields[] = {
	HX_("triangulate",2c,65,9d,e9),
	::String(null())
};

void Fill_Fields__obj::__register()
{
	Fill_Fields__obj _hx_dummy;
	Fill_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("trilateral3.drawing._Fill.Fill_Fields_",4d,10,46,da);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Fill_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Fill_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Fill_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Fill_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Fill_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace trilateral3
} // end namespace drawing
} // end namespace _Fill
