// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_fracs_Fracs
#include <fracs/Fracs.h>
#endif
#ifndef INCLUDED_fracs__Fraction_Fraction_Impl_
#include <fracs/_Fraction/Fraction_Impl_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_32__new,"fracs._Fraction.Fraction_Impl_","_new",0x2a584cf7,"fracs._Fraction.Fraction_Impl_._new","fracs/Fraction.hx",32,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_46_optimize,"fracs._Fraction.Fraction_Impl_","optimize",0x00d44773,"fracs._Fraction.Fraction_Impl_.optimize","fracs/Fraction.hx",46,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_50_optimizeFraction,"fracs._Fraction.Fraction_Impl_","optimizeFraction",0xea05c495,"fracs._Fraction.Fraction_Impl_.optimizeFraction","fracs/Fraction.hx",50,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_55_toFloat,"fracs._Fraction.Fraction_Impl_","toFloat",0xab643c4b,"fracs._Fraction.Fraction_Impl_.toFloat","fracs/Fraction.hx",55,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_63_float,"fracs._Fraction.Fraction_Impl_","float",0xe96e3146,"fracs._Fraction.Fraction_Impl_.float","fracs/Fraction.hx",63,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_67_verbose,"fracs._Fraction.Fraction_Impl_","verbose",0x4e0301ac,"fracs._Fraction.Fraction_Impl_.verbose","fracs/Fraction.hx",67,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_71_fromString,"fracs._Fraction.Fraction_Impl_","fromString",0x6a8439f1,"fracs._Fraction.Fraction_Impl_.fromString","fracs/Fraction.hx",71,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_82_toString,"fracs._Fraction.Fraction_Impl_","toString",0x1c2a8b42,"fracs._Fraction.Fraction_Impl_.toString","fracs/Fraction.hx",82,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_98_fromFloat,"fracs._Fraction.Fraction_Impl_","fromFloat",0x17a7387c,"fracs._Fraction.Fraction_Impl_.fromFloat","fracs/Fraction.hx",98,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_119_firstFloat,"fracs._Fraction.Fraction_Impl_","firstFloat",0x56851b62,"fracs._Fraction.Fraction_Impl_.firstFloat","fracs/Fraction.hx",119,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_126_byDenominator,"fracs._Fraction.Fraction_Impl_","byDenominator",0xa7ebbeb9,"fracs._Fraction.Fraction_Impl_.byDenominator","fracs/Fraction.hx",126,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_138_all,"fracs._Fraction.Fraction_Impl_","all",0x2614464b,"fracs._Fraction.Fraction_Impl_.all","fracs/Fraction.hx",138,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_141_similarToFraction,"fracs._Fraction.Fraction_Impl_","similarToFraction",0x69a71b52,"fracs._Fraction.Fraction_Impl_.similarToFraction","fracs/Fraction.hx",141,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_2fa7d690c1539e6b_147_similarToValue,"fracs._Fraction.Fraction_Impl_","similarToValue",0x124a8821,"fracs._Fraction.Fraction_Impl_.similarToValue","fracs/Fraction.hx",147,0xf40fb512)
namespace fracs{
namespace _Fraction{

void Fraction_Impl__obj::__construct() { }

Dynamic Fraction_Impl__obj::__CreateEmpty() { return new Fraction_Impl__obj; }

void *Fraction_Impl__obj::_hx_vtable = 0;

Dynamic Fraction_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Fraction_Impl__obj > _hx_result = new Fraction_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Fraction_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1a57794a;
}

 ::Dynamic Fraction_Impl__obj::_new(int numerator,int denominator, ::Dynamic __o_positive, ::Dynamic value){
            		 ::Dynamic positive = __o_positive;
            		if (::hx::IsNull(__o_positive)) positive = true;
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_32__new)
HXLINE(  34)		bool numNeg = (numerator < 0);
HXLINE(  35)		bool denoNeg = (denominator < 0);
HXLINE(  36)		if (::hx::IsNull( value )) {
HXLINE(  36)			if (( (bool)(positive) )) {
HXLINE(  36)				value = (( (Float)(numerator) ) / ( (Float)(denominator) ));
            			}
            			else {
HXLINE(  36)				value = (( (Float)(-(numerator)) ) / ( (Float)(denominator) ));
            			}
            		}
HXLINE(  37)		bool _hx_tmp;
HXDLIN(  37)		if (!(numNeg)) {
HXLINE(  37)			_hx_tmp = denoNeg;
            		}
            		else {
HXLINE(  37)			_hx_tmp = true;
            		}
HXDLIN(  37)		if (_hx_tmp) {
HXLINE(  38)			bool _hx_tmp;
HXDLIN(  38)			if (numNeg) {
HXLINE(  38)				_hx_tmp = denoNeg;
            			}
            			else {
HXLINE(  38)				_hx_tmp = false;
            			}
HXDLIN(  38)			if (!(_hx_tmp)) {
HXLINE(  38)				positive = !(( (bool)(positive) ));
            			}
HXLINE(  39)			if (numNeg) {
HXLINE(  39)				numerator = -(numerator);
            			}
HXLINE(  40)			if (denoNeg) {
HXLINE(  40)				denominator = -(denominator);
            			}
            		}
HXLINE(  32)		 ::Dynamic this1 =  ::Dynamic(::hx::Anon_obj::Create(4)
            			->setFixed(0,HX_("numerator",89,82,9c,c2),numerator)
            			->setFixed(1,HX_("positive",b9,a6,fa,ca),positive)
            			->setFixed(2,HX_("denominator",a6,25,84,eb),denominator)
            			->setFixed(3,HX_("value",71,7f,b8,31),value));
HXDLIN(  32)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Fraction_Impl__obj,_new,return )

 ::Dynamic Fraction_Impl__obj::optimize( ::Dynamic this1){
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_46_optimize)
HXDLIN(  46)		Float f = ( (Float)(this1->__Field(HX_("value",71,7f,b8,31),::hx::paccDynamic)) );
HXDLIN(  46)		::Array< ::Dynamic> arr = ::fracs::Fracs_obj::approximateFractions(f);
HXDLIN(  46)		Float dist = ::Math_obj::POSITIVE_INFINITY;
HXDLIN(  46)		Float dif;
HXDLIN(  46)		int l = arr->length;
HXDLIN(  46)		Float fracFloat;
HXDLIN(  46)		 ::Dynamic frac;
HXDLIN(  46)		 ::Dynamic fracStore = arr->__get(0);
HXDLIN(  46)		{
HXDLIN(  46)			int _g = 0;
HXDLIN(  46)			int _g1 = l;
HXDLIN(  46)			while((_g < _g1)){
HXDLIN(  46)				_g = (_g + 1);
HXDLIN(  46)				int i = (_g - 1);
HXDLIN(  46)				 ::Dynamic frac = arr->__get(i);
HXDLIN(  46)				if (( (bool)(frac->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXDLIN(  46)					fracFloat = (( (Float)(frac->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ) / ( (Float)(frac->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            				}
            				else {
HXDLIN(  46)					fracFloat = (( (Float)(-(( (int)(frac->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ))) ) / ( (Float)(frac->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            				}
HXDLIN(  46)				dif = ::Math_obj::abs((fracFloat - f));
HXDLIN(  46)				if ((dif < dist)) {
HXDLIN(  46)					dist = dif;
HXDLIN(  46)					fracStore = frac;
            				}
            			}
            		}
HXDLIN(  46)		return fracStore;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fraction_Impl__obj,optimize,return )

 ::Dynamic Fraction_Impl__obj::optimizeFraction( ::Dynamic this1){
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_50_optimizeFraction)
HXDLIN(  50)		Float f;
HXDLIN(  50)		if (( (bool)(this1->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXDLIN(  50)			f = (( (Float)(this1->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ) / ( (Float)(this1->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            		}
            		else {
HXDLIN(  50)			f = (( (Float)(-(( (int)(this1->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ))) ) / ( (Float)(this1->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            		}
HXDLIN(  50)		::Array< ::Dynamic> arr = ::fracs::Fracs_obj::approximateFractions(f);
HXDLIN(  50)		Float dist = ::Math_obj::POSITIVE_INFINITY;
HXDLIN(  50)		Float dif;
HXDLIN(  50)		int l = arr->length;
HXDLIN(  50)		Float fracFloat;
HXDLIN(  50)		 ::Dynamic frac;
HXDLIN(  50)		 ::Dynamic fracStore = arr->__get(0);
HXDLIN(  50)		{
HXDLIN(  50)			int _g = 0;
HXDLIN(  50)			int _g1 = l;
HXDLIN(  50)			while((_g < _g1)){
HXDLIN(  50)				_g = (_g + 1);
HXDLIN(  50)				int i = (_g - 1);
HXDLIN(  50)				 ::Dynamic frac = arr->__get(i);
HXDLIN(  50)				if (( (bool)(frac->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXDLIN(  50)					fracFloat = (( (Float)(frac->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ) / ( (Float)(frac->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            				}
            				else {
HXDLIN(  50)					fracFloat = (( (Float)(-(( (int)(frac->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ))) ) / ( (Float)(frac->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            				}
HXDLIN(  50)				dif = ::Math_obj::abs((fracFloat - f));
HXDLIN(  50)				if ((dif < dist)) {
HXDLIN(  50)					dist = dif;
HXDLIN(  50)					fracStore = frac;
            				}
            			}
            		}
HXDLIN(  50)		return fracStore;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fraction_Impl__obj,optimizeFraction,return )

Float Fraction_Impl__obj::toFloat( ::Dynamic this1){
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_55_toFloat)
HXDLIN(  55)		if (( (bool)(this1->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXLINE(  56)			return (( (Float)(this1->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ) / ( (Float)(this1->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            		}
            		else {
HXLINE(  58)			return (( (Float)(-(( (int)(this1->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ))) ) / ( (Float)(this1->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            		}
HXLINE(  55)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fraction_Impl__obj,toFloat,return )

Float Fraction_Impl__obj::_hx_float( ::Dynamic this1){
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_63_float)
HXDLIN(  63)		return ( (Float)(this1->__Field(HX_("value",71,7f,b8,31),::hx::paccDynamic)) );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fraction_Impl__obj,_hx_float,return )

::String Fraction_Impl__obj::verbose( ::Dynamic this1){
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_67_verbose)
HXDLIN(  67)		::String _hx_tmp = ( (::String)(((((HX_("{ numerator:",16,c9,1c,39) + this1->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) + HX_(", denominator: ",d8,6e,ff,e1)) + this1->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) + HX_(", positive: ",13,f9,b0,e4))) );
HXDLIN(  67)		::String _hx_tmp1 = ((_hx_tmp + ::Std_obj::string( ::Dynamic(this1->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)))) + HX_(", value: ",63,80,38,d8));
HXDLIN(  67)		return ( (::String)(((_hx_tmp1 + this1->__Field(HX_("value",71,7f,b8,31),::hx::paccDynamic)) + HX_(" }",5d,1c,00,00))) );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fraction_Impl__obj,verbose,return )

 ::Dynamic Fraction_Impl__obj::fromString(::String val){
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_71_fromString)
HXLINE(  72)		int i = val.indexOf(HX_("/",2f,00,00,00),null());
HXLINE(  73)		 ::Dynamic frac;
HXDLIN(  73)		if ((i != -1)) {
HXLINE(  74)			int numerator = ( (int)(::Std_obj::parseInt(val.substr(0,i))) );
HXDLIN(  74)			int denominator = ( (int)(::Std_obj::parseInt(val.substr((i + 1),val.length))) );
HXDLIN(  74)			 ::Dynamic positive = true;
HXDLIN(  74)			 ::Dynamic value = null();
HXDLIN(  74)			bool numNeg = (numerator < 0);
HXDLIN(  74)			bool denoNeg = (denominator < 0);
HXDLIN(  74)			if (::hx::IsNull( value )) {
HXLINE(  74)				if (( (bool)(positive) )) {
HXLINE(  74)					value = (( (Float)(numerator) ) / ( (Float)(denominator) ));
            				}
            				else {
HXLINE(  74)					value = (( (Float)(-(numerator)) ) / ( (Float)(denominator) ));
            				}
            			}
HXDLIN(  74)			bool frac1;
HXDLIN(  74)			if (!(numNeg)) {
HXLINE(  74)				frac1 = denoNeg;
            			}
            			else {
HXLINE(  74)				frac1 = true;
            			}
HXDLIN(  74)			if (frac1) {
HXLINE(  74)				bool frac;
HXDLIN(  74)				if (numNeg) {
HXLINE(  74)					frac = denoNeg;
            				}
            				else {
HXLINE(  74)					frac = false;
            				}
HXDLIN(  74)				if (!(frac)) {
HXLINE(  74)					positive = !(( (bool)(positive) ));
            				}
HXDLIN(  74)				if (numNeg) {
HXLINE(  74)					numerator = -(numerator);
            				}
HXDLIN(  74)				if (denoNeg) {
HXLINE(  74)					denominator = -(denominator);
            				}
            			}
HXDLIN(  74)			 ::Dynamic this1 =  ::Dynamic(::hx::Anon_obj::Create(4)
            				->setFixed(0,HX_("numerator",89,82,9c,c2),numerator)
            				->setFixed(1,HX_("positive",b9,a6,fa,ca),positive)
            				->setFixed(2,HX_("denominator",a6,25,84,eb),denominator)
            				->setFixed(3,HX_("value",71,7f,b8,31),value));
HXLINE(  73)			frac = this1;
            		}
            		else {
HXLINE(  75)			Float f = ::Std_obj::parseFloat(val);
HXDLIN(  75)			::Array< ::Dynamic> arr = ::fracs::Fracs_obj::approximateFractions(f);
HXDLIN(  75)			Float dist = ::Math_obj::POSITIVE_INFINITY;
HXDLIN(  75)			Float dif;
HXDLIN(  75)			int l = arr->length;
HXDLIN(  75)			Float fracFloat;
HXDLIN(  75)			 ::Dynamic frac1;
HXDLIN(  75)			 ::Dynamic fracStore = arr->__get(0);
HXDLIN(  75)			{
HXLINE(  75)				int _g = 0;
HXDLIN(  75)				int _g1 = l;
HXDLIN(  75)				while((_g < _g1)){
HXLINE(  75)					_g = (_g + 1);
HXDLIN(  75)					int i = (_g - 1);
HXDLIN(  75)					 ::Dynamic frac = arr->__get(i);
HXDLIN(  75)					if (( (bool)(frac->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXLINE(  75)						fracFloat = (( (Float)(frac->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ) / ( (Float)(frac->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            					}
            					else {
HXLINE(  75)						fracFloat = (( (Float)(-(( (int)(frac->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ))) ) / ( (Float)(frac->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            					}
HXDLIN(  75)					dif = ::Math_obj::abs((fracFloat - f));
HXDLIN(  75)					if ((dif < dist)) {
HXLINE(  75)						dist = dif;
HXDLIN(  75)						fracStore = frac;
            					}
            				}
            			}
HXLINE(  73)			frac = fracStore;
            		}
HXLINE(  78)		return frac;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fraction_Impl__obj,fromString,return )

::String Fraction_Impl__obj::toString( ::Dynamic this1){
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_82_toString)
HXLINE(  83)		int n = ( (int)(this1->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) );
HXLINE(  84)		int d = ( (int)(this1->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) );
HXLINE(  85)		::String out;
HXDLIN(  85)		if ((n == 0)) {
HXLINE(  85)			out = HX_("0",30,00,00,00);
            		}
            		else {
HXLINE(  87)			if ((n == d)) {
HXLINE(  85)				out = HX_("1",31,00,00,00);
            			}
            			else {
HXLINE(  89)				if ((d == 1)) {
HXLINE(  90)					if (( (bool)(this1->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXLINE(  85)						out = (HX_("",00,00,00,00) + n);
            					}
            					else {
HXLINE(  85)						out = (HX_("-",2d,00,00,00) + n);
            					}
            				}
            				else {
HXLINE(  92)					if (( (bool)(this1->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXLINE(  85)						out = (((HX_("",00,00,00,00) + n) + HX_("/",2f,00,00,00)) + d);
            					}
            					else {
HXLINE(  85)						out = (((HX_("-",2d,00,00,00) + n) + HX_("/",2f,00,00,00)) + d);
            					}
            				}
            			}
            		}
HXLINE(  94)		return out;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fraction_Impl__obj,toString,return )

 ::Dynamic Fraction_Impl__obj::fromFloat(Float f){
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_98_fromFloat)
HXLINE(  99)		::Array< ::Dynamic> arr = ::fracs::Fracs_obj::approximateFractions(f);
HXLINE( 100)		Float dist = ::Math_obj::POSITIVE_INFINITY;
HXLINE( 101)		Float dif;
HXLINE( 102)		int l = arr->length;
HXLINE( 103)		Float fracFloat;
HXLINE( 104)		 ::Dynamic frac;
HXLINE( 105)		 ::Dynamic fracStore = arr->__get(0);
HXLINE( 107)		{
HXLINE( 107)			int _g = 0;
HXDLIN( 107)			int _g1 = l;
HXDLIN( 107)			while((_g < _g1)){
HXLINE( 107)				_g = (_g + 1);
HXDLIN( 107)				int i = (_g - 1);
HXLINE( 108)				 ::Dynamic frac = arr->__get(i);
HXLINE( 109)				if (( (bool)(frac->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXLINE( 109)					fracFloat = (( (Float)(frac->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ) / ( (Float)(frac->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            				}
            				else {
HXLINE( 109)					fracFloat = (( (Float)(-(( (int)(frac->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ))) ) / ( (Float)(frac->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            				}
HXLINE( 110)				dif = ::Math_obj::abs((fracFloat - f));
HXLINE( 111)				if ((dif < dist)) {
HXLINE( 112)					dist = dif;
HXLINE( 113)					fracStore = frac;
            				}
            			}
            		}
HXLINE( 116)		return fracStore;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fraction_Impl__obj,fromFloat,return )

 ::Dynamic Fraction_Impl__obj::firstFloat(Float f){
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_119_firstFloat)
HXLINE( 120)		::Array< ::Dynamic> arr = ::fracs::Fracs_obj::approximateFractions(f);
HXLINE( 121)		 ::Dynamic fracStore = arr->__get(0);
HXLINE( 122)		return fracStore;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fraction_Impl__obj,firstFloat,return )

::String Fraction_Impl__obj::byDenominator( ::Dynamic this1,int val){
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_126_byDenominator)
HXLINE( 127)		int n = ( (int)(this1->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) );
HXDLIN( 127)		int d = ( (int)(this1->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) );
HXDLIN( 127)		::String out;
HXDLIN( 127)		if ((n == 0)) {
HXLINE( 127)			out = HX_("0",30,00,00,00);
            		}
            		else {
HXLINE( 127)			if ((n == d)) {
HXLINE( 127)				out = HX_("1",31,00,00,00);
            			}
            			else {
HXLINE( 127)				if ((d == 1)) {
HXLINE( 127)					if (( (bool)(this1->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXLINE( 127)						out = (HX_("",00,00,00,00) + n);
            					}
            					else {
HXLINE( 127)						out = (HX_("-",2d,00,00,00) + n);
            					}
            				}
            				else {
HXLINE( 127)					if (( (bool)(this1->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXLINE( 127)						out = (((HX_("",00,00,00,00) + n) + HX_("/",2f,00,00,00)) + d);
            					}
            					else {
HXLINE( 127)						out = (((HX_("-",2d,00,00,00) + n) + HX_("/",2f,00,00,00)) + d);
            					}
            				}
            			}
            		}
HXDLIN( 127)		::String out1 = out;
HXLINE( 128)		bool _hx_tmp;
HXDLIN( 128)		bool _hx_tmp1;
HXDLIN( 128)		if (::hx::IsNotEq( this1->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic),val )) {
HXLINE( 128)			_hx_tmp1 = (out1 == HX_("0",30,00,00,00));
            		}
            		else {
HXLINE( 128)			_hx_tmp1 = true;
            		}
HXDLIN( 128)		if (!(_hx_tmp1)) {
HXLINE( 128)			_hx_tmp = (out1 == HX_("1",31,00,00,00));
            		}
            		else {
HXLINE( 128)			_hx_tmp = true;
            		}
HXDLIN( 128)		if (!(_hx_tmp)) {
HXLINE( 130)			int dom = ::Math_obj::round((( (Float)(this1->__Field(HX_("value",71,7f,b8,31),::hx::paccDynamic)) ) * ( (Float)(val) )));
HXLINE( 131)			int numerator = dom;
HXDLIN( 131)			int denominator = val;
HXDLIN( 131)			 ::Dynamic positive = true;
HXDLIN( 131)			 ::Dynamic value = null();
HXDLIN( 131)			bool numNeg = (numerator < 0);
HXDLIN( 131)			bool denoNeg = (denominator < 0);
HXDLIN( 131)			if (::hx::IsNull( value )) {
HXLINE( 131)				if (( (bool)(positive) )) {
HXLINE( 131)					value = (( (Float)(numerator) ) / ( (Float)(denominator) ));
            				}
            				else {
HXLINE( 131)					value = (( (Float)(-(numerator)) ) / ( (Float)(denominator) ));
            				}
            			}
HXDLIN( 131)			bool _hx_tmp;
HXDLIN( 131)			if (!(numNeg)) {
HXLINE( 131)				_hx_tmp = denoNeg;
            			}
            			else {
HXLINE( 131)				_hx_tmp = true;
            			}
HXDLIN( 131)			if (_hx_tmp) {
HXLINE( 131)				bool _hx_tmp;
HXDLIN( 131)				if (numNeg) {
HXLINE( 131)					_hx_tmp = denoNeg;
            				}
            				else {
HXLINE( 131)					_hx_tmp = false;
            				}
HXDLIN( 131)				if (!(_hx_tmp)) {
HXLINE( 131)					positive = !(( (bool)(positive) ));
            				}
HXDLIN( 131)				if (numNeg) {
HXLINE( 131)					numerator = -(numerator);
            				}
HXDLIN( 131)				if (denoNeg) {
HXLINE( 131)					denominator = -(denominator);
            				}
            			}
HXDLIN( 131)			 ::Dynamic this2 =  ::Dynamic(::hx::Anon_obj::Create(4)
            				->setFixed(0,HX_("numerator",89,82,9c,c2),numerator)
            				->setFixed(1,HX_("positive",b9,a6,fa,ca),positive)
            				->setFixed(2,HX_("denominator",a6,25,84,eb),denominator)
            				->setFixed(3,HX_("value",71,7f,b8,31),value));
HXDLIN( 131)			 ::Dynamic frac = this2;
HXLINE( 132)			int n = ( (int)(frac->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) );
HXDLIN( 132)			int d = ( (int)(frac->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) );
HXDLIN( 132)			::String out;
HXDLIN( 132)			if ((n == 0)) {
HXLINE( 132)				out = HX_("0",30,00,00,00);
            			}
            			else {
HXLINE( 132)				if ((n == d)) {
HXLINE( 132)					out = HX_("1",31,00,00,00);
            				}
            				else {
HXLINE( 132)					if ((d == 1)) {
HXLINE( 132)						if (( (bool)(frac->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXLINE( 132)							out = (HX_("",00,00,00,00) + n);
            						}
            						else {
HXLINE( 132)							out = (HX_("-",2d,00,00,00) + n);
            						}
            					}
            					else {
HXLINE( 132)						if (( (bool)(frac->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXLINE( 132)							out = (((HX_("",00,00,00,00) + n) + HX_("/",2f,00,00,00)) + d);
            						}
            						else {
HXLINE( 132)							out = (((HX_("-",2d,00,00,00) + n) + HX_("/",2f,00,00,00)) + d);
            						}
            					}
            				}
            			}
HXDLIN( 132)			out1 = out;
            		}
HXLINE( 134)		return out1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Fraction_Impl__obj,byDenominator,return )

::Array< ::Dynamic> Fraction_Impl__obj::all(Float f){
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_138_all)
HXDLIN( 138)		return ::fracs::Fracs_obj::approximateFractions(f);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fraction_Impl__obj,all,return )

::Array< ::Dynamic> Fraction_Impl__obj::similarToFraction( ::Dynamic this1){
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_141_similarToFraction)
HXLINE( 142)		Float f;
HXDLIN( 142)		if (( (bool)(this1->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXLINE( 142)			f = (( (Float)(this1->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ) / ( (Float)(this1->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            		}
            		else {
HXLINE( 142)			f = (( (Float)(-(( (int)(this1->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ))) ) / ( (Float)(this1->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            		}
HXLINE( 143)		return ::fracs::Fracs_obj::approximateFractions(f);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fraction_Impl__obj,similarToFraction,return )

::Array< ::Dynamic> Fraction_Impl__obj::similarToValue( ::Dynamic this1){
            	HX_STACKFRAME(&_hx_pos_2fa7d690c1539e6b_147_similarToValue)
HXDLIN( 147)		return ::fracs::Fracs_obj::approximateFractions(( (Float)(this1->__Field(HX_("value",71,7f,b8,31),::hx::paccDynamic)) ));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fraction_Impl__obj,similarToValue,return )


Fraction_Impl__obj::Fraction_Impl__obj()
{
}

bool Fraction_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"all") ) { outValue = all_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"_new") ) { outValue = _new_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"float") ) { outValue = _hx_float_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"toFloat") ) { outValue = toFloat_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"verbose") ) { outValue = verbose_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"optimize") ) { outValue = optimize_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"toString") ) { outValue = toString_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"fromFloat") ) { outValue = fromFloat_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"fromString") ) { outValue = fromString_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"firstFloat") ) { outValue = firstFloat_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"byDenominator") ) { outValue = byDenominator_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"similarToValue") ) { outValue = similarToValue_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"optimizeFraction") ) { outValue = optimizeFraction_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"similarToFraction") ) { outValue = similarToFraction_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Fraction_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Fraction_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class Fraction_Impl__obj::__mClass;

static ::String Fraction_Impl__obj_sStaticFields[] = {
	HX_("_new",61,15,1f,3f),
	HX_("optimize",dd,8c,18,1d),
	HX_("optimizeFraction",ff,83,8c,53),
	HX_("toFloat",21,12,1b,cf),
	HX_("float",9c,c5,96,02),
	HX_("verbose",82,d7,b9,71),
	HX_("fromString",db,2d,74,54),
	HX_("toString",ac,d0,6e,38),
	HX_("fromFloat",d2,af,1f,b7),
	HX_("firstFloat",4c,0f,75,40),
	HX_("byDenominator",0f,99,e1,96),
	HX_("all",21,f9,49,00),
	HX_("similarToFraction",a8,d8,07,56),
	HX_("similarToValue",0b,b9,73,3a),
	::String(null())
};

void Fraction_Impl__obj::__register()
{
	Fraction_Impl__obj _hx_dummy;
	Fraction_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("fracs._Fraction.Fraction_Impl_",98,50,12,83);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Fraction_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Fraction_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Fraction_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Fraction_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Fraction_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace fracs
} // end namespace _Fraction
