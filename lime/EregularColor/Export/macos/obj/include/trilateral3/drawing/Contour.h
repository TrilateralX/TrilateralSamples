// Generated by Haxe 4.2.0-rc.1+7dc565e63
#ifndef INCLUDED_trilateral3_drawing_Contour
#define INCLUDED_trilateral3_drawing_Contour

#ifndef HXCPP_H
#include <hxcpp.h>
#endif

HX_DECLARE_CLASS1(fracs,DifferencePreference)
HX_DECLARE_CLASS2(trilateral3,drawing,Contour)
HX_DECLARE_CLASS2(trilateral3,drawing,Pen)

namespace trilateral3{
namespace drawing{


class HXCPP_CLASS_ATTRIBUTES Contour_obj : public ::hx::Object
{
	public:
		typedef ::hx::Object super;
		typedef Contour_obj OBJ_;
		Contour_obj();

	public:
		enum { _hx_ClassId = 0x2f69a3a3 };

		void __construct( ::trilateral3::drawing::Pen pen_,::hx::Null< int >  __o_endLine_);
		inline void *operator new(size_t inSize, bool inContainer=true,const char *inName="trilateral3.drawing.Contour")
			{ return ::hx::Object::operator new(inSize,inContainer,inName); }
		inline void *operator new(size_t inSize, int extra)
			{ return ::hx::Object::operator new(inSize+extra,true,"trilateral3.drawing.Contour"); }
		static ::hx::ObjectPtr< Contour_obj > __new( ::trilateral3::drawing::Pen pen_,::hx::Null< int >  __o_endLine_);
		static ::hx::ObjectPtr< Contour_obj > __alloc(::hx::Ctx *_hx_ctx, ::trilateral3::drawing::Pen pen_,::hx::Null< int >  __o_endLine_);
		static void * _hx_vtable;
		static Dynamic __CreateEmpty();
		static Dynamic __Create(::hx::DynamicArray inArgs);
		//~Contour_obj();

		HX_DO_RTTI_ALL;
		::hx::Val __Field(const ::String &inString, ::hx::PropertyAccess inCallProp);
		static bool __GetStatic(const ::String &inString, Dynamic &outValue, ::hx::PropertyAccess inCallProp);
		::hx::Val __SetField(const ::String &inString,const ::hx::Val &inValue, ::hx::PropertyAccess inCallProp);
		void __GetFields(Array< ::String> &outFields);
		static void __register();
		void __Mark(HX_MARK_PARAMS);
		void __Visit(HX_VISIT_PARAMS);
		bool _hx_isInstanceOf(int inClassId);
		::String __ToString() const { return HX_("Contour",ba,51,d0,e6); }

		static void __boot();
		static Float smallDotScale;
		static Float thetaCompute(Float px,Float py,Float qx,Float qy);
		static ::Dynamic thetaCompute_dyn();

		static Float dist(Float px,Float py,Float qx,Float qy);
		static ::Dynamic dist_dyn();

		int debugCol0;
		int debugCol1;
		int debugCol2;
		int debugCol3;
		int debugCol4;
		int debugCol5;
		int debugCol6;
		int debugCol7;
		int debugCol8;
		int debugCol9;
		int debugCol10;
		int debugCol11;
		int debugCol12;
		::Array< Float > pointsClock;
		::Array< Float > pointsAnti;
		Float penultimateCX;
		Float penultimateCY;
		Float lastClockX;
		Float lastClockY;
		Float penultimateAX;
		Float penultimateAY;
		Float lastAntiX;
		Float lastAntiY;
		 ::trilateral3::drawing::Pen pen;
		int endLine;
		Float ax;
		Float ay;
		Float bx;
		Float by;
		Float cx;
		Float cy;
		 ::Dynamic dx;
		 ::Dynamic dy;
		 ::Dynamic ex;
		 ::Dynamic ey;
		 ::Dynamic dxPrev;
		 ::Dynamic dyPrev;
		 ::Dynamic exPrev;
		 ::Dynamic eyPrev;
		 ::Dynamic dxOld;
		 ::Dynamic dyOld;
		 ::Dynamic exOld;
		 ::Dynamic eyOld;
		Float jx;
		Float jy;
		bool lastClock;
		Float jxOld;
		Float jyOld;
		Float kax;
		Float kay;
		Float kbx;
		Float kby;
		Float kcx;
		Float kcy;
		Float ncx;
		Float ncy;
		Float quadIndex;
		Float angleA;
		Float halfA;
		Float beta;
		Float r;
		Float theta;
		 ::Dynamic angle1;
		Float angle2;
		void reset();
		::Dynamic reset_dyn();

		int count;
		void computeDE();
		::Dynamic computeDE_dyn();

		void anglesCompute();
		::Dynamic anglesCompute_dyn();

		Float thetaComputeAdj(Float qx,Float qy);
		::Dynamic thetaComputeAdj_dyn();

		void triangleJoin(Float ax_,Float ay_,Float bx_,Float by_,Float width_,::hx::Null< bool >  curveEnds,::hx::Null< bool >  overlap);
		::Dynamic triangleJoin_dyn();

		void overlapQuad();
		::Dynamic overlapQuad_dyn();

		void end(Float width_);
		::Dynamic end_dyn();

		void triangle2DFill(Float ax_,Float ay_,Float bx_,Float by_,Float cx_,Float cy_,::hx::Null< int >  color_);
		::Dynamic triangle2DFill_dyn();

		void addPieXstart(Float ax,Float ay,Float radius,Float beta,Float gamma, ::fracs::DifferencePreference prefer, ::Dynamic mark, ::Dynamic sides);
		::Dynamic addPieXstart_dyn();

		void addPieX(Float ax,Float ay,Float radius,Float beta,Float gamma, ::fracs::DifferencePreference prefer, ::Dynamic mark, ::Dynamic sides);
		::Dynamic addPieX_dyn();

		void addPie(Float ax,Float ay,Float radius,Float beta,Float gamma, ::fracs::DifferencePreference prefer, ::Dynamic mark, ::Dynamic sides);
		::Dynamic addPie_dyn();

		void computeJ(Float width_,Float theta0,Float dif);
		::Dynamic computeJ_dyn();

		void addDot(Float x,Float y,int color,Float width_);
		::Dynamic addDot_dyn();

		void addSmallTriangles(bool clockWise,Float width_);
		::Dynamic addSmallTriangles_dyn();

		void triangle2DFillangleCorners(Float oldx_,Float oldy_,Float prevx_,Float prevy_,Float width_);
		::Dynamic triangle2DFillangleCorners_dyn();

		void triangle2DFillangleCornersLess(Float oldx_,Float oldy_,Float prevx_,Float prevy_,Float width_);
		::Dynamic triangle2DFillangleCornersLess_dyn();

		void connectQuadsWhenQuadsOverlay(bool clockWise,Float width_);
		::Dynamic connectQuadsWhenQuadsOverlay_dyn();

		void connectQuads(bool clockWise,Float width_);
		::Dynamic connectQuads_dyn();

		void addInitialQuads(bool clockWise,Float width_);
		::Dynamic addInitialQuads_dyn();

		void endEdges();
		::Dynamic endEdges_dyn();

		int counter;
		void addQuads(bool clockWise,Float width_);
		::Dynamic addQuads_dyn();

		void storeLastQuads();
		::Dynamic storeLastQuads_dyn();

		bool isClockwise(Float x,Float y);
		::Dynamic isClockwise_dyn();

		void line(Float ax_,Float ay_,Float bx_,Float by_,Float width_, ::Dynamic endLineCurve);
		::Dynamic line_dyn();

};

} // end namespace trilateral3
} // end namespace drawing

#endif /* INCLUDED_trilateral3_drawing_Contour */ 
