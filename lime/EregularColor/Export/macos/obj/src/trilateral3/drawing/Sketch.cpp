// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringBuf
#include <StringBuf.h>
#endif
#ifndef INCLUDED_dsHelper_splitter_StringCodeIterator
#include <dsHelper/splitter/StringCodeIterator.h>
#endif
#ifndef INCLUDED_fracs_DifferencePreference
#include <fracs/DifferencePreference.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_justPath_IPathContext
#include <justPath/IPathContext.h>
#endif
#ifndef INCLUDED_trilateral3_Trilateral
#include <trilateral3/Trilateral.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Contour
#include <trilateral3/drawing/Contour.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Pen
#include <trilateral3/drawing/Pen.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Sketch
#include <trilateral3/drawing/Sketch.h>
#endif
#ifndef INCLUDED_trilateral3_math__Algebra_Algebra_Fields_
#include <trilateral3/math/_Algebra/Algebra_Fields_.h>
#endif
#ifndef INCLUDED_trilateral3_matrix_MatrixDozen
#include <trilateral3/matrix/MatrixDozen.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_6351d8d914bc61da_22_new,"trilateral3.drawing.Sketch","new",0x720a6595,"trilateral3.drawing.Sketch.new","trilateral3/drawing/Sketch.hx",22,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_38_tracerLine,"trilateral3.drawing.Sketch","tracerLine",0x0f56c04c,"trilateral3.drawing.Sketch.tracerLine","trilateral3/drawing/Sketch.hx",38,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_40_fillOnlyLine,"trilateral3.drawing.Sketch","fillOnlyLine",0x8ad9d14e,"trilateral3.drawing.Sketch.fillOnlyLine","trilateral3/drawing/Sketch.hx",40,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_42_baseLine,"trilateral3.drawing.Sketch","baseLine",0xf4387350,"trilateral3.drawing.Sketch.baseLine","trilateral3/drawing/Sketch.hx",42,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_47_crudeLine,"trilateral3.drawing.Sketch","crudeLine",0x9b1c8e70,"trilateral3.drawing.Sketch.crudeLine","trilateral3/drawing/Sketch.hx",47,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_50_roundEndLine,"trilateral3.drawing.Sketch","roundEndLine",0xcb0a62ec,"trilateral3.drawing.Sketch.roundEndLine","trilateral3/drawing/Sketch.hx",50,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_53_mediumLine,"trilateral3.drawing.Sketch","mediumLine",0x40d82274,"trilateral3.drawing.Sketch.mediumLine","trilateral3/drawing/Sketch.hx",53,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_56_mediumOverlapLine,"trilateral3.drawing.Sketch","mediumOverlapLine",0x6ebb9c9b,"trilateral3.drawing.Sketch.mediumOverlapLine","trilateral3/drawing/Sketch.hx",56,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_59_fineLine,"trilateral3.drawing.Sketch","fineLine",0x25e523f9,"trilateral3.drawing.Sketch.fineLine","trilateral3/drawing/Sketch.hx",59,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_62_fineOverlapLine,"trilateral3.drawing.Sketch","fineOverlapLine",0xdef605b6,"trilateral3.drawing.Sketch.fineOverlapLine","trilateral3/drawing/Sketch.hx",62,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_98_reset,"trilateral3.drawing.Sketch","reset",0x23365644,"trilateral3.drawing.Sketch.reset","trilateral3/drawing/Sketch.hx",98,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_107_pointsNoEndOverlap,"trilateral3.drawing.Sketch","pointsNoEndOverlap",0x74eb1dbb,"trilateral3.drawing.Sketch.pointsNoEndOverlap","trilateral3/drawing/Sketch.hx",107,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_161_pointsRewound,"trilateral3.drawing.Sketch","pointsRewound",0x5e7f2bd2,"trilateral3.drawing.Sketch.pointsRewound","trilateral3/drawing/Sketch.hx",161,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_222_initDim,"trilateral3.drawing.Sketch","initDim",0x88e4d7cd,"trilateral3.drawing.Sketch.initDim","trilateral3/drawing/Sketch.hx",222,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_224_updateDim,"trilateral3.drawing.Sketch","updateDim",0xbb1f05b4,"trilateral3.drawing.Sketch.updateDim","trilateral3/drawing/Sketch.hx",224,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_231_moveTo,"trilateral3.drawing.Sketch","moveTo",0x7089acd7,"trilateral3.drawing.Sketch.moveTo","trilateral3/drawing/Sketch.hx",231,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_250_lastClock,"trilateral3.drawing.Sketch","lastClock",0xcd56228d,"trilateral3.drawing.Sketch.lastClock","trilateral3/drawing/Sketch.hx",250,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_259_getEdges,"trilateral3.drawing.Sketch","getEdges",0xc1eee7cb,"trilateral3.drawing.Sketch.getEdges","trilateral3/drawing/Sketch.hx",259,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_287_lineTo,"trilateral3.drawing.Sketch","lineTo",0x907d207a,"trilateral3.drawing.Sketch.lineTo","trilateral3/drawing/Sketch.hx",287,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_304_quadTo,"trilateral3.drawing.Sketch","quadTo",0x707c5c0d,"trilateral3.drawing.Sketch.quadTo","trilateral3/drawing/Sketch.hx",304,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_313_quadThru,"trilateral3.drawing.Sketch","quadThru",0xcd504d49,"trilateral3.drawing.Sketch.quadThru","trilateral3/drawing/Sketch.hx",313,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_319_curveTo,"trilateral3.drawing.Sketch","curveTo",0x8bea33bf,"trilateral3.drawing.Sketch.curveTo","trilateral3/drawing/Sketch.hx",319,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_327_plotCoord,"trilateral3.drawing.Sketch","plotCoord",0xe9ec83c9,"trilateral3.drawing.Sketch.plotCoord","trilateral3/drawing/Sketch.hx",327,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_340_aiColorSet,"trilateral3.drawing.Sketch","aiColorSet",0xc9c48672,"trilateral3.drawing.Sketch.aiColorSet","trilateral3/drawing/Sketch.hx",340,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_357_getColorType,"trilateral3.drawing.Sketch","getColorType",0x0686b672,"trilateral3.drawing.Sketch.getColorType","trilateral3/drawing/Sketch.hx",357,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_364_aiStringPart,"trilateral3.drawing.Sketch","aiStringPart",0x867b9c97,"trilateral3.drawing.Sketch.aiStringPart","trilateral3/drawing/Sketch.hx",364,0x5aa78a39)
HX_LOCAL_STACK_FRAME(_hx_pos_6351d8d914bc61da_92_create,"trilateral3.drawing.Sketch","create",0x1fec40e7,"trilateral3.drawing.Sketch.create","trilateral3/drawing/Sketch.hx",92,0x5aa78a39)
namespace trilateral3{
namespace drawing{

void Sketch_obj::__construct( ::trilateral3::drawing::Pen pen_,int sketchForm_,::hx::Null< int >  __o_endLine_){
            		int endLine_ = __o_endLine_.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_6351d8d914bc61da_22_new)
HXLINE(  25)		this->width = ((Float)0.01);
HXLINE(  24)		this->y = ((Float)0.);
HXLINE(  23)		this->x = ((Float)0.);
HXLINE(  67)		this->contour =  ::trilateral3::drawing::Contour_obj::__alloc( HX_CTX ,pen_,endLine_);
HXLINE(  68)		this->pen = pen_;
HXLINE(  69)		this->endLine = endLine_;
HXLINE(  70)		this->sketchForm = sketchForm_;
HXLINE(  71)		switch((int)(sketchForm_)){
            			case (int)0: {
HXLINE(  72)				this->line = this->tracerLine_dyn();
            			}
            			break;
            			case (int)1: {
HXLINE(  73)				this->line = this->baseLine_dyn();
            			}
            			break;
            			case (int)2: {
HXLINE(  74)				this->line = this->crudeLine_dyn();
            			}
            			break;
            			case (int)3: {
HXLINE(  75)				this->line = this->fillOnlyLine_dyn();
            			}
            			break;
            			case (int)4: {
HXLINE(  76)				this->line = this->fineLine_dyn();
            			}
            			break;
            			case (int)5: {
HXLINE(  77)				this->line = this->fineOverlapLine_dyn();
            			}
            			break;
            			case (int)6: {
HXLINE(  78)				this->line = this->mediumLine_dyn();
            			}
            			break;
            			case (int)7: {
HXLINE(  79)				this->line = this->mediumOverlapLine_dyn();
            			}
            			break;
            			case (int)8: {
HXLINE(  80)				this->line = this->roundEndLine_dyn();
            			}
            			break;
            		}
HXLINE(  82)		this->points = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  83)		this->pointsClock = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  84)		this->pointsAnti = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  85)		this->points[0] = ::Array_obj< Float >::__new();
HXLINE(  86)		this->dim = ::Array_obj< ::Dynamic>::__new();
            	}

Dynamic Sketch_obj::__CreateEmpty() { return new Sketch_obj; }

void *Sketch_obj::_hx_vtable = 0;

Dynamic Sketch_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Sketch_obj > _hx_result = new Sketch_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool Sketch_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x100e59ef;
}

static ::justPath::IPathContext_obj _hx_trilateral3_drawing_Sketch__hx_justPath_IPathContext= {
	( void (::hx::Object::*)(Float,Float))&::trilateral3::drawing::Sketch_obj::moveTo,
	( void (::hx::Object::*)(Float,Float))&::trilateral3::drawing::Sketch_obj::lineTo,
	( void (::hx::Object::*)(Float,Float,Float,Float))&::trilateral3::drawing::Sketch_obj::quadTo,
	( void (::hx::Object::*)(Float,Float,Float,Float,Float,Float))&::trilateral3::drawing::Sketch_obj::curveTo,
};

void *Sketch_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0xed67b972: return &_hx_trilateral3_drawing_Sketch__hx_justPath_IPathContext;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void Sketch_obj::tracerLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_38_tracerLine)
HXDLIN(  38)		::haxe::Log_obj::trace(((((((((HX_("lineTo( ",47,6b,2a,8a) + this->x) + HX_(", ",74,26,00,00)) + this->y) + HX_(", ",74,26,00,00)) + x_) + HX_(", ",74,26,00,00)) + y_) + HX_(", width )",9b,2f,cd,98)),::hx::SourceInfo(HX_("trilateral3/drawing/Sketch.hx",39,8a,a7,5a),38,HX_("trilateral3.drawing.Sketch",23,f7,00,b3),HX_("tracerLine",e1,14,6f,0a)));
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,tracerLine,(void))

void Sketch_obj::fillOnlyLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_40_fillOnlyLine)
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,fillOnlyLine,(void))

void Sketch_obj::baseLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_42_baseLine)
HXLINE(  43)		::haxe::Log_obj::trace(((((((((HX_("lineTo( ",47,6b,2a,8a) + this->x) + HX_(", ",74,26,00,00)) + this->y) + HX_(", ",74,26,00,00)) + x_) + HX_(", ",74,26,00,00)) + y_) + HX_(", width )",9b,2f,cd,98)),::hx::SourceInfo(HX_("trilateral3/drawing/Sketch.hx",39,8a,a7,5a),38,HX_("trilateral3.drawing.Sketch",23,f7,00,b3),HX_("tracerLine",e1,14,6f,0a)));
HXLINE(  44)		{
HXLINE(  44)			 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  44)			Float ax_ = this->x;
HXDLIN(  44)			Float ay_ = this->y;
HXDLIN(  44)			Float width_ = this->width;
HXDLIN(  44)			_this->ax = x_;
HXDLIN(  44)			_this->ay = y_;
HXDLIN(  44)			_this->bx = ax_;
HXDLIN(  44)			_this->by = ay_;
HXDLIN(  44)			_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  44)			_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  44)			_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  44)			{
HXLINE(  44)				{
HXLINE(  44)					_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  44)					if ((_this->theta > 0)) {
HXLINE(  44)						if ((_this->halfA < 0)) {
HXLINE(  44)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            						else {
HXLINE(  44)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  44)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            					}
            					else {
HXLINE(  44)						if ((_this->halfA > 0)) {
HXLINE(  44)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  44)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            						else {
HXLINE(  44)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            					}
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dxPrev )) {
HXLINE(  44)					_this->dxOld = _this->dxPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dyPrev )) {
HXLINE(  44)					_this->dyOld = _this->dyPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->exPrev )) {
HXLINE(  44)					_this->exOld = _this->exPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->eyPrev )) {
HXLINE(  44)					_this->eyOld = _this->eyPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dx )) {
HXLINE(  44)					_this->dxPrev = _this->dx;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dy )) {
HXLINE(  44)					_this->dyPrev = _this->dy;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->ex )) {
HXLINE(  44)					_this->exPrev = _this->ex;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->ey )) {
HXLINE(  44)					_this->eyPrev = _this->ey;
            				}
HXDLIN(  44)				_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  44)				_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  44)				_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  44)				_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            			}
HXDLIN(  44)			 ::Dynamic dxPrev_ = _this->dx;
HXDLIN(  44)			 ::Dynamic dyPrev_ = _this->dy;
HXDLIN(  44)			 ::Dynamic exPrev_ = _this->ex;
HXDLIN(  44)			 ::Dynamic eyPrev_ = _this->ey;
HXDLIN(  44)			_this->ax = ax_;
HXDLIN(  44)			_this->ay = ay_;
HXDLIN(  44)			_this->bx = x_;
HXDLIN(  44)			_this->by = y_;
HXDLIN(  44)			{
HXLINE(  44)				{
HXLINE(  44)					_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  44)					if ((_this->theta > 0)) {
HXLINE(  44)						if ((_this->halfA < 0)) {
HXLINE(  44)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            						else {
HXLINE(  44)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  44)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            					}
            					else {
HXLINE(  44)						if ((_this->halfA > 0)) {
HXLINE(  44)							_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  44)							_this->angle2 = (_this->theta + _this->halfA);
            						}
            						else {
HXLINE(  44)							_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  44)							_this->angle1 = (_this->theta - _this->halfA);
            						}
            					}
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dxPrev )) {
HXLINE(  44)					_this->dxOld = _this->dxPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dyPrev )) {
HXLINE(  44)					_this->dyOld = _this->dyPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->exPrev )) {
HXLINE(  44)					_this->exOld = _this->exPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->eyPrev )) {
HXLINE(  44)					_this->eyOld = _this->eyPrev;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dx )) {
HXLINE(  44)					_this->dxPrev = _this->dx;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->dy )) {
HXLINE(  44)					_this->dyPrev = _this->dy;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->ex )) {
HXLINE(  44)					_this->exPrev = _this->ex;
            				}
HXDLIN(  44)				if (::hx::IsNotNull( _this->ey )) {
HXLINE(  44)					_this->eyPrev = _this->ey;
            				}
HXDLIN(  44)				_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  44)				_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  44)				_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  44)				_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            			}
HXDLIN(  44)			{
HXLINE(  44)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  44)				int color = -1;
HXDLIN(  44)				if ((color == -1)) {
HXLINE(  44)					color = _this1->currentColor;
            				}
HXDLIN(  44)				{
HXLINE(  44)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(exPrev_) ),( (Float)(eyPrev_) ),0);
HXDLIN(  44)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE(  44)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  44)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  44)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  44)			{
HXLINE(  44)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  44)				int color1 = -1;
HXDLIN(  44)				if ((color1 == -1)) {
HXLINE(  44)					color1 = _this2->currentColor;
            				}
HXDLIN(  44)				{
HXLINE(  44)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  44)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXLINE(  44)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  44)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  44)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,baseLine,(void))

void Sketch_obj::crudeLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_47_crudeLine)
HXDLIN(  47)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  47)		Float ax_ = this->x;
HXDLIN(  47)		Float ay_ = this->y;
HXDLIN(  47)		Float width_ = this->width;
HXDLIN(  47)		_this->ax = x_;
HXDLIN(  47)		_this->ay = y_;
HXDLIN(  47)		_this->bx = ax_;
HXDLIN(  47)		_this->by = ay_;
HXDLIN(  47)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  47)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  47)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  47)		{
HXDLIN(  47)			{
HXDLIN(  47)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  47)				if ((_this->theta > 0)) {
HXDLIN(  47)					if ((_this->halfA < 0)) {
HXDLIN(  47)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  47)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  47)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  47)					if ((_this->halfA > 0)) {
HXDLIN(  47)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  47)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  47)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  47)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  47)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  47)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  47)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  47)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  47)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  47)				_this->exPrev = _this->ex;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  47)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  47)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  47)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  47)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  47)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  47)		 ::Dynamic dxPrev_ = _this->dx;
HXDLIN(  47)		 ::Dynamic dyPrev_ = _this->dy;
HXDLIN(  47)		 ::Dynamic exPrev_ = _this->ex;
HXDLIN(  47)		 ::Dynamic eyPrev_ = _this->ey;
HXDLIN(  47)		_this->ax = ax_;
HXDLIN(  47)		_this->ay = ay_;
HXDLIN(  47)		_this->bx = x_;
HXDLIN(  47)		_this->by = y_;
HXDLIN(  47)		{
HXDLIN(  47)			{
HXDLIN(  47)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  47)				if ((_this->theta > 0)) {
HXDLIN(  47)					if ((_this->halfA < 0)) {
HXDLIN(  47)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  47)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  47)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  47)					if ((_this->halfA > 0)) {
HXDLIN(  47)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  47)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  47)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  47)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  47)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  47)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  47)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  47)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  47)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  47)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  47)				_this->exPrev = _this->ex;
            			}
HXDLIN(  47)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  47)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  47)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  47)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  47)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  47)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  47)		{
HXDLIN(  47)			 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  47)			int color = -1;
HXDLIN(  47)			if ((color == -1)) {
HXDLIN(  47)				color = _this1->currentColor;
            			}
HXDLIN(  47)			{
HXDLIN(  47)				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(exPrev_) ),( (Float)(eyPrev_) ),0);
HXDLIN(  47)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  47)					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN(  47)				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN(  47)			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            		}
HXDLIN(  47)		{
HXDLIN(  47)			 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  47)			int color1 = -1;
HXDLIN(  47)			if ((color1 == -1)) {
HXDLIN(  47)				color1 = _this2->currentColor;
            			}
HXDLIN(  47)			{
HXDLIN(  47)				_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  47)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  47)					_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN(  47)				_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN(  47)			_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,crudeLine,(void))

void Sketch_obj::roundEndLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_50_roundEndLine)
HXDLIN(  50)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  50)		Float ax_ = this->x;
HXDLIN(  50)		Float ay_ = this->y;
HXDLIN(  50)		Float width_ = this->width;
HXDLIN(  50)		 ::Dynamic endLineCurve = 3;
HXDLIN(  50)		if (::hx::IsNull( endLineCurve )) {
HXDLIN(  50)			endLineCurve = 0;
            		}
HXDLIN(  50)		_this->ax = x_;
HXDLIN(  50)		_this->ay = y_;
HXDLIN(  50)		_this->bx = ax_;
HXDLIN(  50)		_this->by = ay_;
HXDLIN(  50)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  50)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  50)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  50)		{
HXDLIN(  50)			{
HXDLIN(  50)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  50)				if ((_this->theta > 0)) {
HXDLIN(  50)					if ((_this->halfA < 0)) {
HXDLIN(  50)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  50)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  50)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  50)					if ((_this->halfA > 0)) {
HXDLIN(  50)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  50)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  50)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  50)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  50)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  50)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  50)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  50)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  50)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  50)				_this->exPrev = _this->ex;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  50)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  50)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  50)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  50)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  50)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  50)		 ::Dynamic dxPrev_ = _this->dx;
HXDLIN(  50)		 ::Dynamic dyPrev_ = _this->dy;
HXDLIN(  50)		 ::Dynamic exPrev_ = _this->ex;
HXDLIN(  50)		 ::Dynamic eyPrev_ = _this->ey;
HXDLIN(  50)		_this->ax = ax_;
HXDLIN(  50)		_this->ay = ay_;
HXDLIN(  50)		_this->bx = x_;
HXDLIN(  50)		_this->by = y_;
HXDLIN(  50)		{
HXDLIN(  50)			{
HXDLIN(  50)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  50)				if ((_this->theta > 0)) {
HXDLIN(  50)					if ((_this->halfA < 0)) {
HXDLIN(  50)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  50)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  50)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  50)					if ((_this->halfA > 0)) {
HXDLIN(  50)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  50)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  50)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  50)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  50)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  50)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  50)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  50)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  50)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  50)				_this->exPrev = _this->ex;
            			}
HXDLIN(  50)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  50)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  50)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  50)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  50)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  50)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  50)		 ::Dynamic _hx_switch_0 = endLineCurve;
            		if (  (_hx_switch_0==0) ){
HXDLIN(  50)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==1) ){
HXDLIN(  50)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  50)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  50)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  50)			 ::Dynamic sides = 36;
HXDLIN(  50)			if (::hx::IsNull( sides )) {
HXDLIN(  50)				sides = 36;
            			}
HXDLIN(  50)			Float pi = ::Math_obj::PI;
HXDLIN(  50)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  50)			Float dif;
HXDLIN(  50)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if ((dif1 > 0)) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if ((dif1 < 0)) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if (smallest) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if (largest) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  50)			bool positive = (dif >= 0);
HXDLIN(  50)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  50)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  50)			Float angle = beta;
HXDLIN(  50)			Float cx;
HXDLIN(  50)			Float cy;
HXDLIN(  50)			Float bx = ( (Float)(0) );
HXDLIN(  50)			Float by = ( (Float)(0) );
HXDLIN(  50)			{
HXDLIN(  50)				int _g = 0;
HXDLIN(  50)				int _g1 = (totalSteps + 1);
HXDLIN(  50)				while((_g < _g1)){
HXDLIN(  50)					_g = (_g + 1);
HXDLIN(  50)					int i = (_g - 1);
HXDLIN(  50)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  50)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  50)					if ((i != 0)) {
HXDLIN(  50)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  50)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  50)						if (::hx::IsNotNull( m )) {
HXDLIN(  50)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  50)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  50)					angle = (angle + step1);
HXDLIN(  50)					bx = cx;
HXDLIN(  50)					by = cy;
            				}
            			}
HXDLIN(  50)			int len = totalSteps;
HXDLIN(  50)			{
HXDLIN(  50)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  50)				int color = 0;
HXDLIN(  50)				if ((color == -1)) {
HXDLIN(  50)					color = _this1->currentColor;
            				}
HXDLIN(  50)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  50)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==2) ){
HXDLIN(  50)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  50)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN(  50)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  50)			 ::Dynamic sides = 36;
HXDLIN(  50)			if (::hx::IsNull( sides )) {
HXDLIN(  50)				sides = 36;
            			}
HXDLIN(  50)			Float pi = ::Math_obj::PI;
HXDLIN(  50)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  50)			Float dif;
HXDLIN(  50)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if ((dif1 > 0)) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if ((dif1 < 0)) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if (smallest) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  50)					Float f;
HXDLIN(  50)					bool f1;
HXDLIN(  50)					if ((beta >= 0)) {
HXDLIN(  50)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f1 = false;
            					}
HXDLIN(  50)					if (f1) {
HXDLIN(  50)						f = beta;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f = a;
            						}
            						else {
HXDLIN(  50)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this1 = f;
HXDLIN(  50)					Float za = this1;
HXDLIN(  50)					Float f2;
HXDLIN(  50)					bool f3;
HXDLIN(  50)					if ((gamma >= 0)) {
HXDLIN(  50)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  50)						f3 = false;
            					}
HXDLIN(  50)					if (f3) {
HXDLIN(  50)						f2 = gamma;
            					}
            					else {
HXDLIN(  50)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)						if ((a >= 0)) {
HXDLIN(  50)							f2 = a;
            						}
            						else {
HXDLIN(  50)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  50)					Float this2 = f2;
HXDLIN(  50)					Float zb = this2;
HXDLIN(  50)					Float fa = za;
HXDLIN(  50)					Float fb = zb;
HXDLIN(  50)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  50)					bool clockwise = (fa < fb);
HXDLIN(  50)					Float dif1;
HXDLIN(  50)					if (clockwise) {
HXDLIN(  50)						dif1 = theta;
            					}
            					else {
HXDLIN(  50)						dif1 = -(theta);
            					}
HXDLIN(  50)					if (largest) {
HXDLIN(  50)						dif = dif1;
            					}
            					else {
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  50)			bool positive = (dif >= 0);
HXDLIN(  50)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  50)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  50)			Float angle = beta;
HXDLIN(  50)			Float cx;
HXDLIN(  50)			Float cy;
HXDLIN(  50)			Float bx = ( (Float)(0) );
HXDLIN(  50)			Float by = ( (Float)(0) );
HXDLIN(  50)			{
HXDLIN(  50)				int _g = 0;
HXDLIN(  50)				int _g1 = (totalSteps + 1);
HXDLIN(  50)				while((_g < _g1)){
HXDLIN(  50)					_g = (_g + 1);
HXDLIN(  50)					int i = (_g - 1);
HXDLIN(  50)					cx = (x_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  50)					cy = (y_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  50)					if ((i != 0)) {
HXDLIN(  50)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(x_,y_,0,bx,by,0,cx,cy,0);
HXDLIN(  50)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  50)						if (::hx::IsNotNull( m )) {
HXDLIN(  50)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  50)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  50)					angle = (angle + step1);
HXDLIN(  50)					bx = cx;
HXDLIN(  50)					by = cy;
            				}
            			}
HXDLIN(  50)			int len = totalSteps;
HXDLIN(  50)			{
HXDLIN(  50)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  50)				int color = 0;
HXDLIN(  50)				if ((color == -1)) {
HXDLIN(  50)					color = _this1->currentColor;
            				}
HXDLIN(  50)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  50)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==3) ){
HXDLIN(  50)			{
HXDLIN(  50)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  50)				Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)				Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  50)				 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  50)				 ::Dynamic sides = 36;
HXDLIN(  50)				if (::hx::IsNull( sides )) {
HXDLIN(  50)					sides = 36;
            				}
HXDLIN(  50)				Float pi = ::Math_obj::PI;
HXDLIN(  50)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  50)				Float dif;
HXDLIN(  50)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta >= 0)) {
HXDLIN(  50)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma >= 0)) {
HXDLIN(  50)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif1;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif1 = theta;
            						}
            						else {
HXDLIN(  50)							dif1 = -(theta);
            						}
HXDLIN(  50)						if ((dif1 > 0)) {
HXDLIN(  50)							dif = dif1;
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta >= 0)) {
HXDLIN(  50)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma >= 0)) {
HXDLIN(  50)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif1;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif1 = theta;
            						}
            						else {
HXDLIN(  50)							dif1 = -(theta);
            						}
HXDLIN(  50)						if ((dif1 < 0)) {
HXDLIN(  50)							dif = dif1;
            						}
            						else {
HXDLIN(  50)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta >= 0)) {
HXDLIN(  50)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma >= 0)) {
HXDLIN(  50)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif1;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif1 = theta;
            						}
            						else {
HXDLIN(  50)							dif1 = -(theta);
            						}
HXDLIN(  50)						if (smallest) {
HXDLIN(  50)							dif = dif1;
            						}
            						else {
HXDLIN(  50)							if (clockwise) {
HXDLIN(  50)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  50)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta >= 0)) {
HXDLIN(  50)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma >= 0)) {
HXDLIN(  50)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif1;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif1 = theta;
            						}
            						else {
HXDLIN(  50)							dif1 = -(theta);
            						}
HXDLIN(  50)						if (largest) {
HXDLIN(  50)							dif = dif1;
            						}
            						else {
HXDLIN(  50)							if (clockwise) {
HXDLIN(  50)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  50)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  50)				bool positive = (dif >= 0);
HXDLIN(  50)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  50)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  50)				Float angle = beta;
HXDLIN(  50)				Float cx;
HXDLIN(  50)				Float cy;
HXDLIN(  50)				Float bx = ( (Float)(0) );
HXDLIN(  50)				Float by = ( (Float)(0) );
HXDLIN(  50)				{
HXDLIN(  50)					int _g = 0;
HXDLIN(  50)					int _g1 = (totalSteps + 1);
HXDLIN(  50)					while((_g < _g1)){
HXDLIN(  50)						_g = (_g + 1);
HXDLIN(  50)						int i = (_g - 1);
HXDLIN(  50)						cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  50)						cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  50)						if ((i != 0)) {
HXDLIN(  50)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  50)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  50)							if (::hx::IsNotNull( m )) {
HXDLIN(  50)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  50)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  50)						angle = (angle + step1);
HXDLIN(  50)						bx = cx;
HXDLIN(  50)						by = cy;
            					}
            				}
HXDLIN(  50)				int len = totalSteps;
HXDLIN(  50)				{
HXDLIN(  50)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  50)					int color = 0;
HXDLIN(  50)					if ((color == -1)) {
HXDLIN(  50)						color = _this1->currentColor;
            					}
HXDLIN(  50)					_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            				}
            			}
HXDLIN(  50)			{
HXDLIN(  50)				Float radius1 = (width_ / ( (Float)(2) ));
HXDLIN(  50)				Float beta1 = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  50)				Float gamma1 = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN(  50)				 ::Dynamic drawType1 = _this->pen->drawType;
HXDLIN(  50)				 ::Dynamic sides1 = 36;
HXDLIN(  50)				if (::hx::IsNull( sides1 )) {
HXDLIN(  50)					sides1 = 36;
            				}
HXDLIN(  50)				Float pi1 = ::Math_obj::PI;
HXDLIN(  50)				Float step2 = ((pi1 * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN(  50)				Float dif1;
HXDLIN(  50)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta1 >= 0)) {
HXDLIN(  50)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma1 >= 0)) {
HXDLIN(  50)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = theta;
            						}
            						else {
HXDLIN(  50)							dif = -(theta);
            						}
HXDLIN(  50)						if ((dif > 0)) {
HXDLIN(  50)							dif1 = dif;
            						}
            						else {
HXDLIN(  50)							dif1 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)1: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta1 >= 0)) {
HXDLIN(  50)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma1 >= 0)) {
HXDLIN(  50)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = theta;
            						}
            						else {
HXDLIN(  50)							dif = -(theta);
            						}
HXDLIN(  50)						if ((dif < 0)) {
HXDLIN(  50)							dif1 = dif;
            						}
            						else {
HXDLIN(  50)							dif1 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)2: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta1 >= 0)) {
HXDLIN(  50)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma1 >= 0)) {
HXDLIN(  50)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = theta;
            						}
            						else {
HXDLIN(  50)							dif = -(theta);
            						}
HXDLIN(  50)						if (smallest) {
HXDLIN(  50)							dif1 = dif;
            						}
            						else {
HXDLIN(  50)							if (clockwise) {
HXDLIN(  50)								dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  50)								dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXDLIN(  50)						Float f;
HXDLIN(  50)						bool f1;
HXDLIN(  50)						if ((beta1 >= 0)) {
HXDLIN(  50)							f1 = (beta1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f1 = false;
            						}
HXDLIN(  50)						if (f1) {
HXDLIN(  50)							f = beta1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f = a;
            							}
            							else {
HXDLIN(  50)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this1 = f;
HXDLIN(  50)						Float za = this1;
HXDLIN(  50)						Float f2;
HXDLIN(  50)						bool f3;
HXDLIN(  50)						if ((gamma1 >= 0)) {
HXDLIN(  50)							f3 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXDLIN(  50)							f3 = false;
            						}
HXDLIN(  50)						if (f3) {
HXDLIN(  50)							f2 = gamma1;
            						}
            						else {
HXDLIN(  50)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  50)							if ((a >= 0)) {
HXDLIN(  50)								f2 = a;
            							}
            							else {
HXDLIN(  50)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  50)						Float this2 = f2;
HXDLIN(  50)						Float zb = this2;
HXDLIN(  50)						Float fa = za;
HXDLIN(  50)						Float fb = zb;
HXDLIN(  50)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  50)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  50)						bool clockwise = (fa < fb);
HXDLIN(  50)						Float dif;
HXDLIN(  50)						if (clockwise) {
HXDLIN(  50)							dif = theta;
            						}
            						else {
HXDLIN(  50)							dif = -(theta);
            						}
HXDLIN(  50)						if (largest) {
HXDLIN(  50)							dif1 = dif;
            						}
            						else {
HXDLIN(  50)							if (clockwise) {
HXDLIN(  50)								dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXDLIN(  50)								dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  50)				bool positive1 = (dif1 >= 0);
HXDLIN(  50)				int totalSteps1 = ::Math_obj::ceil((::Math_obj::abs(dif1) / step2));
HXDLIN(  50)				Float step3 = (dif1 / ( (Float)(totalSteps1) ));
HXDLIN(  50)				Float angle1 = beta1;
HXDLIN(  50)				Float cx1;
HXDLIN(  50)				Float cy1;
HXDLIN(  50)				Float bx1 = ( (Float)(0) );
HXDLIN(  50)				Float by1 = ( (Float)(0) );
HXDLIN(  50)				{
HXDLIN(  50)					int _g2 = 0;
HXDLIN(  50)					int _g3 = (totalSteps1 + 1);
HXDLIN(  50)					while((_g2 < _g3)){
HXDLIN(  50)						_g2 = (_g2 + 1);
HXDLIN(  50)						int i = (_g2 - 1);
HXDLIN(  50)						cx1 = (x_ + (radius1 * ::Math_obj::sin(angle1)));
HXDLIN(  50)						cy1 = (y_ + (radius1 * ::Math_obj::cos(angle1)));
HXDLIN(  50)						if ((i != 0)) {
HXDLIN(  50)							drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(x_,y_,0,bx1,by1,0,cx1,cy1,0);
HXDLIN(  50)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  50)							if (::hx::IsNotNull( m )) {
HXDLIN(  50)								drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  50)							drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  50)						angle1 = (angle1 + step3);
HXDLIN(  50)						bx1 = cx1;
HXDLIN(  50)						by1 = cy1;
            					}
            				}
HXDLIN(  50)				int len1 = totalSteps1;
HXDLIN(  50)				{
HXDLIN(  50)					 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  50)					int color1 = 0;
HXDLIN(  50)					if ((color1 == -1)) {
HXDLIN(  50)						color1 = _this2->currentColor;
            					}
HXDLIN(  50)					_this2->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
            				}
            			}
HXDLIN(  50)			goto _hx_goto_5;
            		}
            		_hx_goto_5:;
HXDLIN(  50)		{
HXDLIN(  50)			 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  50)			int color = -1;
HXDLIN(  50)			if ((color == -1)) {
HXDLIN(  50)				color = _this1->currentColor;
            			}
HXDLIN(  50)			{
HXDLIN(  50)				_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(exPrev_) ),( (Float)(eyPrev_) ),0);
HXDLIN(  50)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  50)					_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN(  50)				_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN(  50)			_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            		}
HXDLIN(  50)		{
HXDLIN(  50)			 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  50)			int color1 = -1;
HXDLIN(  50)			if ((color1 == -1)) {
HXDLIN(  50)				color1 = _this2->currentColor;
            			}
HXDLIN(  50)			{
HXDLIN(  50)				_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(dxPrev_) ),( (Float)(dyPrev_) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  50)				if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  50)					_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            				}
HXDLIN(  50)				_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN(  50)			_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,roundEndLine,(void))

void Sketch_obj::mediumLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_53_mediumLine)
HXDLIN(  53)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  53)		Float ax_ = this->x;
HXDLIN(  53)		Float ay_ = this->y;
HXDLIN(  53)		Float width_ = this->width;
HXDLIN(  53)		bool overlap = false;
HXDLIN(  53)		 ::Dynamic oldAngle;
HXDLIN(  53)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  53)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  53)			oldAngle = null();
            		}
HXDLIN(  53)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  53)		_this->ax = x_;
HXDLIN(  53)		_this->ay = y_;
HXDLIN(  53)		_this->bx = ax_;
HXDLIN(  53)		_this->by = ay_;
HXDLIN(  53)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  53)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  53)		{
HXDLIN(  53)			{
HXDLIN(  53)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  53)				if ((_this->theta > 0)) {
HXDLIN(  53)					if ((_this->halfA < 0)) {
HXDLIN(  53)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  53)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  53)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  53)					if ((_this->halfA > 0)) {
HXDLIN(  53)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  53)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  53)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  53)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  53)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  53)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  53)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  53)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  53)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  53)				_this->exPrev = _this->ex;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  53)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  53)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  53)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  53)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  53)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  53)		_this->ax = ax_;
HXDLIN(  53)		_this->ay = ay_;
HXDLIN(  53)		_this->bx = x_;
HXDLIN(  53)		_this->by = y_;
HXDLIN(  53)		{
HXDLIN(  53)			{
HXDLIN(  53)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  53)				if ((_this->theta > 0)) {
HXDLIN(  53)					if ((_this->halfA < 0)) {
HXDLIN(  53)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  53)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  53)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  53)					if ((_this->halfA > 0)) {
HXDLIN(  53)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  53)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  53)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  53)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  53)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  53)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  53)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  53)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  53)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  53)				_this->exPrev = _this->ex;
            			}
HXDLIN(  53)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  53)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  53)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  53)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  53)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  53)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  53)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  53)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  53)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  53)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  53)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  53)		Float theta0;
HXDLIN(  53)		Float theta1;
HXDLIN(  53)		if (clockWise) {
HXDLIN(  53)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  53)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  53)		Float dif;
HXDLIN(  53)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  53)				Float f;
HXDLIN(  53)				bool f1;
HXDLIN(  53)				if ((theta0 >= 0)) {
HXDLIN(  53)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f1 = false;
            				}
HXDLIN(  53)				if (f1) {
HXDLIN(  53)					f = theta0;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f = a;
            					}
            					else {
HXDLIN(  53)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this1 = f;
HXDLIN(  53)				Float za = this1;
HXDLIN(  53)				Float f2;
HXDLIN(  53)				bool f3;
HXDLIN(  53)				if ((theta1 >= 0)) {
HXDLIN(  53)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f3 = false;
            				}
HXDLIN(  53)				if (f3) {
HXDLIN(  53)					f2 = theta1;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f2 = a;
            					}
            					else {
HXDLIN(  53)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this2 = f2;
HXDLIN(  53)				Float zb = this2;
HXDLIN(  53)				Float fa = za;
HXDLIN(  53)				Float fb = zb;
HXDLIN(  53)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)				bool clockwise = (fa < fb);
HXDLIN(  53)				Float dif1;
HXDLIN(  53)				if (clockwise) {
HXDLIN(  53)					dif1 = theta;
            				}
            				else {
HXDLIN(  53)					dif1 = -(theta);
            				}
HXDLIN(  53)				if ((dif1 > 0)) {
HXDLIN(  53)					dif = dif1;
            				}
            				else {
HXDLIN(  53)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  53)				Float f;
HXDLIN(  53)				bool f1;
HXDLIN(  53)				if ((theta0 >= 0)) {
HXDLIN(  53)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f1 = false;
            				}
HXDLIN(  53)				if (f1) {
HXDLIN(  53)					f = theta0;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f = a;
            					}
            					else {
HXDLIN(  53)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this1 = f;
HXDLIN(  53)				Float za = this1;
HXDLIN(  53)				Float f2;
HXDLIN(  53)				bool f3;
HXDLIN(  53)				if ((theta1 >= 0)) {
HXDLIN(  53)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f3 = false;
            				}
HXDLIN(  53)				if (f3) {
HXDLIN(  53)					f2 = theta1;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f2 = a;
            					}
            					else {
HXDLIN(  53)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this2 = f2;
HXDLIN(  53)				Float zb = this2;
HXDLIN(  53)				Float fa = za;
HXDLIN(  53)				Float fb = zb;
HXDLIN(  53)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)				bool clockwise = (fa < fb);
HXDLIN(  53)				Float dif1;
HXDLIN(  53)				if (clockwise) {
HXDLIN(  53)					dif1 = theta;
            				}
            				else {
HXDLIN(  53)					dif1 = -(theta);
            				}
HXDLIN(  53)				if ((dif1 < 0)) {
HXDLIN(  53)					dif = dif1;
            				}
            				else {
HXDLIN(  53)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  53)				Float f;
HXDLIN(  53)				bool f1;
HXDLIN(  53)				if ((theta0 >= 0)) {
HXDLIN(  53)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f1 = false;
            				}
HXDLIN(  53)				if (f1) {
HXDLIN(  53)					f = theta0;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f = a;
            					}
            					else {
HXDLIN(  53)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this1 = f;
HXDLIN(  53)				Float za = this1;
HXDLIN(  53)				Float f2;
HXDLIN(  53)				bool f3;
HXDLIN(  53)				if ((theta1 >= 0)) {
HXDLIN(  53)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f3 = false;
            				}
HXDLIN(  53)				if (f3) {
HXDLIN(  53)					f2 = theta1;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f2 = a;
            					}
            					else {
HXDLIN(  53)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this2 = f2;
HXDLIN(  53)				Float zb = this2;
HXDLIN(  53)				Float fa = za;
HXDLIN(  53)				Float fb = zb;
HXDLIN(  53)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  53)				bool clockwise = (fa < fb);
HXDLIN(  53)				Float dif1;
HXDLIN(  53)				if (clockwise) {
HXDLIN(  53)					dif1 = theta;
            				}
            				else {
HXDLIN(  53)					dif1 = -(theta);
            				}
HXDLIN(  53)				if (smallest) {
HXDLIN(  53)					dif = dif1;
            				}
            				else {
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  53)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  53)				Float f;
HXDLIN(  53)				bool f1;
HXDLIN(  53)				if ((theta0 >= 0)) {
HXDLIN(  53)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f1 = false;
            				}
HXDLIN(  53)				if (f1) {
HXDLIN(  53)					f = theta0;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f = a;
            					}
            					else {
HXDLIN(  53)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this1 = f;
HXDLIN(  53)				Float za = this1;
HXDLIN(  53)				Float f2;
HXDLIN(  53)				bool f3;
HXDLIN(  53)				if ((theta1 >= 0)) {
HXDLIN(  53)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f3 = false;
            				}
HXDLIN(  53)				if (f3) {
HXDLIN(  53)					f2 = theta1;
            				}
            				else {
HXDLIN(  53)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)					if ((a >= 0)) {
HXDLIN(  53)						f2 = a;
            					}
            					else {
HXDLIN(  53)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  53)				Float this2 = f2;
HXDLIN(  53)				Float zb = this2;
HXDLIN(  53)				Float fa = za;
HXDLIN(  53)				Float fb = zb;
HXDLIN(  53)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  53)				bool clockwise = (fa < fb);
HXDLIN(  53)				Float dif1;
HXDLIN(  53)				if (clockwise) {
HXDLIN(  53)					dif1 = theta;
            				}
            				else {
HXDLIN(  53)					dif1 = -(theta);
            				}
HXDLIN(  53)				if (largest) {
HXDLIN(  53)					dif = dif1;
            				}
            				else {
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  53)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  53)		bool _hx_tmp;
HXDLIN(  53)		if (!(overlap)) {
HXDLIN(  53)			_hx_tmp = (_this->count != 0);
            		}
            		else {
HXDLIN(  53)			_hx_tmp = false;
            		}
HXDLIN(  53)		if (_hx_tmp) {
HXDLIN(  53)			Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
HXDLIN(  53)			Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
HXDLIN(  53)			Float f;
HXDLIN(  53)			bool f1;
HXDLIN(  53)			if ((theta0 <= ::Math_obj::PI)) {
HXDLIN(  53)				f1 = (theta0 > -(::Math_obj::PI));
            			}
            			else {
HXDLIN(  53)				f1 = false;
            			}
HXDLIN(  53)			if (f1) {
HXDLIN(  53)				f = theta0;
            			}
            			else {
HXDLIN(  53)				Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)				if ((a >= 0)) {
HXDLIN(  53)					f = (a - ::Math_obj::PI);
            				}
            				else {
HXDLIN(  53)					f = (a + ::Math_obj::PI);
            				}
            			}
HXDLIN(  53)			Float this1 = f;
HXDLIN(  53)			Float start = this1;
HXDLIN(  53)			Float start2 = start;
HXDLIN(  53)			Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  53)			_this->jx = (_this->ax + (h * ::Math_obj::sin(delta)));
HXDLIN(  53)			_this->jy = (_this->ay + (h * ::Math_obj::cos(delta)));
            		}
HXDLIN(  53)		bool _hx_tmp1;
HXDLIN(  53)		if ((_this->count == 0)) {
HXDLIN(  53)			if ((_this->endLine != 1)) {
HXDLIN(  53)				_hx_tmp1 = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  53)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXDLIN(  53)			_hx_tmp1 = false;
            		}
HXDLIN(  53)		if (_hx_tmp1) {
HXDLIN(  53)			Float ax = _this->ax;
HXDLIN(  53)			Float ay = _this->ay;
HXDLIN(  53)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  53)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  53)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  53)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  53)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  53)			 ::Dynamic sides = 36;
HXDLIN(  53)			if (::hx::IsNull( sides )) {
HXDLIN(  53)				sides = 36;
            			}
HXDLIN(  53)			Float pi = ::Math_obj::PI;
HXDLIN(  53)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  53)			Float dif;
HXDLIN(  53)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  53)					Float f;
HXDLIN(  53)					bool f1;
HXDLIN(  53)					if ((beta >= 0)) {
HXDLIN(  53)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f1 = false;
            					}
HXDLIN(  53)					if (f1) {
HXDLIN(  53)						f = beta;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f = a;
            						}
            						else {
HXDLIN(  53)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this1 = f;
HXDLIN(  53)					Float za = this1;
HXDLIN(  53)					Float f2;
HXDLIN(  53)					bool f3;
HXDLIN(  53)					if ((gamma >= 0)) {
HXDLIN(  53)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f3 = false;
            					}
HXDLIN(  53)					if (f3) {
HXDLIN(  53)						f2 = gamma;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f2 = a;
            						}
            						else {
HXDLIN(  53)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this2 = f2;
HXDLIN(  53)					Float zb = this2;
HXDLIN(  53)					Float fa = za;
HXDLIN(  53)					Float fb = zb;
HXDLIN(  53)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)					bool clockwise = (fa < fb);
HXDLIN(  53)					Float dif1;
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif1 = theta;
            					}
            					else {
HXDLIN(  53)						dif1 = -(theta);
            					}
HXDLIN(  53)					if ((dif1 > 0)) {
HXDLIN(  53)						dif = dif1;
            					}
            					else {
HXDLIN(  53)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  53)					Float f;
HXDLIN(  53)					bool f1;
HXDLIN(  53)					if ((beta >= 0)) {
HXDLIN(  53)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f1 = false;
            					}
HXDLIN(  53)					if (f1) {
HXDLIN(  53)						f = beta;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f = a;
            						}
            						else {
HXDLIN(  53)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this1 = f;
HXDLIN(  53)					Float za = this1;
HXDLIN(  53)					Float f2;
HXDLIN(  53)					bool f3;
HXDLIN(  53)					if ((gamma >= 0)) {
HXDLIN(  53)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f3 = false;
            					}
HXDLIN(  53)					if (f3) {
HXDLIN(  53)						f2 = gamma;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f2 = a;
            						}
            						else {
HXDLIN(  53)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this2 = f2;
HXDLIN(  53)					Float zb = this2;
HXDLIN(  53)					Float fa = za;
HXDLIN(  53)					Float fb = zb;
HXDLIN(  53)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)					bool clockwise = (fa < fb);
HXDLIN(  53)					Float dif1;
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif1 = theta;
            					}
            					else {
HXDLIN(  53)						dif1 = -(theta);
            					}
HXDLIN(  53)					if ((dif1 < 0)) {
HXDLIN(  53)						dif = dif1;
            					}
            					else {
HXDLIN(  53)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  53)					Float f;
HXDLIN(  53)					bool f1;
HXDLIN(  53)					if ((beta >= 0)) {
HXDLIN(  53)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f1 = false;
            					}
HXDLIN(  53)					if (f1) {
HXDLIN(  53)						f = beta;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f = a;
            						}
            						else {
HXDLIN(  53)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this1 = f;
HXDLIN(  53)					Float za = this1;
HXDLIN(  53)					Float f2;
HXDLIN(  53)					bool f3;
HXDLIN(  53)					if ((gamma >= 0)) {
HXDLIN(  53)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f3 = false;
            					}
HXDLIN(  53)					if (f3) {
HXDLIN(  53)						f2 = gamma;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f2 = a;
            						}
            						else {
HXDLIN(  53)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this2 = f2;
HXDLIN(  53)					Float zb = this2;
HXDLIN(  53)					Float fa = za;
HXDLIN(  53)					Float fb = zb;
HXDLIN(  53)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  53)					bool clockwise = (fa < fb);
HXDLIN(  53)					Float dif1;
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif1 = theta;
            					}
            					else {
HXDLIN(  53)						dif1 = -(theta);
            					}
HXDLIN(  53)					if (smallest) {
HXDLIN(  53)						dif = dif1;
            					}
            					else {
HXDLIN(  53)						if (clockwise) {
HXDLIN(  53)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  53)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  53)					Float f;
HXDLIN(  53)					bool f1;
HXDLIN(  53)					if ((beta >= 0)) {
HXDLIN(  53)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f1 = false;
            					}
HXDLIN(  53)					if (f1) {
HXDLIN(  53)						f = beta;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f = a;
            						}
            						else {
HXDLIN(  53)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this1 = f;
HXDLIN(  53)					Float za = this1;
HXDLIN(  53)					Float f2;
HXDLIN(  53)					bool f3;
HXDLIN(  53)					if ((gamma >= 0)) {
HXDLIN(  53)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  53)						f3 = false;
            					}
HXDLIN(  53)					if (f3) {
HXDLIN(  53)						f2 = gamma;
            					}
            					else {
HXDLIN(  53)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  53)						if ((a >= 0)) {
HXDLIN(  53)							f2 = a;
            						}
            						else {
HXDLIN(  53)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  53)					Float this2 = f2;
HXDLIN(  53)					Float zb = this2;
HXDLIN(  53)					Float fa = za;
HXDLIN(  53)					Float fb = zb;
HXDLIN(  53)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  53)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  53)					bool clockwise = (fa < fb);
HXDLIN(  53)					Float dif1;
HXDLIN(  53)					if (clockwise) {
HXDLIN(  53)						dif1 = theta;
            					}
            					else {
HXDLIN(  53)						dif1 = -(theta);
            					}
HXDLIN(  53)					if (largest) {
HXDLIN(  53)						dif = dif1;
            					}
            					else {
HXDLIN(  53)						if (clockwise) {
HXDLIN(  53)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  53)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  53)			bool positive = (dif >= 0);
HXDLIN(  53)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  53)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  53)			Float angle = beta;
HXDLIN(  53)			Float cx;
HXDLIN(  53)			Float cy;
HXDLIN(  53)			Float bx = ( (Float)(0) );
HXDLIN(  53)			Float by = ( (Float)(0) );
HXDLIN(  53)			int p2 = temp->length;
HXDLIN(  53)			{
HXDLIN(  53)				int _g = 0;
HXDLIN(  53)				int _g1 = (totalSteps + 1);
HXDLIN(  53)				while((_g < _g1)){
HXDLIN(  53)					_g = (_g + 1);
HXDLIN(  53)					int i = (_g - 1);
HXDLIN(  53)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  53)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  53)					p2 = (p2 + 1);
HXDLIN(  53)					temp[(p2 - 1)] = cx;
HXDLIN(  53)					p2 = (p2 + 1);
HXDLIN(  53)					temp[(p2 - 1)] = cy;
HXDLIN(  53)					if ((i != 0)) {
HXDLIN(  53)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  53)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  53)						if (::hx::IsNotNull( m )) {
HXDLIN(  53)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  53)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  53)					angle = (angle + step1);
HXDLIN(  53)					bx = cx;
HXDLIN(  53)					by = cy;
            				}
            			}
HXDLIN(  53)			int len = totalSteps;
HXDLIN(  53)			{
HXDLIN(  53)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)				int color = -1;
HXDLIN(  53)				if ((color == -1)) {
HXDLIN(  53)					color = _this1->currentColor;
            				}
HXDLIN(  53)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  53)			int pA = _this->pointsAnti->length;
HXDLIN(  53)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  53)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  53)			{
HXDLIN(  53)				int _g2 = 0;
HXDLIN(  53)				int _g3 = p4;
HXDLIN(  53)				while((_g2 < _g3)){
HXDLIN(  53)					_g2 = (_g2 + 1);
HXDLIN(  53)					int i = (_g2 - 1);
HXDLIN(  53)					pA = (pA + 1);
HXDLIN(  53)					_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXDLIN(  53)					pA = (pA + 1);
HXDLIN(  53)					_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            				}
            			}
HXDLIN(  53)			int pC = _this->pointsClock->length;
HXDLIN(  53)			{
HXDLIN(  53)				int _g4 = 0;
HXDLIN(  53)				int _g5 = p4;
HXDLIN(  53)				while((_g4 < _g5)){
HXDLIN(  53)					_g4 = (_g4 + 1);
HXDLIN(  53)					int i = (_g4 - 1);
HXDLIN(  53)					pC = (pC + 1);
HXDLIN(  53)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXDLIN(  53)					pC = (pC + 1);
HXDLIN(  53)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            				}
            			}
            		}
HXDLIN(  53)		if (overlap) {
HXDLIN(  53)			{
HXDLIN(  53)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)				int color = -1;
HXDLIN(  53)				if ((color == -1)) {
HXDLIN(  53)					color = _this1->currentColor;
            				}
HXDLIN(  53)				{
HXDLIN(  53)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  53)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  53)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  53)			{
HXDLIN(  53)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  53)				int color1 = -1;
HXDLIN(  53)				if ((color1 == -1)) {
HXDLIN(  53)					color1 = _this2->currentColor;
            				}
HXDLIN(  53)				{
HXDLIN(  53)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  53)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  53)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  53)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
            		else {
HXDLIN(  53)			if ((_this->count != 0)) {
HXDLIN(  53)				_this->addQuads(clockWise,width_);
            			}
HXDLIN(  53)			{
HXDLIN(  53)				_this->quadIndex = ( (Float)(_this->pen->drawType->__Field(HX_("get_pos",2b,26,ca,26),::hx::paccDynamic)()) );
HXDLIN(  53)				if ((_this->count == 0)) {
HXDLIN(  53)					_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  53)					_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  53)					_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  53)					_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  53)					_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  53)					_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  53)					_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  53)					_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  53)					{
HXDLIN(  53)						 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)						int color = -1;
HXDLIN(  53)						if ((color == -1)) {
HXDLIN(  53)							color = _this1->currentColor;
            						}
HXDLIN(  53)						{
HXDLIN(  53)							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN(  53)							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  53)						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            					}
HXDLIN(  53)					{
HXDLIN(  53)						 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  53)						int color1 = -1;
HXDLIN(  53)						if ((color1 == -1)) {
HXDLIN(  53)							color1 = _this2->currentColor;
            						}
HXDLIN(  53)						{
HXDLIN(  53)							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  53)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN(  53)							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  53)						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            					}
            				}
            				else {
HXDLIN(  53)					bool _hx_tmp;
HXDLIN(  53)					if (clockWise) {
HXDLIN(  53)						_hx_tmp = !(_this->lastClock);
            					}
            					else {
HXDLIN(  53)						_hx_tmp = false;
            					}
HXDLIN(  53)					if (_hx_tmp) {
HXDLIN(  53)						_this->penultimateAX = _this->jx;
HXDLIN(  53)						_this->penultimateAY = _this->jy;
HXDLIN(  53)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  53)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  53)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  53)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  53)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  53)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)							int color = -1;
HXDLIN(  53)							if ((color == -1)) {
HXDLIN(  53)								color = _this1->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  53)							int color1 = -1;
HXDLIN(  53)							if ((color1 == -1)) {
HXDLIN(  53)								color1 = _this2->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  53)					bool _hx_tmp1;
HXDLIN(  53)					if (clockWise) {
HXDLIN(  53)						_hx_tmp1 = _this->lastClock;
            					}
            					else {
HXDLIN(  53)						_hx_tmp1 = false;
            					}
HXDLIN(  53)					if (_hx_tmp1) {
HXDLIN(  53)						_this->penultimateAX = _this->jx;
HXDLIN(  53)						_this->penultimateAY = _this->jy;
HXDLIN(  53)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  53)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  53)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  53)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  53)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  53)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)							int color = -1;
HXDLIN(  53)							if ((color == -1)) {
HXDLIN(  53)								color = _this1->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  53)							int color1 = -1;
HXDLIN(  53)							if ((color1 == -1)) {
HXDLIN(  53)								color1 = _this2->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  53)					bool _hx_tmp2;
HXDLIN(  53)					if (!(clockWise)) {
HXDLIN(  53)						_hx_tmp2 = !(_this->lastClock);
            					}
            					else {
HXDLIN(  53)						_hx_tmp2 = false;
            					}
HXDLIN(  53)					if (_hx_tmp2) {
HXDLIN(  53)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  53)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  53)						_this->lastClockX = _this->jx;
HXDLIN(  53)						_this->lastClockY = _this->jy;
HXDLIN(  53)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  53)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  53)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  53)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)							int color = -1;
HXDLIN(  53)							if ((color == -1)) {
HXDLIN(  53)								color = _this1->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,_this->jx,_this->jy,0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  53)							int color1 = -1;
HXDLIN(  53)							if ((color1 == -1)) {
HXDLIN(  53)								color1 = _this2->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  53)					bool _hx_tmp3;
HXDLIN(  53)					if (!(clockWise)) {
HXDLIN(  53)						_hx_tmp3 = _this->lastClock;
            					}
            					else {
HXDLIN(  53)						_hx_tmp3 = false;
            					}
HXDLIN(  53)					if (_hx_tmp3) {
HXDLIN(  53)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  53)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  53)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  53)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  53)						_this->penultimateCX = _this->jx;
HXDLIN(  53)						_this->penultimateCY = _this->jy;
HXDLIN(  53)						_this->lastClockX = ( (Float)(_this->dx) );
HXDLIN(  53)						_this->lastClockY = ( (Float)(_this->dy) );
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)							int color = -1;
HXDLIN(  53)							if ((color == -1)) {
HXDLIN(  53)								color = _this1->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  53)						{
HXDLIN(  53)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  53)							int color1 = -1;
HXDLIN(  53)							if ((color1 == -1)) {
HXDLIN(  53)								color1 = _this2->currentColor;
            							}
HXDLIN(  53)							{
HXDLIN(  53)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  53)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  53)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  53)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
            				}
            			}
            		}
HXDLIN(  53)		if ((_this->count != 0)) {
HXDLIN(  53)			if (overlap) {
HXDLIN(  53)				if (clockWise) {
HXDLIN(  53)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)					int color = -1;
HXDLIN(  53)					if ((color == -1)) {
HXDLIN(  53)						color = _this1->currentColor;
            					}
HXDLIN(  53)					{
HXDLIN(  53)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->ax,_this->ay,0);
HXDLIN(  53)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  53)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  53)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            				else {
HXDLIN(  53)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)					int color = -1;
HXDLIN(  53)					if ((color == -1)) {
HXDLIN(  53)						color = _this1->currentColor;
            					}
HXDLIN(  53)					{
HXDLIN(  53)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->ax,_this->ay,0);
HXDLIN(  53)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  53)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  53)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            			}
            			else {
HXDLIN(  53)				if (clockWise) {
HXDLIN(  53)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)					int color = -1;
HXDLIN(  53)					if ((color == -1)) {
HXDLIN(  53)						color = _this1->currentColor;
            					}
HXDLIN(  53)					{
HXDLIN(  53)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->jx,_this->jy,0);
HXDLIN(  53)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  53)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  53)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            				else {
HXDLIN(  53)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  53)					int color = -1;
HXDLIN(  53)					if ((color == -1)) {
HXDLIN(  53)						color = _this1->currentColor;
            					}
HXDLIN(  53)					{
HXDLIN(  53)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0);
HXDLIN(  53)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  53)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  53)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  53)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
            			}
            		}
HXDLIN(  53)		{
HXDLIN(  53)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  53)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  53)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  53)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  53)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  53)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  53)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  53)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  53)		_this->jxOld = _this->jx;
HXDLIN(  53)		_this->jyOld = _this->jy;
HXDLIN(  53)		_this->lastClock = clockWise;
HXDLIN(  53)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,mediumLine,(void))

void Sketch_obj::mediumOverlapLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_56_mediumOverlapLine)
HXDLIN(  56)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  56)		Float ax_ = this->x;
HXDLIN(  56)		Float ay_ = this->y;
HXDLIN(  56)		Float width_ = this->width;
HXDLIN(  56)		 ::Dynamic oldAngle;
HXDLIN(  56)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  56)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  56)			oldAngle = null();
            		}
HXDLIN(  56)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  56)		_this->ax = x_;
HXDLIN(  56)		_this->ay = y_;
HXDLIN(  56)		_this->bx = ax_;
HXDLIN(  56)		_this->by = ay_;
HXDLIN(  56)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  56)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  56)		{
HXDLIN(  56)			{
HXDLIN(  56)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  56)				if ((_this->theta > 0)) {
HXDLIN(  56)					if ((_this->halfA < 0)) {
HXDLIN(  56)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  56)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  56)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  56)					if ((_this->halfA > 0)) {
HXDLIN(  56)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  56)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  56)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  56)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  56)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  56)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  56)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  56)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  56)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  56)				_this->exPrev = _this->ex;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  56)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  56)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  56)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  56)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  56)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  56)		_this->ax = ax_;
HXDLIN(  56)		_this->ay = ay_;
HXDLIN(  56)		_this->bx = x_;
HXDLIN(  56)		_this->by = y_;
HXDLIN(  56)		{
HXDLIN(  56)			{
HXDLIN(  56)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  56)				if ((_this->theta > 0)) {
HXDLIN(  56)					if ((_this->halfA < 0)) {
HXDLIN(  56)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  56)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  56)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  56)					if ((_this->halfA > 0)) {
HXDLIN(  56)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  56)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  56)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  56)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  56)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  56)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  56)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  56)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  56)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  56)				_this->exPrev = _this->ex;
            			}
HXDLIN(  56)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  56)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  56)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  56)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  56)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  56)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  56)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  56)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  56)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  56)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  56)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  56)		Float theta0;
HXDLIN(  56)		Float theta1;
HXDLIN(  56)		if (clockWise) {
HXDLIN(  56)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  56)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  56)		Float dif;
HXDLIN(  56)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  56)				Float f;
HXDLIN(  56)				bool f1;
HXDLIN(  56)				if ((theta0 >= 0)) {
HXDLIN(  56)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f1 = false;
            				}
HXDLIN(  56)				if (f1) {
HXDLIN(  56)					f = theta0;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f = a;
            					}
            					else {
HXDLIN(  56)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this1 = f;
HXDLIN(  56)				Float za = this1;
HXDLIN(  56)				Float f2;
HXDLIN(  56)				bool f3;
HXDLIN(  56)				if ((theta1 >= 0)) {
HXDLIN(  56)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f3 = false;
            				}
HXDLIN(  56)				if (f3) {
HXDLIN(  56)					f2 = theta1;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f2 = a;
            					}
            					else {
HXDLIN(  56)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this2 = f2;
HXDLIN(  56)				Float zb = this2;
HXDLIN(  56)				Float fa = za;
HXDLIN(  56)				Float fb = zb;
HXDLIN(  56)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)				bool clockwise = (fa < fb);
HXDLIN(  56)				Float dif1;
HXDLIN(  56)				if (clockwise) {
HXDLIN(  56)					dif1 = theta;
            				}
            				else {
HXDLIN(  56)					dif1 = -(theta);
            				}
HXDLIN(  56)				if ((dif1 > 0)) {
HXDLIN(  56)					dif = dif1;
            				}
            				else {
HXDLIN(  56)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  56)				Float f;
HXDLIN(  56)				bool f1;
HXDLIN(  56)				if ((theta0 >= 0)) {
HXDLIN(  56)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f1 = false;
            				}
HXDLIN(  56)				if (f1) {
HXDLIN(  56)					f = theta0;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f = a;
            					}
            					else {
HXDLIN(  56)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this1 = f;
HXDLIN(  56)				Float za = this1;
HXDLIN(  56)				Float f2;
HXDLIN(  56)				bool f3;
HXDLIN(  56)				if ((theta1 >= 0)) {
HXDLIN(  56)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f3 = false;
            				}
HXDLIN(  56)				if (f3) {
HXDLIN(  56)					f2 = theta1;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f2 = a;
            					}
            					else {
HXDLIN(  56)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this2 = f2;
HXDLIN(  56)				Float zb = this2;
HXDLIN(  56)				Float fa = za;
HXDLIN(  56)				Float fb = zb;
HXDLIN(  56)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)				bool clockwise = (fa < fb);
HXDLIN(  56)				Float dif1;
HXDLIN(  56)				if (clockwise) {
HXDLIN(  56)					dif1 = theta;
            				}
            				else {
HXDLIN(  56)					dif1 = -(theta);
            				}
HXDLIN(  56)				if ((dif1 < 0)) {
HXDLIN(  56)					dif = dif1;
            				}
            				else {
HXDLIN(  56)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  56)				Float f;
HXDLIN(  56)				bool f1;
HXDLIN(  56)				if ((theta0 >= 0)) {
HXDLIN(  56)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f1 = false;
            				}
HXDLIN(  56)				if (f1) {
HXDLIN(  56)					f = theta0;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f = a;
            					}
            					else {
HXDLIN(  56)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this1 = f;
HXDLIN(  56)				Float za = this1;
HXDLIN(  56)				Float f2;
HXDLIN(  56)				bool f3;
HXDLIN(  56)				if ((theta1 >= 0)) {
HXDLIN(  56)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f3 = false;
            				}
HXDLIN(  56)				if (f3) {
HXDLIN(  56)					f2 = theta1;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f2 = a;
            					}
            					else {
HXDLIN(  56)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this2 = f2;
HXDLIN(  56)				Float zb = this2;
HXDLIN(  56)				Float fa = za;
HXDLIN(  56)				Float fb = zb;
HXDLIN(  56)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  56)				bool clockwise = (fa < fb);
HXDLIN(  56)				Float dif1;
HXDLIN(  56)				if (clockwise) {
HXDLIN(  56)					dif1 = theta;
            				}
            				else {
HXDLIN(  56)					dif1 = -(theta);
            				}
HXDLIN(  56)				if (smallest) {
HXDLIN(  56)					dif = dif1;
            				}
            				else {
HXDLIN(  56)					if (clockwise) {
HXDLIN(  56)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  56)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  56)				Float f;
HXDLIN(  56)				bool f1;
HXDLIN(  56)				if ((theta0 >= 0)) {
HXDLIN(  56)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f1 = false;
            				}
HXDLIN(  56)				if (f1) {
HXDLIN(  56)					f = theta0;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f = a;
            					}
            					else {
HXDLIN(  56)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this1 = f;
HXDLIN(  56)				Float za = this1;
HXDLIN(  56)				Float f2;
HXDLIN(  56)				bool f3;
HXDLIN(  56)				if ((theta1 >= 0)) {
HXDLIN(  56)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  56)					f3 = false;
            				}
HXDLIN(  56)				if (f3) {
HXDLIN(  56)					f2 = theta1;
            				}
            				else {
HXDLIN(  56)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)					if ((a >= 0)) {
HXDLIN(  56)						f2 = a;
            					}
            					else {
HXDLIN(  56)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  56)				Float this2 = f2;
HXDLIN(  56)				Float zb = this2;
HXDLIN(  56)				Float fa = za;
HXDLIN(  56)				Float fb = zb;
HXDLIN(  56)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  56)				bool clockwise = (fa < fb);
HXDLIN(  56)				Float dif1;
HXDLIN(  56)				if (clockwise) {
HXDLIN(  56)					dif1 = theta;
            				}
            				else {
HXDLIN(  56)					dif1 = -(theta);
            				}
HXDLIN(  56)				if (largest) {
HXDLIN(  56)					dif = dif1;
            				}
            				else {
HXDLIN(  56)					if (clockwise) {
HXDLIN(  56)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  56)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  56)		bool _hx_tmp;
HXDLIN(  56)		if ((_this->count == 0)) {
HXDLIN(  56)			if ((_this->endLine != 1)) {
HXDLIN(  56)				_hx_tmp = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  56)				_hx_tmp = true;
            			}
            		}
            		else {
HXDLIN(  56)			_hx_tmp = false;
            		}
HXDLIN(  56)		if (_hx_tmp) {
HXDLIN(  56)			Float ax = _this->ax;
HXDLIN(  56)			Float ay = _this->ay;
HXDLIN(  56)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  56)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  56)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  56)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  56)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  56)			 ::Dynamic sides = 36;
HXDLIN(  56)			if (::hx::IsNull( sides )) {
HXDLIN(  56)				sides = 36;
            			}
HXDLIN(  56)			Float pi = ::Math_obj::PI;
HXDLIN(  56)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  56)			Float dif;
HXDLIN(  56)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  56)					Float f;
HXDLIN(  56)					bool f1;
HXDLIN(  56)					if ((beta >= 0)) {
HXDLIN(  56)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f1 = false;
            					}
HXDLIN(  56)					if (f1) {
HXDLIN(  56)						f = beta;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f = a;
            						}
            						else {
HXDLIN(  56)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this1 = f;
HXDLIN(  56)					Float za = this1;
HXDLIN(  56)					Float f2;
HXDLIN(  56)					bool f3;
HXDLIN(  56)					if ((gamma >= 0)) {
HXDLIN(  56)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f3 = false;
            					}
HXDLIN(  56)					if (f3) {
HXDLIN(  56)						f2 = gamma;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f2 = a;
            						}
            						else {
HXDLIN(  56)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this2 = f2;
HXDLIN(  56)					Float zb = this2;
HXDLIN(  56)					Float fa = za;
HXDLIN(  56)					Float fb = zb;
HXDLIN(  56)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)					bool clockwise = (fa < fb);
HXDLIN(  56)					Float dif1;
HXDLIN(  56)					if (clockwise) {
HXDLIN(  56)						dif1 = theta;
            					}
            					else {
HXDLIN(  56)						dif1 = -(theta);
            					}
HXDLIN(  56)					if ((dif1 > 0)) {
HXDLIN(  56)						dif = dif1;
            					}
            					else {
HXDLIN(  56)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  56)					Float f;
HXDLIN(  56)					bool f1;
HXDLIN(  56)					if ((beta >= 0)) {
HXDLIN(  56)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f1 = false;
            					}
HXDLIN(  56)					if (f1) {
HXDLIN(  56)						f = beta;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f = a;
            						}
            						else {
HXDLIN(  56)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this1 = f;
HXDLIN(  56)					Float za = this1;
HXDLIN(  56)					Float f2;
HXDLIN(  56)					bool f3;
HXDLIN(  56)					if ((gamma >= 0)) {
HXDLIN(  56)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f3 = false;
            					}
HXDLIN(  56)					if (f3) {
HXDLIN(  56)						f2 = gamma;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f2 = a;
            						}
            						else {
HXDLIN(  56)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this2 = f2;
HXDLIN(  56)					Float zb = this2;
HXDLIN(  56)					Float fa = za;
HXDLIN(  56)					Float fb = zb;
HXDLIN(  56)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)					bool clockwise = (fa < fb);
HXDLIN(  56)					Float dif1;
HXDLIN(  56)					if (clockwise) {
HXDLIN(  56)						dif1 = theta;
            					}
            					else {
HXDLIN(  56)						dif1 = -(theta);
            					}
HXDLIN(  56)					if ((dif1 < 0)) {
HXDLIN(  56)						dif = dif1;
            					}
            					else {
HXDLIN(  56)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  56)					Float f;
HXDLIN(  56)					bool f1;
HXDLIN(  56)					if ((beta >= 0)) {
HXDLIN(  56)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f1 = false;
            					}
HXDLIN(  56)					if (f1) {
HXDLIN(  56)						f = beta;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f = a;
            						}
            						else {
HXDLIN(  56)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this1 = f;
HXDLIN(  56)					Float za = this1;
HXDLIN(  56)					Float f2;
HXDLIN(  56)					bool f3;
HXDLIN(  56)					if ((gamma >= 0)) {
HXDLIN(  56)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f3 = false;
            					}
HXDLIN(  56)					if (f3) {
HXDLIN(  56)						f2 = gamma;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f2 = a;
            						}
            						else {
HXDLIN(  56)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this2 = f2;
HXDLIN(  56)					Float zb = this2;
HXDLIN(  56)					Float fa = za;
HXDLIN(  56)					Float fb = zb;
HXDLIN(  56)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  56)					bool clockwise = (fa < fb);
HXDLIN(  56)					Float dif1;
HXDLIN(  56)					if (clockwise) {
HXDLIN(  56)						dif1 = theta;
            					}
            					else {
HXDLIN(  56)						dif1 = -(theta);
            					}
HXDLIN(  56)					if (smallest) {
HXDLIN(  56)						dif = dif1;
            					}
            					else {
HXDLIN(  56)						if (clockwise) {
HXDLIN(  56)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  56)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  56)					Float f;
HXDLIN(  56)					bool f1;
HXDLIN(  56)					if ((beta >= 0)) {
HXDLIN(  56)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f1 = false;
            					}
HXDLIN(  56)					if (f1) {
HXDLIN(  56)						f = beta;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f = a;
            						}
            						else {
HXDLIN(  56)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this1 = f;
HXDLIN(  56)					Float za = this1;
HXDLIN(  56)					Float f2;
HXDLIN(  56)					bool f3;
HXDLIN(  56)					if ((gamma >= 0)) {
HXDLIN(  56)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  56)						f3 = false;
            					}
HXDLIN(  56)					if (f3) {
HXDLIN(  56)						f2 = gamma;
            					}
            					else {
HXDLIN(  56)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  56)						if ((a >= 0)) {
HXDLIN(  56)							f2 = a;
            						}
            						else {
HXDLIN(  56)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  56)					Float this2 = f2;
HXDLIN(  56)					Float zb = this2;
HXDLIN(  56)					Float fa = za;
HXDLIN(  56)					Float fb = zb;
HXDLIN(  56)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  56)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  56)					bool clockwise = (fa < fb);
HXDLIN(  56)					Float dif1;
HXDLIN(  56)					if (clockwise) {
HXDLIN(  56)						dif1 = theta;
            					}
            					else {
HXDLIN(  56)						dif1 = -(theta);
            					}
HXDLIN(  56)					if (largest) {
HXDLIN(  56)						dif = dif1;
            					}
            					else {
HXDLIN(  56)						if (clockwise) {
HXDLIN(  56)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  56)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  56)			bool positive = (dif >= 0);
HXDLIN(  56)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  56)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  56)			Float angle = beta;
HXDLIN(  56)			Float cx;
HXDLIN(  56)			Float cy;
HXDLIN(  56)			Float bx = ( (Float)(0) );
HXDLIN(  56)			Float by = ( (Float)(0) );
HXDLIN(  56)			int p2 = temp->length;
HXDLIN(  56)			{
HXDLIN(  56)				int _g = 0;
HXDLIN(  56)				int _g1 = (totalSteps + 1);
HXDLIN(  56)				while((_g < _g1)){
HXDLIN(  56)					_g = (_g + 1);
HXDLIN(  56)					int i = (_g - 1);
HXDLIN(  56)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  56)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  56)					p2 = (p2 + 1);
HXDLIN(  56)					temp[(p2 - 1)] = cx;
HXDLIN(  56)					p2 = (p2 + 1);
HXDLIN(  56)					temp[(p2 - 1)] = cy;
HXDLIN(  56)					if ((i != 0)) {
HXDLIN(  56)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  56)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  56)						if (::hx::IsNotNull( m )) {
HXDLIN(  56)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  56)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  56)					angle = (angle + step1);
HXDLIN(  56)					bx = cx;
HXDLIN(  56)					by = cy;
            				}
            			}
HXDLIN(  56)			int len = totalSteps;
HXDLIN(  56)			{
HXDLIN(  56)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  56)				int color = -1;
HXDLIN(  56)				if ((color == -1)) {
HXDLIN(  56)					color = _this1->currentColor;
            				}
HXDLIN(  56)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  56)			int pA = _this->pointsAnti->length;
HXDLIN(  56)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  56)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  56)			{
HXDLIN(  56)				int _g2 = 0;
HXDLIN(  56)				int _g3 = p4;
HXDLIN(  56)				while((_g2 < _g3)){
HXDLIN(  56)					_g2 = (_g2 + 1);
HXDLIN(  56)					int i = (_g2 - 1);
HXDLIN(  56)					pA = (pA + 1);
HXDLIN(  56)					_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXDLIN(  56)					pA = (pA + 1);
HXDLIN(  56)					_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            				}
            			}
HXDLIN(  56)			int pC = _this->pointsClock->length;
HXDLIN(  56)			{
HXDLIN(  56)				int _g4 = 0;
HXDLIN(  56)				int _g5 = p4;
HXDLIN(  56)				while((_g4 < _g5)){
HXDLIN(  56)					_g4 = (_g4 + 1);
HXDLIN(  56)					int i = (_g4 - 1);
HXDLIN(  56)					pC = (pC + 1);
HXDLIN(  56)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXDLIN(  56)					pC = (pC + 1);
HXDLIN(  56)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            				}
            			}
            		}
HXDLIN(  56)		{
HXDLIN(  56)			{
HXDLIN(  56)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  56)				int color = -1;
HXDLIN(  56)				if ((color == -1)) {
HXDLIN(  56)					color = _this1->currentColor;
            				}
HXDLIN(  56)				{
HXDLIN(  56)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  56)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  56)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  56)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  56)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  56)			{
HXDLIN(  56)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  56)				int color1 = -1;
HXDLIN(  56)				if ((color1 == -1)) {
HXDLIN(  56)					color1 = _this2->currentColor;
            				}
HXDLIN(  56)				{
HXDLIN(  56)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  56)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  56)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  56)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  56)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
HXDLIN(  56)		if ((_this->count != 0)) {
HXDLIN(  56)			if (clockWise) {
HXDLIN(  56)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  56)				int color = -1;
HXDLIN(  56)				if ((color == -1)) {
HXDLIN(  56)					color = _this1->currentColor;
            				}
HXDLIN(  56)				{
HXDLIN(  56)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->ax,_this->ay,0);
HXDLIN(  56)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  56)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  56)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  56)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
            			else {
HXDLIN(  56)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  56)				int color = -1;
HXDLIN(  56)				if ((color == -1)) {
HXDLIN(  56)					color = _this1->currentColor;
            				}
HXDLIN(  56)				{
HXDLIN(  56)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->ax,_this->ay,0);
HXDLIN(  56)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  56)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  56)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  56)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
            		}
HXDLIN(  56)		{
HXDLIN(  56)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  56)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  56)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  56)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  56)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  56)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  56)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  56)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  56)		_this->jxOld = _this->jx;
HXDLIN(  56)		_this->jyOld = _this->jy;
HXDLIN(  56)		_this->lastClock = clockWise;
HXDLIN(  56)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,mediumOverlapLine,(void))

void Sketch_obj::fineLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_59_fineLine)
HXDLIN(  59)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  59)		Float ax_ = this->x;
HXDLIN(  59)		Float ay_ = this->y;
HXDLIN(  59)		Float width_ = this->width;
HXDLIN(  59)		bool overlap = false;
HXDLIN(  59)		 ::Dynamic oldAngle;
HXDLIN(  59)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  59)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  59)			oldAngle = null();
            		}
HXDLIN(  59)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  59)		_this->ax = x_;
HXDLIN(  59)		_this->ay = y_;
HXDLIN(  59)		_this->bx = ax_;
HXDLIN(  59)		_this->by = ay_;
HXDLIN(  59)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  59)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  59)		{
HXDLIN(  59)			{
HXDLIN(  59)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  59)				if ((_this->theta > 0)) {
HXDLIN(  59)					if ((_this->halfA < 0)) {
HXDLIN(  59)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  59)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  59)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  59)					if ((_this->halfA > 0)) {
HXDLIN(  59)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  59)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  59)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  59)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  59)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  59)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  59)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  59)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  59)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  59)				_this->exPrev = _this->ex;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  59)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  59)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  59)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  59)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  59)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  59)		_this->ax = ax_;
HXDLIN(  59)		_this->ay = ay_;
HXDLIN(  59)		_this->bx = x_;
HXDLIN(  59)		_this->by = y_;
HXDLIN(  59)		{
HXDLIN(  59)			{
HXDLIN(  59)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  59)				if ((_this->theta > 0)) {
HXDLIN(  59)					if ((_this->halfA < 0)) {
HXDLIN(  59)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  59)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  59)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  59)					if ((_this->halfA > 0)) {
HXDLIN(  59)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  59)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  59)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  59)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  59)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  59)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  59)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  59)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  59)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  59)				_this->exPrev = _this->ex;
            			}
HXDLIN(  59)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  59)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  59)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  59)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  59)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  59)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  59)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  59)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  59)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  59)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  59)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  59)		Float theta0;
HXDLIN(  59)		Float theta1;
HXDLIN(  59)		if (clockWise) {
HXDLIN(  59)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  59)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  59)		Float dif;
HXDLIN(  59)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  59)				Float f;
HXDLIN(  59)				bool f1;
HXDLIN(  59)				if ((theta0 >= 0)) {
HXDLIN(  59)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f1 = false;
            				}
HXDLIN(  59)				if (f1) {
HXDLIN(  59)					f = theta0;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f = a;
            					}
            					else {
HXDLIN(  59)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this1 = f;
HXDLIN(  59)				Float za = this1;
HXDLIN(  59)				Float f2;
HXDLIN(  59)				bool f3;
HXDLIN(  59)				if ((theta1 >= 0)) {
HXDLIN(  59)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f3 = false;
            				}
HXDLIN(  59)				if (f3) {
HXDLIN(  59)					f2 = theta1;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f2 = a;
            					}
            					else {
HXDLIN(  59)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this2 = f2;
HXDLIN(  59)				Float zb = this2;
HXDLIN(  59)				Float fa = za;
HXDLIN(  59)				Float fb = zb;
HXDLIN(  59)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)				bool clockwise = (fa < fb);
HXDLIN(  59)				Float dif1;
HXDLIN(  59)				if (clockwise) {
HXDLIN(  59)					dif1 = theta;
            				}
            				else {
HXDLIN(  59)					dif1 = -(theta);
            				}
HXDLIN(  59)				if ((dif1 > 0)) {
HXDLIN(  59)					dif = dif1;
            				}
            				else {
HXDLIN(  59)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  59)				Float f;
HXDLIN(  59)				bool f1;
HXDLIN(  59)				if ((theta0 >= 0)) {
HXDLIN(  59)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f1 = false;
            				}
HXDLIN(  59)				if (f1) {
HXDLIN(  59)					f = theta0;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f = a;
            					}
            					else {
HXDLIN(  59)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this1 = f;
HXDLIN(  59)				Float za = this1;
HXDLIN(  59)				Float f2;
HXDLIN(  59)				bool f3;
HXDLIN(  59)				if ((theta1 >= 0)) {
HXDLIN(  59)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f3 = false;
            				}
HXDLIN(  59)				if (f3) {
HXDLIN(  59)					f2 = theta1;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f2 = a;
            					}
            					else {
HXDLIN(  59)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this2 = f2;
HXDLIN(  59)				Float zb = this2;
HXDLIN(  59)				Float fa = za;
HXDLIN(  59)				Float fb = zb;
HXDLIN(  59)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)				bool clockwise = (fa < fb);
HXDLIN(  59)				Float dif1;
HXDLIN(  59)				if (clockwise) {
HXDLIN(  59)					dif1 = theta;
            				}
            				else {
HXDLIN(  59)					dif1 = -(theta);
            				}
HXDLIN(  59)				if ((dif1 < 0)) {
HXDLIN(  59)					dif = dif1;
            				}
            				else {
HXDLIN(  59)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  59)				Float f;
HXDLIN(  59)				bool f1;
HXDLIN(  59)				if ((theta0 >= 0)) {
HXDLIN(  59)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f1 = false;
            				}
HXDLIN(  59)				if (f1) {
HXDLIN(  59)					f = theta0;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f = a;
            					}
            					else {
HXDLIN(  59)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this1 = f;
HXDLIN(  59)				Float za = this1;
HXDLIN(  59)				Float f2;
HXDLIN(  59)				bool f3;
HXDLIN(  59)				if ((theta1 >= 0)) {
HXDLIN(  59)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f3 = false;
            				}
HXDLIN(  59)				if (f3) {
HXDLIN(  59)					f2 = theta1;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f2 = a;
            					}
            					else {
HXDLIN(  59)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this2 = f2;
HXDLIN(  59)				Float zb = this2;
HXDLIN(  59)				Float fa = za;
HXDLIN(  59)				Float fb = zb;
HXDLIN(  59)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  59)				bool clockwise = (fa < fb);
HXDLIN(  59)				Float dif1;
HXDLIN(  59)				if (clockwise) {
HXDLIN(  59)					dif1 = theta;
            				}
            				else {
HXDLIN(  59)					dif1 = -(theta);
            				}
HXDLIN(  59)				if (smallest) {
HXDLIN(  59)					dif = dif1;
            				}
            				else {
HXDLIN(  59)					if (clockwise) {
HXDLIN(  59)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  59)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  59)				Float f;
HXDLIN(  59)				bool f1;
HXDLIN(  59)				if ((theta0 >= 0)) {
HXDLIN(  59)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f1 = false;
            				}
HXDLIN(  59)				if (f1) {
HXDLIN(  59)					f = theta0;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f = a;
            					}
            					else {
HXDLIN(  59)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this1 = f;
HXDLIN(  59)				Float za = this1;
HXDLIN(  59)				Float f2;
HXDLIN(  59)				bool f3;
HXDLIN(  59)				if ((theta1 >= 0)) {
HXDLIN(  59)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f3 = false;
            				}
HXDLIN(  59)				if (f3) {
HXDLIN(  59)					f2 = theta1;
            				}
            				else {
HXDLIN(  59)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)					if ((a >= 0)) {
HXDLIN(  59)						f2 = a;
            					}
            					else {
HXDLIN(  59)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  59)				Float this2 = f2;
HXDLIN(  59)				Float zb = this2;
HXDLIN(  59)				Float fa = za;
HXDLIN(  59)				Float fb = zb;
HXDLIN(  59)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  59)				bool clockwise = (fa < fb);
HXDLIN(  59)				Float dif1;
HXDLIN(  59)				if (clockwise) {
HXDLIN(  59)					dif1 = theta;
            				}
            				else {
HXDLIN(  59)					dif1 = -(theta);
            				}
HXDLIN(  59)				if (largest) {
HXDLIN(  59)					dif = dif1;
            				}
            				else {
HXDLIN(  59)					if (clockwise) {
HXDLIN(  59)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  59)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  59)		bool _hx_tmp;
HXDLIN(  59)		if (!(overlap)) {
HXDLIN(  59)			_hx_tmp = (_this->count != 0);
            		}
            		else {
HXDLIN(  59)			_hx_tmp = false;
            		}
HXDLIN(  59)		if (_hx_tmp) {
HXDLIN(  59)			Float gamma = (::Math_obj::abs(dif) / ( (Float)(2) ));
HXDLIN(  59)			Float h = ((width_ / ( (Float)(2) )) / ::Math_obj::cos(gamma));
HXDLIN(  59)			Float f;
HXDLIN(  59)			bool f1;
HXDLIN(  59)			if ((theta0 <= ::Math_obj::PI)) {
HXDLIN(  59)				f1 = (theta0 > -(::Math_obj::PI));
            			}
            			else {
HXDLIN(  59)				f1 = false;
            			}
HXDLIN(  59)			if (f1) {
HXDLIN(  59)				f = theta0;
            			}
            			else {
HXDLIN(  59)				Float a = ::hx::Mod((theta0 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)				if ((a >= 0)) {
HXDLIN(  59)					f = (a - ::Math_obj::PI);
            				}
            				else {
HXDLIN(  59)					f = (a + ::Math_obj::PI);
            				}
            			}
HXDLIN(  59)			Float this1 = f;
HXDLIN(  59)			Float start = this1;
HXDLIN(  59)			Float start2 = start;
HXDLIN(  59)			Float delta = ((start2 + (dif / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  59)			_this->jx = (_this->ax + (h * ::Math_obj::sin(delta)));
HXDLIN(  59)			_this->jy = (_this->ay + (h * ::Math_obj::cos(delta)));
            		}
HXDLIN(  59)		bool _hx_tmp1;
HXDLIN(  59)		if ((_this->count == 0)) {
HXDLIN(  59)			if ((_this->endLine != 1)) {
HXDLIN(  59)				_hx_tmp1 = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  59)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXDLIN(  59)			_hx_tmp1 = false;
            		}
HXDLIN(  59)		if (_hx_tmp1) {
HXDLIN(  59)			Float ax = _this->ax;
HXDLIN(  59)			Float ay = _this->ay;
HXDLIN(  59)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  59)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  59)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  59)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  59)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  59)			 ::Dynamic sides = 36;
HXDLIN(  59)			if (::hx::IsNull( sides )) {
HXDLIN(  59)				sides = 36;
            			}
HXDLIN(  59)			Float pi = ::Math_obj::PI;
HXDLIN(  59)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  59)			Float dif;
HXDLIN(  59)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  59)					Float f;
HXDLIN(  59)					bool f1;
HXDLIN(  59)					if ((beta >= 0)) {
HXDLIN(  59)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f1 = false;
            					}
HXDLIN(  59)					if (f1) {
HXDLIN(  59)						f = beta;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f = a;
            						}
            						else {
HXDLIN(  59)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this1 = f;
HXDLIN(  59)					Float za = this1;
HXDLIN(  59)					Float f2;
HXDLIN(  59)					bool f3;
HXDLIN(  59)					if ((gamma >= 0)) {
HXDLIN(  59)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f3 = false;
            					}
HXDLIN(  59)					if (f3) {
HXDLIN(  59)						f2 = gamma;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f2 = a;
            						}
            						else {
HXDLIN(  59)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this2 = f2;
HXDLIN(  59)					Float zb = this2;
HXDLIN(  59)					Float fa = za;
HXDLIN(  59)					Float fb = zb;
HXDLIN(  59)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)					bool clockwise = (fa < fb);
HXDLIN(  59)					Float dif1;
HXDLIN(  59)					if (clockwise) {
HXDLIN(  59)						dif1 = theta;
            					}
            					else {
HXDLIN(  59)						dif1 = -(theta);
            					}
HXDLIN(  59)					if ((dif1 > 0)) {
HXDLIN(  59)						dif = dif1;
            					}
            					else {
HXDLIN(  59)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  59)					Float f;
HXDLIN(  59)					bool f1;
HXDLIN(  59)					if ((beta >= 0)) {
HXDLIN(  59)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f1 = false;
            					}
HXDLIN(  59)					if (f1) {
HXDLIN(  59)						f = beta;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f = a;
            						}
            						else {
HXDLIN(  59)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this1 = f;
HXDLIN(  59)					Float za = this1;
HXDLIN(  59)					Float f2;
HXDLIN(  59)					bool f3;
HXDLIN(  59)					if ((gamma >= 0)) {
HXDLIN(  59)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f3 = false;
            					}
HXDLIN(  59)					if (f3) {
HXDLIN(  59)						f2 = gamma;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f2 = a;
            						}
            						else {
HXDLIN(  59)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this2 = f2;
HXDLIN(  59)					Float zb = this2;
HXDLIN(  59)					Float fa = za;
HXDLIN(  59)					Float fb = zb;
HXDLIN(  59)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)					bool clockwise = (fa < fb);
HXDLIN(  59)					Float dif1;
HXDLIN(  59)					if (clockwise) {
HXDLIN(  59)						dif1 = theta;
            					}
            					else {
HXDLIN(  59)						dif1 = -(theta);
            					}
HXDLIN(  59)					if ((dif1 < 0)) {
HXDLIN(  59)						dif = dif1;
            					}
            					else {
HXDLIN(  59)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  59)					Float f;
HXDLIN(  59)					bool f1;
HXDLIN(  59)					if ((beta >= 0)) {
HXDLIN(  59)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f1 = false;
            					}
HXDLIN(  59)					if (f1) {
HXDLIN(  59)						f = beta;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f = a;
            						}
            						else {
HXDLIN(  59)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this1 = f;
HXDLIN(  59)					Float za = this1;
HXDLIN(  59)					Float f2;
HXDLIN(  59)					bool f3;
HXDLIN(  59)					if ((gamma >= 0)) {
HXDLIN(  59)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f3 = false;
            					}
HXDLIN(  59)					if (f3) {
HXDLIN(  59)						f2 = gamma;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f2 = a;
            						}
            						else {
HXDLIN(  59)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this2 = f2;
HXDLIN(  59)					Float zb = this2;
HXDLIN(  59)					Float fa = za;
HXDLIN(  59)					Float fb = zb;
HXDLIN(  59)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  59)					bool clockwise = (fa < fb);
HXDLIN(  59)					Float dif1;
HXDLIN(  59)					if (clockwise) {
HXDLIN(  59)						dif1 = theta;
            					}
            					else {
HXDLIN(  59)						dif1 = -(theta);
            					}
HXDLIN(  59)					if (smallest) {
HXDLIN(  59)						dif = dif1;
            					}
            					else {
HXDLIN(  59)						if (clockwise) {
HXDLIN(  59)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  59)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  59)					Float f;
HXDLIN(  59)					bool f1;
HXDLIN(  59)					if ((beta >= 0)) {
HXDLIN(  59)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f1 = false;
            					}
HXDLIN(  59)					if (f1) {
HXDLIN(  59)						f = beta;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f = a;
            						}
            						else {
HXDLIN(  59)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this1 = f;
HXDLIN(  59)					Float za = this1;
HXDLIN(  59)					Float f2;
HXDLIN(  59)					bool f3;
HXDLIN(  59)					if ((gamma >= 0)) {
HXDLIN(  59)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  59)						f3 = false;
            					}
HXDLIN(  59)					if (f3) {
HXDLIN(  59)						f2 = gamma;
            					}
            					else {
HXDLIN(  59)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  59)						if ((a >= 0)) {
HXDLIN(  59)							f2 = a;
            						}
            						else {
HXDLIN(  59)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  59)					Float this2 = f2;
HXDLIN(  59)					Float zb = this2;
HXDLIN(  59)					Float fa = za;
HXDLIN(  59)					Float fb = zb;
HXDLIN(  59)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  59)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  59)					bool clockwise = (fa < fb);
HXDLIN(  59)					Float dif1;
HXDLIN(  59)					if (clockwise) {
HXDLIN(  59)						dif1 = theta;
            					}
            					else {
HXDLIN(  59)						dif1 = -(theta);
            					}
HXDLIN(  59)					if (largest) {
HXDLIN(  59)						dif = dif1;
            					}
            					else {
HXDLIN(  59)						if (clockwise) {
HXDLIN(  59)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  59)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  59)			bool positive = (dif >= 0);
HXDLIN(  59)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  59)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  59)			Float angle = beta;
HXDLIN(  59)			Float cx;
HXDLIN(  59)			Float cy;
HXDLIN(  59)			Float bx = ( (Float)(0) );
HXDLIN(  59)			Float by = ( (Float)(0) );
HXDLIN(  59)			int p2 = temp->length;
HXDLIN(  59)			{
HXDLIN(  59)				int _g = 0;
HXDLIN(  59)				int _g1 = (totalSteps + 1);
HXDLIN(  59)				while((_g < _g1)){
HXDLIN(  59)					_g = (_g + 1);
HXDLIN(  59)					int i = (_g - 1);
HXDLIN(  59)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  59)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  59)					p2 = (p2 + 1);
HXDLIN(  59)					temp[(p2 - 1)] = cx;
HXDLIN(  59)					p2 = (p2 + 1);
HXDLIN(  59)					temp[(p2 - 1)] = cy;
HXDLIN(  59)					if ((i != 0)) {
HXDLIN(  59)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  59)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  59)						if (::hx::IsNotNull( m )) {
HXDLIN(  59)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  59)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					angle = (angle + step1);
HXDLIN(  59)					bx = cx;
HXDLIN(  59)					by = cy;
            				}
            			}
HXDLIN(  59)			int len = totalSteps;
HXDLIN(  59)			{
HXDLIN(  59)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)				int color = -1;
HXDLIN(  59)				if ((color == -1)) {
HXDLIN(  59)					color = _this1->currentColor;
            				}
HXDLIN(  59)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  59)			int pA = _this->pointsAnti->length;
HXDLIN(  59)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  59)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  59)			{
HXDLIN(  59)				int _g2 = 0;
HXDLIN(  59)				int _g3 = p4;
HXDLIN(  59)				while((_g2 < _g3)){
HXDLIN(  59)					_g2 = (_g2 + 1);
HXDLIN(  59)					int i = (_g2 - 1);
HXDLIN(  59)					pA = (pA + 1);
HXDLIN(  59)					_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXDLIN(  59)					pA = (pA + 1);
HXDLIN(  59)					_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            				}
            			}
HXDLIN(  59)			int pC = _this->pointsClock->length;
HXDLIN(  59)			{
HXDLIN(  59)				int _g4 = 0;
HXDLIN(  59)				int _g5 = p4;
HXDLIN(  59)				while((_g4 < _g5)){
HXDLIN(  59)					_g4 = (_g4 + 1);
HXDLIN(  59)					int i = (_g4 - 1);
HXDLIN(  59)					pC = (pC + 1);
HXDLIN(  59)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXDLIN(  59)					pC = (pC + 1);
HXDLIN(  59)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            				}
            			}
            		}
HXDLIN(  59)		if (overlap) {
HXDLIN(  59)			{
HXDLIN(  59)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)				int color = -1;
HXDLIN(  59)				if ((color == -1)) {
HXDLIN(  59)					color = _this1->currentColor;
            				}
HXDLIN(  59)				{
HXDLIN(  59)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  59)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  59)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  59)			{
HXDLIN(  59)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)				int color1 = -1;
HXDLIN(  59)				if ((color1 == -1)) {
HXDLIN(  59)					color1 = _this2->currentColor;
            				}
HXDLIN(  59)				{
HXDLIN(  59)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  59)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  59)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  59)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
            		else {
HXDLIN(  59)			if ((_this->count != 0)) {
HXDLIN(  59)				_this->addQuads(clockWise,width_);
            			}
HXDLIN(  59)			{
HXDLIN(  59)				_this->quadIndex = ( (Float)(_this->pen->drawType->__Field(HX_("get_pos",2b,26,ca,26),::hx::paccDynamic)()) );
HXDLIN(  59)				if ((_this->count == 0)) {
HXDLIN(  59)					_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  59)					_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  59)					_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  59)					_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  59)					_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  59)					_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  59)					_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  59)					_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  59)					{
HXDLIN(  59)						 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)						int color = -1;
HXDLIN(  59)						if ((color == -1)) {
HXDLIN(  59)							color = _this1->currentColor;
            						}
HXDLIN(  59)						{
HXDLIN(  59)							_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)								_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN(  59)							_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  59)						_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            					}
HXDLIN(  59)					{
HXDLIN(  59)						 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)						int color1 = -1;
HXDLIN(  59)						if ((color1 == -1)) {
HXDLIN(  59)							color1 = _this2->currentColor;
            						}
HXDLIN(  59)						{
HXDLIN(  59)							_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  59)							if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)								_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            							}
HXDLIN(  59)							_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  59)						_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            					}
            				}
            				else {
HXDLIN(  59)					bool _hx_tmp;
HXDLIN(  59)					if (clockWise) {
HXDLIN(  59)						_hx_tmp = !(_this->lastClock);
            					}
            					else {
HXDLIN(  59)						_hx_tmp = false;
            					}
HXDLIN(  59)					if (_hx_tmp) {
HXDLIN(  59)						_this->penultimateAX = _this->jx;
HXDLIN(  59)						_this->penultimateAY = _this->jy;
HXDLIN(  59)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  59)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  59)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  59)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  59)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  59)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)							int color = -1;
HXDLIN(  59)							if ((color == -1)) {
HXDLIN(  59)								color = _this1->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)							int color1 = -1;
HXDLIN(  59)							if ((color1 == -1)) {
HXDLIN(  59)								color1 = _this2->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  59)					bool _hx_tmp1;
HXDLIN(  59)					if (clockWise) {
HXDLIN(  59)						_hx_tmp1 = _this->lastClock;
            					}
            					else {
HXDLIN(  59)						_hx_tmp1 = false;
            					}
HXDLIN(  59)					if (_hx_tmp1) {
HXDLIN(  59)						_this->penultimateAX = _this->jx;
HXDLIN(  59)						_this->penultimateAY = _this->jy;
HXDLIN(  59)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  59)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  59)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  59)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  59)						_this->lastClockX = ( (Float)(_this->exPrev) );
HXDLIN(  59)						_this->lastClockY = ( (Float)(_this->eyPrev) );
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)							int color = -1;
HXDLIN(  59)							if ((color == -1)) {
HXDLIN(  59)								color = _this1->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)							int color1 = -1;
HXDLIN(  59)							if ((color1 == -1)) {
HXDLIN(  59)								color1 = _this2->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  59)					bool _hx_tmp2;
HXDLIN(  59)					if (!(clockWise)) {
HXDLIN(  59)						_hx_tmp2 = !(_this->lastClock);
            					}
            					else {
HXDLIN(  59)						_hx_tmp2 = false;
            					}
HXDLIN(  59)					if (_hx_tmp2) {
HXDLIN(  59)						_this->penultimateCX = ( (Float)(_this->dx) );
HXDLIN(  59)						_this->penultimateCY = ( (Float)(_this->dy) );
HXDLIN(  59)						_this->lastClockX = _this->jx;
HXDLIN(  59)						_this->lastClockY = _this->jy;
HXDLIN(  59)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  59)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  59)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  59)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)							int color = -1;
HXDLIN(  59)							if ((color == -1)) {
HXDLIN(  59)								color = _this1->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,_this->jx,_this->jy,0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)							int color1 = -1;
HXDLIN(  59)							if ((color1 == -1)) {
HXDLIN(  59)								color1 = _this2->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
HXDLIN(  59)					bool _hx_tmp3;
HXDLIN(  59)					if (!(clockWise)) {
HXDLIN(  59)						_hx_tmp3 = _this->lastClock;
            					}
            					else {
HXDLIN(  59)						_hx_tmp3 = false;
            					}
HXDLIN(  59)					if (_hx_tmp3) {
HXDLIN(  59)						_this->penultimateAX = ( (Float)(_this->dxPrev) );
HXDLIN(  59)						_this->penultimateAY = ( (Float)(_this->dyPrev) );
HXDLIN(  59)						_this->lastAntiX = ( (Float)(_this->ex) );
HXDLIN(  59)						_this->lastAntiY = ( (Float)(_this->ey) );
HXDLIN(  59)						_this->penultimateCX = _this->jx;
HXDLIN(  59)						_this->penultimateCY = _this->jy;
HXDLIN(  59)						_this->lastClockX = ( (Float)(_this->dx) );
HXDLIN(  59)						_this->lastClockY = ( (Float)(_this->dy) );
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)							int color = -1;
HXDLIN(  59)							if ((color == -1)) {
HXDLIN(  59)								color = _this1->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->jx,_this->jy,0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            						}
HXDLIN(  59)						{
HXDLIN(  59)							 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)							int color1 = -1;
HXDLIN(  59)							if ((color1 == -1)) {
HXDLIN(  59)								color1 = _this2->currentColor;
            							}
HXDLIN(  59)							{
HXDLIN(  59)								_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  59)								if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)									_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            								}
HXDLIN(  59)								_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            							}
HXDLIN(  59)							_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            						}
            					}
            				}
            			}
            		}
HXDLIN(  59)		if (clockWise) {
HXDLIN(  59)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  59)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  59)			::Array< Float > edgePoly = _this->pointsClock;
HXDLIN(  59)			Float pi = ::Math_obj::PI;
HXDLIN(  59)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  59)			bool positive = (dif >= 0);
HXDLIN(  59)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  59)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  59)			Float angle = theta0;
HXDLIN(  59)			Float cx;
HXDLIN(  59)			Float cy;
HXDLIN(  59)			Float bx = ( (Float)(0) );
HXDLIN(  59)			Float by = ( (Float)(0) );
HXDLIN(  59)			int p2 = edgePoly->length;
HXDLIN(  59)			{
HXDLIN(  59)				int _g = 0;
HXDLIN(  59)				int _g1 = (totalSteps + 1);
HXDLIN(  59)				while((_g < _g1)){
HXDLIN(  59)					_g = (_g + 1);
HXDLIN(  59)					int i = (_g - 1);
HXDLIN(  59)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  59)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  59)					p2 = (p2 + 1);
HXDLIN(  59)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  59)					p2 = (p2 + 1);
HXDLIN(  59)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  59)					if ((i != 0)) {
HXDLIN(  59)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  59)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  59)						if (::hx::IsNotNull( m )) {
HXDLIN(  59)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  59)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					angle = (angle + step1);
HXDLIN(  59)					bx = cx;
HXDLIN(  59)					by = cy;
            				}
            			}
HXDLIN(  59)			int len = totalSteps;
HXDLIN(  59)			{
HXDLIN(  59)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)				int color = -1;
HXDLIN(  59)				if ((color == -1)) {
HXDLIN(  59)					color = _this1->currentColor;
            				}
HXDLIN(  59)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
            		else {
HXDLIN(  59)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  59)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  59)			::Array< Float > edgePoly = _this->pointsAnti;
HXDLIN(  59)			Float pi = ::Math_obj::PI;
HXDLIN(  59)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  59)			bool positive = (dif >= 0);
HXDLIN(  59)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  59)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  59)			Float angle = theta0;
HXDLIN(  59)			Float cx;
HXDLIN(  59)			Float cy;
HXDLIN(  59)			Float bx = ( (Float)(0) );
HXDLIN(  59)			Float by = ( (Float)(0) );
HXDLIN(  59)			int p2 = edgePoly->length;
HXDLIN(  59)			{
HXDLIN(  59)				int _g = 0;
HXDLIN(  59)				int _g1 = (totalSteps + 1);
HXDLIN(  59)				while((_g < _g1)){
HXDLIN(  59)					_g = (_g + 1);
HXDLIN(  59)					int i = (_g - 1);
HXDLIN(  59)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  59)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  59)					p2 = (p2 + 1);
HXDLIN(  59)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  59)					p2 = (p2 + 1);
HXDLIN(  59)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  59)					if ((i != 0)) {
HXDLIN(  59)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  59)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  59)						if (::hx::IsNotNull( m )) {
HXDLIN(  59)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  59)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					angle = (angle + step1);
HXDLIN(  59)					bx = cx;
HXDLIN(  59)					by = cy;
            				}
            			}
HXDLIN(  59)			int len = totalSteps;
HXDLIN(  59)			{
HXDLIN(  59)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)				int color = -1;
HXDLIN(  59)				if ((color == -1)) {
HXDLIN(  59)					color = _this1->currentColor;
            				}
HXDLIN(  59)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  59)		{
HXDLIN(  59)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  59)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  59)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  59)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  59)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  59)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  59)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  59)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  59)		bool _hx_tmp2;
HXDLIN(  59)		if (!(overlap)) {
HXDLIN(  59)			_hx_tmp2 = (_this->count != 0);
            		}
            		else {
HXDLIN(  59)			_hx_tmp2 = false;
            		}
HXDLIN(  59)		if (_hx_tmp2) {
HXDLIN(  59)			if (clockWise) {
HXDLIN(  59)				{
HXDLIN(  59)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)					int color = -1;
HXDLIN(  59)					if ((color == -1)) {
HXDLIN(  59)						color = _this1->currentColor;
            					}
HXDLIN(  59)					{
HXDLIN(  59)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->dxOld) ),( (Float)(_this->dyOld) ),0,_this->jx,_this->jy,0);
HXDLIN(  59)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  59)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXDLIN(  59)				{
HXDLIN(  59)					 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)					int color1 = -1;
HXDLIN(  59)					if ((color1 == -1)) {
HXDLIN(  59)						color1 = _this2->currentColor;
            					}
HXDLIN(  59)					{
HXDLIN(  59)						_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0,_this->jx,_this->jy,0);
HXDLIN(  59)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)							_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  59)						_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
            			else {
HXDLIN(  59)				{
HXDLIN(  59)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  59)					int color = -1;
HXDLIN(  59)					if ((color == -1)) {
HXDLIN(  59)						color = _this1->currentColor;
            					}
HXDLIN(  59)					{
HXDLIN(  59)						_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->exOld) ),( (Float)(_this->eyOld) ),0,_this->jx,_this->jy,0);
HXDLIN(  59)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)							_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  59)						_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            				}
HXDLIN(  59)				{
HXDLIN(  59)					 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  59)					int color1 = -1;
HXDLIN(  59)					if ((color1 == -1)) {
HXDLIN(  59)						color1 = _this2->currentColor;
            					}
HXDLIN(  59)					{
HXDLIN(  59)						_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(_this->ax,_this->ay,0,( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,_this->jx,_this->jy,0);
HXDLIN(  59)						if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  59)							_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            						}
HXDLIN(  59)						_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  59)					_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            				}
            			}
            		}
HXDLIN(  59)		_this->jxOld = _this->jx;
HXDLIN(  59)		_this->jyOld = _this->jy;
HXDLIN(  59)		_this->lastClock = clockWise;
HXDLIN(  59)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,fineLine,(void))

void Sketch_obj::fineOverlapLine(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_62_fineOverlapLine)
HXDLIN(  62)		 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN(  62)		Float ax_ = this->x;
HXDLIN(  62)		Float ay_ = this->y;
HXDLIN(  62)		Float width_ = this->width;
HXDLIN(  62)		 ::Dynamic oldAngle;
HXDLIN(  62)		if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  62)			oldAngle = _this->angle1;
            		}
            		else {
HXDLIN(  62)			oldAngle = null();
            		}
HXDLIN(  62)		_this->halfA = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  62)		_this->ax = x_;
HXDLIN(  62)		_this->ay = y_;
HXDLIN(  62)		_this->bx = ax_;
HXDLIN(  62)		_this->by = ay_;
HXDLIN(  62)		_this->beta = ((::Math_obj::PI / ( (Float)(2) )) - _this->halfA);
HXDLIN(  62)		_this->r = ((width_ / ( (Float)(2) )) * ::Math_obj::cos(_this->beta));
HXDLIN(  62)		{
HXDLIN(  62)			{
HXDLIN(  62)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  62)				if ((_this->theta > 0)) {
HXDLIN(  62)					if ((_this->halfA < 0)) {
HXDLIN(  62)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  62)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  62)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  62)					if ((_this->halfA > 0)) {
HXDLIN(  62)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  62)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  62)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  62)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  62)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  62)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  62)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  62)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  62)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  62)				_this->exPrev = _this->ex;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  62)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  62)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  62)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  62)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  62)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  62)		_this->ax = ax_;
HXDLIN(  62)		_this->ay = ay_;
HXDLIN(  62)		_this->bx = x_;
HXDLIN(  62)		_this->by = y_;
HXDLIN(  62)		{
HXDLIN(  62)			{
HXDLIN(  62)				_this->theta = ::Math_obj::atan2((_this->ay - _this->by),(_this->ax - _this->bx));
HXDLIN(  62)				if ((_this->theta > 0)) {
HXDLIN(  62)					if ((_this->halfA < 0)) {
HXDLIN(  62)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            					else {
HXDLIN(  62)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  62)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            				}
            				else {
HXDLIN(  62)					if ((_this->halfA > 0)) {
HXDLIN(  62)						_this->angle1 = ((_this->theta + _this->halfA) - ::Math_obj::PI);
HXDLIN(  62)						_this->angle2 = (_this->theta + _this->halfA);
            					}
            					else {
HXDLIN(  62)						_this->angle2 = ((_this->theta + _this->halfA) + (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)						_this->angle1 = (_this->theta - _this->halfA);
            					}
            				}
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dxPrev )) {
HXDLIN(  62)				_this->dxOld = _this->dxPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dyPrev )) {
HXDLIN(  62)				_this->dyOld = _this->dyPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->exPrev )) {
HXDLIN(  62)				_this->exOld = _this->exPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->eyPrev )) {
HXDLIN(  62)				_this->eyOld = _this->eyPrev;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dx )) {
HXDLIN(  62)				_this->dxPrev = _this->dx;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->dy )) {
HXDLIN(  62)				_this->dyPrev = _this->dy;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->ex )) {
HXDLIN(  62)				_this->exPrev = _this->ex;
            			}
HXDLIN(  62)			if (::hx::IsNotNull( _this->ey )) {
HXDLIN(  62)				_this->eyPrev = _this->ey;
            			}
HXDLIN(  62)			_this->dx = (_this->bx + (_this->r * ::Math_obj::cos(( (Float)(_this->angle1) ))));
HXDLIN(  62)			_this->dy = (_this->by + (_this->r * ::Math_obj::sin(( (Float)(_this->angle1) ))));
HXDLIN(  62)			_this->ex = (_this->bx + (_this->r * ::Math_obj::cos(_this->angle2)));
HXDLIN(  62)			_this->ey = (_this->by + (_this->r * ::Math_obj::sin(_this->angle2)));
            		}
HXDLIN(  62)		Float x = (( (Float)(_this->dxOld) ) - x_);
HXDLIN(  62)		Float y = (( (Float)(_this->dyOld) ) - y_);
HXDLIN(  62)		Float x1 = (( (Float)(_this->exOld) ) - x_);
HXDLIN(  62)		Float y1 = (( (Float)(_this->eyOld) ) - y_);
HXDLIN(  62)		bool clockWise = (((x * x) + (y * y)) > ((x1 * x1) + (y1 * y1)));
HXDLIN(  62)		Float theta0;
HXDLIN(  62)		Float theta1;
HXDLIN(  62)		if (clockWise) {
HXDLIN(  62)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyOld) )),(_this->ax - ( (Float)(_this->dxOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyPrev) )),(_this->ax - ( (Float)(_this->exPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
            		else {
HXDLIN(  62)			theta0 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->eyOld) )),(_this->ax - ( (Float)(_this->exOld) )))) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)			theta1 = (-(::Math_obj::atan2((_this->ay - ( (Float)(_this->dyPrev) )),(_this->ax - ( (Float)(_this->dxPrev) )))) - (::Math_obj::PI / ( (Float)(2) )));
            		}
HXDLIN(  62)		Float dif;
HXDLIN(  62)		switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            			case (int)0: {
HXDLIN(  62)				Float f;
HXDLIN(  62)				bool f1;
HXDLIN(  62)				if ((theta0 >= 0)) {
HXDLIN(  62)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f1 = false;
            				}
HXDLIN(  62)				if (f1) {
HXDLIN(  62)					f = theta0;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f = a;
            					}
            					else {
HXDLIN(  62)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this1 = f;
HXDLIN(  62)				Float za = this1;
HXDLIN(  62)				Float f2;
HXDLIN(  62)				bool f3;
HXDLIN(  62)				if ((theta1 >= 0)) {
HXDLIN(  62)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f3 = false;
            				}
HXDLIN(  62)				if (f3) {
HXDLIN(  62)					f2 = theta1;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f2 = a;
            					}
            					else {
HXDLIN(  62)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this2 = f2;
HXDLIN(  62)				Float zb = this2;
HXDLIN(  62)				Float fa = za;
HXDLIN(  62)				Float fb = zb;
HXDLIN(  62)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)				bool clockwise = (fa < fb);
HXDLIN(  62)				Float dif1;
HXDLIN(  62)				if (clockwise) {
HXDLIN(  62)					dif1 = theta;
            				}
            				else {
HXDLIN(  62)					dif1 = -(theta);
            				}
HXDLIN(  62)				if ((dif1 > 0)) {
HXDLIN(  62)					dif = dif1;
            				}
            				else {
HXDLIN(  62)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXDLIN(  62)				Float f;
HXDLIN(  62)				bool f1;
HXDLIN(  62)				if ((theta0 >= 0)) {
HXDLIN(  62)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f1 = false;
            				}
HXDLIN(  62)				if (f1) {
HXDLIN(  62)					f = theta0;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f = a;
            					}
            					else {
HXDLIN(  62)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this1 = f;
HXDLIN(  62)				Float za = this1;
HXDLIN(  62)				Float f2;
HXDLIN(  62)				bool f3;
HXDLIN(  62)				if ((theta1 >= 0)) {
HXDLIN(  62)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f3 = false;
            				}
HXDLIN(  62)				if (f3) {
HXDLIN(  62)					f2 = theta1;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f2 = a;
            					}
            					else {
HXDLIN(  62)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this2 = f2;
HXDLIN(  62)				Float zb = this2;
HXDLIN(  62)				Float fa = za;
HXDLIN(  62)				Float fb = zb;
HXDLIN(  62)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)				bool clockwise = (fa < fb);
HXDLIN(  62)				Float dif1;
HXDLIN(  62)				if (clockwise) {
HXDLIN(  62)					dif1 = theta;
            				}
            				else {
HXDLIN(  62)					dif1 = -(theta);
            				}
HXDLIN(  62)				if ((dif1 < 0)) {
HXDLIN(  62)					dif = dif1;
            				}
            				else {
HXDLIN(  62)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXDLIN(  62)				Float f;
HXDLIN(  62)				bool f1;
HXDLIN(  62)				if ((theta0 >= 0)) {
HXDLIN(  62)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f1 = false;
            				}
HXDLIN(  62)				if (f1) {
HXDLIN(  62)					f = theta0;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f = a;
            					}
            					else {
HXDLIN(  62)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this1 = f;
HXDLIN(  62)				Float za = this1;
HXDLIN(  62)				Float f2;
HXDLIN(  62)				bool f3;
HXDLIN(  62)				if ((theta1 >= 0)) {
HXDLIN(  62)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f3 = false;
            				}
HXDLIN(  62)				if (f3) {
HXDLIN(  62)					f2 = theta1;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f2 = a;
            					}
            					else {
HXDLIN(  62)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this2 = f2;
HXDLIN(  62)				Float zb = this2;
HXDLIN(  62)				Float fa = za;
HXDLIN(  62)				Float fb = zb;
HXDLIN(  62)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  62)				bool clockwise = (fa < fb);
HXDLIN(  62)				Float dif1;
HXDLIN(  62)				if (clockwise) {
HXDLIN(  62)					dif1 = theta;
            				}
            				else {
HXDLIN(  62)					dif1 = -(theta);
            				}
HXDLIN(  62)				if (smallest) {
HXDLIN(  62)					dif = dif1;
            				}
            				else {
HXDLIN(  62)					if (clockwise) {
HXDLIN(  62)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  62)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXDLIN(  62)				Float f;
HXDLIN(  62)				bool f1;
HXDLIN(  62)				if ((theta0 >= 0)) {
HXDLIN(  62)					f1 = (theta0 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f1 = false;
            				}
HXDLIN(  62)				if (f1) {
HXDLIN(  62)					f = theta0;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f = a;
            					}
            					else {
HXDLIN(  62)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this1 = f;
HXDLIN(  62)				Float za = this1;
HXDLIN(  62)				Float f2;
HXDLIN(  62)				bool f3;
HXDLIN(  62)				if ((theta1 >= 0)) {
HXDLIN(  62)					f3 = (theta1 > ::Math_obj::PI);
            				}
            				else {
HXDLIN(  62)					f3 = false;
            				}
HXDLIN(  62)				if (f3) {
HXDLIN(  62)					f2 = theta1;
            				}
            				else {
HXDLIN(  62)					Float a = ::hx::Mod(theta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)					if ((a >= 0)) {
HXDLIN(  62)						f2 = a;
            					}
            					else {
HXDLIN(  62)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN(  62)				Float this2 = f2;
HXDLIN(  62)				Float zb = this2;
HXDLIN(  62)				Float fa = za;
HXDLIN(  62)				Float fb = zb;
HXDLIN(  62)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)				bool largest = (theta > ::Math_obj::PI);
HXDLIN(  62)				bool clockwise = (fa < fb);
HXDLIN(  62)				Float dif1;
HXDLIN(  62)				if (clockwise) {
HXDLIN(  62)					dif1 = theta;
            				}
            				else {
HXDLIN(  62)					dif1 = -(theta);
            				}
HXDLIN(  62)				if (largest) {
HXDLIN(  62)					dif = dif1;
            				}
            				else {
HXDLIN(  62)					if (clockwise) {
HXDLIN(  62)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXDLIN(  62)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN(  62)		bool _hx_tmp;
HXDLIN(  62)		if ((_this->count == 0)) {
HXDLIN(  62)			if ((_this->endLine != 1)) {
HXDLIN(  62)				_hx_tmp = (_this->endLine == 3);
            			}
            			else {
HXDLIN(  62)				_hx_tmp = true;
            			}
            		}
            		else {
HXDLIN(  62)			_hx_tmp = false;
            		}
HXDLIN(  62)		if (_hx_tmp) {
HXDLIN(  62)			Float ax = _this->ax;
HXDLIN(  62)			Float ay = _this->ay;
HXDLIN(  62)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  62)			Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN(  62)			Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) + ::Math_obj::PI);
HXDLIN(  62)			::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN(  62)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  62)			 ::Dynamic sides = 36;
HXDLIN(  62)			if (::hx::IsNull( sides )) {
HXDLIN(  62)				sides = 36;
            			}
HXDLIN(  62)			Float pi = ::Math_obj::PI;
HXDLIN(  62)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  62)			Float dif;
HXDLIN(  62)			switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            				case (int)0: {
HXDLIN(  62)					Float f;
HXDLIN(  62)					bool f1;
HXDLIN(  62)					if ((beta >= 0)) {
HXDLIN(  62)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f1 = false;
            					}
HXDLIN(  62)					if (f1) {
HXDLIN(  62)						f = beta;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f = a;
            						}
            						else {
HXDLIN(  62)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this1 = f;
HXDLIN(  62)					Float za = this1;
HXDLIN(  62)					Float f2;
HXDLIN(  62)					bool f3;
HXDLIN(  62)					if ((gamma >= 0)) {
HXDLIN(  62)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f3 = false;
            					}
HXDLIN(  62)					if (f3) {
HXDLIN(  62)						f2 = gamma;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f2 = a;
            						}
            						else {
HXDLIN(  62)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this2 = f2;
HXDLIN(  62)					Float zb = this2;
HXDLIN(  62)					Float fa = za;
HXDLIN(  62)					Float fb = zb;
HXDLIN(  62)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)					bool clockwise = (fa < fb);
HXDLIN(  62)					Float dif1;
HXDLIN(  62)					if (clockwise) {
HXDLIN(  62)						dif1 = theta;
            					}
            					else {
HXDLIN(  62)						dif1 = -(theta);
            					}
HXDLIN(  62)					if ((dif1 > 0)) {
HXDLIN(  62)						dif = dif1;
            					}
            					else {
HXDLIN(  62)						dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)1: {
HXDLIN(  62)					Float f;
HXDLIN(  62)					bool f1;
HXDLIN(  62)					if ((beta >= 0)) {
HXDLIN(  62)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f1 = false;
            					}
HXDLIN(  62)					if (f1) {
HXDLIN(  62)						f = beta;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f = a;
            						}
            						else {
HXDLIN(  62)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this1 = f;
HXDLIN(  62)					Float za = this1;
HXDLIN(  62)					Float f2;
HXDLIN(  62)					bool f3;
HXDLIN(  62)					if ((gamma >= 0)) {
HXDLIN(  62)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f3 = false;
            					}
HXDLIN(  62)					if (f3) {
HXDLIN(  62)						f2 = gamma;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f2 = a;
            						}
            						else {
HXDLIN(  62)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this2 = f2;
HXDLIN(  62)					Float zb = this2;
HXDLIN(  62)					Float fa = za;
HXDLIN(  62)					Float fb = zb;
HXDLIN(  62)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)					bool clockwise = (fa < fb);
HXDLIN(  62)					Float dif1;
HXDLIN(  62)					if (clockwise) {
HXDLIN(  62)						dif1 = theta;
            					}
            					else {
HXDLIN(  62)						dif1 = -(theta);
            					}
HXDLIN(  62)					if ((dif1 < 0)) {
HXDLIN(  62)						dif = dif1;
            					}
            					else {
HXDLIN(  62)						dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            					}
            				}
            				break;
            				case (int)2: {
HXDLIN(  62)					Float f;
HXDLIN(  62)					bool f1;
HXDLIN(  62)					if ((beta >= 0)) {
HXDLIN(  62)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f1 = false;
            					}
HXDLIN(  62)					if (f1) {
HXDLIN(  62)						f = beta;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f = a;
            						}
            						else {
HXDLIN(  62)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this1 = f;
HXDLIN(  62)					Float za = this1;
HXDLIN(  62)					Float f2;
HXDLIN(  62)					bool f3;
HXDLIN(  62)					if ((gamma >= 0)) {
HXDLIN(  62)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f3 = false;
            					}
HXDLIN(  62)					if (f3) {
HXDLIN(  62)						f2 = gamma;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f2 = a;
            						}
            						else {
HXDLIN(  62)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this2 = f2;
HXDLIN(  62)					Float zb = this2;
HXDLIN(  62)					Float fa = za;
HXDLIN(  62)					Float fb = zb;
HXDLIN(  62)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)					bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  62)					bool clockwise = (fa < fb);
HXDLIN(  62)					Float dif1;
HXDLIN(  62)					if (clockwise) {
HXDLIN(  62)						dif1 = theta;
            					}
            					else {
HXDLIN(  62)						dif1 = -(theta);
            					}
HXDLIN(  62)					if (smallest) {
HXDLIN(  62)						dif = dif1;
            					}
            					else {
HXDLIN(  62)						if (clockwise) {
HXDLIN(  62)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  62)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            				case (int)3: {
HXDLIN(  62)					Float f;
HXDLIN(  62)					bool f1;
HXDLIN(  62)					if ((beta >= 0)) {
HXDLIN(  62)						f1 = (beta > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f1 = false;
            					}
HXDLIN(  62)					if (f1) {
HXDLIN(  62)						f = beta;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f = a;
            						}
            						else {
HXDLIN(  62)							f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this1 = f;
HXDLIN(  62)					Float za = this1;
HXDLIN(  62)					Float f2;
HXDLIN(  62)					bool f3;
HXDLIN(  62)					if ((gamma >= 0)) {
HXDLIN(  62)						f3 = (gamma > ::Math_obj::PI);
            					}
            					else {
HXDLIN(  62)						f3 = false;
            					}
HXDLIN(  62)					if (f3) {
HXDLIN(  62)						f2 = gamma;
            					}
            					else {
HXDLIN(  62)						Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  62)						if ((a >= 0)) {
HXDLIN(  62)							f2 = a;
            						}
            						else {
HXDLIN(  62)							f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            						}
            					}
HXDLIN(  62)					Float this2 = f2;
HXDLIN(  62)					Float zb = this2;
HXDLIN(  62)					Float fa = za;
HXDLIN(  62)					Float fb = zb;
HXDLIN(  62)					Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  62)					bool largest = (theta > ::Math_obj::PI);
HXDLIN(  62)					bool clockwise = (fa < fb);
HXDLIN(  62)					Float dif1;
HXDLIN(  62)					if (clockwise) {
HXDLIN(  62)						dif1 = theta;
            					}
            					else {
HXDLIN(  62)						dif1 = -(theta);
            					}
HXDLIN(  62)					if (largest) {
HXDLIN(  62)						dif = dif1;
            					}
            					else {
HXDLIN(  62)						if (clockwise) {
HXDLIN(  62)							dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            						}
            						else {
HXDLIN(  62)							dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            						}
            					}
            				}
            				break;
            			}
HXDLIN(  62)			bool positive = (dif >= 0);
HXDLIN(  62)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  62)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  62)			Float angle = beta;
HXDLIN(  62)			Float cx;
HXDLIN(  62)			Float cy;
HXDLIN(  62)			Float bx = ( (Float)(0) );
HXDLIN(  62)			Float by = ( (Float)(0) );
HXDLIN(  62)			int p2 = temp->length;
HXDLIN(  62)			{
HXDLIN(  62)				int _g = 0;
HXDLIN(  62)				int _g1 = (totalSteps + 1);
HXDLIN(  62)				while((_g < _g1)){
HXDLIN(  62)					_g = (_g + 1);
HXDLIN(  62)					int i = (_g - 1);
HXDLIN(  62)					cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  62)					cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  62)					p2 = (p2 + 1);
HXDLIN(  62)					temp[(p2 - 1)] = cx;
HXDLIN(  62)					p2 = (p2 + 1);
HXDLIN(  62)					temp[(p2 - 1)] = cy;
HXDLIN(  62)					if ((i != 0)) {
HXDLIN(  62)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  62)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  62)						if (::hx::IsNotNull( m )) {
HXDLIN(  62)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  62)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  62)					angle = (angle + step1);
HXDLIN(  62)					bx = cx;
HXDLIN(  62)					by = cy;
            				}
            			}
HXDLIN(  62)			int len = totalSteps;
HXDLIN(  62)			{
HXDLIN(  62)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  62)				int color = -1;
HXDLIN(  62)				if ((color == -1)) {
HXDLIN(  62)					color = _this1->currentColor;
            				}
HXDLIN(  62)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
HXDLIN(  62)			int pA = _this->pointsAnti->length;
HXDLIN(  62)			int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN(  62)			int p4 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(4) )));
HXDLIN(  62)			{
HXDLIN(  62)				int _g2 = 0;
HXDLIN(  62)				int _g3 = p4;
HXDLIN(  62)				while((_g2 < _g3)){
HXDLIN(  62)					_g2 = (_g2 + 1);
HXDLIN(  62)					int i = (_g2 - 1);
HXDLIN(  62)					pA = (pA + 1);
HXDLIN(  62)					_this->pointsAnti[(pA - 1)] = temp->__get(((len1 - (2 * i)) + 1));
HXDLIN(  62)					pA = (pA + 1);
HXDLIN(  62)					_this->pointsAnti[(pA - 1)] = temp->__get((len1 - (2 * i)));
            				}
            			}
HXDLIN(  62)			int pC = _this->pointsClock->length;
HXDLIN(  62)			{
HXDLIN(  62)				int _g4 = 0;
HXDLIN(  62)				int _g5 = p4;
HXDLIN(  62)				while((_g4 < _g5)){
HXDLIN(  62)					_g4 = (_g4 + 1);
HXDLIN(  62)					int i = (_g4 - 1);
HXDLIN(  62)					pC = (pC + 1);
HXDLIN(  62)					_this->pointsClock[(pC - 1)] = temp->__get((((i * 2) + len1) + 1));
HXDLIN(  62)					pC = (pC + 1);
HXDLIN(  62)					_this->pointsClock[(pC - 1)] = temp->__get(((i * 2) + len1));
            				}
            			}
            		}
HXDLIN(  62)		{
HXDLIN(  62)			{
HXDLIN(  62)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  62)				int color = -1;
HXDLIN(  62)				if ((color == -1)) {
HXDLIN(  62)					color = _this1->currentColor;
            				}
HXDLIN(  62)				{
HXDLIN(  62)					_this1->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->ex) ),( (Float)(_this->ey) ),0);
HXDLIN(  62)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  62)						_this1->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  62)					_this1->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  62)				_this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color,color,color);
            			}
HXDLIN(  62)			{
HXDLIN(  62)				 ::trilateral3::drawing::Pen _this2 = _this->pen;
HXDLIN(  62)				int color1 = -1;
HXDLIN(  62)				if ((color1 == -1)) {
HXDLIN(  62)					color1 = _this2->currentColor;
            				}
HXDLIN(  62)				{
HXDLIN(  62)					_this2->drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(( (Float)(_this->dxPrev) ),( (Float)(_this->dyPrev) ),0,( (Float)(_this->dx) ),( (Float)(_this->dy) ),0,( (Float)(_this->exPrev) ),( (Float)(_this->eyPrev) ),0);
HXDLIN(  62)					if (::hx::IsNotNull( ::trilateral3::Trilateral_obj::transformMatrix )) {
HXDLIN(  62)						_this2->drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(::trilateral3::Trilateral_obj::transformMatrix);
            					}
HXDLIN(  62)					_this2->drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  62)				_this2->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(color1,color1,color1);
            			}
            		}
HXDLIN(  62)		if (clockWise) {
HXDLIN(  62)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  62)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  62)			::Array< Float > edgePoly = _this->pointsClock;
HXDLIN(  62)			Float pi = ::Math_obj::PI;
HXDLIN(  62)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  62)			bool positive = (dif >= 0);
HXDLIN(  62)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  62)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  62)			Float angle = theta0;
HXDLIN(  62)			Float cx;
HXDLIN(  62)			Float cy;
HXDLIN(  62)			Float bx = ( (Float)(0) );
HXDLIN(  62)			Float by = ( (Float)(0) );
HXDLIN(  62)			int p2 = edgePoly->length;
HXDLIN(  62)			{
HXDLIN(  62)				int _g = 0;
HXDLIN(  62)				int _g1 = (totalSteps + 1);
HXDLIN(  62)				while((_g < _g1)){
HXDLIN(  62)					_g = (_g + 1);
HXDLIN(  62)					int i = (_g - 1);
HXDLIN(  62)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  62)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  62)					p2 = (p2 + 1);
HXDLIN(  62)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  62)					p2 = (p2 + 1);
HXDLIN(  62)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  62)					if ((i != 0)) {
HXDLIN(  62)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  62)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  62)						if (::hx::IsNotNull( m )) {
HXDLIN(  62)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  62)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  62)					angle = (angle + step1);
HXDLIN(  62)					bx = cx;
HXDLIN(  62)					by = cy;
            				}
            			}
HXDLIN(  62)			int len = totalSteps;
HXDLIN(  62)			{
HXDLIN(  62)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  62)				int color = -1;
HXDLIN(  62)				if ((color == -1)) {
HXDLIN(  62)					color = _this1->currentColor;
            				}
HXDLIN(  62)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
            		else {
HXDLIN(  62)			 ::Dynamic drawType = _this->pen->drawType;
HXDLIN(  62)			Float radius = (width_ / ( (Float)(2) ));
HXDLIN(  62)			::Array< Float > edgePoly = _this->pointsAnti;
HXDLIN(  62)			Float pi = ::Math_obj::PI;
HXDLIN(  62)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  62)			bool positive = (dif >= 0);
HXDLIN(  62)			int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  62)			Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  62)			Float angle = theta0;
HXDLIN(  62)			Float cx;
HXDLIN(  62)			Float cy;
HXDLIN(  62)			Float bx = ( (Float)(0) );
HXDLIN(  62)			Float by = ( (Float)(0) );
HXDLIN(  62)			int p2 = edgePoly->length;
HXDLIN(  62)			{
HXDLIN(  62)				int _g = 0;
HXDLIN(  62)				int _g1 = (totalSteps + 1);
HXDLIN(  62)				while((_g < _g1)){
HXDLIN(  62)					_g = (_g + 1);
HXDLIN(  62)					int i = (_g - 1);
HXDLIN(  62)					cx = (ax_ + (radius * ::Math_obj::sin(angle)));
HXDLIN(  62)					cy = (ay_ + (radius * ::Math_obj::cos(angle)));
HXDLIN(  62)					p2 = (p2 + 1);
HXDLIN(  62)					edgePoly[(p2 - 1)] = cx;
HXDLIN(  62)					p2 = (p2 + 1);
HXDLIN(  62)					edgePoly[(p2 - 1)] = cy;
HXDLIN(  62)					if ((i != 0)) {
HXDLIN(  62)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax_,ay_,0,bx,by,0,cx,cy,0);
HXDLIN(  62)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  62)						if (::hx::IsNotNull( m )) {
HXDLIN(  62)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN(  62)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN(  62)					angle = (angle + step1);
HXDLIN(  62)					bx = cx;
HXDLIN(  62)					by = cy;
            				}
            			}
HXDLIN(  62)			int len = totalSteps;
HXDLIN(  62)			{
HXDLIN(  62)				 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN(  62)				int color = -1;
HXDLIN(  62)				if ((color == -1)) {
HXDLIN(  62)					color = _this1->currentColor;
            				}
HXDLIN(  62)				_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  62)		{
HXDLIN(  62)			_this->kax = ( (Float)(_this->dxPrev) );
HXDLIN(  62)			_this->kay = ( (Float)(_this->dyPrev) );
HXDLIN(  62)			_this->kbx = ( (Float)(_this->dx) );
HXDLIN(  62)			_this->kby = ( (Float)(_this->dy) );
HXDLIN(  62)			_this->ncx = ( (Float)(_this->exPrev) );
HXDLIN(  62)			_this->ncy = ( (Float)(_this->eyPrev) );
HXDLIN(  62)			_this->kcx = ( (Float)(_this->ex) );
HXDLIN(  62)			_this->kcy = ( (Float)(_this->ey) );
            		}
HXDLIN(  62)		_this->jxOld = _this->jx;
HXDLIN(  62)		_this->jyOld = _this->jy;
HXDLIN(  62)		_this->lastClock = clockWise;
HXDLIN(  62)		_this->count++;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,fineOverlapLine,(void))

void Sketch_obj::reset(){
            	HX_GC_STACKFRAME(&_hx_pos_6351d8d914bc61da_98_reset)
HXLINE( 100)		this->contour =  ::trilateral3::drawing::Contour_obj::__alloc( HX_CTX ,this->pen,this->endLine);
HXLINE( 101)		this->points = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 102)		this->pointsClock = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 103)		this->pointsAnti = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 104)		this->points[0] = ::Array_obj< Float >::__new();
HXLINE( 105)		this->dim = ::Array_obj< ::Dynamic>::__new();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketch_obj,reset,(void))

::Array< ::Dynamic> Sketch_obj::pointsNoEndOverlap(){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_107_pointsNoEndOverlap)
HXLINE( 108)		::Array< Float > p;
HXLINE( 109)		int l;
HXLINE( 110)		int j = 0;
HXLINE( 111)		::Array< ::Dynamic> pointsClean = ::Array_obj< ::Dynamic>::__new();
HXLINE( 112)		{
HXLINE( 112)			int _g = 0;
HXDLIN( 112)			int _g1 = this->points->length;
HXDLIN( 112)			while((_g < _g1)){
HXLINE( 112)				_g = (_g + 1);
HXDLIN( 112)				int i = (_g - 1);
HXLINE( 113)				p = this->points->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 114)				if ((p->length > 2)) {
HXLINE( 114)					j = (j + 1);
HXDLIN( 114)					pointsClean[(j - 1)] = p;
            				}
            			}
            		}
HXLINE( 116)		this->points = pointsClean;
HXLINE( 117)		{
HXLINE( 117)			int _g2 = 0;
HXDLIN( 117)			int _g3 = this->points->length;
HXDLIN( 117)			while((_g2 < _g3)){
HXLINE( 117)				_g2 = (_g2 + 1);
HXDLIN( 117)				int i = (_g2 - 1);
HXLINE( 118)				p = this->points->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 119)				l = p->length;
HXLINE( 120)				bool repeat;
HXDLIN( 120)				if ((p->__get(0) == p->__get((l - 2)))) {
HXLINE( 120)					repeat = (p->__get(1) == p->__get((l - 1)));
            				}
            				else {
HXLINE( 120)					repeat = false;
            				}
HXLINE( 121)				if (repeat) {
HXLINE( 122)					this->points->__get(i).StaticCast< ::Array< Float > >()->pop();
HXLINE( 123)					this->points->__get(i).StaticCast< ::Array< Float > >()->pop();
HXLINE( 124)					l = (l - 2);
            				}
            			}
            		}
HXLINE( 159)		return this->points;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketch_obj,pointsNoEndOverlap,return )

::Array< ::Dynamic> Sketch_obj::pointsRewound(){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_161_pointsRewound)
HXLINE( 162)		::Array< Float > p;
HXLINE( 163)		int l;
HXLINE( 164)		int j = 0;
HXLINE( 165)		::Array< ::Dynamic> pointsClean = ::Array_obj< ::Dynamic>::__new();
HXLINE( 166)		{
HXLINE( 166)			int _g = 0;
HXDLIN( 166)			int _g1 = this->points->length;
HXDLIN( 166)			while((_g < _g1)){
HXLINE( 166)				_g = (_g + 1);
HXDLIN( 166)				int i = (_g - 1);
HXLINE( 167)				p = this->points->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 168)				if ((p->length > 2)) {
HXLINE( 168)					j = (j + 1);
HXDLIN( 168)					pointsClean[(j - 1)] = p;
            				}
            			}
            		}
HXLINE( 170)		this->points = pointsClean;
HXLINE( 172)		{
HXLINE( 172)			int _g2 = 0;
HXDLIN( 172)			int _g3 = this->points->length;
HXDLIN( 172)			while((_g2 < _g3)){
HXLINE( 172)				_g2 = (_g2 + 1);
HXDLIN( 172)				int i = (_g2 - 1);
HXLINE( 173)				p = this->points->__get(i).StaticCast< ::Array< Float > >();
HXLINE( 174)				l = p->length;
HXLINE( 176)				bool repeat;
HXDLIN( 176)				if ((p->__get(0) == p->__get((l - 2)))) {
HXLINE( 176)					repeat = (p->__get(1) == p->__get((l - 1)));
            				}
            				else {
HXLINE( 176)					repeat = false;
            				}
HXLINE( 177)				if (repeat) {
HXLINE( 178)					this->points->__get(i).StaticCast< ::Array< Float > >()->pop();
HXLINE( 179)					this->points->__get(i).StaticCast< ::Array< Float > >()->pop();
HXLINE( 180)					l = (l - 2);
            				}
HXLINE( 183)				Float cc = ((Float)0.);
HXLINE( 184)				int k = 0;
HXLINE( 185)				Float x1;
HXLINE( 186)				Float y1;
HXLINE( 187)				Float x2;
HXLINE( 188)				Float y2;
HXLINE( 189)				int last = (l - 2);
HXLINE( 190)				while((k < l)){
HXLINE( 191)					x1 = p->__get(k);
HXLINE( 192)					y1 = p->__get((k + 1));
HXLINE( 193)					if ((k == last)) {
HXLINE( 194)						x2 = p->__get(0);
HXLINE( 195)						y2 = p->__get(1);
            					}
            					else {
HXLINE( 197)						x2 = p->__get((k + 2));
HXLINE( 198)						y2 = p->__get((k + 3));
            					}
HXLINE( 200)					cc = (cc + ((x2 - x1) * (y2 + y1)));
HXLINE( 201)					k = (k + 2);
            				}
HXLINE( 216)				this->points[i] = p;
            			}
            		}
HXLINE( 218)		return this->points;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketch_obj,pointsRewound,return )

 ::Dynamic Sketch_obj::initDim(){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_222_initDim)
HXDLIN( 222)		return  ::Dynamic(::hx::Anon_obj::Create(4)
            			->setFixed(0,HX_("maxX",34,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(1,HX_("maxY",35,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(2,HX_("minX",86,4e,5c,48),::Math_obj::POSITIVE_INFINITY)
            			->setFixed(3,HX_("minY",87,4e,5c,48),::Math_obj::POSITIVE_INFINITY));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketch_obj,initDim,return )

void Sketch_obj::updateDim(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_224_updateDim)
HXLINE( 225)		 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXLINE( 226)		if (::hx::IsLess( x,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 226)			d->__SetField(HX_("minX",86,4e,5c,48),x,::hx::paccDynamic);
            		}
HXLINE( 227)		if (::hx::IsGreater( x,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 227)			d->__SetField(HX_("maxX",34,45,56,48),x,::hx::paccDynamic);
            		}
HXLINE( 228)		if (::hx::IsLess( y,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 228)			d->__SetField(HX_("minY",87,4e,5c,48),y,::hx::paccDynamic);
            		}
HXLINE( 229)		if (::hx::IsGreater( y,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 229)			d->__SetField(HX_("maxY",35,45,56,48),y,::hx::paccDynamic);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,updateDim,(void))

void Sketch_obj::moveTo(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_231_moveTo)
HXLINE( 232)		bool _hx_tmp;
HXDLIN( 232)		if ((this->endLine != 2)) {
HXLINE( 232)			_hx_tmp = (this->endLine == 3);
            		}
            		else {
HXLINE( 232)			_hx_tmp = true;
            		}
HXDLIN( 232)		if (_hx_tmp) {
HXLINE( 232)			 ::trilateral3::drawing::Contour _this = this->contour;
HXDLIN( 232)			Float width_ = this->width;
HXDLIN( 232)			_this->endEdges();
HXDLIN( 232)			if ((_this->count != 0)) {
HXLINE( 232)				Float ax = _this->bx;
HXDLIN( 232)				Float ay = _this->by;
HXDLIN( 232)				Float radius = (width_ / ( (Float)(2) ));
HXDLIN( 232)				Float beta = (-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) )));
HXDLIN( 232)				Float gamma = ((-(_this->angle1) - (::Math_obj::PI / ( (Float)(2) ))) - ::Math_obj::PI);
HXDLIN( 232)				::Array< Float > temp = ::Array_obj< Float >::__new();
HXDLIN( 232)				 ::Dynamic drawType = _this->pen->drawType;
HXDLIN( 232)				 ::Dynamic sides = 36;
HXDLIN( 232)				if (::hx::IsNull( sides )) {
HXLINE( 232)					sides = 36;
            				}
HXDLIN( 232)				Float pi = ::Math_obj::PI;
HXDLIN( 232)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 232)				Float dif;
HXDLIN( 232)				switch((int)(::fracs::DifferencePreference_obj::SMALL_dyn()->_hx_getIndex())){
            					case (int)0: {
HXLINE( 232)						Float f;
HXDLIN( 232)						bool f1;
HXDLIN( 232)						if ((beta >= 0)) {
HXLINE( 232)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f1 = false;
            						}
HXDLIN( 232)						if (f1) {
HXLINE( 232)							f = beta;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f = a;
            							}
            							else {
HXLINE( 232)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this1 = f;
HXDLIN( 232)						Float za = this1;
HXDLIN( 232)						Float f2;
HXDLIN( 232)						bool f3;
HXDLIN( 232)						if ((gamma >= 0)) {
HXLINE( 232)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f3 = false;
            						}
HXDLIN( 232)						if (f3) {
HXLINE( 232)							f2 = gamma;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f2 = a;
            							}
            							else {
HXLINE( 232)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this2 = f2;
HXDLIN( 232)						Float zb = this2;
HXDLIN( 232)						Float fa = za;
HXDLIN( 232)						Float fb = zb;
HXDLIN( 232)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 232)						bool clockwise = (fa < fb);
HXDLIN( 232)						Float dif1;
HXDLIN( 232)						if (clockwise) {
HXLINE( 232)							dif1 = theta;
            						}
            						else {
HXLINE( 232)							dif1 = -(theta);
            						}
HXDLIN( 232)						if ((dif1 > 0)) {
HXLINE( 232)							dif = dif1;
            						}
            						else {
HXLINE( 232)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXLINE( 232)						Float f;
HXDLIN( 232)						bool f1;
HXDLIN( 232)						if ((beta >= 0)) {
HXLINE( 232)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f1 = false;
            						}
HXDLIN( 232)						if (f1) {
HXLINE( 232)							f = beta;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f = a;
            							}
            							else {
HXLINE( 232)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this1 = f;
HXDLIN( 232)						Float za = this1;
HXDLIN( 232)						Float f2;
HXDLIN( 232)						bool f3;
HXDLIN( 232)						if ((gamma >= 0)) {
HXLINE( 232)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f3 = false;
            						}
HXDLIN( 232)						if (f3) {
HXLINE( 232)							f2 = gamma;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f2 = a;
            							}
            							else {
HXLINE( 232)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this2 = f2;
HXDLIN( 232)						Float zb = this2;
HXDLIN( 232)						Float fa = za;
HXDLIN( 232)						Float fb = zb;
HXDLIN( 232)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 232)						bool clockwise = (fa < fb);
HXDLIN( 232)						Float dif1;
HXDLIN( 232)						if (clockwise) {
HXLINE( 232)							dif1 = theta;
            						}
            						else {
HXLINE( 232)							dif1 = -(theta);
            						}
HXDLIN( 232)						if ((dif1 < 0)) {
HXLINE( 232)							dif = dif1;
            						}
            						else {
HXLINE( 232)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXLINE( 232)						Float f;
HXDLIN( 232)						bool f1;
HXDLIN( 232)						if ((beta >= 0)) {
HXLINE( 232)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f1 = false;
            						}
HXDLIN( 232)						if (f1) {
HXLINE( 232)							f = beta;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f = a;
            							}
            							else {
HXLINE( 232)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this1 = f;
HXDLIN( 232)						Float za = this1;
HXDLIN( 232)						Float f2;
HXDLIN( 232)						bool f3;
HXDLIN( 232)						if ((gamma >= 0)) {
HXLINE( 232)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f3 = false;
            						}
HXDLIN( 232)						if (f3) {
HXLINE( 232)							f2 = gamma;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f2 = a;
            							}
            							else {
HXLINE( 232)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this2 = f2;
HXDLIN( 232)						Float zb = this2;
HXDLIN( 232)						Float fa = za;
HXDLIN( 232)						Float fb = zb;
HXDLIN( 232)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 232)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 232)						bool clockwise = (fa < fb);
HXDLIN( 232)						Float dif1;
HXDLIN( 232)						if (clockwise) {
HXLINE( 232)							dif1 = theta;
            						}
            						else {
HXLINE( 232)							dif1 = -(theta);
            						}
HXDLIN( 232)						if (smallest) {
HXLINE( 232)							dif = dif1;
            						}
            						else {
HXLINE( 232)							if (clockwise) {
HXLINE( 232)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 232)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXLINE( 232)						Float f;
HXDLIN( 232)						bool f1;
HXDLIN( 232)						if ((beta >= 0)) {
HXLINE( 232)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f1 = false;
            						}
HXDLIN( 232)						if (f1) {
HXLINE( 232)							f = beta;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f = a;
            							}
            							else {
HXLINE( 232)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this1 = f;
HXDLIN( 232)						Float za = this1;
HXDLIN( 232)						Float f2;
HXDLIN( 232)						bool f3;
HXDLIN( 232)						if ((gamma >= 0)) {
HXLINE( 232)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE( 232)							f3 = false;
            						}
HXDLIN( 232)						if (f3) {
HXLINE( 232)							f2 = gamma;
            						}
            						else {
HXLINE( 232)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 232)							if ((a >= 0)) {
HXLINE( 232)								f2 = a;
            							}
            							else {
HXLINE( 232)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN( 232)						Float this2 = f2;
HXDLIN( 232)						Float zb = this2;
HXDLIN( 232)						Float fa = za;
HXDLIN( 232)						Float fb = zb;
HXDLIN( 232)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 232)						bool largest = (theta > ::Math_obj::PI);
HXDLIN( 232)						bool clockwise = (fa < fb);
HXDLIN( 232)						Float dif1;
HXDLIN( 232)						if (clockwise) {
HXLINE( 232)							dif1 = theta;
            						}
            						else {
HXLINE( 232)							dif1 = -(theta);
            						}
HXDLIN( 232)						if (largest) {
HXLINE( 232)							dif = dif1;
            						}
            						else {
HXLINE( 232)							if (clockwise) {
HXLINE( 232)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE( 232)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN( 232)				bool positive = (dif >= 0);
HXDLIN( 232)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 232)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 232)				Float angle = beta;
HXDLIN( 232)				Float cx;
HXDLIN( 232)				Float cy;
HXDLIN( 232)				Float bx = ( (Float)(0) );
HXDLIN( 232)				Float by = ( (Float)(0) );
HXDLIN( 232)				int p2 = temp->length;
HXDLIN( 232)				{
HXLINE( 232)					int _g = 0;
HXDLIN( 232)					int _g1 = (totalSteps + 1);
HXDLIN( 232)					while((_g < _g1)){
HXLINE( 232)						_g = (_g + 1);
HXDLIN( 232)						int i = (_g - 1);
HXDLIN( 232)						cx = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 232)						cy = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 232)						p2 = (p2 + 1);
HXDLIN( 232)						temp[(p2 - 1)] = cx;
HXDLIN( 232)						p2 = (p2 + 1);
HXDLIN( 232)						temp[(p2 - 1)] = cy;
HXDLIN( 232)						if ((i != 0)) {
HXLINE( 232)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 232)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 232)							if (::hx::IsNotNull( m )) {
HXLINE( 232)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN( 232)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 232)						angle = (angle + step1);
HXDLIN( 232)						bx = cx;
HXDLIN( 232)						by = cy;
            					}
            				}
HXDLIN( 232)				int len = totalSteps;
HXDLIN( 232)				{
HXLINE( 232)					 ::trilateral3::drawing::Pen _this1 = _this->pen;
HXDLIN( 232)					int color = 0;
HXDLIN( 232)					if ((color == -1)) {
HXLINE( 232)						color = _this1->currentColor;
            					}
HXDLIN( 232)					_this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            				}
HXDLIN( 232)				int pA = _this->pointsAnti->length;
HXDLIN( 232)				int len1 = ::Std_obj::_hx_int((( (Float)(temp->length) ) / ( (Float)(2) )));
HXDLIN( 232)				{
HXLINE( 232)					int _g2 = 0;
HXDLIN( 232)					int _g3 = (len1 + 2);
HXDLIN( 232)					while((_g2 < _g3)){
HXLINE( 232)						_g2 = (_g2 + 1);
HXDLIN( 232)						int i = (_g2 - 1);
HXDLIN( 232)						pA = (pA + 1);
HXDLIN( 232)						_this->pointsAnti[(pA - 1)] = temp->__get(i);
            					}
            				}
HXDLIN( 232)				int pC = _this->pointsClock->length;
HXDLIN( 232)				{
HXLINE( 232)					int _g4 = 1;
HXDLIN( 232)					int _g5 = ::Std_obj::_hx_int(((( (Float)(len1) ) / ( (Float)(2) )) + 1));
HXDLIN( 232)					while((_g4 < _g5)){
HXLINE( 232)						_g4 = (_g4 + 1);
HXDLIN( 232)						int i = (_g4 - 1);
HXDLIN( 232)						pC = (pC + 1);
HXDLIN( 232)						_this->pointsClock[(pC - 1)] = temp->__get((temp->length - (2 * i)));
HXDLIN( 232)						pC = (pC + 1);
HXDLIN( 232)						_this->pointsClock[(pC - 1)] = temp->__get(((temp->length - (2 * i)) - 1));
            					}
            				}
            			}
            		}
HXLINE( 233)		this->x = x_;
HXLINE( 234)		this->y = y_;
HXLINE( 235)		int l = this->points->length;
HXLINE( 236)		this->points[l] = ::Array_obj< Float >::__new();
HXLINE( 237)		this->points->__get(l).StaticCast< ::Array< Float > >()[0] = x_;
HXLINE( 238)		this->points->__get(l).StaticCast< ::Array< Float > >()[1] = y_;
HXLINE( 241)		this->pointsClock[this->pointsClock->length] = this->contour->pointsClock->copy();
HXLINE( 242)		this->pointsAnti[this->pointsAnti->length] = this->contour->pointsAnti->copy();
HXLINE( 244)		this->dim[this->dim->length] =  ::Dynamic(::hx::Anon_obj::Create(4)
            			->setFixed(0,HX_("maxX",34,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(1,HX_("maxY",35,45,56,48),::Math_obj::NEGATIVE_INFINITY)
            			->setFixed(2,HX_("minX",86,4e,5c,48),::Math_obj::POSITIVE_INFINITY)
            			->setFixed(3,HX_("minY",87,4e,5c,48),::Math_obj::POSITIVE_INFINITY));
HXLINE( 245)		{
HXLINE( 245)			 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 245)			if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 245)				d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            			}
HXDLIN( 245)			if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 245)				d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            			}
HXDLIN( 245)			if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 245)				d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            			}
HXDLIN( 245)			if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 245)				d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            			}
            		}
HXLINE( 246)		this->contour->reset();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,moveTo,(void))

void Sketch_obj::lastClock(){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_250_lastClock)
HXDLIN( 250)		if ((this->contour->pointsClock->length != 0)) {
HXLINE( 252)			this->pointsClock[this->pointsClock->length] = this->contour->pointsClock->copy();
HXLINE( 253)			this->pointsAnti[this->pointsAnti->length] = this->contour->pointsAnti->copy();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketch_obj,lastClock,(void))

::Array< ::Dynamic> Sketch_obj::getEdges(){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_259_getEdges)
HXLINE( 260)		::Array< ::Dynamic> edges = ::Array_obj< ::Dynamic>::__new();
HXLINE( 261)		int no = this->pointsClock->length;
HXLINE( 262)		if ((no > this->pointsAnti->length)) {
HXLINE( 262)			no = this->pointsAnti->length;
            		}
HXLINE( 263)		::Array< Float > pClock;
HXLINE( 264)		::Array< Float > pAnti;
HXLINE( 265)		::Array< Float > shape;
HXLINE( 266)		{
HXLINE( 266)			int _g = 0;
HXDLIN( 266)			int _g1 = no;
HXDLIN( 266)			while((_g < _g1)){
HXLINE( 266)				_g = (_g + 1);
HXDLIN( 266)				int s = (_g - 1);
HXLINE( 267)				pClock = this->pointsClock->__get(s).StaticCast< ::Array< Float > >();
HXLINE( 268)				pAnti = this->pointsAnti->__get(s).StaticCast< ::Array< Float > >();
HXLINE( 269)				int lc = pClock->length;
HXLINE( 270)				int la = pAnti->length;
HXLINE( 271)				edges[s] = ::Array_obj< Float >::__new();
HXLINE( 272)				shape = edges->__get(s).StaticCast< ::Array< Float > >();
HXLINE( 273)				{
HXLINE( 273)					int _g1 = 0;
HXDLIN( 273)					int _g2 = lc;
HXDLIN( 273)					while((_g1 < _g2)){
HXLINE( 273)						_g1 = (_g1 + 1);
HXDLIN( 273)						int i = (_g1 - 1);
HXDLIN( 273)						shape[i] = pClock->__get(i);
            					}
            				}
HXLINE( 274)				int j = shape->length;
HXLINE( 275)				int l5 = ::Std_obj::_hx_int((( (Float)(la) ) / ( (Float)(2) )));
HXLINE( 276)				{
HXLINE( 276)					int _g3 = 0;
HXDLIN( 276)					int _g4 = l5;
HXDLIN( 276)					while((_g3 < _g4)){
HXLINE( 276)						_g3 = (_g3 + 1);
HXDLIN( 276)						int i = (_g3 - 1);
HXLINE( 277)						shape[(j + (i * 2))] = pAnti->__get(((la - (i * 2)) - 1));
HXLINE( 278)						shape[((j + (i * 2)) + 1)] = pAnti->__get((la - (i * 2)));
            					}
            				}
HXLINE( 280)				j = shape->length;
HXLINE( 281)				j = (j + 1);
HXDLIN( 281)				shape[(j - 1)] = pClock->__get(0);
HXLINE( 282)				shape[j] = pClock->__get(1);
            			}
            		}
HXLINE( 284)		return edges;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sketch_obj,getEdges,return )

void Sketch_obj::lineTo(Float x_,Float y_){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_287_lineTo)
HXLINE( 288)		bool repeat;
HXDLIN( 288)		if ((this->x == x_)) {
HXLINE( 288)			repeat = (this->y == y_);
            		}
            		else {
HXLINE( 288)			repeat = false;
            		}
HXLINE( 289)		if (!(repeat)) {
HXLINE( 290)			if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 290)				this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            			}
HXLINE( 291)			if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 291)				this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            			}
HXLINE( 292)			this->line(x_,y_);
HXLINE( 293)			int l = this->points->length;
HXLINE( 294)			::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXLINE( 295)			int l2 = p->length;
HXLINE( 296)			p[l2] = x_;
HXLINE( 297)			p[(l2 + 1)] = y_;
HXLINE( 298)			{
HXLINE( 298)				 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 298)				if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 298)					d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            				}
HXDLIN( 298)				if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 298)					d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            				}
HXDLIN( 298)				if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 298)					d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            				}
HXDLIN( 298)				if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 298)					d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            				}
            			}
HXLINE( 299)			this->x = x_;
HXLINE( 300)			this->y = y_;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,lineTo,(void))

void Sketch_obj::quadTo(Float x1,Float y1,Float x2,Float y2){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_304_quadTo)
HXLINE( 305)		this->tempArr = ::Array_obj< Float >::__new(0);
HXLINE( 306)		{
HXLINE( 306)			::Array< Float > p = this->tempArr;
HXDLIN( 306)			Float ax = this->x;
HXDLIN( 306)			Float ay = this->y;
HXDLIN( 306)			Float x = (ax - x1);
HXDLIN( 306)			Float y = (ay - y1);
HXDLIN( 306)			Float x3 = (x1 - x2);
HXDLIN( 306)			Float y3 = (y1 - y2);
HXDLIN( 306)			Float approxDistance = (::Math_obj::sqrt(((x * x) + (y * y))) + ::Math_obj::sqrt(((x3 * x3) + (y3 * y3))));
HXDLIN( 306)			if ((approxDistance == 0)) {
HXLINE( 306)				approxDistance = ((Float)0.000001);
            			}
HXDLIN( 306)			Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),::trilateral3::math::_Algebra::Algebra_Fields__obj::quadStep);
HXDLIN( 306)			int l = p->length;
HXDLIN( 306)			l = (l + 1);
HXDLIN( 306)			p[(l - 1)] = ax;
HXDLIN( 306)			l = (l + 1);
HXDLIN( 306)			p[(l - 1)] = ay;
HXDLIN( 306)			Float t = step;
HXDLIN( 306)			while((t < ((Float)1.))){
HXLINE( 306)				l = (l + 1);
HXDLIN( 306)				Float u = (( (Float)(1) ) - t);
HXDLIN( 306)				p[(l - 1)] = (((::Math_obj::pow(u,( (Float)(2) )) * ax) + (((( (Float)(2) ) * u) * t) * x1)) + (::Math_obj::pow(t,( (Float)(2) )) * x2));
HXDLIN( 306)				l = (l + 1);
HXDLIN( 306)				Float u1 = (( (Float)(1) ) - t);
HXDLIN( 306)				p[(l - 1)] = (((::Math_obj::pow(u1,( (Float)(2) )) * ay) + (((( (Float)(2) ) * u1) * t) * y1)) + (::Math_obj::pow(t,( (Float)(2) )) * y2));
HXDLIN( 306)				t = (t + step);
            			}
HXDLIN( 306)			l = (l + 1);
HXDLIN( 306)			p[(l - 1)] = x2;
HXDLIN( 306)			l = (l + 1);
HXDLIN( 306)			p[(l - 1)] = y2;
            		}
HXLINE( 307)		{
HXLINE( 307)			::Array< Float > arr = this->tempArr;
HXDLIN( 307)			 ::Dynamic withMove = false;
HXDLIN( 307)			if (::hx::IsNull( withMove )) {
HXLINE( 307)				withMove = true;
            			}
HXDLIN( 307)			int l1 = arr->length;
HXDLIN( 307)			int i = 2;
HXDLIN( 307)			if (( (bool)(withMove) )) {
HXLINE( 307)				this->moveTo(arr->__get(0),arr->__get(1));
            			}
            			else {
HXLINE( 307)				Float x_ = arr->__get(0);
HXDLIN( 307)				Float y_ = arr->__get(1);
HXDLIN( 307)				bool repeat;
HXDLIN( 307)				if ((this->x == x_)) {
HXLINE( 307)					repeat = (this->y == y_);
            				}
            				else {
HXLINE( 307)					repeat = false;
            				}
HXDLIN( 307)				if (!(repeat)) {
HXLINE( 307)					if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 307)						this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 307)					if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 307)						this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 307)					this->line(x_,y_);
HXDLIN( 307)					int l = this->points->length;
HXDLIN( 307)					::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 307)					int l2 = p->length;
HXDLIN( 307)					p[l2] = x_;
HXDLIN( 307)					p[(l2 + 1)] = y_;
HXDLIN( 307)					{
HXLINE( 307)						 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 307)						if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 307)							d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 307)						if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 307)							d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 307)						if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 307)							d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            						}
HXDLIN( 307)						if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 307)							d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            						}
            					}
HXDLIN( 307)					this->x = x_;
HXDLIN( 307)					this->y = y_;
            				}
            			}
HXDLIN( 307)			while((i < l1)){
HXLINE( 307)				{
HXLINE( 307)					Float x_ = arr->__get(i);
HXDLIN( 307)					Float y_ = arr->__get((i + 1));
HXDLIN( 307)					bool repeat;
HXDLIN( 307)					if ((this->x == x_)) {
HXLINE( 307)						repeat = (this->y == y_);
            					}
            					else {
HXLINE( 307)						repeat = false;
            					}
HXDLIN( 307)					if (!(repeat)) {
HXLINE( 307)						if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 307)							this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 307)						if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 307)							this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 307)						this->line(x_,y_);
HXDLIN( 307)						int l = this->points->length;
HXDLIN( 307)						::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 307)						int l2 = p->length;
HXDLIN( 307)						p[l2] = x_;
HXDLIN( 307)						p[(l2 + 1)] = y_;
HXDLIN( 307)						{
HXLINE( 307)							 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 307)							if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 307)								d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 307)							if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 307)								d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 307)							if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 307)								d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            							}
HXDLIN( 307)							if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 307)								d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            							}
            						}
HXDLIN( 307)						this->x = x_;
HXDLIN( 307)						this->y = y_;
            					}
            				}
HXDLIN( 307)				i = (i + 2);
            			}
            		}
HXLINE( 308)		this->x = x2;
HXLINE( 309)		this->y = y2;
            	}


HX_DEFINE_DYNAMIC_FUNC4(Sketch_obj,quadTo,(void))

void Sketch_obj::quadThru(Float x1,Float y1,Float x2,Float y2){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_313_quadThru)
HXLINE( 314)		Float newx = ((( (Float)(2) ) * x1) - (((Float)0.5) * (this->x + x2)));
HXLINE( 315)		Float newy = ((( (Float)(2) ) * y1) - (((Float)0.5) * (this->y + y2)));
HXLINE( 316)		{
HXLINE( 316)			this->tempArr = ::Array_obj< Float >::__new(0);
HXDLIN( 316)			{
HXLINE( 316)				::Array< Float > p = this->tempArr;
HXDLIN( 316)				Float ax = this->x;
HXDLIN( 316)				Float ay = this->y;
HXDLIN( 316)				Float x = (ax - newx);
HXDLIN( 316)				Float y = (ay - newy);
HXDLIN( 316)				Float x3 = (newx - x2);
HXDLIN( 316)				Float y3 = (newy - y2);
HXDLIN( 316)				Float approxDistance = (::Math_obj::sqrt(((x * x) + (y * y))) + ::Math_obj::sqrt(((x3 * x3) + (y3 * y3))));
HXDLIN( 316)				if ((approxDistance == 0)) {
HXLINE( 316)					approxDistance = ((Float)0.000001);
            				}
HXDLIN( 316)				Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),::trilateral3::math::_Algebra::Algebra_Fields__obj::quadStep);
HXDLIN( 316)				int l = p->length;
HXDLIN( 316)				l = (l + 1);
HXDLIN( 316)				p[(l - 1)] = ax;
HXDLIN( 316)				l = (l + 1);
HXDLIN( 316)				p[(l - 1)] = ay;
HXDLIN( 316)				Float t = step;
HXDLIN( 316)				while((t < ((Float)1.))){
HXLINE( 316)					l = (l + 1);
HXDLIN( 316)					Float u = (( (Float)(1) ) - t);
HXDLIN( 316)					p[(l - 1)] = (((::Math_obj::pow(u,( (Float)(2) )) * ax) + (((( (Float)(2) ) * u) * t) * newx)) + (::Math_obj::pow(t,( (Float)(2) )) * x2));
HXDLIN( 316)					l = (l + 1);
HXDLIN( 316)					Float u1 = (( (Float)(1) ) - t);
HXDLIN( 316)					p[(l - 1)] = (((::Math_obj::pow(u1,( (Float)(2) )) * ay) + (((( (Float)(2) ) * u1) * t) * newy)) + (::Math_obj::pow(t,( (Float)(2) )) * y2));
HXDLIN( 316)					t = (t + step);
            				}
HXDLIN( 316)				l = (l + 1);
HXDLIN( 316)				p[(l - 1)] = x2;
HXDLIN( 316)				l = (l + 1);
HXDLIN( 316)				p[(l - 1)] = y2;
            			}
HXDLIN( 316)			{
HXLINE( 316)				::Array< Float > arr = this->tempArr;
HXDLIN( 316)				 ::Dynamic withMove = false;
HXDLIN( 316)				if (::hx::IsNull( withMove )) {
HXLINE( 316)					withMove = true;
            				}
HXDLIN( 316)				int l1 = arr->length;
HXDLIN( 316)				int i = 2;
HXDLIN( 316)				if (( (bool)(withMove) )) {
HXLINE( 316)					this->moveTo(arr->__get(0),arr->__get(1));
            				}
            				else {
HXLINE( 316)					Float x_ = arr->__get(0);
HXDLIN( 316)					Float y_ = arr->__get(1);
HXDLIN( 316)					bool repeat;
HXDLIN( 316)					if ((this->x == x_)) {
HXLINE( 316)						repeat = (this->y == y_);
            					}
            					else {
HXLINE( 316)						repeat = false;
            					}
HXDLIN( 316)					if (!(repeat)) {
HXLINE( 316)						if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 316)							this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 316)						if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 316)							this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 316)						this->line(x_,y_);
HXDLIN( 316)						int l = this->points->length;
HXDLIN( 316)						::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 316)						int l2 = p->length;
HXDLIN( 316)						p[l2] = x_;
HXDLIN( 316)						p[(l2 + 1)] = y_;
HXDLIN( 316)						{
HXLINE( 316)							 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 316)							if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 316)								d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 316)							if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 316)								d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 316)							if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 316)								d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            							}
HXDLIN( 316)							if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 316)								d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            							}
            						}
HXDLIN( 316)						this->x = x_;
HXDLIN( 316)						this->y = y_;
            					}
            				}
HXDLIN( 316)				while((i < l1)){
HXLINE( 316)					{
HXLINE( 316)						Float x_ = arr->__get(i);
HXDLIN( 316)						Float y_ = arr->__get((i + 1));
HXDLIN( 316)						bool repeat;
HXDLIN( 316)						if ((this->x == x_)) {
HXLINE( 316)							repeat = (this->y == y_);
            						}
            						else {
HXLINE( 316)							repeat = false;
            						}
HXDLIN( 316)						if (!(repeat)) {
HXLINE( 316)							if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 316)								this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            							}
HXDLIN( 316)							if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 316)								this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            							}
HXDLIN( 316)							this->line(x_,y_);
HXDLIN( 316)							int l = this->points->length;
HXDLIN( 316)							::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 316)							int l2 = p->length;
HXDLIN( 316)							p[l2] = x_;
HXDLIN( 316)							p[(l2 + 1)] = y_;
HXDLIN( 316)							{
HXLINE( 316)								 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 316)								if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 316)									d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            								}
HXDLIN( 316)								if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 316)									d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            								}
HXDLIN( 316)								if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 316)									d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            								}
HXDLIN( 316)								if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 316)									d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            								}
            							}
HXDLIN( 316)							this->x = x_;
HXDLIN( 316)							this->y = y_;
            						}
            					}
HXDLIN( 316)					i = (i + 2);
            				}
            			}
HXDLIN( 316)			this->x = x2;
HXDLIN( 316)			this->y = y2;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Sketch_obj,quadThru,(void))

void Sketch_obj::curveTo(Float x1,Float y1,Float x2,Float y2,Float x3,Float y3){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_319_curveTo)
HXLINE( 320)		this->tempArr = ::Array_obj< Float >::__new(0);
HXLINE( 321)		{
HXLINE( 321)			::Array< Float > p = this->tempArr;
HXDLIN( 321)			Float ax = this->x;
HXDLIN( 321)			Float ay = this->y;
HXDLIN( 321)			Float x = (ax - x1);
HXDLIN( 321)			Float y = (ay - y1);
HXDLIN( 321)			Float x4 = (x1 - x2);
HXDLIN( 321)			Float y4 = (y1 - y2);
HXDLIN( 321)			Float x5 = (x2 - x3);
HXDLIN( 321)			Float y5 = (y2 - y3);
HXDLIN( 321)			Float approxDistance = ((::Math_obj::sqrt(((x * x) + (y * y))) + ::Math_obj::sqrt(((x4 * x4) + (y4 * y4)))) + ::Math_obj::sqrt(((x5 * x5) + (y5 * y5))));
HXDLIN( 321)			if ((approxDistance == 0)) {
HXLINE( 321)				approxDistance = ((Float)0.000001);
            			}
HXDLIN( 321)			Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),((Float)0.03));
HXDLIN( 321)			int l = p->length;
HXDLIN( 321)			l = (l + 1);
HXDLIN( 321)			p[(l - 1)] = ax;
HXDLIN( 321)			l = (l + 1);
HXDLIN( 321)			p[(l - 1)] = ay;
HXDLIN( 321)			Float t = step;
HXDLIN( 321)			while((t < ((Float)1.))){
HXLINE( 321)				l = (l + 1);
HXDLIN( 321)				Float u = (( (Float)(1) ) - t);
HXDLIN( 321)				p[(l - 1)] = ((((::Math_obj::pow(u,( (Float)(3) )) * ax) + (((( (Float)(3) ) * ::Math_obj::pow(u,( (Float)(2) ))) * t) * x1)) + (((( (Float)(3) ) * u) * ::Math_obj::pow(t,( (Float)(2) ))) * x2)) + (::Math_obj::pow(t,( (Float)(3) )) * x3));
HXDLIN( 321)				l = (l + 1);
HXDLIN( 321)				Float u1 = (( (Float)(1) ) - t);
HXDLIN( 321)				p[(l - 1)] = ((((::Math_obj::pow(u1,( (Float)(3) )) * ay) + (((( (Float)(3) ) * ::Math_obj::pow(u1,( (Float)(2) ))) * t) * y1)) + (((( (Float)(3) ) * u1) * ::Math_obj::pow(t,( (Float)(2) ))) * y2)) + (::Math_obj::pow(t,( (Float)(3) )) * y3));
HXDLIN( 321)				t = (t + step);
            			}
HXDLIN( 321)			l = (l + 1);
HXDLIN( 321)			p[(l - 1)] = x3;
HXDLIN( 321)			l = (l + 1);
HXDLIN( 321)			p[(l - 1)] = y3;
            		}
HXLINE( 322)		{
HXLINE( 322)			::Array< Float > arr = this->tempArr;
HXDLIN( 322)			 ::Dynamic withMove = false;
HXDLIN( 322)			if (::hx::IsNull( withMove )) {
HXLINE( 322)				withMove = true;
            			}
HXDLIN( 322)			int l1 = arr->length;
HXDLIN( 322)			int i = 2;
HXDLIN( 322)			if (( (bool)(withMove) )) {
HXLINE( 322)				this->moveTo(arr->__get(0),arr->__get(1));
            			}
            			else {
HXLINE( 322)				Float x_ = arr->__get(0);
HXDLIN( 322)				Float y_ = arr->__get(1);
HXDLIN( 322)				bool repeat;
HXDLIN( 322)				if ((this->x == x_)) {
HXLINE( 322)					repeat = (this->y == y_);
            				}
            				else {
HXLINE( 322)					repeat = false;
            				}
HXDLIN( 322)				if (!(repeat)) {
HXLINE( 322)					if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 322)						this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 322)					if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 322)						this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 322)					this->line(x_,y_);
HXDLIN( 322)					int l = this->points->length;
HXDLIN( 322)					::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 322)					int l2 = p->length;
HXDLIN( 322)					p[l2] = x_;
HXDLIN( 322)					p[(l2 + 1)] = y_;
HXDLIN( 322)					{
HXLINE( 322)						 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 322)						if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 322)							d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 322)						if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 322)							d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 322)						if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 322)							d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            						}
HXDLIN( 322)						if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 322)							d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            						}
            					}
HXDLIN( 322)					this->x = x_;
HXDLIN( 322)					this->y = y_;
            				}
            			}
HXDLIN( 322)			while((i < l1)){
HXLINE( 322)				{
HXLINE( 322)					Float x_ = arr->__get(i);
HXDLIN( 322)					Float y_ = arr->__get((i + 1));
HXDLIN( 322)					bool repeat;
HXDLIN( 322)					if ((this->x == x_)) {
HXLINE( 322)						repeat = (this->y == y_);
            					}
            					else {
HXLINE( 322)						repeat = false;
            					}
HXDLIN( 322)					if (!(repeat)) {
HXLINE( 322)						if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 322)							this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 322)						if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 322)							this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 322)						this->line(x_,y_);
HXDLIN( 322)						int l = this->points->length;
HXDLIN( 322)						::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 322)						int l2 = p->length;
HXDLIN( 322)						p[l2] = x_;
HXDLIN( 322)						p[(l2 + 1)] = y_;
HXDLIN( 322)						{
HXLINE( 322)							 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 322)							if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 322)								d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 322)							if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 322)								d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 322)							if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 322)								d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            							}
HXDLIN( 322)							if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 322)								d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            							}
            						}
HXDLIN( 322)						this->x = x_;
HXDLIN( 322)						this->y = y_;
            					}
            				}
HXDLIN( 322)				i = (i + 2);
            			}
            		}
HXLINE( 323)		this->x = x3;
HXLINE( 324)		this->y = y3;
            	}


HX_DEFINE_DYNAMIC_FUNC6(Sketch_obj,curveTo,(void))

void Sketch_obj::plotCoord(::Array< Float > arr, ::Dynamic __o_withMove){
            		 ::Dynamic withMove = __o_withMove;
            		if (::hx::IsNull(__o_withMove)) withMove = true;
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_327_plotCoord)
HXLINE( 328)		int l = arr->length;
HXLINE( 329)		int i = 2;
HXLINE( 330)		if (( (bool)(withMove) )) {
HXLINE( 331)			this->moveTo(arr->__get(0),arr->__get(1));
            		}
            		else {
HXLINE( 333)			Float x_ = arr->__get(0);
HXDLIN( 333)			Float y_ = arr->__get(1);
HXDLIN( 333)			bool repeat;
HXDLIN( 333)			if ((this->x == x_)) {
HXLINE( 333)				repeat = (this->y == y_);
            			}
            			else {
HXLINE( 333)				repeat = false;
            			}
HXDLIN( 333)			if (!(repeat)) {
HXLINE( 333)				if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 333)					this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            				}
HXDLIN( 333)				if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 333)					this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            				}
HXDLIN( 333)				this->line(x_,y_);
HXDLIN( 333)				int l = this->points->length;
HXDLIN( 333)				::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 333)				int l2 = p->length;
HXDLIN( 333)				p[l2] = x_;
HXDLIN( 333)				p[(l2 + 1)] = y_;
HXDLIN( 333)				{
HXLINE( 333)					 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 333)					if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 333)						d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            					}
HXDLIN( 333)					if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 333)						d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            					}
HXDLIN( 333)					if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 333)						d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            					}
HXDLIN( 333)					if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 333)						d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            					}
            				}
HXDLIN( 333)				this->x = x_;
HXDLIN( 333)				this->y = y_;
            			}
            		}
HXLINE( 335)		while((i < l)){
HXLINE( 336)			{
HXLINE( 336)				Float x_ = arr->__get(i);
HXDLIN( 336)				Float y_ = arr->__get((i + 1));
HXDLIN( 336)				bool repeat;
HXDLIN( 336)				if ((this->x == x_)) {
HXLINE( 336)					repeat = (this->y == y_);
            				}
            				else {
HXLINE( 336)					repeat = false;
            				}
HXDLIN( 336)				if (!(repeat)) {
HXLINE( 336)					if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 336)						this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 336)					if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 336)						this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            					}
HXDLIN( 336)					this->line(x_,y_);
HXDLIN( 336)					int l = this->points->length;
HXDLIN( 336)					::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 336)					int l2 = p->length;
HXDLIN( 336)					p[l2] = x_;
HXDLIN( 336)					p[(l2 + 1)] = y_;
HXDLIN( 336)					{
HXLINE( 336)						 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 336)						if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 336)							d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 336)						if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 336)							d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            						}
HXDLIN( 336)						if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 336)							d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            						}
HXDLIN( 336)						if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 336)							d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            						}
            					}
HXDLIN( 336)					this->x = x_;
HXDLIN( 336)					this->y = y_;
            				}
            			}
HXLINE( 337)			i = (i + 2);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,plotCoord,(void))

int Sketch_obj::aiColorSet(::String colorType,::Array< ::String > arr){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_340_aiColorSet)
HXLINE( 341)		int colorInt;
HXDLIN( 341)		::String _hx_switch_0 = colorType;
            		if (  (_hx_switch_0==HX_("g",67,00,00,00)) ){
HXLINE( 343)			Float v = ::Std_obj::parseFloat(arr->__get(0));
HXDLIN( 343)			int this1 = ((((::Math_obj::round(((Float)255.)) << 24) | (::Math_obj::round((v * ( (Float)(255) ))) << 16)) | (::Math_obj::round((v * ( (Float)(255) ))) << 8)) | ::Math_obj::round((v * ( (Float)(255) ))));
HXLINE( 341)			colorInt = this1;
HXLINE( 343)			goto _hx_goto_62;
            		}
            		if (  (_hx_switch_0==HX_("k",6b,00,00,00)) ){
HXLINE( 345)			Float c = ::Std_obj::parseFloat(arr->__get(0));
HXDLIN( 345)			Float y = ::Std_obj::parseFloat(arr->__get(1));
HXDLIN( 345)			Float m = ::Std_obj::parseFloat(arr->__get(2));
HXDLIN( 345)			Float k = ::Std_obj::parseFloat(arr->__get(3));
HXDLIN( 345)			int this1 = ((((::Math_obj::round(((Float)255.)) << 24) | (::Math_obj::round((((( (Float)(1) ) - (c / ( (Float)(100) ))) * (( (Float)(1) ) - (k / ( (Float)(100) )))) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((((( (Float)(1) ) - (m / ( (Float)(100) ))) * (( (Float)(1) ) - (k / ( (Float)(100) )))) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((((( (Float)(1) ) - (y / ( (Float)(100) ))) * (( (Float)(1) ) - (k / ( (Float)(100) )))) * ( (Float)(255) ))));
HXLINE( 341)			colorInt = this1;
HXLINE( 345)			goto _hx_goto_62;
            		}
            		if (  (_hx_switch_0==HX_("r",72,00,00,00)) ){
HXLINE( 349)			Float r = ::Std_obj::parseFloat(arr->__get(0));
HXDLIN( 349)			Float g = ::Std_obj::parseFloat(arr->__get(1));
HXDLIN( 349)			Float b = ::Std_obj::parseFloat(arr->__get(2));
HXDLIN( 349)			int this1 = ((((::Math_obj::round(((Float)255.)) << 24) | (::Math_obj::round((r * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b * ( (Float)(255) ))));
HXLINE( 341)			colorInt = this1;
HXLINE( 349)			goto _hx_goto_62;
            		}
            		if (  (_hx_switch_0==HX_("xa",e9,68,00,00)) ){
HXLINE( 347)			Float r = ::Std_obj::parseFloat(arr->__get(0));
HXDLIN( 347)			Float g = ::Std_obj::parseFloat(arr->__get(1));
HXDLIN( 347)			Float b = ::Std_obj::parseFloat(arr->__get(2));
HXDLIN( 347)			int this1 = ((((::Math_obj::round(((Float)255.)) << 24) | (::Math_obj::round((r * ( (Float)(255) ))) << 16)) | (::Math_obj::round((g * ( (Float)(255) ))) << 8)) | ::Math_obj::round((b * ( (Float)(255) ))));
HXLINE( 341)			colorInt = this1;
HXLINE( 347)			goto _hx_goto_62;
            		}
            		/* default */{
HXLINE( 351)			::haxe::Log_obj::trace(HX_("color not found",78,1e,5d,7a),::hx::SourceInfo(HX_("trilateral3/drawing/Sketch.hx",39,8a,a7,5a),351,HX_("trilateral3.drawing.Sketch",23,f7,00,b3),HX_("aiColorSet",07,db,dc,c4)));
HXLINE( 352)			Float v = ::Std_obj::parseFloat(HX_("0",30,00,00,00));
HXDLIN( 352)			int this1 = ((((::Math_obj::round(((Float)255.)) << 24) | (::Math_obj::round((v * ( (Float)(255) ))) << 16)) | (::Math_obj::round((v * ( (Float)(255) ))) << 8)) | ::Math_obj::round((v * ( (Float)(255) ))));
HXLINE( 341)			colorInt = this1;
            		}
            		_hx_goto_62:;
HXLINE( 354)		this->pen->currentColor = colorInt;
HXLINE( 355)		return colorInt;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sketch_obj,aiColorSet,return )

::String Sketch_obj::getColorType(::Array< ::String > arr){
            	HX_STACKFRAME(&_hx_pos_6351d8d914bc61da_357_getColorType)
HXLINE( 358)		::String col = arr->__get((arr->length - 1)).toLowerCase();
HXLINE( 359)		return col;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Sketch_obj,getColorType,return )

void Sketch_obj::aiStringPart(::String str,Float x,Float y,::hx::Null< Float >  __o_flipY){
            		Float flipY = __o_flipY.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_6351d8d914bc61da_364_aiStringPart)
HXLINE( 365)		 ::dsHelper::splitter::StringCodeIterator sl =  ::dsHelper::splitter::StringCodeIterator_obj::__alloc( HX_CTX ,str,null());
HXDLIN( 365)		sl->c = sl->str.cca(sl->pos++);
HXDLIN( 365)		::Array< ::Dynamic> arr = ::Array_obj< ::Dynamic>::__new();
HXDLIN( 365)		::Array< ::String > arrTemp = ::Array_obj< ::String >::__new();
HXDLIN( 365)		int no = 0;
HXDLIN( 365)		int count = 0;
HXDLIN( 365)		while((sl->pos < sl->length)){
HXLINE( 365)			switch((int)(sl->c)){
            				case (int)10: case (int)13: {
HXLINE( 365)					sl->last2 = sl->last;
HXDLIN( 365)					sl->last = sl->b->toString();
HXDLIN( 365)					arrTemp[count] = sl->last;
HXDLIN( 365)					no = (no + 1);
HXDLIN( 365)					arr[(no - 1)] = arrTemp->copy();
HXDLIN( 365)					count = 0;
HXDLIN( 365)					sl->b =  ::StringBuf_obj::__alloc( HX_CTX );
            				}
            				break;
            				case (int)32: {
HXLINE( 365)					if ((count == 0)) {
HXLINE( 365)						arrTemp->resize(0);
HXDLIN( 365)						sl->last2 = sl->last;
HXDLIN( 365)						sl->last = sl->b->toString();
HXDLIN( 365)						arrTemp[0] = sl->last;
            					}
            					else {
HXLINE( 365)						sl->last2 = sl->last;
HXDLIN( 365)						sl->last = sl->b->toString();
HXDLIN( 365)						arrTemp[count] = sl->last;
            					}
HXDLIN( 365)					count = (count + 1);
HXDLIN( 365)					sl->b =  ::StringBuf_obj::__alloc( HX_CTX );
            				}
            				break;
            				default:{
HXLINE( 365)					 ::StringBuf _this = sl->b;
HXDLIN( 365)					int c = sl->c;
HXDLIN( 365)					if ((c >= 127)) {
HXLINE( 365)						::String x = ::String::fromCharCode(c);
HXDLIN( 365)						if (::hx::IsNotNull( _this->charBuf )) {
HXLINE( 365)							_this->flush();
            						}
HXDLIN( 365)						if (::hx::IsNull( _this->b )) {
HXLINE( 365)							_this->b = ::Array_obj< ::String >::__new(1)->init(0,::Std_obj::string(x));
            						}
            						else {
HXLINE( 365)							::Array< ::String > _this1 = _this->b;
HXDLIN( 365)							_this1->push(::Std_obj::string(x));
            						}
            					}
            					else {
HXLINE( 365)						if (::hx::IsNull( _this->charBuf )) {
HXLINE( 365)							_this->charBuf = ::Array_obj< char >::__new();
            						}
HXDLIN( 365)						_this->charBuf->push(c);
            					}
            				}
            			}
HXDLIN( 365)			sl->c = sl->str.cca(sl->pos++);
            		}
HXDLIN( 365)		::Array< ::Dynamic> arr1 = arr;
HXLINE( 366)		::Array< ::String > arr2 = ( (::Array< ::String >)(arr1->shift()) );
HXLINE( 367)		this->aiColorSet(this->getColorType(arr2),arr2);
HXLINE( 368)		int len = arr1->length;
HXLINE( 369)		if ((flipY == 0)) {
HXLINE( 370)			int _g = 0;
HXDLIN( 370)			int _g1 = len;
HXDLIN( 370)			while((_g < _g1)){
HXLINE( 370)				_g = (_g + 1);
HXDLIN( 370)				int i = (_g - 1);
HXLINE( 371)				int len2 = arr1->__get(i).StaticCast< ::Array< ::String > >()->length;
HXLINE( 372)				::Array< ::String > arr3 = arr1->__get(i).StaticCast< ::Array< ::String > >();
HXLINE( 373)				::String str = arr3->__get((len2 - 1));
HXLINE( 374)				::String _hx_switch_0 = str;
            				if (  (_hx_switch_0==HX_("C",43,00,00,00)) ||  (_hx_switch_0==HX_("c",63,00,00,00)) ){
HXLINE( 381)					Float x1 = (::Std_obj::parseFloat(arr3->__get(0)) + x);
HXDLIN( 381)					Float y1 = (::Std_obj::parseFloat(arr3->__get(1)) + y);
HXDLIN( 381)					Float x2 = (::Std_obj::parseFloat(arr3->__get(1)) + x);
HXDLIN( 381)					Float y2 = (::Std_obj::parseFloat(arr3->__get(2)) + y);
HXDLIN( 381)					this->tempArr = ::Array_obj< Float >::__new(0);
HXDLIN( 381)					{
HXLINE( 381)						::Array< Float > p = this->tempArr;
HXDLIN( 381)						Float ax = this->x;
HXDLIN( 381)						Float ay = this->y;
HXDLIN( 381)						Float x3 = (ax - x1);
HXDLIN( 381)						Float y3 = (ay - y1);
HXDLIN( 381)						Float x4 = (x1 - x2);
HXDLIN( 381)						Float y4 = (y1 - y2);
HXDLIN( 381)						Float approxDistance = (::Math_obj::sqrt(((x3 * x3) + (y3 * y3))) + ::Math_obj::sqrt(((x4 * x4) + (y4 * y4))));
HXDLIN( 381)						if ((approxDistance == 0)) {
HXLINE( 381)							approxDistance = ((Float)0.000001);
            						}
HXDLIN( 381)						Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),::trilateral3::math::_Algebra::Algebra_Fields__obj::quadStep);
HXDLIN( 381)						int l = p->length;
HXDLIN( 381)						l = (l + 1);
HXDLIN( 381)						p[(l - 1)] = ax;
HXDLIN( 381)						l = (l + 1);
HXDLIN( 381)						p[(l - 1)] = ay;
HXDLIN( 381)						Float t = step;
HXDLIN( 381)						while((t < ((Float)1.))){
HXLINE( 381)							l = (l + 1);
HXDLIN( 381)							Float u = (( (Float)(1) ) - t);
HXDLIN( 381)							p[(l - 1)] = (((::Math_obj::pow(u,( (Float)(2) )) * ax) + (((( (Float)(2) ) * u) * t) * x1)) + (::Math_obj::pow(t,( (Float)(2) )) * x2));
HXDLIN( 381)							l = (l + 1);
HXDLIN( 381)							Float u1 = (( (Float)(1) ) - t);
HXDLIN( 381)							p[(l - 1)] = (((::Math_obj::pow(u1,( (Float)(2) )) * ay) + (((( (Float)(2) ) * u1) * t) * y1)) + (::Math_obj::pow(t,( (Float)(2) )) * y2));
HXDLIN( 381)							t = (t + step);
            						}
HXDLIN( 381)						l = (l + 1);
HXDLIN( 381)						p[(l - 1)] = x2;
HXDLIN( 381)						l = (l + 1);
HXDLIN( 381)						p[(l - 1)] = y2;
            					}
HXDLIN( 381)					{
HXLINE( 381)						::Array< Float > arr = this->tempArr;
HXDLIN( 381)						 ::Dynamic withMove = false;
HXDLIN( 381)						if (::hx::IsNull( withMove )) {
HXLINE( 381)							withMove = true;
            						}
HXDLIN( 381)						int l1 = arr->length;
HXDLIN( 381)						int i = 2;
HXDLIN( 381)						if (( (bool)(withMove) )) {
HXLINE( 381)							this->moveTo(arr->__get(0),arr->__get(1));
            						}
            						else {
HXLINE( 381)							Float x_ = arr->__get(0);
HXDLIN( 381)							Float y_ = arr->__get(1);
HXDLIN( 381)							bool repeat;
HXDLIN( 381)							if ((this->x == x_)) {
HXLINE( 381)								repeat = (this->y == y_);
            							}
            							else {
HXLINE( 381)								repeat = false;
            							}
HXDLIN( 381)							if (!(repeat)) {
HXLINE( 381)								if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 381)									this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            								}
HXDLIN( 381)								if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 381)									this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            								}
HXDLIN( 381)								this->line(x_,y_);
HXDLIN( 381)								int l = this->points->length;
HXDLIN( 381)								::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 381)								int l2 = p->length;
HXDLIN( 381)								p[l2] = x_;
HXDLIN( 381)								p[(l2 + 1)] = y_;
HXDLIN( 381)								{
HXLINE( 381)									 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 381)									if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 381)										d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            									}
HXDLIN( 381)									if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 381)										d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            									}
HXDLIN( 381)									if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 381)										d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            									}
HXDLIN( 381)									if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 381)										d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            									}
            								}
HXDLIN( 381)								this->x = x_;
HXDLIN( 381)								this->y = y_;
            							}
            						}
HXDLIN( 381)						while((i < l1)){
HXLINE( 381)							{
HXLINE( 381)								Float x_ = arr->__get(i);
HXDLIN( 381)								Float y_ = arr->__get((i + 1));
HXDLIN( 381)								bool repeat;
HXDLIN( 381)								if ((this->x == x_)) {
HXLINE( 381)									repeat = (this->y == y_);
            								}
            								else {
HXLINE( 381)									repeat = false;
            								}
HXDLIN( 381)								if (!(repeat)) {
HXLINE( 381)									if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 381)										this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            									}
HXDLIN( 381)									if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 381)										this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            									}
HXDLIN( 381)									this->line(x_,y_);
HXDLIN( 381)									int l = this->points->length;
HXDLIN( 381)									::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 381)									int l2 = p->length;
HXDLIN( 381)									p[l2] = x_;
HXDLIN( 381)									p[(l2 + 1)] = y_;
HXDLIN( 381)									{
HXLINE( 381)										 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 381)										if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 381)											d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            										}
HXDLIN( 381)										if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 381)											d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            										}
HXDLIN( 381)										if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 381)											d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            										}
HXDLIN( 381)										if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 381)											d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            										}
            									}
HXDLIN( 381)									this->x = x_;
HXDLIN( 381)									this->y = y_;
            								}
            							}
HXDLIN( 381)							i = (i + 2);
            						}
            					}
HXDLIN( 381)					this->x = x2;
HXDLIN( 381)					this->y = y2;
HXDLIN( 381)					goto _hx_goto_67;
            				}
            				if (  (_hx_switch_0==HX_("M",4d,00,00,00)) ||  (_hx_switch_0==HX_("m",6d,00,00,00)) ){
HXLINE( 377)					Float _hx_tmp = (::Std_obj::parseFloat(arr3->__get(0)) + x);
HXDLIN( 377)					this->moveTo(_hx_tmp,(::Std_obj::parseFloat(arr3->__get(1)) + y));
HXDLIN( 377)					goto _hx_goto_67;
            				}
            				if (  (_hx_switch_0==HX_("L",4c,00,00,00)) ||  (_hx_switch_0==HX_("l",6c,00,00,00)) ){
HXLINE( 379)					Float x_ = (::Std_obj::parseFloat(arr3->__get(0)) + x);
HXDLIN( 379)					Float y_ = (::Std_obj::parseFloat(arr3->__get(1)) + y);
HXDLIN( 379)					bool repeat;
HXDLIN( 379)					if ((this->x == x_)) {
HXLINE( 379)						repeat = (this->y == y_);
            					}
            					else {
HXLINE( 379)						repeat = false;
            					}
HXDLIN( 379)					if (!(repeat)) {
HXLINE( 379)						if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 379)							this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 379)						if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 379)							this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 379)						this->line(x_,y_);
HXDLIN( 379)						int l = this->points->length;
HXDLIN( 379)						::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 379)						int l2 = p->length;
HXDLIN( 379)						p[l2] = x_;
HXDLIN( 379)						p[(l2 + 1)] = y_;
HXDLIN( 379)						{
HXLINE( 379)							 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 379)							if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 379)								d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 379)							if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 379)								d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 379)							if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 379)								d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            							}
HXDLIN( 379)							if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 379)								d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            							}
            						}
HXDLIN( 379)						this->x = x_;
HXDLIN( 379)						this->y = y_;
            					}
HXDLIN( 379)					goto _hx_goto_67;
            				}
            				/* default */{
HXLINE( 384)					::haxe::Log_obj::trace((str + HX_(" NOT FOUND in aiString",e9,9d,62,e1)),::hx::SourceInfo(HX_("trilateral3/drawing/Sketch.hx",39,8a,a7,5a),384,HX_("trilateral3.drawing.Sketch",23,f7,00,b3),HX_("aiStringPart",6c,00,c2,b7)));
            				}
            				_hx_goto_67:;
            			}
            		}
            		else {
HXLINE( 388)			int _g = 0;
HXDLIN( 388)			int _g1 = len;
HXDLIN( 388)			while((_g < _g1)){
HXLINE( 388)				_g = (_g + 1);
HXDLIN( 388)				int i = (_g - 1);
HXLINE( 389)				int len2 = arr1->__get(i).StaticCast< ::Array< ::String > >()->length;
HXLINE( 390)				::Array< ::String > arr3 = arr1->__get(i).StaticCast< ::Array< ::String > >();
HXLINE( 391)				::String str = arr3->__get((len2 - 1));
HXLINE( 392)				::String _hx_switch_1 = str;
            				if (  (_hx_switch_1==HX_("C",43,00,00,00)) ){
HXLINE( 398)					Float x1 = (::Std_obj::parseFloat(arr3->__get(0)) + x);
HXDLIN( 398)					Float y1 = ((flipY - ::Std_obj::parseFloat(arr3->__get(1))) + y);
HXDLIN( 398)					Float x2 = (::Std_obj::parseFloat(arr3->__get(1)) + x);
HXDLIN( 398)					Float y2 = ((flipY - ::Std_obj::parseFloat(arr3->__get(2))) + y);
HXDLIN( 398)					this->tempArr = ::Array_obj< Float >::__new(0);
HXDLIN( 398)					{
HXLINE( 398)						::Array< Float > p = this->tempArr;
HXDLIN( 398)						Float ax = this->x;
HXDLIN( 398)						Float ay = this->y;
HXDLIN( 398)						Float x3 = (ax - x1);
HXDLIN( 398)						Float y3 = (ay - y1);
HXDLIN( 398)						Float x4 = (x1 - x2);
HXDLIN( 398)						Float y4 = (y1 - y2);
HXDLIN( 398)						Float approxDistance = (::Math_obj::sqrt(((x3 * x3) + (y3 * y3))) + ::Math_obj::sqrt(((x4 * x4) + (y4 * y4))));
HXDLIN( 398)						if ((approxDistance == 0)) {
HXLINE( 398)							approxDistance = ((Float)0.000001);
            						}
HXDLIN( 398)						Float step = ::Math_obj::min((( (Float)(1) ) / (approxDistance * ((Float)0.707))),::trilateral3::math::_Algebra::Algebra_Fields__obj::quadStep);
HXDLIN( 398)						int l = p->length;
HXDLIN( 398)						l = (l + 1);
HXDLIN( 398)						p[(l - 1)] = ax;
HXDLIN( 398)						l = (l + 1);
HXDLIN( 398)						p[(l - 1)] = ay;
HXDLIN( 398)						Float t = step;
HXDLIN( 398)						while((t < ((Float)1.))){
HXLINE( 398)							l = (l + 1);
HXDLIN( 398)							Float u = (( (Float)(1) ) - t);
HXDLIN( 398)							p[(l - 1)] = (((::Math_obj::pow(u,( (Float)(2) )) * ax) + (((( (Float)(2) ) * u) * t) * x1)) + (::Math_obj::pow(t,( (Float)(2) )) * x2));
HXDLIN( 398)							l = (l + 1);
HXDLIN( 398)							Float u1 = (( (Float)(1) ) - t);
HXDLIN( 398)							p[(l - 1)] = (((::Math_obj::pow(u1,( (Float)(2) )) * ay) + (((( (Float)(2) ) * u1) * t) * y1)) + (::Math_obj::pow(t,( (Float)(2) )) * y2));
HXDLIN( 398)							t = (t + step);
            						}
HXDLIN( 398)						l = (l + 1);
HXDLIN( 398)						p[(l - 1)] = x2;
HXDLIN( 398)						l = (l + 1);
HXDLIN( 398)						p[(l - 1)] = y2;
            					}
HXDLIN( 398)					{
HXLINE( 398)						::Array< Float > arr = this->tempArr;
HXDLIN( 398)						 ::Dynamic withMove = false;
HXDLIN( 398)						if (::hx::IsNull( withMove )) {
HXLINE( 398)							withMove = true;
            						}
HXDLIN( 398)						int l1 = arr->length;
HXDLIN( 398)						int i = 2;
HXDLIN( 398)						if (( (bool)(withMove) )) {
HXLINE( 398)							this->moveTo(arr->__get(0),arr->__get(1));
            						}
            						else {
HXLINE( 398)							Float x_ = arr->__get(0);
HXDLIN( 398)							Float y_ = arr->__get(1);
HXDLIN( 398)							bool repeat;
HXDLIN( 398)							if ((this->x == x_)) {
HXLINE( 398)								repeat = (this->y == y_);
            							}
            							else {
HXLINE( 398)								repeat = false;
            							}
HXDLIN( 398)							if (!(repeat)) {
HXLINE( 398)								if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 398)									this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            								}
HXDLIN( 398)								if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 398)									this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            								}
HXDLIN( 398)								this->line(x_,y_);
HXDLIN( 398)								int l = this->points->length;
HXDLIN( 398)								::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 398)								int l2 = p->length;
HXDLIN( 398)								p[l2] = x_;
HXDLIN( 398)								p[(l2 + 1)] = y_;
HXDLIN( 398)								{
HXLINE( 398)									 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 398)									if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 398)										d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            									}
HXDLIN( 398)									if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 398)										d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            									}
HXDLIN( 398)									if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 398)										d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            									}
HXDLIN( 398)									if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 398)										d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            									}
            								}
HXDLIN( 398)								this->x = x_;
HXDLIN( 398)								this->y = y_;
            							}
            						}
HXDLIN( 398)						while((i < l1)){
HXLINE( 398)							{
HXLINE( 398)								Float x_ = arr->__get(i);
HXDLIN( 398)								Float y_ = arr->__get((i + 1));
HXDLIN( 398)								bool repeat;
HXDLIN( 398)								if ((this->x == x_)) {
HXLINE( 398)									repeat = (this->y == y_);
            								}
            								else {
HXLINE( 398)									repeat = false;
            								}
HXDLIN( 398)								if (!(repeat)) {
HXLINE( 398)									if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 398)										this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            									}
HXDLIN( 398)									if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 398)										this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            									}
HXDLIN( 398)									this->line(x_,y_);
HXDLIN( 398)									int l = this->points->length;
HXDLIN( 398)									::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 398)									int l2 = p->length;
HXDLIN( 398)									p[l2] = x_;
HXDLIN( 398)									p[(l2 + 1)] = y_;
HXDLIN( 398)									{
HXLINE( 398)										 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 398)										if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 398)											d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            										}
HXDLIN( 398)										if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 398)											d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            										}
HXDLIN( 398)										if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 398)											d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            										}
HXDLIN( 398)										if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 398)											d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            										}
            									}
HXDLIN( 398)									this->x = x_;
HXDLIN( 398)									this->y = y_;
            								}
            							}
HXDLIN( 398)							i = (i + 2);
            						}
            					}
HXDLIN( 398)					this->x = x2;
HXDLIN( 398)					this->y = y2;
HXDLIN( 398)					goto _hx_goto_71;
            				}
            				if (  (_hx_switch_1==HX_("L",4c,00,00,00)) ){
HXLINE( 396)					Float x_ = (::Std_obj::parseFloat(arr3->__get(0)) + x);
HXDLIN( 396)					Float y_ = ((flipY - ::Std_obj::parseFloat(arr3->__get(1))) + y);
HXDLIN( 396)					bool repeat;
HXDLIN( 396)					if ((this->x == x_)) {
HXLINE( 396)						repeat = (this->y == y_);
            					}
            					else {
HXLINE( 396)						repeat = false;
            					}
HXDLIN( 396)					if (!(repeat)) {
HXLINE( 396)						if (::hx::IsNotNull( this->widthFunction )) {
HXLINE( 396)							this->width = ( (Float)(this->widthFunction(this->width,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 396)						if (::hx::IsNotNull( this->colourFunction )) {
HXLINE( 396)							this->pen->currentColor = ( (int)(this->colourFunction(this->pen->currentColor,this->x,this->y,x_,y_)) );
            						}
HXDLIN( 396)						this->line(x_,y_);
HXDLIN( 396)						int l = this->points->length;
HXDLIN( 396)						::Array< Float > p = this->points->__get((l - 1)).StaticCast< ::Array< Float > >();
HXDLIN( 396)						int l2 = p->length;
HXDLIN( 396)						p[l2] = x_;
HXDLIN( 396)						p[(l2 + 1)] = y_;
HXDLIN( 396)						{
HXLINE( 396)							 ::Dynamic d = this->dim->__get((this->dim->length - 1));
HXDLIN( 396)							if (::hx::IsLess( x_,d->__Field(HX_("minX",86,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 396)								d->__SetField(HX_("minX",86,4e,5c,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 396)							if (::hx::IsGreater( x_,d->__Field(HX_("maxX",34,45,56,48),::hx::paccDynamic) )) {
HXLINE( 396)								d->__SetField(HX_("maxX",34,45,56,48),x_,::hx::paccDynamic);
            							}
HXDLIN( 396)							if (::hx::IsLess( y_,d->__Field(HX_("minY",87,4e,5c,48),::hx::paccDynamic) )) {
HXLINE( 396)								d->__SetField(HX_("minY",87,4e,5c,48),y_,::hx::paccDynamic);
            							}
HXDLIN( 396)							if (::hx::IsGreater( y_,d->__Field(HX_("maxY",35,45,56,48),::hx::paccDynamic) )) {
HXLINE( 396)								d->__SetField(HX_("maxY",35,45,56,48),y_,::hx::paccDynamic);
            							}
            						}
HXDLIN( 396)						this->x = x_;
HXDLIN( 396)						this->y = y_;
            					}
HXDLIN( 396)					goto _hx_goto_71;
            				}
            				if (  (_hx_switch_1==HX_("m",6d,00,00,00)) ){
HXLINE( 394)					Float _hx_tmp = (::Std_obj::parseFloat(arr3->__get(0)) + x);
HXDLIN( 394)					this->moveTo(_hx_tmp,((flipY - ::Std_obj::parseFloat(arr3->__get(1))) + y));
HXDLIN( 394)					goto _hx_goto_71;
            				}
            				/* default */{
HXLINE( 401)					::haxe::Log_obj::trace((str + HX_(" NOT FOUND in aiString",e9,9d,62,e1)),::hx::SourceInfo(HX_("trilateral3/drawing/Sketch.hx",39,8a,a7,5a),401,HX_("trilateral3.drawing.Sketch",23,f7,00,b3),HX_("aiStringPart",6c,00,c2,b7)));
            				}
            				_hx_goto_71:;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Sketch_obj,aiStringPart,(void))

 ::trilateral3::drawing::Sketch Sketch_obj::create( ::Dynamic drawType_, ::Dynamic colorType_,int sketchForm_,::hx::Null< int >  __o_endLine_){
            		int endLine_ = __o_endLine_.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_6351d8d914bc61da_92_create)
HXLINE(  94)		 ::trilateral3::drawing::Pen pen =  ::trilateral3::drawing::Pen_obj::__alloc( HX_CTX ,drawType_,colorType_);
HXLINE(  95)		return  ::trilateral3::drawing::Sketch_obj::__alloc( HX_CTX ,pen,sketchForm_,endLine_);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Sketch_obj,create,return )


::hx::ObjectPtr< Sketch_obj > Sketch_obj::__new( ::trilateral3::drawing::Pen pen_,int sketchForm_,::hx::Null< int >  __o_endLine_) {
	::hx::ObjectPtr< Sketch_obj > __this = new Sketch_obj();
	__this->__construct(pen_,sketchForm_,__o_endLine_);
	return __this;
}

::hx::ObjectPtr< Sketch_obj > Sketch_obj::__alloc(::hx::Ctx *_hx_ctx, ::trilateral3::drawing::Pen pen_,int sketchForm_,::hx::Null< int >  __o_endLine_) {
	Sketch_obj *__this = (Sketch_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Sketch_obj), true, "trilateral3.drawing.Sketch"));
	*(void **)__this = Sketch_obj::_hx_vtable;
	__this->__construct(pen_,sketchForm_,__o_endLine_);
	return __this;
}

Sketch_obj::Sketch_obj()
{
}

void Sketch_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Sketch);
	HX_MARK_MEMBER_NAME(x,"x");
	HX_MARK_MEMBER_NAME(y,"y");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(widthFunction,"widthFunction");
	HX_MARK_MEMBER_NAME(colourFunction,"colourFunction");
	HX_MARK_MEMBER_NAME(tempArr,"tempArr");
	HX_MARK_MEMBER_NAME(contour,"contour");
	HX_MARK_MEMBER_NAME(pen,"pen");
	HX_MARK_MEMBER_NAME(endLine,"endLine");
	HX_MARK_MEMBER_NAME(sketchForm,"sketchForm");
	HX_MARK_MEMBER_NAME(points,"points");
	HX_MARK_MEMBER_NAME(pointsClock,"pointsClock");
	HX_MARK_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_MARK_MEMBER_NAME(dim,"dim");
	HX_MARK_MEMBER_NAME(line,"line");
	HX_MARK_END_CLASS();
}

void Sketch_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(x,"x");
	HX_VISIT_MEMBER_NAME(y,"y");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(widthFunction,"widthFunction");
	HX_VISIT_MEMBER_NAME(colourFunction,"colourFunction");
	HX_VISIT_MEMBER_NAME(tempArr,"tempArr");
	HX_VISIT_MEMBER_NAME(contour,"contour");
	HX_VISIT_MEMBER_NAME(pen,"pen");
	HX_VISIT_MEMBER_NAME(endLine,"endLine");
	HX_VISIT_MEMBER_NAME(sketchForm,"sketchForm");
	HX_VISIT_MEMBER_NAME(points,"points");
	HX_VISIT_MEMBER_NAME(pointsClock,"pointsClock");
	HX_VISIT_MEMBER_NAME(pointsAnti,"pointsAnti");
	HX_VISIT_MEMBER_NAME(dim,"dim");
	HX_VISIT_MEMBER_NAME(line,"line");
}

::hx::Val Sketch_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return ::hx::Val( x ); }
		if (HX_FIELD_EQ(inName,"y") ) { return ::hx::Val( y ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { return ::hx::Val( pen ); }
		if (HX_FIELD_EQ(inName,"dim") ) { return ::hx::Val( dim ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"line") ) { return ::hx::Val( line ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		if (HX_FIELD_EQ(inName,"reset") ) { return ::hx::Val( reset_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { return ::hx::Val( points ); }
		if (HX_FIELD_EQ(inName,"moveTo") ) { return ::hx::Val( moveTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"lineTo") ) { return ::hx::Val( lineTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"quadTo") ) { return ::hx::Val( quadTo_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tempArr") ) { return ::hx::Val( tempArr ); }
		if (HX_FIELD_EQ(inName,"contour") ) { return ::hx::Val( contour ); }
		if (HX_FIELD_EQ(inName,"endLine") ) { return ::hx::Val( endLine ); }
		if (HX_FIELD_EQ(inName,"initDim") ) { return ::hx::Val( initDim_dyn() ); }
		if (HX_FIELD_EQ(inName,"curveTo") ) { return ::hx::Val( curveTo_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"baseLine") ) { return ::hx::Val( baseLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"fineLine") ) { return ::hx::Val( fineLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"getEdges") ) { return ::hx::Val( getEdges_dyn() ); }
		if (HX_FIELD_EQ(inName,"quadThru") ) { return ::hx::Val( quadThru_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"crudeLine") ) { return ::hx::Val( crudeLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateDim") ) { return ::hx::Val( updateDim_dyn() ); }
		if (HX_FIELD_EQ(inName,"lastClock") ) { return ::hx::Val( lastClock_dyn() ); }
		if (HX_FIELD_EQ(inName,"plotCoord") ) { return ::hx::Val( plotCoord_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sketchForm") ) { return ::hx::Val( sketchForm ); }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { return ::hx::Val( pointsAnti ); }
		if (HX_FIELD_EQ(inName,"tracerLine") ) { return ::hx::Val( tracerLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"mediumLine") ) { return ::hx::Val( mediumLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"aiColorSet") ) { return ::hx::Val( aiColorSet_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { return ::hx::Val( pointsClock ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"fillOnlyLine") ) { return ::hx::Val( fillOnlyLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"roundEndLine") ) { return ::hx::Val( roundEndLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"getColorType") ) { return ::hx::Val( getColorType_dyn() ); }
		if (HX_FIELD_EQ(inName,"aiStringPart") ) { return ::hx::Val( aiStringPart_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"widthFunction") ) { return ::hx::Val( widthFunction ); }
		if (HX_FIELD_EQ(inName,"pointsRewound") ) { return ::hx::Val( pointsRewound_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colourFunction") ) { return ::hx::Val( colourFunction ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"fineOverlapLine") ) { return ::hx::Val( fineOverlapLine_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"mediumOverlapLine") ) { return ::hx::Val( mediumOverlapLine_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"pointsNoEndOverlap") ) { return ::hx::Val( pointsNoEndOverlap_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Sketch_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"create") ) { outValue = create_dyn(); return true; }
	}
	return false;
}

::hx::Val Sketch_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { y=inValue.Cast< Float >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pen") ) { pen=inValue.Cast<  ::trilateral3::drawing::Pen >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dim") ) { dim=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"line") ) { line=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { points=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tempArr") ) { tempArr=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"contour") ) { contour=inValue.Cast<  ::trilateral3::drawing::Contour >(); return inValue; }
		if (HX_FIELD_EQ(inName,"endLine") ) { endLine=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sketchForm") ) { sketchForm=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pointsAnti") ) { pointsAnti=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"pointsClock") ) { pointsClock=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"widthFunction") ) { widthFunction=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colourFunction") ) { colourFunction=inValue.Cast<  ::Dynamic >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Sketch_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x",78,00,00,00));
	outFields->push(HX_("y",79,00,00,00));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("tempArr",ad,17,ac,46));
	outFields->push(HX_("contour",da,29,7f,19));
	outFields->push(HX_("pen",d9,54,55,00));
	outFields->push(HX_("endLine",6f,d1,d7,29));
	outFields->push(HX_("sketchForm",d0,2c,96,9a));
	outFields->push(HX_("points",23,12,2e,f7));
	outFields->push(HX_("pointsClock",ab,c8,9e,88));
	outFields->push(HX_("pointsAnti",65,1b,f0,ae));
	outFields->push(HX_("dim",48,3d,4c,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Sketch_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(Sketch_obj,x),HX_("x",78,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Sketch_obj,y),HX_("y",79,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Sketch_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketch_obj,widthFunction),HX_("widthFunction",3e,93,b5,7c)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketch_obj,colourFunction),HX_("colourFunction",84,5b,3e,e4)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(Sketch_obj,tempArr),HX_("tempArr",ad,17,ac,46)},
	{::hx::fsObject /*  ::trilateral3::drawing::Contour */ ,(int)offsetof(Sketch_obj,contour),HX_("contour",da,29,7f,19)},
	{::hx::fsObject /*  ::trilateral3::drawing::Pen */ ,(int)offsetof(Sketch_obj,pen),HX_("pen",d9,54,55,00)},
	{::hx::fsInt,(int)offsetof(Sketch_obj,endLine),HX_("endLine",6f,d1,d7,29)},
	{::hx::fsInt,(int)offsetof(Sketch_obj,sketchForm),HX_("sketchForm",d0,2c,96,9a)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,points),HX_("points",23,12,2e,f7)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,pointsClock),HX_("pointsClock",ab,c8,9e,88)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,pointsAnti),HX_("pointsAnti",65,1b,f0,ae)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Sketch_obj,dim),HX_("dim",48,3d,4c,00)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Sketch_obj,line),HX_("line",f4,17,b3,47)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Sketch_obj_sStaticStorageInfo = 0;
#endif

static ::String Sketch_obj_sMemberFields[] = {
	HX_("x",78,00,00,00),
	HX_("y",79,00,00,00),
	HX_("width",06,b6,62,ca),
	HX_("widthFunction",3e,93,b5,7c),
	HX_("colourFunction",84,5b,3e,e4),
	HX_("tempArr",ad,17,ac,46),
	HX_("contour",da,29,7f,19),
	HX_("pen",d9,54,55,00),
	HX_("endLine",6f,d1,d7,29),
	HX_("sketchForm",d0,2c,96,9a),
	HX_("points",23,12,2e,f7),
	HX_("pointsClock",ab,c8,9e,88),
	HX_("pointsAnti",65,1b,f0,ae),
	HX_("dim",48,3d,4c,00),
	HX_("tracerLine",e1,14,6f,0a),
	HX_("fillOnlyLine",23,35,20,bc),
	HX_("baseLine",a5,08,01,fc),
	HX_("crudeLine",7b,a3,d6,62),
	HX_("roundEndLine",c1,c6,50,fc),
	HX_("mediumLine",09,77,f0,3b),
	HX_("mediumOverlapLine",a6,34,72,5e),
	HX_("fineLine",4e,b9,ad,2d),
	HX_("fineOverlapLine",01,f5,59,3a),
	HX_("line",f4,17,b3,47),
	HX_("reset",cf,49,c8,e6),
	HX_("pointsNoEndOverlap",50,8f,f9,44),
	HX_("pointsRewound",5d,22,d0,4a),
	HX_("initDim",18,04,83,cb),
	HX_("updateDim",bf,1a,d9,82),
	HX_("moveTo",ec,d2,ac,cc),
	HX_("lastClock",98,37,10,95),
	HX_("getEdges",20,7d,b7,c9),
	HX_("lineTo",8f,46,a0,ec),
	HX_("quadTo",22,82,9f,cc),
	HX_("quadThru",9e,e2,18,d5),
	HX_("curveTo",0a,60,88,ce),
	HX_("plotCoord",d4,98,a6,b1),
	HX_("aiColorSet",07,db,dc,c4),
	HX_("getColorType",47,1a,cd,37),
	HX_("aiStringPart",6c,00,c2,b7),
	::String(null()) };

::hx::Class Sketch_obj::__mClass;

static ::String Sketch_obj_sStaticFields[] = {
	HX_("create",fc,66,0f,7c),
	::String(null())
};

void Sketch_obj::__register()
{
	Sketch_obj _hx_dummy;
	Sketch_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("trilateral3.drawing.Sketch",23,f7,00,b3);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Sketch_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Sketch_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Sketch_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Sketch_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Sketch_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Sketch_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace trilateral3
} // end namespace drawing
