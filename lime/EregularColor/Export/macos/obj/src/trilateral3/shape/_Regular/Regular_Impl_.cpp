// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_fracs_DifferencePreference
#include <fracs/DifferencePreference.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_trilateral3_Trilateral
#include <trilateral3/Trilateral.h>
#endif
#ifndef INCLUDED_trilateral3_drawing_Pen
#include <trilateral3/drawing/Pen.h>
#endif
#ifndef INCLUDED_trilateral3_matrix_MatrixDozen
#include <trilateral3/matrix/MatrixDozen.h>
#endif
#ifndef INCLUDED_trilateral3_shape__IndexRange_IndexRange_Impl_
#include <trilateral3/shape/_IndexRange/IndexRange_Impl_.h>
#endif
#ifndef INCLUDED_trilateral3_shape__Regular_Regular_Impl_
#include <trilateral3/shape/_Regular/Regular_Impl_.h>
#endif
#ifndef INCLUDED_trilateral3_structure_RegularShape
#include <trilateral3/structure/RegularShape.h>
#endif
#ifndef INCLUDED_trilateral3_structure_StartEnd
#include <trilateral3/structure/StartEnd.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_7__new,"trilateral3.shape._Regular.Regular_Impl_","_new",0xf6c27850,"trilateral3.shape._Regular.Regular_Impl_._new","trilateral3/shape/Regular.hx",7,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_12_addRegular,"trilateral3.shape._Regular.Regular_Impl_","addRegular",0x87f53e6a,"trilateral3.shape._Regular.Regular_Impl_.addRegular","trilateral3/shape/Regular.hx",12,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_34_triangle,"trilateral3.shape._Regular.Regular_Impl_","triangle",0x3486c537,"trilateral3.shape._Regular.Regular_Impl_.triangle","trilateral3/shape/Regular.hx",34,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_37_triangle2,"trilateral3.shape._Regular.Regular_Impl_","triangle2",0xc165cb1b,"trilateral3.shape._Regular.Regular_Impl_.triangle2","trilateral3/shape/Regular.hx",37,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_45_square,"trilateral3.shape._Regular.Regular_Impl_","square",0xca673d4c,"trilateral3.shape._Regular.Regular_Impl_.square","trilateral3/shape/Regular.hx",45,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_48_square2,"trilateral3.shape._Regular.Regular_Impl_","square2",0x4fee6566,"trilateral3.shape._Regular.Regular_Impl_.square2","trilateral3/shape/Regular.hx",48,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_55_bar,"trilateral3.shape._Regular.Regular_Impl_","bar",0xefe541c4,"trilateral3.shape._Regular.Regular_Impl_.bar","trilateral3/shape/Regular.hx",55,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_65_colorTrianglesPos,"trilateral3.shape._Regular.Regular_Impl_","colorTrianglesPos",0x205e5b5d,"trilateral3.shape._Regular.Regular_Impl_.colorTrianglesPos","trilateral3/shape/Regular.hx",65,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_70_bar2,"trilateral3.shape._Regular.Regular_Impl_","bar2",0xf8b449ee,"trilateral3.shape._Regular.Regular_Impl_.bar2","trilateral3/shape/Regular.hx",70,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_78_pentagon,"trilateral3.shape._Regular.Regular_Impl_","pentagon",0x1af404ef,"trilateral3.shape._Regular.Regular_Impl_.pentagon","trilateral3/shape/Regular.hx",78,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_81_pentagon2,"trilateral3.shape._Regular.Regular_Impl_","pentagon2",0x7a904c63,"trilateral3.shape._Regular.Regular_Impl_.pentagon2","trilateral3/shape/Regular.hx",81,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_89_hexagon,"trilateral3.shape._Regular.Regular_Impl_","hexagon",0x74656451,"trilateral3.shape._Regular.Regular_Impl_.hexagon","trilateral3/shape/Regular.hx",89,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_92_hexagon2,"trilateral3.shape._Regular.Regular_Impl_","hexagon2",0x645262c1,"trilateral3.shape._Regular.Regular_Impl_.hexagon2","trilateral3/shape/Regular.hx",92,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_100_circle,"trilateral3.shape._Regular.Regular_Impl_","circle",0xc782aebf,"trilateral3.shape._Regular.Regular_Impl_.circle","trilateral3/shape/Regular.hx",100,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_103_circle2,"trilateral3.shape._Regular.Regular_Impl_","circle2",0xcad63893,"trilateral3.shape._Regular.Regular_Impl_.circle2","trilateral3/shape/Regular.hx",103,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_111_circleRadial,"trilateral3.shape._Regular.Regular_Impl_","circleRadial",0xd7c7fafe,"trilateral3.shape._Regular.Regular_Impl_.circleRadial","trilateral3/shape/Regular.hx",111,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_114_circleRadial2,"trilateral3.shape._Regular.Regular_Impl_","circleRadial2",0xf733a374,"trilateral3.shape._Regular.Regular_Impl_.circleRadial2","trilateral3/shape/Regular.hx",114,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_121_roundedSquare,"trilateral3.shape._Regular.Regular_Impl_","roundedSquare",0x9de21bdb,"trilateral3.shape._Regular.Regular_Impl_.roundedSquare","trilateral3/shape/Regular.hx",121,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_130_roundedSquare2,"trilateral3.shape._Regular.Regular_Impl_","roundedSquare2",0x87f643f7,"trilateral3.shape._Regular.Regular_Impl_.roundedSquare2","trilateral3/shape/Regular.hx",130,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_137_star,"trilateral3.shape._Regular.Regular_Impl_","star",0x03ff46c1,"trilateral3.shape._Regular.Regular_Impl_.star","trilateral3/shape/Regular.hx",137,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_146_star2,"trilateral3.shape._Regular.Regular_Impl_","star2",0x7b5ea251,"trilateral3.shape._Regular.Regular_Impl_.star2","trilateral3/shape/Regular.hx",146,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_153_polygon,"trilateral3.shape._Regular.Regular_Impl_","polygon",0xe7b0deeb,"trilateral3.shape._Regular.Regular_Impl_.polygon","trilateral3/shape/Regular.hx",153,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_162_polygonRadial,"trilateral3.shape._Regular.Regular_Impl_","polygonRadial",0x7a6a942a,"trilateral3.shape._Regular.Regular_Impl_.polygonRadial","trilateral3/shape/Regular.hx",162,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_172_circleMultiCorners,"trilateral3.shape._Regular.Regular_Impl_","circleMultiCorners",0xe99306e4,"trilateral3.shape._Regular.Regular_Impl_.circleMultiCorners","trilateral3/shape/Regular.hx",172,0x6ea60db8)
HX_LOCAL_STACK_FRAME(_hx_pos_49840cc5972809fa_175_polygonMultiCorners,"trilateral3.shape._Regular.Regular_Impl_","polygonMultiCorners",0xab5ec910,"trilateral3.shape._Regular.Regular_Impl_.polygonMultiCorners","trilateral3/shape/Regular.hx",175,0x6ea60db8)
namespace trilateral3{
namespace shape{
namespace _Regular{

void Regular_Impl__obj::__construct() { }

Dynamic Regular_Impl__obj::__CreateEmpty() { return new Regular_Impl__obj; }

void *Regular_Impl__obj::_hx_vtable = 0;

Dynamic Regular_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Regular_Impl__obj > _hx_result = new Regular_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Regular_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x289cc005;
}

 ::trilateral3::drawing::Pen Regular_Impl__obj::_new( ::trilateral3::drawing::Pen pen_){
            	HX_STACKFRAME(&_hx_pos_49840cc5972809fa_7__new)
HXDLIN(   7)		 ::trilateral3::drawing::Pen this1 = pen_;
HXDLIN(   7)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Regular_Impl__obj,_new,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::addRegular( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs,int style){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_12_addRegular)
HXDLIN(  12)		switch((int)(style)){
            			case (int)0: {
HXLINE(  14)				int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  14)				 ::Dynamic drawType = this1->drawType;
HXDLIN(  14)				Float ax = rs->x;
HXDLIN(  14)				Float ay = rs->y;
HXDLIN(  14)				Float radius = rs->radius;
HXDLIN(  14)				 ::Dynamic sides = 3;
HXDLIN(  14)				if (::hx::IsNull( sides )) {
HXLINE(  14)					sides = 36;
            				}
HXDLIN(  14)				Float pi = ::Math_obj::PI;
HXDLIN(  14)				Float theta = (pi / ( (Float)(2) ));
HXDLIN(  14)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  14)				Float bx;
HXDLIN(  14)				Float by;
HXDLIN(  14)				Float cx;
HXDLIN(  14)				Float cy;
HXDLIN(  14)				{
HXLINE(  14)					int _g = 0;
HXDLIN(  14)					 ::Dynamic _g1 = sides;
HXDLIN(  14)					while(::hx::IsLess( _g,_g1 )){
HXLINE(  14)						_g = (_g + 1);
HXDLIN(  14)						int i = (_g - 1);
HXDLIN(  14)						bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  14)						by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  14)						theta = (theta + step);
HXDLIN(  14)						cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  14)						cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  14)						{
HXLINE(  14)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  14)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  14)							if (::hx::IsNotNull( m )) {
HXLINE(  14)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  14)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
            					}
            				}
HXDLIN(  14)				int len = ( (int)(sides) );
HXDLIN(  14)				{
HXLINE(  14)					int col = rs->color;
HXDLIN(  14)					{
HXLINE(  14)						this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  14)						this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            					}
HXDLIN(  14)					{
HXLINE(  14)						int color = col;
HXDLIN(  14)						if ((color == -1)) {
HXLINE(  14)							color = this1->currentColor;
            						}
HXDLIN(  14)						this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            					}
            				}
HXDLIN(  14)				int end = ((start + len) - 1);
HXDLIN(  14)				 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  14)				return startEnd;
            			}
            			break;
            			case (int)1: {
HXLINE(  16)				int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  16)				 ::Dynamic drawType = this1->drawType;
HXDLIN(  16)				Float ax = rs->x;
HXDLIN(  16)				Float ay = rs->y;
HXDLIN(  16)				Float radius = rs->radius;
HXDLIN(  16)				 ::Dynamic sides = 4;
HXDLIN(  16)				if (::hx::IsNull( sides )) {
HXLINE(  16)					sides = 36;
            				}
HXDLIN(  16)				Float pi = ::Math_obj::PI;
HXDLIN(  16)				Float theta = (pi / ( (Float)(2) ));
HXDLIN(  16)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  16)				Float bx;
HXDLIN(  16)				Float by;
HXDLIN(  16)				Float cx;
HXDLIN(  16)				Float cy;
HXDLIN(  16)				{
HXLINE(  16)					int _g = 0;
HXDLIN(  16)					 ::Dynamic _g1 = sides;
HXDLIN(  16)					while(::hx::IsLess( _g,_g1 )){
HXLINE(  16)						_g = (_g + 1);
HXDLIN(  16)						int i = (_g - 1);
HXDLIN(  16)						bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  16)						by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  16)						theta = (theta + step);
HXDLIN(  16)						cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  16)						cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  16)						{
HXLINE(  16)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  16)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  16)							if (::hx::IsNotNull( m )) {
HXLINE(  16)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  16)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
            					}
            				}
HXDLIN(  16)				int len = ( (int)(sides) );
HXDLIN(  16)				{
HXLINE(  16)					int col = rs->color;
HXDLIN(  16)					{
HXLINE(  16)						this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  16)						this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            					}
HXDLIN(  16)					{
HXLINE(  16)						int color = col;
HXDLIN(  16)						if ((color == -1)) {
HXLINE(  16)							color = this1->currentColor;
            						}
HXDLIN(  16)						this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            					}
            				}
HXDLIN(  16)				int end = ((start + len) - 1);
HXDLIN(  16)				 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  16)				return startEnd;
            			}
            			break;
            			case (int)2: {
HXLINE(  18)				int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  18)				 ::Dynamic drawType = this1->drawType;
HXDLIN(  18)				Float x = (rs->x - rs->radius);
HXDLIN(  18)				Float ax = x;
HXDLIN(  18)				Float ay = (rs->y - (rs->radius / ( (Float)(4) )));
HXDLIN(  18)				Float bx = (x + (rs->radius * ( (Float)(2) )));
HXDLIN(  18)				Float by = ay;
HXDLIN(  18)				Float cx = bx;
HXDLIN(  18)				Float cy = (ay + (rs->radius / ( (Float)(3) )));
HXDLIN(  18)				Float dx = x;
HXDLIN(  18)				Float dy = cy;
HXDLIN(  18)				{
HXLINE(  18)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,dx,dy,0);
HXDLIN(  18)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  18)					if (::hx::IsNotNull( m )) {
HXLINE(  18)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  18)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  18)				{
HXLINE(  18)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,cx,cy,0,dx,dy,0);
HXDLIN(  18)					 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  18)					if (::hx::IsNotNull( m1 )) {
HXLINE(  18)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            					}
HXDLIN(  18)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  18)				int len = 2;
HXDLIN(  18)				{
HXLINE(  18)					int col = rs->color;
HXDLIN(  18)					{
HXLINE(  18)						this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  18)						this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            					}
HXDLIN(  18)					{
HXLINE(  18)						int color = col;
HXDLIN(  18)						if ((color == -1)) {
HXLINE(  18)							color = this1->currentColor;
            						}
HXDLIN(  18)						this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            					}
            				}
HXDLIN(  18)				int end = ((start + len) - 1);
HXDLIN(  18)				return  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
            			}
            			break;
            			case (int)3: {
HXLINE(  20)				int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  20)				 ::Dynamic drawType = this1->drawType;
HXDLIN(  20)				Float ax = rs->x;
HXDLIN(  20)				Float ay = rs->y;
HXDLIN(  20)				Float radius = rs->radius;
HXDLIN(  20)				 ::Dynamic sides = 5;
HXDLIN(  20)				if (::hx::IsNull( sides )) {
HXLINE(  20)					sides = 36;
            				}
HXDLIN(  20)				Float pi = ::Math_obj::PI;
HXDLIN(  20)				Float theta = (pi / ( (Float)(2) ));
HXDLIN(  20)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  20)				Float bx;
HXDLIN(  20)				Float by;
HXDLIN(  20)				Float cx;
HXDLIN(  20)				Float cy;
HXDLIN(  20)				{
HXLINE(  20)					int _g = 0;
HXDLIN(  20)					 ::Dynamic _g1 = sides;
HXDLIN(  20)					while(::hx::IsLess( _g,_g1 )){
HXLINE(  20)						_g = (_g + 1);
HXDLIN(  20)						int i = (_g - 1);
HXDLIN(  20)						bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  20)						by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  20)						theta = (theta + step);
HXDLIN(  20)						cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  20)						cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  20)						{
HXLINE(  20)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  20)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  20)							if (::hx::IsNotNull( m )) {
HXLINE(  20)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  20)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
            					}
            				}
HXDLIN(  20)				int len = ( (int)(sides) );
HXDLIN(  20)				{
HXLINE(  20)					int col = rs->color;
HXDLIN(  20)					{
HXLINE(  20)						this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  20)						this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            					}
HXDLIN(  20)					{
HXLINE(  20)						int color = col;
HXDLIN(  20)						if ((color == -1)) {
HXLINE(  20)							color = this1->currentColor;
            						}
HXDLIN(  20)						this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            					}
            				}
HXDLIN(  20)				int end = ((start + len) - 1);
HXDLIN(  20)				 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  20)				return startEnd;
            			}
            			break;
            			case (int)4: {
HXLINE(  22)				int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  22)				 ::Dynamic drawType = this1->drawType;
HXDLIN(  22)				Float ax = rs->x;
HXDLIN(  22)				Float ay = rs->y;
HXDLIN(  22)				Float radius = rs->radius;
HXDLIN(  22)				 ::Dynamic sides = 6;
HXDLIN(  22)				if (::hx::IsNull( sides )) {
HXLINE(  22)					sides = 36;
            				}
HXDLIN(  22)				Float pi = ::Math_obj::PI;
HXDLIN(  22)				Float theta = (pi / ( (Float)(2) ));
HXDLIN(  22)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  22)				Float bx;
HXDLIN(  22)				Float by;
HXDLIN(  22)				Float cx;
HXDLIN(  22)				Float cy;
HXDLIN(  22)				{
HXLINE(  22)					int _g = 0;
HXDLIN(  22)					 ::Dynamic _g1 = sides;
HXDLIN(  22)					while(::hx::IsLess( _g,_g1 )){
HXLINE(  22)						_g = (_g + 1);
HXDLIN(  22)						int i = (_g - 1);
HXDLIN(  22)						bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  22)						by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  22)						theta = (theta + step);
HXDLIN(  22)						cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  22)						cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  22)						{
HXLINE(  22)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  22)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  22)							if (::hx::IsNotNull( m )) {
HXLINE(  22)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  22)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
            					}
            				}
HXDLIN(  22)				int len = ( (int)(sides) );
HXDLIN(  22)				{
HXLINE(  22)					int col = rs->color;
HXDLIN(  22)					{
HXLINE(  22)						this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  22)						this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            					}
HXDLIN(  22)					{
HXLINE(  22)						int color = col;
HXDLIN(  22)						if ((color == -1)) {
HXLINE(  22)							color = this1->currentColor;
            						}
HXDLIN(  22)						this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            					}
            				}
HXDLIN(  22)				int end = ((start + len) - 1);
HXDLIN(  22)				 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  22)				return startEnd;
            			}
            			break;
            			case (int)5: {
HXLINE(  24)				int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  24)				 ::Dynamic drawType = this1->drawType;
HXDLIN(  24)				Float ax = rs->x;
HXDLIN(  24)				Float ay = rs->y;
HXDLIN(  24)				Float radius = rs->radius;
HXDLIN(  24)				 ::Dynamic sides = 36;
HXDLIN(  24)				if (::hx::IsNull( sides )) {
HXLINE(  24)					sides = 36;
            				}
HXDLIN(  24)				Float pi = ::Math_obj::PI;
HXDLIN(  24)				Float theta = (pi / ( (Float)(2) ));
HXDLIN(  24)				Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  24)				Float bx;
HXDLIN(  24)				Float by;
HXDLIN(  24)				Float cx;
HXDLIN(  24)				Float cy;
HXDLIN(  24)				{
HXLINE(  24)					int _g = 0;
HXDLIN(  24)					 ::Dynamic _g1 = sides;
HXDLIN(  24)					while(::hx::IsLess( _g,_g1 )){
HXLINE(  24)						_g = (_g + 1);
HXDLIN(  24)						int i = (_g - 1);
HXDLIN(  24)						bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  24)						by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  24)						theta = (theta + step);
HXDLIN(  24)						cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  24)						cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  24)						{
HXLINE(  24)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  24)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  24)							if (::hx::IsNotNull( m )) {
HXLINE(  24)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  24)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
            					}
            				}
HXDLIN(  24)				int len = ( (int)(sides) );
HXDLIN(  24)				{
HXLINE(  24)					int col = rs->color;
HXDLIN(  24)					{
HXLINE(  24)						this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  24)						this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            					}
HXDLIN(  24)					{
HXLINE(  24)						int color = col;
HXDLIN(  24)						if ((color == -1)) {
HXLINE(  24)							color = this1->currentColor;
            						}
HXDLIN(  24)						this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            					}
            				}
HXDLIN(  24)				int end = ((start + len) - 1);
HXDLIN(  24)				 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  24)				return startEnd;
            			}
            			break;
            			case (int)6: {
HXLINE(  26)				int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  26)				 ::Dynamic drawType = this1->drawType;
HXDLIN(  26)				Float x = (rs->x - rs->radius);
HXDLIN(  26)				Float y = (rs->y - rs->radius);
HXDLIN(  26)				Float width = (rs->radius * ( (Float)(2) ));
HXDLIN(  26)				Float height = (rs->radius * ( (Float)(2) ));
HXDLIN(  26)				Float radius = this1->rounded;
HXDLIN(  26)				Float pi = ::Math_obj::PI;
HXDLIN(  26)				Float pi_2 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN(  26)				Float ax = (x + radius);
HXDLIN(  26)				Float ay = (y + radius);
HXDLIN(  26)				Float bx = ((x + width) - radius);
HXDLIN(  26)				Float by = (y + radius);
HXDLIN(  26)				Float cx = bx;
HXDLIN(  26)				Float cy = ((y + height) - radius);
HXDLIN(  26)				Float dx = ax;
HXDLIN(  26)				Float dy = cy;
HXDLIN(  26)				int count = 0;
HXDLIN(  26)				Float ax1 = ax;
HXDLIN(  26)				Float ay1 = y;
HXDLIN(  26)				Float bx1 = (ax + (width - (radius * ( (Float)(2) ))));
HXDLIN(  26)				Float by1 = ay1;
HXDLIN(  26)				Float cx1 = bx1;
HXDLIN(  26)				Float cy1 = (ay1 + height);
HXDLIN(  26)				Float dx1 = ax;
HXDLIN(  26)				Float dy1 = cy1;
HXDLIN(  26)				{
HXLINE(  26)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax1,ay1,0,bx1,by1,0,dx1,dy1,0);
HXDLIN(  26)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  26)					if (::hx::IsNotNull( m )) {
HXLINE(  26)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  26)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  26)				{
HXLINE(  26)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx1,by1,0,cx1,cy1,0,dx1,dy1,0);
HXDLIN(  26)					 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  26)					if (::hx::IsNotNull( m1 )) {
HXLINE(  26)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            					}
HXDLIN(  26)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  26)				count = (count + 2);
HXDLIN(  26)				Float dimY = (height - (( (Float)(2) ) * radius));
HXDLIN(  26)				Float ax2 = x;
HXDLIN(  26)				Float ay2 = ay;
HXDLIN(  26)				Float bx2 = (x + radius);
HXDLIN(  26)				Float by2 = ay2;
HXDLIN(  26)				Float cx2 = bx2;
HXDLIN(  26)				Float cy2 = (ay2 + dimY);
HXDLIN(  26)				Float dx2 = x;
HXDLIN(  26)				Float dy2 = cy2;
HXDLIN(  26)				{
HXLINE(  26)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax2,ay2,0,bx2,by2,0,dx2,dy2,0);
HXDLIN(  26)					 ::trilateral3::matrix::MatrixDozen m2 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  26)					if (::hx::IsNotNull( m2 )) {
HXLINE(  26)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m2);
            					}
HXDLIN(  26)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  26)				{
HXLINE(  26)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx2,by2,0,cx2,cy2,0,dx2,dy2,0);
HXDLIN(  26)					 ::trilateral3::matrix::MatrixDozen m3 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  26)					if (::hx::IsNotNull( m3 )) {
HXLINE(  26)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m3);
            					}
HXDLIN(  26)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  26)				count = (count + 2);
HXDLIN(  26)				Float ax3 = bx;
HXDLIN(  26)				Float ay3 = by;
HXDLIN(  26)				Float bx3 = (bx + radius);
HXDLIN(  26)				Float by3 = ay3;
HXDLIN(  26)				Float cx3 = bx3;
HXDLIN(  26)				Float cy3 = (ay3 + dimY);
HXDLIN(  26)				Float dx3 = bx;
HXDLIN(  26)				Float dy3 = cy3;
HXDLIN(  26)				{
HXLINE(  26)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax3,ay3,0,bx3,by3,0,dx3,dy3,0);
HXDLIN(  26)					 ::trilateral3::matrix::MatrixDozen m4 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  26)					if (::hx::IsNotNull( m4 )) {
HXLINE(  26)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m4);
            					}
HXDLIN(  26)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  26)				{
HXLINE(  26)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx3,by3,0,cx3,cy3,0,dx3,dy3,0);
HXDLIN(  26)					 ::trilateral3::matrix::MatrixDozen m5 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  26)					if (::hx::IsNotNull( m5 )) {
HXLINE(  26)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m5);
            					}
HXDLIN(  26)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  26)				count = (count + 2);
HXDLIN(  26)				Float beta = -(pi);
HXDLIN(  26)				Float gamma = -(pi_2);
HXDLIN(  26)				Float pi1 = ::Math_obj::PI;
HXDLIN(  26)				Float step = ((pi1 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  26)				Float dif;
HXDLIN(  26)				switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            					case (int)0: {
HXLINE(  26)						Float f;
HXDLIN(  26)						bool f1;
HXDLIN(  26)						if ((beta >= 0)) {
HXLINE(  26)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f1 = false;
            						}
HXDLIN(  26)						if (f1) {
HXLINE(  26)							f = beta;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f2;
HXDLIN(  26)						bool f3;
HXDLIN(  26)						if ((gamma >= 0)) {
HXLINE(  26)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f3 = false;
            						}
HXDLIN(  26)						if (f3) {
HXLINE(  26)							f2 = gamma;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f2 = a;
            							}
            							else {
HXLINE(  26)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f2;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif1;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif1 = theta;
            						}
            						else {
HXLINE(  26)							dif1 = -(theta);
            						}
HXDLIN(  26)						if ((dif1 > 0)) {
HXLINE(  26)							dif = dif1;
            						}
            						else {
HXLINE(  26)							dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)1: {
HXLINE(  26)						Float f;
HXDLIN(  26)						bool f1;
HXDLIN(  26)						if ((beta >= 0)) {
HXLINE(  26)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f1 = false;
            						}
HXDLIN(  26)						if (f1) {
HXLINE(  26)							f = beta;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f2;
HXDLIN(  26)						bool f3;
HXDLIN(  26)						if ((gamma >= 0)) {
HXLINE(  26)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f3 = false;
            						}
HXDLIN(  26)						if (f3) {
HXLINE(  26)							f2 = gamma;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f2 = a;
            							}
            							else {
HXLINE(  26)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f2;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif1;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif1 = theta;
            						}
            						else {
HXLINE(  26)							dif1 = -(theta);
            						}
HXDLIN(  26)						if ((dif1 < 0)) {
HXLINE(  26)							dif = dif1;
            						}
            						else {
HXLINE(  26)							dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            						}
            					}
            					break;
            					case (int)2: {
HXLINE(  26)						Float f;
HXDLIN(  26)						bool f1;
HXDLIN(  26)						if ((beta >= 0)) {
HXLINE(  26)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f1 = false;
            						}
HXDLIN(  26)						if (f1) {
HXLINE(  26)							f = beta;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f2;
HXDLIN(  26)						bool f3;
HXDLIN(  26)						if ((gamma >= 0)) {
HXLINE(  26)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f3 = false;
            						}
HXDLIN(  26)						if (f3) {
HXLINE(  26)							f2 = gamma;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f2 = a;
            							}
            							else {
HXLINE(  26)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f2;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif1;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif1 = theta;
            						}
            						else {
HXLINE(  26)							dif1 = -(theta);
            						}
HXDLIN(  26)						if (smallest) {
HXLINE(  26)							dif = dif1;
            						}
            						else {
HXLINE(  26)							if (clockwise) {
HXLINE(  26)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE(  26)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXLINE(  26)						Float f;
HXDLIN(  26)						bool f1;
HXDLIN(  26)						if ((beta >= 0)) {
HXLINE(  26)							f1 = (beta > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f1 = false;
            						}
HXDLIN(  26)						if (f1) {
HXLINE(  26)							f = beta;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f2;
HXDLIN(  26)						bool f3;
HXDLIN(  26)						if ((gamma >= 0)) {
HXLINE(  26)							f3 = (gamma > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f3 = false;
            						}
HXDLIN(  26)						if (f3) {
HXLINE(  26)							f2 = gamma;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f2 = a;
            							}
            							else {
HXLINE(  26)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f2;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif1;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif1 = theta;
            						}
            						else {
HXLINE(  26)							dif1 = -(theta);
            						}
HXDLIN(  26)						if (largest) {
HXLINE(  26)							dif = dif1;
            						}
            						else {
HXLINE(  26)							if (clockwise) {
HXLINE(  26)								dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE(  26)								dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  26)				bool positive = (dif >= 0);
HXDLIN(  26)				int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN(  26)				Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN(  26)				Float angle = beta;
HXDLIN(  26)				Float cx4;
HXDLIN(  26)				Float cy4;
HXDLIN(  26)				Float bx4 = ( (Float)(0) );
HXDLIN(  26)				Float by4 = ( (Float)(0) );
HXDLIN(  26)				{
HXLINE(  26)					int _g = 0;
HXDLIN(  26)					int _g1 = (totalSteps + 1);
HXDLIN(  26)					while((_g < _g1)){
HXLINE(  26)						_g = (_g + 1);
HXDLIN(  26)						int i = (_g - 1);
HXDLIN(  26)						cx4 = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN(  26)						cy4 = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN(  26)						if ((i != 0)) {
HXLINE(  26)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx4,by4,0,cx4,cy4,0);
HXDLIN(  26)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  26)							if (::hx::IsNotNull( m )) {
HXLINE(  26)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  26)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  26)						angle = (angle + step1);
HXDLIN(  26)						bx4 = cx4;
HXDLIN(  26)						by4 = cy4;
            					}
            				}
HXDLIN(  26)				count = (count + totalSteps);
HXDLIN(  26)				Float pi2 = ::Math_obj::PI;
HXDLIN(  26)				Float step2 = ((pi2 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  26)				Float dif1;
HXDLIN(  26)				switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            					case (int)0: {
HXLINE(  26)						Float f;
HXDLIN(  26)						bool f1;
HXDLIN(  26)						if ((pi_2 >= 0)) {
HXLINE(  26)							f1 = (pi_2 > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f1 = false;
            						}
HXDLIN(  26)						if (f1) {
HXLINE(  26)							f = pi_2;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f2;
HXDLIN(  26)						bool f3;
HXDLIN(  26)						if ((pi >= 0)) {
HXLINE(  26)							f3 = (pi > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f3 = false;
            						}
HXDLIN(  26)						if (f3) {
HXLINE(  26)							f2 = pi;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f2 = a;
            							}
            							else {
HXLINE(  26)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f2;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif = theta;
            						}
            						else {
HXLINE(  26)							dif = -(theta);
            						}
HXDLIN(  26)						if ((dif > 0)) {
HXLINE(  26)							dif1 = dif;
            						}
            						else {
HXLINE(  26)							dif1 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)1: {
HXLINE(  26)						Float f;
HXDLIN(  26)						bool f1;
HXDLIN(  26)						if ((pi_2 >= 0)) {
HXLINE(  26)							f1 = (pi_2 > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f1 = false;
            						}
HXDLIN(  26)						if (f1) {
HXLINE(  26)							f = pi_2;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f2;
HXDLIN(  26)						bool f3;
HXDLIN(  26)						if ((pi >= 0)) {
HXLINE(  26)							f3 = (pi > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f3 = false;
            						}
HXDLIN(  26)						if (f3) {
HXLINE(  26)							f2 = pi;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f2 = a;
            							}
            							else {
HXLINE(  26)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f2;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif = theta;
            						}
            						else {
HXLINE(  26)							dif = -(theta);
            						}
HXDLIN(  26)						if ((dif < 0)) {
HXLINE(  26)							dif1 = dif;
            						}
            						else {
HXLINE(  26)							dif1 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)2: {
HXLINE(  26)						Float f;
HXDLIN(  26)						bool f1;
HXDLIN(  26)						if ((pi_2 >= 0)) {
HXLINE(  26)							f1 = (pi_2 > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f1 = false;
            						}
HXDLIN(  26)						if (f1) {
HXLINE(  26)							f = pi_2;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f2;
HXDLIN(  26)						bool f3;
HXDLIN(  26)						if ((pi >= 0)) {
HXLINE(  26)							f3 = (pi > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f3 = false;
            						}
HXDLIN(  26)						if (f3) {
HXLINE(  26)							f2 = pi;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f2 = a;
            							}
            							else {
HXLINE(  26)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f2;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif = theta;
            						}
            						else {
HXLINE(  26)							dif = -(theta);
            						}
HXDLIN(  26)						if (smallest) {
HXLINE(  26)							dif1 = dif;
            						}
            						else {
HXLINE(  26)							if (clockwise) {
HXLINE(  26)								dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE(  26)								dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXLINE(  26)						Float f;
HXDLIN(  26)						bool f1;
HXDLIN(  26)						if ((pi_2 >= 0)) {
HXLINE(  26)							f1 = (pi_2 > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f1 = false;
            						}
HXDLIN(  26)						if (f1) {
HXLINE(  26)							f = pi_2;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f2;
HXDLIN(  26)						bool f3;
HXDLIN(  26)						if ((pi >= 0)) {
HXLINE(  26)							f3 = (pi > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f3 = false;
            						}
HXDLIN(  26)						if (f3) {
HXLINE(  26)							f2 = pi;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f2 = a;
            							}
            							else {
HXLINE(  26)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f2;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif = theta;
            						}
            						else {
HXLINE(  26)							dif = -(theta);
            						}
HXDLIN(  26)						if (largest) {
HXLINE(  26)							dif1 = dif;
            						}
            						else {
HXLINE(  26)							if (clockwise) {
HXLINE(  26)								dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE(  26)								dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  26)				bool positive1 = (dif1 >= 0);
HXDLIN(  26)				int totalSteps1 = ::Math_obj::ceil((::Math_obj::abs(dif1) / step2));
HXDLIN(  26)				Float step3 = (dif1 / ( (Float)(totalSteps1) ));
HXDLIN(  26)				Float angle1 = pi_2;
HXDLIN(  26)				Float cx5;
HXDLIN(  26)				Float cy5;
HXDLIN(  26)				Float bx5 = ( (Float)(0) );
HXDLIN(  26)				Float by5 = ( (Float)(0) );
HXDLIN(  26)				{
HXLINE(  26)					int _g2 = 0;
HXDLIN(  26)					int _g3 = (totalSteps1 + 1);
HXDLIN(  26)					while((_g2 < _g3)){
HXLINE(  26)						_g2 = (_g2 + 1);
HXDLIN(  26)						int i = (_g2 - 1);
HXDLIN(  26)						cx5 = (bx + (radius * ::Math_obj::sin(angle1)));
HXDLIN(  26)						cy5 = (by + (radius * ::Math_obj::cos(angle1)));
HXDLIN(  26)						if ((i != 0)) {
HXLINE(  26)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,bx5,by5,0,cx5,cy5,0);
HXDLIN(  26)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  26)							if (::hx::IsNotNull( m )) {
HXLINE(  26)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  26)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  26)						angle1 = (angle1 + step3);
HXDLIN(  26)						bx5 = cx5;
HXDLIN(  26)						by5 = cy5;
            					}
            				}
HXDLIN(  26)				count = (count + totalSteps1);
HXDLIN(  26)				Float pi3 = ::Math_obj::PI;
HXDLIN(  26)				Float step4 = ((pi3 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  26)				Float dif2;
HXDLIN(  26)				switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            					case (int)0: {
HXLINE(  26)						Float f;
HXDLIN(  26)						bool f1;
HXDLIN(  26)						if ((pi_2 >= 0)) {
HXLINE(  26)							f1 = (pi_2 > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f1 = false;
            						}
HXDLIN(  26)						if (f1) {
HXLINE(  26)							f = pi_2;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f2;
HXDLIN(  26)						if ((0 > ::Math_obj::PI)) {
HXLINE(  26)							f2 = ( (Float)(0) );
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f2 = a;
            							}
            							else {
HXLINE(  26)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f2;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif = theta;
            						}
            						else {
HXLINE(  26)							dif = -(theta);
            						}
HXDLIN(  26)						if ((dif > 0)) {
HXLINE(  26)							dif2 = dif;
            						}
            						else {
HXLINE(  26)							dif2 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)1: {
HXLINE(  26)						Float f;
HXDLIN(  26)						bool f1;
HXDLIN(  26)						if ((pi_2 >= 0)) {
HXLINE(  26)							f1 = (pi_2 > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f1 = false;
            						}
HXDLIN(  26)						if (f1) {
HXLINE(  26)							f = pi_2;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f2;
HXDLIN(  26)						if ((0 > ::Math_obj::PI)) {
HXLINE(  26)							f2 = ( (Float)(0) );
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f2 = a;
            							}
            							else {
HXLINE(  26)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f2;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif = theta;
            						}
            						else {
HXLINE(  26)							dif = -(theta);
            						}
HXDLIN(  26)						if ((dif < 0)) {
HXLINE(  26)							dif2 = dif;
            						}
            						else {
HXLINE(  26)							dif2 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)2: {
HXLINE(  26)						Float f;
HXDLIN(  26)						bool f1;
HXDLIN(  26)						if ((pi_2 >= 0)) {
HXLINE(  26)							f1 = (pi_2 > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f1 = false;
            						}
HXDLIN(  26)						if (f1) {
HXLINE(  26)							f = pi_2;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f2;
HXDLIN(  26)						if ((0 > ::Math_obj::PI)) {
HXLINE(  26)							f2 = ( (Float)(0) );
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f2 = a;
            							}
            							else {
HXLINE(  26)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f2;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif = theta;
            						}
            						else {
HXLINE(  26)							dif = -(theta);
            						}
HXDLIN(  26)						if (smallest) {
HXLINE(  26)							dif2 = dif;
            						}
            						else {
HXLINE(  26)							if (clockwise) {
HXLINE(  26)								dif2 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE(  26)								dif2 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXLINE(  26)						Float f;
HXDLIN(  26)						bool f1;
HXDLIN(  26)						if ((pi_2 >= 0)) {
HXLINE(  26)							f1 = (pi_2 > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f1 = false;
            						}
HXDLIN(  26)						if (f1) {
HXLINE(  26)							f = pi_2;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f2;
HXDLIN(  26)						if ((0 > ::Math_obj::PI)) {
HXLINE(  26)							f2 = ( (Float)(0) );
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f2 = a;
            							}
            							else {
HXLINE(  26)								f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f2;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif = theta;
            						}
            						else {
HXLINE(  26)							dif = -(theta);
            						}
HXDLIN(  26)						if (largest) {
HXLINE(  26)							dif2 = dif;
            						}
            						else {
HXLINE(  26)							if (clockwise) {
HXLINE(  26)								dif2 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE(  26)								dif2 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  26)				bool positive2 = (dif2 >= 0);
HXDLIN(  26)				int totalSteps2 = ::Math_obj::ceil((::Math_obj::abs(dif2) / step4));
HXDLIN(  26)				Float step5 = (dif2 / ( (Float)(totalSteps2) ));
HXDLIN(  26)				Float angle2 = pi_2;
HXDLIN(  26)				Float cx6;
HXDLIN(  26)				Float cy6;
HXDLIN(  26)				Float bx6 = ( (Float)(0) );
HXDLIN(  26)				Float by6 = ( (Float)(0) );
HXDLIN(  26)				{
HXLINE(  26)					int _g4 = 0;
HXDLIN(  26)					int _g5 = (totalSteps2 + 1);
HXDLIN(  26)					while((_g4 < _g5)){
HXLINE(  26)						_g4 = (_g4 + 1);
HXDLIN(  26)						int i = (_g4 - 1);
HXDLIN(  26)						cx6 = (cx + (radius * ::Math_obj::sin(angle2)));
HXDLIN(  26)						cy6 = (cy + (radius * ::Math_obj::cos(angle2)));
HXDLIN(  26)						if ((i != 0)) {
HXLINE(  26)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(cx,cy,0,bx6,by6,0,cx6,cy6,0);
HXDLIN(  26)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  26)							if (::hx::IsNotNull( m )) {
HXLINE(  26)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  26)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  26)						angle2 = (angle2 + step5);
HXDLIN(  26)						bx6 = cx6;
HXDLIN(  26)						by6 = cy6;
            					}
            				}
HXDLIN(  26)				count = (count + totalSteps2);
HXDLIN(  26)				Float gamma1 = -(pi_2);
HXDLIN(  26)				Float pi4 = ::Math_obj::PI;
HXDLIN(  26)				Float step6 = ((pi4 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN(  26)				Float dif3;
HXDLIN(  26)				switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            					case (int)0: {
HXLINE(  26)						Float f;
HXDLIN(  26)						if ((0 > ::Math_obj::PI)) {
HXLINE(  26)							f = ( (Float)(0) );
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f1;
HXDLIN(  26)						bool f2;
HXDLIN(  26)						if ((gamma1 >= 0)) {
HXLINE(  26)							f2 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f2 = false;
            						}
HXDLIN(  26)						if (f2) {
HXLINE(  26)							f1 = gamma1;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f1 = a;
            							}
            							else {
HXLINE(  26)								f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f1;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif = theta;
            						}
            						else {
HXLINE(  26)							dif = -(theta);
            						}
HXDLIN(  26)						if ((dif > 0)) {
HXLINE(  26)							dif3 = dif;
            						}
            						else {
HXLINE(  26)							dif3 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)1: {
HXLINE(  26)						Float f;
HXDLIN(  26)						if ((0 > ::Math_obj::PI)) {
HXLINE(  26)							f = ( (Float)(0) );
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f1;
HXDLIN(  26)						bool f2;
HXDLIN(  26)						if ((gamma1 >= 0)) {
HXLINE(  26)							f2 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f2 = false;
            						}
HXDLIN(  26)						if (f2) {
HXLINE(  26)							f1 = gamma1;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f1 = a;
            							}
            							else {
HXLINE(  26)								f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f1;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif = theta;
            						}
            						else {
HXLINE(  26)							dif = -(theta);
            						}
HXDLIN(  26)						if ((dif < 0)) {
HXLINE(  26)							dif3 = dif;
            						}
            						else {
HXLINE(  26)							dif3 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            						}
            					}
            					break;
            					case (int)2: {
HXLINE(  26)						Float f;
HXDLIN(  26)						if ((0 > ::Math_obj::PI)) {
HXLINE(  26)							f = ( (Float)(0) );
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f1;
HXDLIN(  26)						bool f2;
HXDLIN(  26)						if ((gamma1 >= 0)) {
HXLINE(  26)							f2 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f2 = false;
            						}
HXDLIN(  26)						if (f2) {
HXLINE(  26)							f1 = gamma1;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f1 = a;
            							}
            							else {
HXLINE(  26)								f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f1;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool smallest = (theta <= ::Math_obj::PI);
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif = theta;
            						}
            						else {
HXLINE(  26)							dif = -(theta);
            						}
HXDLIN(  26)						if (smallest) {
HXLINE(  26)							dif3 = dif;
            						}
            						else {
HXLINE(  26)							if (clockwise) {
HXLINE(  26)								dif3 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE(  26)								dif3 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            					case (int)3: {
HXLINE(  26)						Float f;
HXDLIN(  26)						if ((0 > ::Math_obj::PI)) {
HXLINE(  26)							f = ( (Float)(0) );
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f = a;
            							}
            							else {
HXLINE(  26)								f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this1 = f;
HXDLIN(  26)						Float za = this1;
HXDLIN(  26)						Float f1;
HXDLIN(  26)						bool f2;
HXDLIN(  26)						if ((gamma1 >= 0)) {
HXLINE(  26)							f2 = (gamma1 > ::Math_obj::PI);
            						}
            						else {
HXLINE(  26)							f2 = false;
            						}
HXDLIN(  26)						if (f2) {
HXLINE(  26)							f1 = gamma1;
            						}
            						else {
HXLINE(  26)							Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  26)							if ((a >= 0)) {
HXLINE(  26)								f1 = a;
            							}
            							else {
HXLINE(  26)								f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            							}
            						}
HXDLIN(  26)						Float this2 = f1;
HXDLIN(  26)						Float zb = this2;
HXDLIN(  26)						Float fa = za;
HXDLIN(  26)						Float fb = zb;
HXDLIN(  26)						Float theta = ::Math_obj::abs((fa - fb));
HXDLIN(  26)						bool largest = (theta > ::Math_obj::PI);
HXDLIN(  26)						bool clockwise = (fa < fb);
HXDLIN(  26)						Float dif;
HXDLIN(  26)						if (clockwise) {
HXLINE(  26)							dif = theta;
            						}
            						else {
HXLINE(  26)							dif = -(theta);
            						}
HXDLIN(  26)						if (largest) {
HXLINE(  26)							dif3 = dif;
            						}
            						else {
HXLINE(  26)							if (clockwise) {
HXLINE(  26)								dif3 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            							}
            							else {
HXLINE(  26)								dif3 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            							}
            						}
            					}
            					break;
            				}
HXDLIN(  26)				bool positive3 = (dif3 >= 0);
HXDLIN(  26)				int totalSteps3 = ::Math_obj::ceil((::Math_obj::abs(dif3) / step6));
HXDLIN(  26)				Float step7 = (dif3 / ( (Float)(totalSteps3) ));
HXDLIN(  26)				Float angle3 = ( (Float)(0) );
HXDLIN(  26)				Float cx7;
HXDLIN(  26)				Float cy7;
HXDLIN(  26)				Float bx7 = ( (Float)(0) );
HXDLIN(  26)				Float by7 = ( (Float)(0) );
HXDLIN(  26)				{
HXLINE(  26)					int _g6 = 0;
HXDLIN(  26)					int _g7 = (totalSteps3 + 1);
HXDLIN(  26)					while((_g6 < _g7)){
HXLINE(  26)						_g6 = (_g6 + 1);
HXDLIN(  26)						int i = (_g6 - 1);
HXDLIN(  26)						cx7 = (dx + (radius * ::Math_obj::sin(angle3)));
HXDLIN(  26)						cy7 = (dy + (radius * ::Math_obj::cos(angle3)));
HXDLIN(  26)						if ((i != 0)) {
HXLINE(  26)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx,dy,0,bx7,by7,0,cx7,cy7,0);
HXDLIN(  26)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  26)							if (::hx::IsNotNull( m )) {
HXLINE(  26)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN(  26)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN(  26)						angle3 = (angle3 + step7);
HXDLIN(  26)						bx7 = cx7;
HXDLIN(  26)						by7 = cy7;
            					}
            				}
HXDLIN(  26)				count = (count + totalSteps3);
HXDLIN(  26)				int len = count;
HXDLIN(  26)				{
HXLINE(  26)					int col = rs->color;
HXDLIN(  26)					{
HXLINE(  26)						this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  26)						this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            					}
HXDLIN(  26)					{
HXLINE(  26)						int color = col;
HXDLIN(  26)						if ((color == -1)) {
HXLINE(  26)							color = this1->currentColor;
            						}
HXDLIN(  26)						this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            					}
            				}
HXDLIN(  26)				int end = ((start + len) - 1);
HXDLIN(  26)				return  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
            			}
            			break;
            			case (int)7: {
HXLINE(  28)				int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  28)				 ::Dynamic drawType = this1->drawType;
HXDLIN(  28)				Float px = (rs->x - rs->radius);
HXDLIN(  28)				Float py = (rs->y - rs->radius);
HXDLIN(  28)				Float radius = (rs->radius * ( (Float)(2) ));
HXDLIN(  28)				 ::Dynamic theta = (rs->radius * ( (Float)(2) ));
HXDLIN(  28)				if (::hx::IsNull( theta )) {
HXLINE(  28)					theta = 0;
            				}
HXDLIN(  28)				Float pi = ::Math_obj::PI;
HXDLIN(  28)				Float omega = (-(pi) + theta);
HXDLIN(  28)				radius = (radius / ((Float)1.9));
HXDLIN(  28)				px = (px + radius);
HXDLIN(  28)				py = (py + radius);
HXDLIN(  28)				Float a0x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN(  28)				Float a0y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN(  28)				omega = (omega + (pi / ( (Float)(3) )));
HXDLIN(  28)				Float a1x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN(  28)				Float a1y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN(  28)				omega = (omega + (pi / ( (Float)(3) )));
HXDLIN(  28)				Float b0x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN(  28)				Float b0y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN(  28)				omega = (omega + (pi / ( (Float)(3) )));
HXDLIN(  28)				Float b1x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN(  28)				Float b1y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN(  28)				omega = (omega + (pi / ( (Float)(3) )));
HXDLIN(  28)				Float c0x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN(  28)				Float c0y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN(  28)				omega = (omega + (pi / ( (Float)(3) )));
HXDLIN(  28)				Float c1x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN(  28)				Float c1y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN(  28)				{
HXLINE(  28)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(a0x,a0y,0,b0x,b0y,0,c0x,c0y,0);
HXDLIN(  28)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  28)					if (::hx::IsNotNull( m )) {
HXLINE(  28)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  28)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  28)				{
HXLINE(  28)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(a1x,a1y,0,b1x,b1y,0,c1x,c1y,0);
HXDLIN(  28)					 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  28)					if (::hx::IsNotNull( m1 )) {
HXLINE(  28)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            					}
HXDLIN(  28)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN(  28)				int len = 2;
HXDLIN(  28)				{
HXLINE(  28)					int col = rs->color;
HXDLIN(  28)					{
HXLINE(  28)						this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  28)						this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            					}
HXDLIN(  28)					{
HXLINE(  28)						int color = col;
HXDLIN(  28)						if ((color == -1)) {
HXLINE(  28)							color = this1->currentColor;
            						}
HXDLIN(  28)						this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            					}
            				}
HXDLIN(  28)				int end = ((start + len) - 1);
HXDLIN(  28)				return  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
            			}
            			break;
            		}
HXLINE(  12)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Regular_Impl__obj,addRegular,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::triangle( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_34_triangle)
HXDLIN(  34)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  34)		 ::Dynamic drawType = this1->drawType;
HXDLIN(  34)		Float ax = rs->x;
HXDLIN(  34)		Float ay = rs->y;
HXDLIN(  34)		Float radius = rs->radius;
HXDLIN(  34)		 ::Dynamic sides = 3;
HXDLIN(  34)		if (::hx::IsNull( sides )) {
HXDLIN(  34)			sides = 36;
            		}
HXDLIN(  34)		Float pi = ::Math_obj::PI;
HXDLIN(  34)		Float theta = (pi / ( (Float)(2) ));
HXDLIN(  34)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  34)		Float bx;
HXDLIN(  34)		Float by;
HXDLIN(  34)		Float cx;
HXDLIN(  34)		Float cy;
HXDLIN(  34)		{
HXDLIN(  34)			int _g = 0;
HXDLIN(  34)			 ::Dynamic _g1 = sides;
HXDLIN(  34)			while(::hx::IsLess( _g,_g1 )){
HXDLIN(  34)				_g = (_g + 1);
HXDLIN(  34)				int i = (_g - 1);
HXDLIN(  34)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  34)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  34)				theta = (theta + step);
HXDLIN(  34)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  34)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  34)				{
HXDLIN(  34)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  34)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  34)					if (::hx::IsNotNull( m )) {
HXDLIN(  34)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  34)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  34)		int len = ( (int)(sides) );
HXDLIN(  34)		{
HXDLIN(  34)			int col = rs->color;
HXDLIN(  34)			{
HXDLIN(  34)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  34)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN(  34)			{
HXDLIN(  34)				int color = col;
HXDLIN(  34)				if ((color == -1)) {
HXDLIN(  34)					color = this1->currentColor;
            				}
HXDLIN(  34)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  34)		int end = ((start + len) - 1);
HXDLIN(  34)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  34)		return startEnd;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,triangle,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::triangle2( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_37_triangle2)
HXLINE(  38)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  38)		 ::Dynamic drawType = this1->drawType;
HXDLIN(  38)		Float ax = rs->x;
HXDLIN(  38)		Float ay = rs->y;
HXDLIN(  38)		Float radius = rs->radius;
HXDLIN(  38)		 ::Dynamic sides = 3;
HXDLIN(  38)		if (::hx::IsNull( sides )) {
HXLINE(  38)			sides = 36;
            		}
HXDLIN(  38)		Float pi = ::Math_obj::PI;
HXDLIN(  38)		Float theta = (pi / ( (Float)(2) ));
HXDLIN(  38)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  38)		Float bx;
HXDLIN(  38)		Float by;
HXDLIN(  38)		Float cx;
HXDLIN(  38)		Float cy;
HXDLIN(  38)		{
HXLINE(  38)			int _g = 0;
HXDLIN(  38)			 ::Dynamic _g1 = sides;
HXDLIN(  38)			while(::hx::IsLess( _g,_g1 )){
HXLINE(  38)				_g = (_g + 1);
HXDLIN(  38)				int i = (_g - 1);
HXDLIN(  38)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  38)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  38)				theta = (theta + step);
HXDLIN(  38)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  38)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  38)				{
HXLINE(  38)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  38)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  38)					if (::hx::IsNotNull( m )) {
HXLINE(  38)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  38)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  38)		int len = ( (int)(sides) );
HXDLIN(  38)		{
HXLINE(  38)			int col = rs->color;
HXDLIN(  38)			{
HXLINE(  38)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  38)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN(  38)			{
HXLINE(  38)				int color = col;
HXDLIN(  38)				if ((color == -1)) {
HXLINE(  38)					color = this1->currentColor;
            				}
HXDLIN(  38)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  38)		int end = ((start + len) - 1);
HXDLIN(  38)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  38)		 ::trilateral3::structure::StartEnd se0 = startEnd;
HXLINE(  39)		int start1 = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  39)		 ::Dynamic drawType1 = this1->drawType;
HXDLIN(  39)		Float ax1 = rs->x;
HXDLIN(  39)		Float ay1 = rs->y;
HXDLIN(  39)		Float radius1 = rs->radius;
HXDLIN(  39)		 ::Dynamic sides1 = 3;
HXDLIN(  39)		if (::hx::IsNull( sides1 )) {
HXLINE(  39)			sides1 = 36;
            		}
HXDLIN(  39)		Float pi1 = ::Math_obj::PI;
HXDLIN(  39)		Float theta1 = (pi1 / ( (Float)(2) ));
HXDLIN(  39)		Float step1 = ((pi1 * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN(  39)		Float bx1;
HXDLIN(  39)		Float by1;
HXDLIN(  39)		Float cx1;
HXDLIN(  39)		Float cy1;
HXDLIN(  39)		{
HXLINE(  39)			int _g2 = 0;
HXDLIN(  39)			 ::Dynamic _g3 = sides1;
HXDLIN(  39)			while(::hx::IsLess( _g2,_g3 )){
HXLINE(  39)				_g2 = (_g2 + 1);
HXDLIN(  39)				int i = (_g2 - 1);
HXDLIN(  39)				bx1 = (ax1 + (radius1 * ::Math_obj::sin(theta1)));
HXDLIN(  39)				by1 = (ay1 + (radius1 * ::Math_obj::cos(theta1)));
HXDLIN(  39)				theta1 = (theta1 + step1);
HXDLIN(  39)				cx1 = (ax1 + (radius1 * ::Math_obj::sin(theta1)));
HXDLIN(  39)				cy1 = (ay1 + (radius1 * ::Math_obj::cos(theta1)));
HXDLIN(  39)				{
HXLINE(  39)					drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax1,ay1,0,bx1,by1,0,cx1,cy1,0);
HXDLIN(  39)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  39)					if (::hx::IsNotNull( m )) {
HXLINE(  39)						drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  39)					drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  39)		int len1 = ( (int)(sides1) );
HXDLIN(  39)		{
HXLINE(  39)			int col1 = rs->color;
HXDLIN(  39)			{
HXLINE(  39)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
HXDLIN(  39)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
            			}
HXDLIN(  39)			{
HXLINE(  39)				int color1 = col1;
HXDLIN(  39)				if ((color1 == -1)) {
HXLINE(  39)					color1 = this1->currentColor;
            				}
HXDLIN(  39)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
            			}
            		}
HXDLIN(  39)		int end1 = ((start1 + len1) - 1);
HXDLIN(  39)		 ::trilateral3::structure::StartEnd startEnd1 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start1,end1);
HXDLIN(  39)		 ::trilateral3::structure::StartEnd se1 = startEnd1;
HXLINE(  40)		{
HXLINE(  40)			 ::trilateral3::matrix::MatrixDozen r = ( ( ::trilateral3::matrix::MatrixDozen)(this1->rotateX(::Math_obj::PI)) );
HXDLIN(  40)			 ::trilateral3::matrix::MatrixDozen s = ( ( ::trilateral3::matrix::MatrixDozen)(this1->translateX(this1->dz)) );
HXDLIN(  40)			 ::trilateral3::matrix::MatrixDozen m =  ::trilateral3::matrix::MatrixDozen_obj::__alloc( HX_CTX ,(((r->a * s->a) + (r->b * s->e)) + (r->c * s->i)),(((r->a * s->b) + (r->b * s->f)) + (r->c * s->j)),(((r->a * s->c) + (r->b * s->g)) + (r->c * s->k)),((((r->a * s->d) + (r->b * s->h)) + (r->c * s->l)) + r->d),(((r->e * s->a) + (r->f * s->e)) + (r->g * s->i)),(((r->e * s->b) + (r->f * s->f)) + (r->g * s->j)),(((r->e * s->c) + (r->f * s->g)) + (r->g * s->k)),((((r->e * s->d) + (r->f * s->h)) + (r->g * s->l)) + r->h),(((r->i * s->a) + (r->j * s->e)) + (r->k * s->i)),(((r->i * s->b) + (r->j * s->f)) + (r->k * s->j)),(((r->i * s->c) + (r->j * s->g)) + (r->k * s->k)),((((r->i * s->d) + (r->j * s->h)) + (r->k * s->l)) + r->l));
HXDLIN(  40)			this1->drawType->__Field(HX_("transformRange",b1,c0,a1,5a),::hx::paccDynamic)(m,se1);
            		}
HXLINE(  41)		int begin = ::Std_obj::_hx_int(::Math_obj::min(( (Float)(se0->start) ),( (Float)(se1->start) )));
HXDLIN(  41)		int _hx_tmp;
HXDLIN(  41)		if ((begin == se0->start)) {
HXLINE(  41)			_hx_tmp = se1->end;
            		}
            		else {
HXLINE(  41)			_hx_tmp = se0->end;
            		}
HXDLIN(  41)		return ::trilateral3::shape::_IndexRange::IndexRange_Impl__obj::_new( ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,begin,_hx_tmp));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,triangle2,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::square( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_45_square)
HXDLIN(  45)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  45)		 ::Dynamic drawType = this1->drawType;
HXDLIN(  45)		Float ax = rs->x;
HXDLIN(  45)		Float ay = rs->y;
HXDLIN(  45)		Float radius = rs->radius;
HXDLIN(  45)		 ::Dynamic sides = 4;
HXDLIN(  45)		if (::hx::IsNull( sides )) {
HXDLIN(  45)			sides = 36;
            		}
HXDLIN(  45)		Float pi = ::Math_obj::PI;
HXDLIN(  45)		Float theta = (pi / ( (Float)(2) ));
HXDLIN(  45)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  45)		Float bx;
HXDLIN(  45)		Float by;
HXDLIN(  45)		Float cx;
HXDLIN(  45)		Float cy;
HXDLIN(  45)		{
HXDLIN(  45)			int _g = 0;
HXDLIN(  45)			 ::Dynamic _g1 = sides;
HXDLIN(  45)			while(::hx::IsLess( _g,_g1 )){
HXDLIN(  45)				_g = (_g + 1);
HXDLIN(  45)				int i = (_g - 1);
HXDLIN(  45)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  45)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  45)				theta = (theta + step);
HXDLIN(  45)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  45)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  45)				{
HXDLIN(  45)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  45)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  45)					if (::hx::IsNotNull( m )) {
HXDLIN(  45)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  45)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  45)		int len = ( (int)(sides) );
HXDLIN(  45)		{
HXDLIN(  45)			int col = rs->color;
HXDLIN(  45)			{
HXDLIN(  45)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  45)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN(  45)			{
HXDLIN(  45)				int color = col;
HXDLIN(  45)				if ((color == -1)) {
HXDLIN(  45)					color = this1->currentColor;
            				}
HXDLIN(  45)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  45)		int end = ((start + len) - 1);
HXDLIN(  45)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  45)		return startEnd;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,square,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::square2( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_48_square2)
HXLINE(  49)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  49)		 ::Dynamic drawType = this1->drawType;
HXDLIN(  49)		Float ax = rs->x;
HXDLIN(  49)		Float ay = rs->y;
HXDLIN(  49)		Float radius = rs->radius;
HXDLIN(  49)		 ::Dynamic sides = 4;
HXDLIN(  49)		if (::hx::IsNull( sides )) {
HXLINE(  49)			sides = 36;
            		}
HXDLIN(  49)		Float pi = ::Math_obj::PI;
HXDLIN(  49)		Float theta = (pi / ( (Float)(2) ));
HXDLIN(  49)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  49)		Float bx;
HXDLIN(  49)		Float by;
HXDLIN(  49)		Float cx;
HXDLIN(  49)		Float cy;
HXDLIN(  49)		{
HXLINE(  49)			int _g = 0;
HXDLIN(  49)			 ::Dynamic _g1 = sides;
HXDLIN(  49)			while(::hx::IsLess( _g,_g1 )){
HXLINE(  49)				_g = (_g + 1);
HXDLIN(  49)				int i = (_g - 1);
HXDLIN(  49)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  49)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  49)				theta = (theta + step);
HXDLIN(  49)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  49)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  49)				{
HXLINE(  49)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  49)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  49)					if (::hx::IsNotNull( m )) {
HXLINE(  49)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  49)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  49)		int len = ( (int)(sides) );
HXDLIN(  49)		{
HXLINE(  49)			int col = rs->color;
HXDLIN(  49)			{
HXLINE(  49)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  49)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN(  49)			{
HXLINE(  49)				int color = col;
HXDLIN(  49)				if ((color == -1)) {
HXLINE(  49)					color = this1->currentColor;
            				}
HXDLIN(  49)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  49)		int end = ((start + len) - 1);
HXDLIN(  49)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  49)		 ::trilateral3::structure::StartEnd se0 = startEnd;
HXLINE(  50)		int start1 = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  50)		 ::Dynamic drawType1 = this1->drawType;
HXDLIN(  50)		Float ax1 = rs->x;
HXDLIN(  50)		Float ay1 = rs->y;
HXDLIN(  50)		Float radius1 = rs->radius;
HXDLIN(  50)		 ::Dynamic sides1 = 4;
HXDLIN(  50)		if (::hx::IsNull( sides1 )) {
HXLINE(  50)			sides1 = 36;
            		}
HXDLIN(  50)		Float pi1 = ::Math_obj::PI;
HXDLIN(  50)		Float theta1 = (pi1 / ( (Float)(2) ));
HXDLIN(  50)		Float step1 = ((pi1 * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN(  50)		Float bx1;
HXDLIN(  50)		Float by1;
HXDLIN(  50)		Float cx1;
HXDLIN(  50)		Float cy1;
HXDLIN(  50)		{
HXLINE(  50)			int _g2 = 0;
HXDLIN(  50)			 ::Dynamic _g3 = sides1;
HXDLIN(  50)			while(::hx::IsLess( _g2,_g3 )){
HXLINE(  50)				_g2 = (_g2 + 1);
HXDLIN(  50)				int i = (_g2 - 1);
HXDLIN(  50)				bx1 = (ax1 + (radius1 * ::Math_obj::sin(theta1)));
HXDLIN(  50)				by1 = (ay1 + (radius1 * ::Math_obj::cos(theta1)));
HXDLIN(  50)				theta1 = (theta1 + step1);
HXDLIN(  50)				cx1 = (ax1 + (radius1 * ::Math_obj::sin(theta1)));
HXDLIN(  50)				cy1 = (ay1 + (radius1 * ::Math_obj::cos(theta1)));
HXDLIN(  50)				{
HXLINE(  50)					drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax1,ay1,0,bx1,by1,0,cx1,cy1,0);
HXDLIN(  50)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  50)					if (::hx::IsNotNull( m )) {
HXLINE(  50)						drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  50)					drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  50)		int len1 = ( (int)(sides1) );
HXDLIN(  50)		{
HXLINE(  50)			int col1 = rs->color;
HXDLIN(  50)			{
HXLINE(  50)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
HXDLIN(  50)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
            			}
HXDLIN(  50)			{
HXLINE(  50)				int color1 = col1;
HXDLIN(  50)				if ((color1 == -1)) {
HXLINE(  50)					color1 = this1->currentColor;
            				}
HXDLIN(  50)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
            			}
            		}
HXDLIN(  50)		int end1 = ((start1 + len1) - 1);
HXDLIN(  50)		 ::trilateral3::structure::StartEnd startEnd1 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start1,end1);
HXDLIN(  50)		 ::trilateral3::structure::StartEnd se1 = startEnd1;
HXLINE(  51)		{
HXLINE(  51)			 ::trilateral3::matrix::MatrixDozen r = ( ( ::trilateral3::matrix::MatrixDozen)(this1->rotateX(::Math_obj::PI)) );
HXDLIN(  51)			 ::trilateral3::matrix::MatrixDozen s = ( ( ::trilateral3::matrix::MatrixDozen)(this1->translateX(this1->dz)) );
HXDLIN(  51)			 ::trilateral3::matrix::MatrixDozen m =  ::trilateral3::matrix::MatrixDozen_obj::__alloc( HX_CTX ,(((r->a * s->a) + (r->b * s->e)) + (r->c * s->i)),(((r->a * s->b) + (r->b * s->f)) + (r->c * s->j)),(((r->a * s->c) + (r->b * s->g)) + (r->c * s->k)),((((r->a * s->d) + (r->b * s->h)) + (r->c * s->l)) + r->d),(((r->e * s->a) + (r->f * s->e)) + (r->g * s->i)),(((r->e * s->b) + (r->f * s->f)) + (r->g * s->j)),(((r->e * s->c) + (r->f * s->g)) + (r->g * s->k)),((((r->e * s->d) + (r->f * s->h)) + (r->g * s->l)) + r->h),(((r->i * s->a) + (r->j * s->e)) + (r->k * s->i)),(((r->i * s->b) + (r->j * s->f)) + (r->k * s->j)),(((r->i * s->c) + (r->j * s->g)) + (r->k * s->k)),((((r->i * s->d) + (r->j * s->h)) + (r->k * s->l)) + r->l));
HXDLIN(  51)			this1->drawType->__Field(HX_("transformRange",b1,c0,a1,5a),::hx::paccDynamic)(m,se1);
            		}
HXLINE(  52)		int begin = ::Std_obj::_hx_int(::Math_obj::min(( (Float)(se0->start) ),( (Float)(se1->start) )));
HXDLIN(  52)		int _hx_tmp;
HXDLIN(  52)		if ((begin == se0->start)) {
HXLINE(  52)			_hx_tmp = se1->end;
            		}
            		else {
HXLINE(  52)			_hx_tmp = se0->end;
            		}
HXDLIN(  52)		return ::trilateral3::shape::_IndexRange::IndexRange_Impl__obj::_new( ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,begin,_hx_tmp));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,square2,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::bar( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_55_bar)
HXLINE(  56)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXLINE(  57)		 ::Dynamic drawType = this1->drawType;
HXDLIN(  57)		Float x = (rs->x - rs->radius);
HXDLIN(  57)		Float ax = x;
HXDLIN(  57)		Float ay = (rs->y - (rs->radius / ( (Float)(4) )));
HXDLIN(  57)		Float bx = (x + (rs->radius * ( (Float)(2) )));
HXDLIN(  57)		Float by = ay;
HXDLIN(  57)		Float cx = bx;
HXDLIN(  57)		Float cy = (ay + (rs->radius / ( (Float)(3) )));
HXDLIN(  57)		Float dx = x;
HXDLIN(  57)		Float dy = cy;
HXDLIN(  57)		{
HXLINE(  57)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,dx,dy,0);
HXDLIN(  57)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  57)			if (::hx::IsNotNull( m )) {
HXLINE(  57)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN(  57)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  57)		{
HXLINE(  57)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,cx,cy,0,dx,dy,0);
HXDLIN(  57)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  57)			if (::hx::IsNotNull( m1 )) {
HXLINE(  57)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN(  57)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  57)		int len = 2;
HXLINE(  59)		{
HXLINE(  59)			int col = rs->color;
HXDLIN(  59)			{
HXLINE(  59)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  59)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN(  59)			{
HXLINE(  59)				int color = col;
HXDLIN(  59)				if ((color == -1)) {
HXLINE(  59)					color = this1->currentColor;
            				}
HXDLIN(  59)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXLINE(  60)		int end = ((start + len) - 1);
HXLINE(  61)		return  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,bar,return )

void Regular_Impl__obj::colorTrianglesPos( ::trilateral3::drawing::Pen this1,Float start,int col,int len){
            	HX_STACKFRAME(&_hx_pos_49840cc5972809fa_65_colorTrianglesPos)
HXLINE(  66)		{
HXLINE(  66)			this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  66)			this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            		}
HXLINE(  67)		{
HXLINE(  67)			int color = col;
HXDLIN(  67)			if ((color == -1)) {
HXLINE(  67)				color = this1->currentColor;
            			}
HXDLIN(  67)			this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Regular_Impl__obj,colorTrianglesPos,(void))

 ::trilateral3::structure::StartEnd Regular_Impl__obj::bar2( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_70_bar2)
HXLINE(  71)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  71)		 ::Dynamic drawType = this1->drawType;
HXDLIN(  71)		Float x = (rs->x - rs->radius);
HXDLIN(  71)		Float ax = x;
HXDLIN(  71)		Float ay = (rs->y - (rs->radius / ( (Float)(4) )));
HXDLIN(  71)		Float bx = (x + (rs->radius * ( (Float)(2) )));
HXDLIN(  71)		Float by = ay;
HXDLIN(  71)		Float cx = bx;
HXDLIN(  71)		Float cy = (ay + (rs->radius / ( (Float)(3) )));
HXDLIN(  71)		Float dx = x;
HXDLIN(  71)		Float dy = cy;
HXDLIN(  71)		{
HXLINE(  71)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,dx,dy,0);
HXDLIN(  71)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  71)			if (::hx::IsNotNull( m )) {
HXLINE(  71)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN(  71)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  71)		{
HXLINE(  71)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,cx,cy,0,dx,dy,0);
HXDLIN(  71)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  71)			if (::hx::IsNotNull( m1 )) {
HXLINE(  71)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN(  71)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  71)		int len = 2;
HXDLIN(  71)		{
HXLINE(  71)			int col = rs->color;
HXDLIN(  71)			{
HXLINE(  71)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  71)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN(  71)			{
HXLINE(  71)				int color = col;
HXDLIN(  71)				if ((color == -1)) {
HXLINE(  71)					color = this1->currentColor;
            				}
HXDLIN(  71)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  71)		int end = ((start + len) - 1);
HXDLIN(  71)		 ::trilateral3::structure::StartEnd se0 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXLINE(  72)		int start1 = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  72)		 ::Dynamic drawType1 = this1->drawType;
HXDLIN(  72)		Float x1 = (rs->x - rs->radius);
HXDLIN(  72)		Float ax1 = x1;
HXDLIN(  72)		Float ay1 = (rs->y - (rs->radius / ( (Float)(4) )));
HXDLIN(  72)		Float bx1 = (x1 + (rs->radius * ( (Float)(2) )));
HXDLIN(  72)		Float by1 = ay1;
HXDLIN(  72)		Float cx1 = bx1;
HXDLIN(  72)		Float cy1 = (ay1 + (rs->radius / ( (Float)(3) )));
HXDLIN(  72)		Float dx1 = x1;
HXDLIN(  72)		Float dy1 = cy1;
HXDLIN(  72)		{
HXLINE(  72)			drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax1,ay1,0,bx1,by1,0,dx1,dy1,0);
HXDLIN(  72)			 ::trilateral3::matrix::MatrixDozen m2 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  72)			if (::hx::IsNotNull( m2 )) {
HXLINE(  72)				drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m2);
            			}
HXDLIN(  72)			drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  72)		{
HXLINE(  72)			drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx1,by1,0,cx1,cy1,0,dx1,dy1,0);
HXDLIN(  72)			 ::trilateral3::matrix::MatrixDozen m3 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  72)			if (::hx::IsNotNull( m3 )) {
HXLINE(  72)				drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m3);
            			}
HXDLIN(  72)			drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  72)		int len1 = 2;
HXDLIN(  72)		{
HXLINE(  72)			int col1 = rs->color;
HXDLIN(  72)			{
HXLINE(  72)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
HXDLIN(  72)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
            			}
HXDLIN(  72)			{
HXLINE(  72)				int color1 = col1;
HXDLIN(  72)				if ((color1 == -1)) {
HXLINE(  72)					color1 = this1->currentColor;
            				}
HXDLIN(  72)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
            			}
            		}
HXDLIN(  72)		int end1 = ((start1 + len1) - 1);
HXDLIN(  72)		 ::trilateral3::structure::StartEnd se1 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start1,end1);
HXLINE(  73)		{
HXLINE(  73)			 ::trilateral3::matrix::MatrixDozen r = ( ( ::trilateral3::matrix::MatrixDozen)(this1->rotateX(::Math_obj::PI)) );
HXDLIN(  73)			 ::trilateral3::matrix::MatrixDozen s = ( ( ::trilateral3::matrix::MatrixDozen)(this1->translateX(this1->dz)) );
HXDLIN(  73)			 ::trilateral3::matrix::MatrixDozen m4 =  ::trilateral3::matrix::MatrixDozen_obj::__alloc( HX_CTX ,(((r->a * s->a) + (r->b * s->e)) + (r->c * s->i)),(((r->a * s->b) + (r->b * s->f)) + (r->c * s->j)),(((r->a * s->c) + (r->b * s->g)) + (r->c * s->k)),((((r->a * s->d) + (r->b * s->h)) + (r->c * s->l)) + r->d),(((r->e * s->a) + (r->f * s->e)) + (r->g * s->i)),(((r->e * s->b) + (r->f * s->f)) + (r->g * s->j)),(((r->e * s->c) + (r->f * s->g)) + (r->g * s->k)),((((r->e * s->d) + (r->f * s->h)) + (r->g * s->l)) + r->h),(((r->i * s->a) + (r->j * s->e)) + (r->k * s->i)),(((r->i * s->b) + (r->j * s->f)) + (r->k * s->j)),(((r->i * s->c) + (r->j * s->g)) + (r->k * s->k)),((((r->i * s->d) + (r->j * s->h)) + (r->k * s->l)) + r->l));
HXDLIN(  73)			this1->drawType->__Field(HX_("transformRange",b1,c0,a1,5a),::hx::paccDynamic)(m4,se1);
            		}
HXLINE(  74)		int begin = ::Std_obj::_hx_int(::Math_obj::min(( (Float)(se0->start) ),( (Float)(se1->start) )));
HXDLIN(  74)		int _hx_tmp;
HXDLIN(  74)		if ((begin == se0->start)) {
HXLINE(  74)			_hx_tmp = se1->end;
            		}
            		else {
HXLINE(  74)			_hx_tmp = se0->end;
            		}
HXDLIN(  74)		return ::trilateral3::shape::_IndexRange::IndexRange_Impl__obj::_new( ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,begin,_hx_tmp));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,bar2,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::pentagon( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_78_pentagon)
HXDLIN(  78)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  78)		 ::Dynamic drawType = this1->drawType;
HXDLIN(  78)		Float ax = rs->x;
HXDLIN(  78)		Float ay = rs->y;
HXDLIN(  78)		Float radius = rs->radius;
HXDLIN(  78)		 ::Dynamic sides = 5;
HXDLIN(  78)		if (::hx::IsNull( sides )) {
HXDLIN(  78)			sides = 36;
            		}
HXDLIN(  78)		Float pi = ::Math_obj::PI;
HXDLIN(  78)		Float theta = (pi / ( (Float)(2) ));
HXDLIN(  78)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  78)		Float bx;
HXDLIN(  78)		Float by;
HXDLIN(  78)		Float cx;
HXDLIN(  78)		Float cy;
HXDLIN(  78)		{
HXDLIN(  78)			int _g = 0;
HXDLIN(  78)			 ::Dynamic _g1 = sides;
HXDLIN(  78)			while(::hx::IsLess( _g,_g1 )){
HXDLIN(  78)				_g = (_g + 1);
HXDLIN(  78)				int i = (_g - 1);
HXDLIN(  78)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  78)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  78)				theta = (theta + step);
HXDLIN(  78)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  78)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  78)				{
HXDLIN(  78)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  78)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  78)					if (::hx::IsNotNull( m )) {
HXDLIN(  78)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  78)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  78)		int len = ( (int)(sides) );
HXDLIN(  78)		{
HXDLIN(  78)			int col = rs->color;
HXDLIN(  78)			{
HXDLIN(  78)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  78)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN(  78)			{
HXDLIN(  78)				int color = col;
HXDLIN(  78)				if ((color == -1)) {
HXDLIN(  78)					color = this1->currentColor;
            				}
HXDLIN(  78)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  78)		int end = ((start + len) - 1);
HXDLIN(  78)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  78)		return startEnd;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,pentagon,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::pentagon2( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_81_pentagon2)
HXLINE(  82)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  82)		 ::Dynamic drawType = this1->drawType;
HXDLIN(  82)		Float ax = rs->x;
HXDLIN(  82)		Float ay = rs->y;
HXDLIN(  82)		Float radius = rs->radius;
HXDLIN(  82)		 ::Dynamic sides = 5;
HXDLIN(  82)		if (::hx::IsNull( sides )) {
HXLINE(  82)			sides = 36;
            		}
HXDLIN(  82)		Float pi = ::Math_obj::PI;
HXDLIN(  82)		Float theta = (pi / ( (Float)(2) ));
HXDLIN(  82)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  82)		Float bx;
HXDLIN(  82)		Float by;
HXDLIN(  82)		Float cx;
HXDLIN(  82)		Float cy;
HXDLIN(  82)		{
HXLINE(  82)			int _g = 0;
HXDLIN(  82)			 ::Dynamic _g1 = sides;
HXDLIN(  82)			while(::hx::IsLess( _g,_g1 )){
HXLINE(  82)				_g = (_g + 1);
HXDLIN(  82)				int i = (_g - 1);
HXDLIN(  82)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  82)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  82)				theta = (theta + step);
HXDLIN(  82)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  82)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  82)				{
HXLINE(  82)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  82)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  82)					if (::hx::IsNotNull( m )) {
HXLINE(  82)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  82)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  82)		int len = ( (int)(sides) );
HXDLIN(  82)		{
HXLINE(  82)			int col = rs->color;
HXDLIN(  82)			{
HXLINE(  82)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  82)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN(  82)			{
HXLINE(  82)				int color = col;
HXDLIN(  82)				if ((color == -1)) {
HXLINE(  82)					color = this1->currentColor;
            				}
HXDLIN(  82)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  82)		int end = ((start + len) - 1);
HXDLIN(  82)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  82)		 ::trilateral3::structure::StartEnd se0 = startEnd;
HXLINE(  83)		int start1 = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  83)		 ::Dynamic drawType1 = this1->drawType;
HXDLIN(  83)		Float ax1 = rs->x;
HXDLIN(  83)		Float ay1 = rs->y;
HXDLIN(  83)		Float radius1 = rs->radius;
HXDLIN(  83)		 ::Dynamic sides1 = 5;
HXDLIN(  83)		if (::hx::IsNull( sides1 )) {
HXLINE(  83)			sides1 = 36;
            		}
HXDLIN(  83)		Float pi1 = ::Math_obj::PI;
HXDLIN(  83)		Float theta1 = (pi1 / ( (Float)(2) ));
HXDLIN(  83)		Float step1 = ((pi1 * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN(  83)		Float bx1;
HXDLIN(  83)		Float by1;
HXDLIN(  83)		Float cx1;
HXDLIN(  83)		Float cy1;
HXDLIN(  83)		{
HXLINE(  83)			int _g2 = 0;
HXDLIN(  83)			 ::Dynamic _g3 = sides1;
HXDLIN(  83)			while(::hx::IsLess( _g2,_g3 )){
HXLINE(  83)				_g2 = (_g2 + 1);
HXDLIN(  83)				int i = (_g2 - 1);
HXDLIN(  83)				bx1 = (ax1 + (radius1 * ::Math_obj::sin(theta1)));
HXDLIN(  83)				by1 = (ay1 + (radius1 * ::Math_obj::cos(theta1)));
HXDLIN(  83)				theta1 = (theta1 + step1);
HXDLIN(  83)				cx1 = (ax1 + (radius1 * ::Math_obj::sin(theta1)));
HXDLIN(  83)				cy1 = (ay1 + (radius1 * ::Math_obj::cos(theta1)));
HXDLIN(  83)				{
HXLINE(  83)					drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax1,ay1,0,bx1,by1,0,cx1,cy1,0);
HXDLIN(  83)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  83)					if (::hx::IsNotNull( m )) {
HXLINE(  83)						drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  83)					drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  83)		int len1 = ( (int)(sides1) );
HXDLIN(  83)		{
HXLINE(  83)			int col1 = rs->color;
HXDLIN(  83)			{
HXLINE(  83)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
HXDLIN(  83)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
            			}
HXDLIN(  83)			{
HXLINE(  83)				int color1 = col1;
HXDLIN(  83)				if ((color1 == -1)) {
HXLINE(  83)					color1 = this1->currentColor;
            				}
HXDLIN(  83)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
            			}
            		}
HXDLIN(  83)		int end1 = ((start1 + len1) - 1);
HXDLIN(  83)		 ::trilateral3::structure::StartEnd startEnd1 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start1,end1);
HXDLIN(  83)		 ::trilateral3::structure::StartEnd se1 = startEnd1;
HXLINE(  84)		{
HXLINE(  84)			 ::trilateral3::matrix::MatrixDozen r = ( ( ::trilateral3::matrix::MatrixDozen)(this1->rotateX(::Math_obj::PI)) );
HXDLIN(  84)			 ::trilateral3::matrix::MatrixDozen s = ( ( ::trilateral3::matrix::MatrixDozen)(this1->translateX(this1->dz)) );
HXDLIN(  84)			 ::trilateral3::matrix::MatrixDozen m =  ::trilateral3::matrix::MatrixDozen_obj::__alloc( HX_CTX ,(((r->a * s->a) + (r->b * s->e)) + (r->c * s->i)),(((r->a * s->b) + (r->b * s->f)) + (r->c * s->j)),(((r->a * s->c) + (r->b * s->g)) + (r->c * s->k)),((((r->a * s->d) + (r->b * s->h)) + (r->c * s->l)) + r->d),(((r->e * s->a) + (r->f * s->e)) + (r->g * s->i)),(((r->e * s->b) + (r->f * s->f)) + (r->g * s->j)),(((r->e * s->c) + (r->f * s->g)) + (r->g * s->k)),((((r->e * s->d) + (r->f * s->h)) + (r->g * s->l)) + r->h),(((r->i * s->a) + (r->j * s->e)) + (r->k * s->i)),(((r->i * s->b) + (r->j * s->f)) + (r->k * s->j)),(((r->i * s->c) + (r->j * s->g)) + (r->k * s->k)),((((r->i * s->d) + (r->j * s->h)) + (r->k * s->l)) + r->l));
HXDLIN(  84)			this1->drawType->__Field(HX_("transformRange",b1,c0,a1,5a),::hx::paccDynamic)(m,se1);
            		}
HXLINE(  85)		int begin = ::Std_obj::_hx_int(::Math_obj::min(( (Float)(se0->start) ),( (Float)(se1->start) )));
HXDLIN(  85)		int _hx_tmp;
HXDLIN(  85)		if ((begin == se0->start)) {
HXLINE(  85)			_hx_tmp = se1->end;
            		}
            		else {
HXLINE(  85)			_hx_tmp = se0->end;
            		}
HXDLIN(  85)		return ::trilateral3::shape::_IndexRange::IndexRange_Impl__obj::_new( ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,begin,_hx_tmp));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,pentagon2,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::hexagon( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_89_hexagon)
HXDLIN(  89)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  89)		 ::Dynamic drawType = this1->drawType;
HXDLIN(  89)		Float ax = rs->x;
HXDLIN(  89)		Float ay = rs->y;
HXDLIN(  89)		Float radius = rs->radius;
HXDLIN(  89)		 ::Dynamic sides = 6;
HXDLIN(  89)		if (::hx::IsNull( sides )) {
HXDLIN(  89)			sides = 36;
            		}
HXDLIN(  89)		Float pi = ::Math_obj::PI;
HXDLIN(  89)		Float theta = (pi / ( (Float)(2) ));
HXDLIN(  89)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  89)		Float bx;
HXDLIN(  89)		Float by;
HXDLIN(  89)		Float cx;
HXDLIN(  89)		Float cy;
HXDLIN(  89)		{
HXDLIN(  89)			int _g = 0;
HXDLIN(  89)			 ::Dynamic _g1 = sides;
HXDLIN(  89)			while(::hx::IsLess( _g,_g1 )){
HXDLIN(  89)				_g = (_g + 1);
HXDLIN(  89)				int i = (_g - 1);
HXDLIN(  89)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  89)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  89)				theta = (theta + step);
HXDLIN(  89)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  89)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  89)				{
HXDLIN(  89)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  89)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  89)					if (::hx::IsNotNull( m )) {
HXDLIN(  89)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  89)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  89)		int len = ( (int)(sides) );
HXDLIN(  89)		{
HXDLIN(  89)			int col = rs->color;
HXDLIN(  89)			{
HXDLIN(  89)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  89)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN(  89)			{
HXDLIN(  89)				int color = col;
HXDLIN(  89)				if ((color == -1)) {
HXDLIN(  89)					color = this1->currentColor;
            				}
HXDLIN(  89)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  89)		int end = ((start + len) - 1);
HXDLIN(  89)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  89)		return startEnd;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,hexagon,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::hexagon2( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_92_hexagon2)
HXLINE(  93)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  93)		 ::Dynamic drawType = this1->drawType;
HXDLIN(  93)		Float ax = rs->x;
HXDLIN(  93)		Float ay = rs->y;
HXDLIN(  93)		Float radius = rs->radius;
HXDLIN(  93)		 ::Dynamic sides = 6;
HXDLIN(  93)		if (::hx::IsNull( sides )) {
HXLINE(  93)			sides = 36;
            		}
HXDLIN(  93)		Float pi = ::Math_obj::PI;
HXDLIN(  93)		Float theta = (pi / ( (Float)(2) ));
HXDLIN(  93)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN(  93)		Float bx;
HXDLIN(  93)		Float by;
HXDLIN(  93)		Float cx;
HXDLIN(  93)		Float cy;
HXDLIN(  93)		{
HXLINE(  93)			int _g = 0;
HXDLIN(  93)			 ::Dynamic _g1 = sides;
HXDLIN(  93)			while(::hx::IsLess( _g,_g1 )){
HXLINE(  93)				_g = (_g + 1);
HXDLIN(  93)				int i = (_g - 1);
HXDLIN(  93)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  93)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  93)				theta = (theta + step);
HXDLIN(  93)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN(  93)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN(  93)				{
HXLINE(  93)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN(  93)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  93)					if (::hx::IsNotNull( m )) {
HXLINE(  93)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  93)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  93)		int len = ( (int)(sides) );
HXDLIN(  93)		{
HXLINE(  93)			int col = rs->color;
HXDLIN(  93)			{
HXLINE(  93)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN(  93)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN(  93)			{
HXLINE(  93)				int color = col;
HXDLIN(  93)				if ((color == -1)) {
HXLINE(  93)					color = this1->currentColor;
            				}
HXDLIN(  93)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN(  93)		int end = ((start + len) - 1);
HXDLIN(  93)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN(  93)		 ::trilateral3::structure::StartEnd se0 = startEnd;
HXLINE(  94)		int start1 = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN(  94)		 ::Dynamic drawType1 = this1->drawType;
HXDLIN(  94)		Float ax1 = rs->x;
HXDLIN(  94)		Float ay1 = rs->y;
HXDLIN(  94)		Float radius1 = rs->radius;
HXDLIN(  94)		 ::Dynamic sides1 = 6;
HXDLIN(  94)		if (::hx::IsNull( sides1 )) {
HXLINE(  94)			sides1 = 36;
            		}
HXDLIN(  94)		Float pi1 = ::Math_obj::PI;
HXDLIN(  94)		Float theta1 = (pi1 / ( (Float)(2) ));
HXDLIN(  94)		Float step1 = ((pi1 * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN(  94)		Float bx1;
HXDLIN(  94)		Float by1;
HXDLIN(  94)		Float cx1;
HXDLIN(  94)		Float cy1;
HXDLIN(  94)		{
HXLINE(  94)			int _g2 = 0;
HXDLIN(  94)			 ::Dynamic _g3 = sides1;
HXDLIN(  94)			while(::hx::IsLess( _g2,_g3 )){
HXLINE(  94)				_g2 = (_g2 + 1);
HXDLIN(  94)				int i = (_g2 - 1);
HXDLIN(  94)				bx1 = (ax1 + (radius1 * ::Math_obj::sin(theta1)));
HXDLIN(  94)				by1 = (ay1 + (radius1 * ::Math_obj::cos(theta1)));
HXDLIN(  94)				theta1 = (theta1 + step1);
HXDLIN(  94)				cx1 = (ax1 + (radius1 * ::Math_obj::sin(theta1)));
HXDLIN(  94)				cy1 = (ay1 + (radius1 * ::Math_obj::cos(theta1)));
HXDLIN(  94)				{
HXLINE(  94)					drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax1,ay1,0,bx1,by1,0,cx1,cy1,0);
HXDLIN(  94)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  94)					if (::hx::IsNotNull( m )) {
HXLINE(  94)						drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN(  94)					drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN(  94)		int len1 = ( (int)(sides1) );
HXDLIN(  94)		{
HXLINE(  94)			int col1 = rs->color;
HXDLIN(  94)			{
HXLINE(  94)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
HXDLIN(  94)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
            			}
HXDLIN(  94)			{
HXLINE(  94)				int color1 = col1;
HXDLIN(  94)				if ((color1 == -1)) {
HXLINE(  94)					color1 = this1->currentColor;
            				}
HXDLIN(  94)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
            			}
            		}
HXDLIN(  94)		int end1 = ((start1 + len1) - 1);
HXDLIN(  94)		 ::trilateral3::structure::StartEnd startEnd1 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start1,end1);
HXDLIN(  94)		 ::trilateral3::structure::StartEnd se1 = startEnd1;
HXLINE(  95)		{
HXLINE(  95)			 ::trilateral3::matrix::MatrixDozen r = ( ( ::trilateral3::matrix::MatrixDozen)(this1->rotateX(::Math_obj::PI)) );
HXDLIN(  95)			 ::trilateral3::matrix::MatrixDozen s = ( ( ::trilateral3::matrix::MatrixDozen)(this1->translateX(this1->dz)) );
HXDLIN(  95)			 ::trilateral3::matrix::MatrixDozen m =  ::trilateral3::matrix::MatrixDozen_obj::__alloc( HX_CTX ,(((r->a * s->a) + (r->b * s->e)) + (r->c * s->i)),(((r->a * s->b) + (r->b * s->f)) + (r->c * s->j)),(((r->a * s->c) + (r->b * s->g)) + (r->c * s->k)),((((r->a * s->d) + (r->b * s->h)) + (r->c * s->l)) + r->d),(((r->e * s->a) + (r->f * s->e)) + (r->g * s->i)),(((r->e * s->b) + (r->f * s->f)) + (r->g * s->j)),(((r->e * s->c) + (r->f * s->g)) + (r->g * s->k)),((((r->e * s->d) + (r->f * s->h)) + (r->g * s->l)) + r->h),(((r->i * s->a) + (r->j * s->e)) + (r->k * s->i)),(((r->i * s->b) + (r->j * s->f)) + (r->k * s->j)),(((r->i * s->c) + (r->j * s->g)) + (r->k * s->k)),((((r->i * s->d) + (r->j * s->h)) + (r->k * s->l)) + r->l));
HXDLIN(  95)			this1->drawType->__Field(HX_("transformRange",b1,c0,a1,5a),::hx::paccDynamic)(m,se1);
            		}
HXLINE(  96)		int begin = ::Std_obj::_hx_int(::Math_obj::min(( (Float)(se0->start) ),( (Float)(se1->start) )));
HXDLIN(  96)		int _hx_tmp;
HXDLIN(  96)		if ((begin == se0->start)) {
HXLINE(  96)			_hx_tmp = se1->end;
            		}
            		else {
HXLINE(  96)			_hx_tmp = se0->end;
            		}
HXDLIN(  96)		return ::trilateral3::shape::_IndexRange::IndexRange_Impl__obj::_new( ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,begin,_hx_tmp));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,hexagon2,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::circle( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_100_circle)
HXDLIN( 100)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN( 100)		 ::Dynamic drawType = this1->drawType;
HXDLIN( 100)		Float ax = rs->x;
HXDLIN( 100)		Float ay = rs->y;
HXDLIN( 100)		Float radius = rs->radius;
HXDLIN( 100)		 ::Dynamic sides = 36;
HXDLIN( 100)		if (::hx::IsNull( sides )) {
HXDLIN( 100)			sides = 36;
            		}
HXDLIN( 100)		Float pi = ::Math_obj::PI;
HXDLIN( 100)		Float theta = (pi / ( (Float)(2) ));
HXDLIN( 100)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 100)		Float bx;
HXDLIN( 100)		Float by;
HXDLIN( 100)		Float cx;
HXDLIN( 100)		Float cy;
HXDLIN( 100)		{
HXDLIN( 100)			int _g = 0;
HXDLIN( 100)			 ::Dynamic _g1 = sides;
HXDLIN( 100)			while(::hx::IsLess( _g,_g1 )){
HXDLIN( 100)				_g = (_g + 1);
HXDLIN( 100)				int i = (_g - 1);
HXDLIN( 100)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN( 100)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN( 100)				theta = (theta + step);
HXDLIN( 100)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN( 100)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN( 100)				{
HXDLIN( 100)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 100)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 100)					if (::hx::IsNotNull( m )) {
HXDLIN( 100)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 100)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN( 100)		int len = ( (int)(sides) );
HXDLIN( 100)		{
HXDLIN( 100)			int col = rs->color;
HXDLIN( 100)			{
HXDLIN( 100)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN( 100)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN( 100)			{
HXDLIN( 100)				int color = col;
HXDLIN( 100)				if ((color == -1)) {
HXDLIN( 100)					color = this1->currentColor;
            				}
HXDLIN( 100)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN( 100)		int end = ((start + len) - 1);
HXDLIN( 100)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN( 100)		return startEnd;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,circle,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::circle2( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_103_circle2)
HXLINE( 104)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN( 104)		 ::Dynamic drawType = this1->drawType;
HXDLIN( 104)		Float ax = rs->x;
HXDLIN( 104)		Float ay = rs->y;
HXDLIN( 104)		Float radius = rs->radius;
HXDLIN( 104)		 ::Dynamic sides = 36;
HXDLIN( 104)		if (::hx::IsNull( sides )) {
HXLINE( 104)			sides = 36;
            		}
HXDLIN( 104)		Float pi = ::Math_obj::PI;
HXDLIN( 104)		Float theta = (pi / ( (Float)(2) ));
HXDLIN( 104)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 104)		Float bx;
HXDLIN( 104)		Float by;
HXDLIN( 104)		Float cx;
HXDLIN( 104)		Float cy;
HXDLIN( 104)		{
HXLINE( 104)			int _g = 0;
HXDLIN( 104)			 ::Dynamic _g1 = sides;
HXDLIN( 104)			while(::hx::IsLess( _g,_g1 )){
HXLINE( 104)				_g = (_g + 1);
HXDLIN( 104)				int i = (_g - 1);
HXDLIN( 104)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN( 104)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN( 104)				theta = (theta + step);
HXDLIN( 104)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN( 104)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN( 104)				{
HXLINE( 104)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 104)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 104)					if (::hx::IsNotNull( m )) {
HXLINE( 104)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 104)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN( 104)		int len = ( (int)(sides) );
HXDLIN( 104)		{
HXLINE( 104)			int col = rs->color;
HXDLIN( 104)			{
HXLINE( 104)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN( 104)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN( 104)			{
HXLINE( 104)				int color = col;
HXDLIN( 104)				if ((color == -1)) {
HXLINE( 104)					color = this1->currentColor;
            				}
HXDLIN( 104)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN( 104)		int end = ((start + len) - 1);
HXDLIN( 104)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN( 104)		 ::trilateral3::structure::StartEnd se0 = startEnd;
HXLINE( 105)		int start1 = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN( 105)		 ::Dynamic drawType1 = this1->drawType;
HXDLIN( 105)		Float ax1 = rs->x;
HXDLIN( 105)		Float ay1 = rs->y;
HXDLIN( 105)		Float radius1 = rs->radius;
HXDLIN( 105)		 ::Dynamic sides1 = 36;
HXDLIN( 105)		if (::hx::IsNull( sides1 )) {
HXLINE( 105)			sides1 = 36;
            		}
HXDLIN( 105)		Float pi1 = ::Math_obj::PI;
HXDLIN( 105)		Float theta1 = (pi1 / ( (Float)(2) ));
HXDLIN( 105)		Float step1 = ((pi1 * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 105)		Float bx1;
HXDLIN( 105)		Float by1;
HXDLIN( 105)		Float cx1;
HXDLIN( 105)		Float cy1;
HXDLIN( 105)		{
HXLINE( 105)			int _g2 = 0;
HXDLIN( 105)			 ::Dynamic _g3 = sides1;
HXDLIN( 105)			while(::hx::IsLess( _g2,_g3 )){
HXLINE( 105)				_g2 = (_g2 + 1);
HXDLIN( 105)				int i = (_g2 - 1);
HXDLIN( 105)				bx1 = (ax1 + (radius1 * ::Math_obj::sin(theta1)));
HXDLIN( 105)				by1 = (ay1 + (radius1 * ::Math_obj::cos(theta1)));
HXDLIN( 105)				theta1 = (theta1 + step1);
HXDLIN( 105)				cx1 = (ax1 + (radius1 * ::Math_obj::sin(theta1)));
HXDLIN( 105)				cy1 = (ay1 + (radius1 * ::Math_obj::cos(theta1)));
HXDLIN( 105)				{
HXLINE( 105)					drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax1,ay1,0,bx1,by1,0,cx1,cy1,0);
HXDLIN( 105)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 105)					if (::hx::IsNotNull( m )) {
HXLINE( 105)						drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 105)					drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN( 105)		int len1 = ( (int)(sides1) );
HXDLIN( 105)		{
HXLINE( 105)			int col1 = rs->color;
HXDLIN( 105)			{
HXLINE( 105)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
HXDLIN( 105)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
            			}
HXDLIN( 105)			{
HXLINE( 105)				int color1 = col1;
HXDLIN( 105)				if ((color1 == -1)) {
HXLINE( 105)					color1 = this1->currentColor;
            				}
HXDLIN( 105)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
            			}
            		}
HXDLIN( 105)		int end1 = ((start1 + len1) - 1);
HXDLIN( 105)		 ::trilateral3::structure::StartEnd startEnd1 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start1,end1);
HXDLIN( 105)		 ::trilateral3::structure::StartEnd se1 = startEnd1;
HXLINE( 106)		{
HXLINE( 106)			 ::trilateral3::matrix::MatrixDozen r = ( ( ::trilateral3::matrix::MatrixDozen)(this1->rotateX(::Math_obj::PI)) );
HXDLIN( 106)			 ::trilateral3::matrix::MatrixDozen s = ( ( ::trilateral3::matrix::MatrixDozen)(this1->translateX(this1->dz)) );
HXDLIN( 106)			 ::trilateral3::matrix::MatrixDozen m =  ::trilateral3::matrix::MatrixDozen_obj::__alloc( HX_CTX ,(((r->a * s->a) + (r->b * s->e)) + (r->c * s->i)),(((r->a * s->b) + (r->b * s->f)) + (r->c * s->j)),(((r->a * s->c) + (r->b * s->g)) + (r->c * s->k)),((((r->a * s->d) + (r->b * s->h)) + (r->c * s->l)) + r->d),(((r->e * s->a) + (r->f * s->e)) + (r->g * s->i)),(((r->e * s->b) + (r->f * s->f)) + (r->g * s->j)),(((r->e * s->c) + (r->f * s->g)) + (r->g * s->k)),((((r->e * s->d) + (r->f * s->h)) + (r->g * s->l)) + r->h),(((r->i * s->a) + (r->j * s->e)) + (r->k * s->i)),(((r->i * s->b) + (r->j * s->f)) + (r->k * s->j)),(((r->i * s->c) + (r->j * s->g)) + (r->k * s->k)),((((r->i * s->d) + (r->j * s->h)) + (r->k * s->l)) + r->l));
HXDLIN( 106)			this1->drawType->__Field(HX_("transformRange",b1,c0,a1,5a),::hx::paccDynamic)(m,se1);
            		}
HXLINE( 107)		int begin = ::Std_obj::_hx_int(::Math_obj::min(( (Float)(se0->start) ),( (Float)(se1->start) )));
HXDLIN( 107)		int _hx_tmp;
HXDLIN( 107)		if ((begin == se0->start)) {
HXLINE( 107)			_hx_tmp = se1->end;
            		}
            		else {
HXLINE( 107)			_hx_tmp = se0->end;
            		}
HXDLIN( 107)		return ::trilateral3::shape::_IndexRange::IndexRange_Impl__obj::_new( ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,begin,_hx_tmp));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,circle2,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::circleRadial( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs,int colorCentre,Float rx,Float ry){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_111_circleRadial)
HXDLIN( 111)		int sides = 36;
HXDLIN( 111)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN( 111)		 ::Dynamic drawType = this1->drawType;
HXDLIN( 111)		Float x = rs->x;
HXDLIN( 111)		Float y = rs->y;
HXDLIN( 111)		Float radius = rs->radius;
HXDLIN( 111)		int len;
HXDLIN( 111)		if (((sides & 1) == 0)) {
HXDLIN( 111)			::haxe::Log_obj::trace(HX_("even",1a,6f,1c,43),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),650,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 111)			Float rx1 = rx;
HXDLIN( 111)			Float ry1 = ry;
HXDLIN( 111)			 ::Dynamic sides1 = sides;
HXDLIN( 111)			 ::Dynamic omega = ((Float)0.);
HXDLIN( 111)			if (::hx::IsNull( omega )) {
HXDLIN( 111)				omega = ((Float)0.);
            			}
HXDLIN( 111)			if (::hx::IsNull( sides1 )) {
HXDLIN( 111)				sides1 = 36;
            			}
HXDLIN( 111)			Float pi = ::Math_obj::PI;
HXDLIN( 111)			Float theta = ((pi / ( (Float)(2) )) + omega);
HXDLIN( 111)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 111)			Float bx;
HXDLIN( 111)			Float by;
HXDLIN( 111)			Float cx;
HXDLIN( 111)			Float cy;
HXDLIN( 111)			if ((rx1 > ((Float)1.))) {
HXDLIN( 111)				rx1 = ( (Float)(1) );
            			}
HXDLIN( 111)			if ((rx1 < ((Float)-1.))) {
HXDLIN( 111)				rx1 = ( (Float)(-1) );
            			}
HXDLIN( 111)			if ((ry1 > ((Float)1.))) {
HXDLIN( 111)				ry1 = ( (Float)(1) );
            			}
HXDLIN( 111)			if ((ry1 < ((Float)-1.))) {
HXDLIN( 111)				ry1 = ( (Float)(-1) );
            			}
HXDLIN( 111)			Float mx = (x + (rx1 * radius));
HXDLIN( 111)			Float my = (y - (ry1 * radius));
HXDLIN( 111)			{
HXDLIN( 111)				int _g = 0;
HXDLIN( 111)				 ::Dynamic _g1 = sides1;
HXDLIN( 111)				while(::hx::IsLess( _g,_g1 )){
HXDLIN( 111)					_g = (_g + 1);
HXDLIN( 111)					int i = (_g - 1);
HXDLIN( 111)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 111)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 111)					theta = (theta + step);
HXDLIN( 111)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 111)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 111)					{
HXDLIN( 111)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 111)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 111)						if (::hx::IsNotNull( m )) {
HXDLIN( 111)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 111)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 111)			len = ( (int)(sides1) );
            		}
            		else {
HXDLIN( 111)			::haxe::Log_obj::trace(HX_("odd",af,91,54,00),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),653,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 111)			::haxe::Log_obj::trace((sides & 1),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),654,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 111)			Float rx1 = rx;
HXDLIN( 111)			Float ry1 = ry;
HXDLIN( 111)			 ::Dynamic sides1 = sides;
HXDLIN( 111)			 ::Dynamic omega = ((Float)0.);
HXDLIN( 111)			if (::hx::IsNull( omega )) {
HXDLIN( 111)				omega = ((Float)0.);
            			}
HXDLIN( 111)			if (::hx::IsNull( sides1 )) {
HXDLIN( 111)				sides1 = 36;
            			}
HXDLIN( 111)			Float pi = ::Math_obj::PI;
HXDLIN( 111)			Float theta = (pi / ( (Float)(2) ));
HXDLIN( 111)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 111)			theta = (theta - ((step / ( (Float)(2) )) + omega));
HXDLIN( 111)			Float bx = ( (Float)(0) );
HXDLIN( 111)			Float by = ( (Float)(0) );
HXDLIN( 111)			Float cx = ( (Float)(0) );
HXDLIN( 111)			Float cy = ( (Float)(0) );
HXDLIN( 111)			if ((rx1 > ((Float)1.))) {
HXDLIN( 111)				rx1 = ( (Float)(1) );
            			}
HXDLIN( 111)			if ((rx1 < ((Float)-1.))) {
HXDLIN( 111)				rx1 = ( (Float)(-1) );
            			}
HXDLIN( 111)			if ((ry1 > ((Float)1.))) {
HXDLIN( 111)				ry1 = ( (Float)(1) );
            			}
HXDLIN( 111)			if ((ry1 < ((Float)-1.))) {
HXDLIN( 111)				ry1 = ( (Float)(-1) );
            			}
HXDLIN( 111)			Float mx = (x + (rx1 * radius));
HXDLIN( 111)			Float my = (y - (ry1 * radius));
HXDLIN( 111)			Float dx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 111)			Float dy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 111)			{
HXDLIN( 111)				int _g = 0;
HXDLIN( 111)				int _g1 = (( (int)(sides1) ) - 1);
HXDLIN( 111)				while((_g < _g1)){
HXDLIN( 111)					_g = (_g + 1);
HXDLIN( 111)					int i = (_g - 1);
HXDLIN( 111)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 111)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 111)					theta = (theta + step);
HXDLIN( 111)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 111)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 111)					{
HXDLIN( 111)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 111)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 111)						if (::hx::IsNotNull( m )) {
HXDLIN( 111)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 111)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 111)			{
HXDLIN( 111)				drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,cx,cy,0,dx,dy,0);
HXDLIN( 111)				 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 111)				if (::hx::IsNotNull( m )) {
HXDLIN( 111)					drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            				}
HXDLIN( 111)				drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 111)			len = ( (int)(sides1) );
            		}
HXDLIN( 111)		{
HXDLIN( 111)			int colorCentre1 = rs->color;
HXDLIN( 111)			{
HXDLIN( 111)				int _g = 0;
HXDLIN( 111)				int _g1 = len;
HXDLIN( 111)				while((_g < _g1)){
HXDLIN( 111)					_g = (_g + 1);
HXDLIN( 111)					int i = (_g - 1);
HXDLIN( 111)					this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(colorCentre1,colorCentre,colorCentre);
            				}
            			}
            		}
HXDLIN( 111)		int end = ((start + len) - 1);
HXDLIN( 111)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN( 111)		return startEnd;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Regular_Impl__obj,circleRadial,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::circleRadial2( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs,int colorCentre,Float rx,Float ry){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_114_circleRadial2)
HXLINE( 115)		int sides = 36;
HXDLIN( 115)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN( 115)		 ::Dynamic drawType = this1->drawType;
HXDLIN( 115)		Float x = rs->x;
HXDLIN( 115)		Float y = rs->y;
HXDLIN( 115)		Float radius = rs->radius;
HXDLIN( 115)		int len;
HXDLIN( 115)		if (((sides & 1) == 0)) {
HXLINE( 115)			::haxe::Log_obj::trace(HX_("even",1a,6f,1c,43),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),650,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 115)			Float rx1 = rx;
HXDLIN( 115)			Float ry1 = ry;
HXDLIN( 115)			 ::Dynamic sides1 = sides;
HXDLIN( 115)			 ::Dynamic omega = ((Float)0.);
HXDLIN( 115)			if (::hx::IsNull( omega )) {
HXLINE( 115)				omega = ((Float)0.);
            			}
HXDLIN( 115)			if (::hx::IsNull( sides1 )) {
HXLINE( 115)				sides1 = 36;
            			}
HXDLIN( 115)			Float pi = ::Math_obj::PI;
HXDLIN( 115)			Float theta = ((pi / ( (Float)(2) )) + omega);
HXDLIN( 115)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 115)			Float bx;
HXDLIN( 115)			Float by;
HXDLIN( 115)			Float cx;
HXDLIN( 115)			Float cy;
HXDLIN( 115)			if ((rx1 > ((Float)1.))) {
HXLINE( 115)				rx1 = ( (Float)(1) );
            			}
HXDLIN( 115)			if ((rx1 < ((Float)-1.))) {
HXLINE( 115)				rx1 = ( (Float)(-1) );
            			}
HXDLIN( 115)			if ((ry1 > ((Float)1.))) {
HXLINE( 115)				ry1 = ( (Float)(1) );
            			}
HXDLIN( 115)			if ((ry1 < ((Float)-1.))) {
HXLINE( 115)				ry1 = ( (Float)(-1) );
            			}
HXDLIN( 115)			Float mx = (x + (rx1 * radius));
HXDLIN( 115)			Float my = (y - (ry1 * radius));
HXDLIN( 115)			{
HXLINE( 115)				int _g = 0;
HXDLIN( 115)				 ::Dynamic _g1 = sides1;
HXDLIN( 115)				while(::hx::IsLess( _g,_g1 )){
HXLINE( 115)					_g = (_g + 1);
HXDLIN( 115)					int i = (_g - 1);
HXDLIN( 115)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 115)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 115)					theta = (theta + step);
HXDLIN( 115)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 115)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 115)					{
HXLINE( 115)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 115)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 115)						if (::hx::IsNotNull( m )) {
HXLINE( 115)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 115)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 115)			len = ( (int)(sides1) );
            		}
            		else {
HXLINE( 115)			::haxe::Log_obj::trace(HX_("odd",af,91,54,00),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),653,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 115)			::haxe::Log_obj::trace((sides & 1),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),654,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 115)			Float rx1 = rx;
HXDLIN( 115)			Float ry1 = ry;
HXDLIN( 115)			 ::Dynamic sides1 = sides;
HXDLIN( 115)			 ::Dynamic omega = ((Float)0.);
HXDLIN( 115)			if (::hx::IsNull( omega )) {
HXLINE( 115)				omega = ((Float)0.);
            			}
HXDLIN( 115)			if (::hx::IsNull( sides1 )) {
HXLINE( 115)				sides1 = 36;
            			}
HXDLIN( 115)			Float pi = ::Math_obj::PI;
HXDLIN( 115)			Float theta = (pi / ( (Float)(2) ));
HXDLIN( 115)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 115)			theta = (theta - ((step / ( (Float)(2) )) + omega));
HXDLIN( 115)			Float bx = ( (Float)(0) );
HXDLIN( 115)			Float by = ( (Float)(0) );
HXDLIN( 115)			Float cx = ( (Float)(0) );
HXDLIN( 115)			Float cy = ( (Float)(0) );
HXDLIN( 115)			if ((rx1 > ((Float)1.))) {
HXLINE( 115)				rx1 = ( (Float)(1) );
            			}
HXDLIN( 115)			if ((rx1 < ((Float)-1.))) {
HXLINE( 115)				rx1 = ( (Float)(-1) );
            			}
HXDLIN( 115)			if ((ry1 > ((Float)1.))) {
HXLINE( 115)				ry1 = ( (Float)(1) );
            			}
HXDLIN( 115)			if ((ry1 < ((Float)-1.))) {
HXLINE( 115)				ry1 = ( (Float)(-1) );
            			}
HXDLIN( 115)			Float mx = (x + (rx1 * radius));
HXDLIN( 115)			Float my = (y - (ry1 * radius));
HXDLIN( 115)			Float dx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 115)			Float dy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 115)			{
HXLINE( 115)				int _g = 0;
HXDLIN( 115)				int _g1 = (( (int)(sides1) ) - 1);
HXDLIN( 115)				while((_g < _g1)){
HXLINE( 115)					_g = (_g + 1);
HXDLIN( 115)					int i = (_g - 1);
HXDLIN( 115)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 115)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 115)					theta = (theta + step);
HXDLIN( 115)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 115)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 115)					{
HXLINE( 115)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 115)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 115)						if (::hx::IsNotNull( m )) {
HXLINE( 115)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 115)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 115)			{
HXLINE( 115)				drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,cx,cy,0,dx,dy,0);
HXDLIN( 115)				 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 115)				if (::hx::IsNotNull( m )) {
HXLINE( 115)					drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            				}
HXDLIN( 115)				drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 115)			len = ( (int)(sides1) );
            		}
HXDLIN( 115)		{
HXLINE( 115)			int colorCentre1 = rs->color;
HXDLIN( 115)			{
HXLINE( 115)				int _g = 0;
HXDLIN( 115)				int _g1 = len;
HXDLIN( 115)				while((_g < _g1)){
HXLINE( 115)					_g = (_g + 1);
HXDLIN( 115)					int i = (_g - 1);
HXDLIN( 115)					this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(colorCentre1,colorCentre,colorCentre);
            				}
            			}
            		}
HXDLIN( 115)		int end = ((start + len) - 1);
HXDLIN( 115)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN( 115)		 ::trilateral3::structure::StartEnd se0 = startEnd;
HXLINE( 116)		Float rx1 = -(rx);
HXDLIN( 116)		Float ry1 = -(ry);
HXDLIN( 116)		int sides1 = 36;
HXDLIN( 116)		int start1 = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN( 116)		 ::Dynamic drawType1 = this1->drawType;
HXDLIN( 116)		Float x1 = rs->x;
HXDLIN( 116)		Float y1 = rs->y;
HXDLIN( 116)		Float radius1 = rs->radius;
HXDLIN( 116)		int len1;
HXDLIN( 116)		if (((sides1 & 1) == 0)) {
HXLINE( 116)			::haxe::Log_obj::trace(HX_("even",1a,6f,1c,43),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),650,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 116)			Float rx = rx1;
HXDLIN( 116)			Float ry = ry1;
HXDLIN( 116)			 ::Dynamic sides = sides1;
HXDLIN( 116)			 ::Dynamic omega = ((Float)0.);
HXDLIN( 116)			if (::hx::IsNull( omega )) {
HXLINE( 116)				omega = ((Float)0.);
            			}
HXDLIN( 116)			if (::hx::IsNull( sides )) {
HXLINE( 116)				sides = 36;
            			}
HXDLIN( 116)			Float pi = ::Math_obj::PI;
HXDLIN( 116)			Float theta = ((pi / ( (Float)(2) )) + omega);
HXDLIN( 116)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 116)			Float bx;
HXDLIN( 116)			Float by;
HXDLIN( 116)			Float cx;
HXDLIN( 116)			Float cy;
HXDLIN( 116)			if ((rx > ((Float)1.))) {
HXLINE( 116)				rx = ( (Float)(1) );
            			}
HXDLIN( 116)			if ((rx < ((Float)-1.))) {
HXLINE( 116)				rx = ( (Float)(-1) );
            			}
HXDLIN( 116)			if ((ry > ((Float)1.))) {
HXLINE( 116)				ry = ( (Float)(1) );
            			}
HXDLIN( 116)			if ((ry < ((Float)-1.))) {
HXLINE( 116)				ry = ( (Float)(-1) );
            			}
HXDLIN( 116)			Float mx = (x1 + (rx * radius1));
HXDLIN( 116)			Float my = (y1 - (ry * radius1));
HXDLIN( 116)			{
HXLINE( 116)				int _g = 0;
HXDLIN( 116)				 ::Dynamic _g1 = sides;
HXDLIN( 116)				while(::hx::IsLess( _g,_g1 )){
HXLINE( 116)					_g = (_g + 1);
HXDLIN( 116)					int i = (_g - 1);
HXDLIN( 116)					bx = (x1 + (radius1 * ::Math_obj::sin(theta)));
HXDLIN( 116)					by = (y1 + (radius1 * ::Math_obj::cos(theta)));
HXDLIN( 116)					theta = (theta + step);
HXDLIN( 116)					cx = (x1 + (radius1 * ::Math_obj::sin(theta)));
HXDLIN( 116)					cy = (y1 + (radius1 * ::Math_obj::cos(theta)));
HXDLIN( 116)					{
HXLINE( 116)						drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 116)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 116)						if (::hx::IsNotNull( m )) {
HXLINE( 116)							drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 116)						drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 116)			len1 = ( (int)(sides) );
            		}
            		else {
HXLINE( 116)			::haxe::Log_obj::trace(HX_("odd",af,91,54,00),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),653,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 116)			::haxe::Log_obj::trace((sides1 & 1),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),654,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 116)			Float rx = rx1;
HXDLIN( 116)			Float ry = ry1;
HXDLIN( 116)			 ::Dynamic sides = sides1;
HXDLIN( 116)			 ::Dynamic omega = ((Float)0.);
HXDLIN( 116)			if (::hx::IsNull( omega )) {
HXLINE( 116)				omega = ((Float)0.);
            			}
HXDLIN( 116)			if (::hx::IsNull( sides )) {
HXLINE( 116)				sides = 36;
            			}
HXDLIN( 116)			Float pi = ::Math_obj::PI;
HXDLIN( 116)			Float theta = (pi / ( (Float)(2) ));
HXDLIN( 116)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 116)			theta = (theta - ((step / ( (Float)(2) )) + omega));
HXDLIN( 116)			Float bx = ( (Float)(0) );
HXDLIN( 116)			Float by = ( (Float)(0) );
HXDLIN( 116)			Float cx = ( (Float)(0) );
HXDLIN( 116)			Float cy = ( (Float)(0) );
HXDLIN( 116)			if ((rx > ((Float)1.))) {
HXLINE( 116)				rx = ( (Float)(1) );
            			}
HXDLIN( 116)			if ((rx < ((Float)-1.))) {
HXLINE( 116)				rx = ( (Float)(-1) );
            			}
HXDLIN( 116)			if ((ry > ((Float)1.))) {
HXLINE( 116)				ry = ( (Float)(1) );
            			}
HXDLIN( 116)			if ((ry < ((Float)-1.))) {
HXLINE( 116)				ry = ( (Float)(-1) );
            			}
HXDLIN( 116)			Float mx = (x1 + (rx * radius1));
HXDLIN( 116)			Float my = (y1 - (ry * radius1));
HXDLIN( 116)			Float dx = (x1 + (radius1 * ::Math_obj::sin(theta)));
HXDLIN( 116)			Float dy = (y1 + (radius1 * ::Math_obj::cos(theta)));
HXDLIN( 116)			{
HXLINE( 116)				int _g = 0;
HXDLIN( 116)				int _g1 = (( (int)(sides) ) - 1);
HXDLIN( 116)				while((_g < _g1)){
HXLINE( 116)					_g = (_g + 1);
HXDLIN( 116)					int i = (_g - 1);
HXDLIN( 116)					bx = (x1 + (radius1 * ::Math_obj::sin(theta)));
HXDLIN( 116)					by = (y1 + (radius1 * ::Math_obj::cos(theta)));
HXDLIN( 116)					theta = (theta + step);
HXDLIN( 116)					cx = (x1 + (radius1 * ::Math_obj::sin(theta)));
HXDLIN( 116)					cy = (y1 + (radius1 * ::Math_obj::cos(theta)));
HXDLIN( 116)					{
HXLINE( 116)						drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 116)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 116)						if (::hx::IsNotNull( m )) {
HXLINE( 116)							drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 116)						drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 116)			{
HXLINE( 116)				drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,cx,cy,0,dx,dy,0);
HXDLIN( 116)				 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 116)				if (::hx::IsNotNull( m )) {
HXLINE( 116)					drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            				}
HXDLIN( 116)				drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 116)			len1 = ( (int)(sides) );
            		}
HXDLIN( 116)		{
HXLINE( 116)			int colorCentre2 = rs->color;
HXDLIN( 116)			{
HXLINE( 116)				int _g2 = 0;
HXDLIN( 116)				int _g3 = len1;
HXDLIN( 116)				while((_g2 < _g3)){
HXLINE( 116)					_g2 = (_g2 + 1);
HXDLIN( 116)					int i = (_g2 - 1);
HXDLIN( 116)					this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(colorCentre2,colorCentre,colorCentre);
            				}
            			}
            		}
HXDLIN( 116)		int end1 = ((start1 + len1) - 1);
HXDLIN( 116)		 ::trilateral3::structure::StartEnd startEnd1 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start1,end1);
HXDLIN( 116)		 ::trilateral3::structure::StartEnd se1 = startEnd1;
HXLINE( 117)		{
HXLINE( 117)			 ::trilateral3::matrix::MatrixDozen r = ( ( ::trilateral3::matrix::MatrixDozen)(this1->rotateX(::Math_obj::PI)) );
HXDLIN( 117)			 ::trilateral3::matrix::MatrixDozen s = ( ( ::trilateral3::matrix::MatrixDozen)(this1->translateX(this1->dz)) );
HXDLIN( 117)			 ::trilateral3::matrix::MatrixDozen m =  ::trilateral3::matrix::MatrixDozen_obj::__alloc( HX_CTX ,(((r->a * s->a) + (r->b * s->e)) + (r->c * s->i)),(((r->a * s->b) + (r->b * s->f)) + (r->c * s->j)),(((r->a * s->c) + (r->b * s->g)) + (r->c * s->k)),((((r->a * s->d) + (r->b * s->h)) + (r->c * s->l)) + r->d),(((r->e * s->a) + (r->f * s->e)) + (r->g * s->i)),(((r->e * s->b) + (r->f * s->f)) + (r->g * s->j)),(((r->e * s->c) + (r->f * s->g)) + (r->g * s->k)),((((r->e * s->d) + (r->f * s->h)) + (r->g * s->l)) + r->h),(((r->i * s->a) + (r->j * s->e)) + (r->k * s->i)),(((r->i * s->b) + (r->j * s->f)) + (r->k * s->j)),(((r->i * s->c) + (r->j * s->g)) + (r->k * s->k)),((((r->i * s->d) + (r->j * s->h)) + (r->k * s->l)) + r->l));
HXDLIN( 117)			this1->drawType->__Field(HX_("transformRange",b1,c0,a1,5a),::hx::paccDynamic)(m,se1);
            		}
HXLINE( 118)		int begin = ::Std_obj::_hx_int(::Math_obj::min(( (Float)(se0->start) ),( (Float)(se1->start) )));
HXDLIN( 118)		int _hx_tmp;
HXDLIN( 118)		if ((begin == se0->start)) {
HXLINE( 118)			_hx_tmp = se1->end;
            		}
            		else {
HXLINE( 118)			_hx_tmp = se0->end;
            		}
HXDLIN( 118)		return ::trilateral3::shape::_IndexRange::IndexRange_Impl__obj::_new( ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,begin,_hx_tmp));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Regular_Impl__obj,circleRadial2,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::roundedSquare( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_121_roundedSquare)
HXLINE( 122)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXLINE( 123)		 ::Dynamic drawType = this1->drawType;
HXDLIN( 123)		Float x = (rs->x - rs->radius);
HXDLIN( 123)		Float y = (rs->y - rs->radius);
HXDLIN( 123)		Float width = (rs->radius * ( (Float)(2) ));
HXDLIN( 123)		Float height = (rs->radius * ( (Float)(2) ));
HXDLIN( 123)		Float radius = this1->rounded;
HXDLIN( 123)		Float pi = ::Math_obj::PI;
HXDLIN( 123)		Float pi_2 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN( 123)		Float ax = (x + radius);
HXDLIN( 123)		Float ay = (y + radius);
HXDLIN( 123)		Float bx = ((x + width) - radius);
HXDLIN( 123)		Float by = (y + radius);
HXDLIN( 123)		Float cx = bx;
HXDLIN( 123)		Float cy = ((y + height) - radius);
HXDLIN( 123)		Float dx = ax;
HXDLIN( 123)		Float dy = cy;
HXDLIN( 123)		int count = 0;
HXDLIN( 123)		Float ax1 = ax;
HXDLIN( 123)		Float ay1 = y;
HXDLIN( 123)		Float bx1 = (ax + (width - (radius * ( (Float)(2) ))));
HXDLIN( 123)		Float by1 = ay1;
HXDLIN( 123)		Float cx1 = bx1;
HXDLIN( 123)		Float cy1 = (ay1 + height);
HXDLIN( 123)		Float dx1 = ax;
HXDLIN( 123)		Float dy1 = cy1;
HXDLIN( 123)		{
HXLINE( 123)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax1,ay1,0,bx1,by1,0,dx1,dy1,0);
HXDLIN( 123)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 123)			if (::hx::IsNotNull( m )) {
HXLINE( 123)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN( 123)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 123)		{
HXLINE( 123)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx1,by1,0,cx1,cy1,0,dx1,dy1,0);
HXDLIN( 123)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 123)			if (::hx::IsNotNull( m1 )) {
HXLINE( 123)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN( 123)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 123)		count = (count + 2);
HXDLIN( 123)		Float dimY = (height - (( (Float)(2) ) * radius));
HXDLIN( 123)		Float ax2 = x;
HXDLIN( 123)		Float ay2 = ay;
HXDLIN( 123)		Float bx2 = (x + radius);
HXDLIN( 123)		Float by2 = ay2;
HXDLIN( 123)		Float cx2 = bx2;
HXDLIN( 123)		Float cy2 = (ay2 + dimY);
HXDLIN( 123)		Float dx2 = x;
HXDLIN( 123)		Float dy2 = cy2;
HXDLIN( 123)		{
HXLINE( 123)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax2,ay2,0,bx2,by2,0,dx2,dy2,0);
HXDLIN( 123)			 ::trilateral3::matrix::MatrixDozen m2 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 123)			if (::hx::IsNotNull( m2 )) {
HXLINE( 123)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m2);
            			}
HXDLIN( 123)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 123)		{
HXLINE( 123)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx2,by2,0,cx2,cy2,0,dx2,dy2,0);
HXDLIN( 123)			 ::trilateral3::matrix::MatrixDozen m3 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 123)			if (::hx::IsNotNull( m3 )) {
HXLINE( 123)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m3);
            			}
HXDLIN( 123)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 123)		count = (count + 2);
HXDLIN( 123)		Float ax3 = bx;
HXDLIN( 123)		Float ay3 = by;
HXDLIN( 123)		Float bx3 = (bx + radius);
HXDLIN( 123)		Float by3 = ay3;
HXDLIN( 123)		Float cx3 = bx3;
HXDLIN( 123)		Float cy3 = (ay3 + dimY);
HXDLIN( 123)		Float dx3 = bx;
HXDLIN( 123)		Float dy3 = cy3;
HXDLIN( 123)		{
HXLINE( 123)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax3,ay3,0,bx3,by3,0,dx3,dy3,0);
HXDLIN( 123)			 ::trilateral3::matrix::MatrixDozen m4 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 123)			if (::hx::IsNotNull( m4 )) {
HXLINE( 123)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m4);
            			}
HXDLIN( 123)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 123)		{
HXLINE( 123)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx3,by3,0,cx3,cy3,0,dx3,dy3,0);
HXDLIN( 123)			 ::trilateral3::matrix::MatrixDozen m5 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 123)			if (::hx::IsNotNull( m5 )) {
HXLINE( 123)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m5);
            			}
HXDLIN( 123)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 123)		count = (count + 2);
HXDLIN( 123)		Float beta = -(pi);
HXDLIN( 123)		Float gamma = -(pi_2);
HXDLIN( 123)		Float pi1 = ::Math_obj::PI;
HXDLIN( 123)		Float step = ((pi1 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 123)		Float dif;
HXDLIN( 123)		switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 123)				Float f;
HXDLIN( 123)				bool f1;
HXDLIN( 123)				if ((beta >= 0)) {
HXLINE( 123)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f1 = false;
            				}
HXDLIN( 123)				if (f1) {
HXLINE( 123)					f = beta;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f2;
HXDLIN( 123)				bool f3;
HXDLIN( 123)				if ((gamma >= 0)) {
HXLINE( 123)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f3 = false;
            				}
HXDLIN( 123)				if (f3) {
HXLINE( 123)					f2 = gamma;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f2 = a;
            					}
            					else {
HXLINE( 123)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f2;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif1;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif1 = theta;
            				}
            				else {
HXLINE( 123)					dif1 = -(theta);
            				}
HXDLIN( 123)				if ((dif1 > 0)) {
HXLINE( 123)					dif = dif1;
            				}
            				else {
HXLINE( 123)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 123)				Float f;
HXDLIN( 123)				bool f1;
HXDLIN( 123)				if ((beta >= 0)) {
HXLINE( 123)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f1 = false;
            				}
HXDLIN( 123)				if (f1) {
HXLINE( 123)					f = beta;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f2;
HXDLIN( 123)				bool f3;
HXDLIN( 123)				if ((gamma >= 0)) {
HXLINE( 123)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f3 = false;
            				}
HXDLIN( 123)				if (f3) {
HXLINE( 123)					f2 = gamma;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f2 = a;
            					}
            					else {
HXLINE( 123)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f2;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif1;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif1 = theta;
            				}
            				else {
HXLINE( 123)					dif1 = -(theta);
            				}
HXDLIN( 123)				if ((dif1 < 0)) {
HXLINE( 123)					dif = dif1;
            				}
            				else {
HXLINE( 123)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 123)				Float f;
HXDLIN( 123)				bool f1;
HXDLIN( 123)				if ((beta >= 0)) {
HXLINE( 123)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f1 = false;
            				}
HXDLIN( 123)				if (f1) {
HXLINE( 123)					f = beta;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f2;
HXDLIN( 123)				bool f3;
HXDLIN( 123)				if ((gamma >= 0)) {
HXLINE( 123)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f3 = false;
            				}
HXDLIN( 123)				if (f3) {
HXLINE( 123)					f2 = gamma;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f2 = a;
            					}
            					else {
HXLINE( 123)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f2;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif1;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif1 = theta;
            				}
            				else {
HXLINE( 123)					dif1 = -(theta);
            				}
HXDLIN( 123)				if (smallest) {
HXLINE( 123)					dif = dif1;
            				}
            				else {
HXLINE( 123)					if (clockwise) {
HXLINE( 123)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 123)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 123)				Float f;
HXDLIN( 123)				bool f1;
HXDLIN( 123)				if ((beta >= 0)) {
HXLINE( 123)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f1 = false;
            				}
HXDLIN( 123)				if (f1) {
HXLINE( 123)					f = beta;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f2;
HXDLIN( 123)				bool f3;
HXDLIN( 123)				if ((gamma >= 0)) {
HXLINE( 123)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f3 = false;
            				}
HXDLIN( 123)				if (f3) {
HXLINE( 123)					f2 = gamma;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f2 = a;
            					}
            					else {
HXLINE( 123)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f2;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif1;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif1 = theta;
            				}
            				else {
HXLINE( 123)					dif1 = -(theta);
            				}
HXDLIN( 123)				if (largest) {
HXLINE( 123)					dif = dif1;
            				}
            				else {
HXLINE( 123)					if (clockwise) {
HXLINE( 123)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 123)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 123)		bool positive = (dif >= 0);
HXDLIN( 123)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 123)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 123)		Float angle = beta;
HXDLIN( 123)		Float cx4;
HXDLIN( 123)		Float cy4;
HXDLIN( 123)		Float bx4 = ( (Float)(0) );
HXDLIN( 123)		Float by4 = ( (Float)(0) );
HXDLIN( 123)		{
HXLINE( 123)			int _g = 0;
HXDLIN( 123)			int _g1 = (totalSteps + 1);
HXDLIN( 123)			while((_g < _g1)){
HXLINE( 123)				_g = (_g + 1);
HXDLIN( 123)				int i = (_g - 1);
HXDLIN( 123)				cx4 = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 123)				cy4 = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 123)				if ((i != 0)) {
HXLINE( 123)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx4,by4,0,cx4,cy4,0);
HXDLIN( 123)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 123)					if (::hx::IsNotNull( m )) {
HXLINE( 123)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 123)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 123)				angle = (angle + step1);
HXDLIN( 123)				bx4 = cx4;
HXDLIN( 123)				by4 = cy4;
            			}
            		}
HXDLIN( 123)		count = (count + totalSteps);
HXDLIN( 123)		Float pi2 = ::Math_obj::PI;
HXDLIN( 123)		Float step2 = ((pi2 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 123)		Float dif1;
HXDLIN( 123)		switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 123)				Float f;
HXDLIN( 123)				bool f1;
HXDLIN( 123)				if ((pi_2 >= 0)) {
HXLINE( 123)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f1 = false;
            				}
HXDLIN( 123)				if (f1) {
HXLINE( 123)					f = pi_2;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f2;
HXDLIN( 123)				bool f3;
HXDLIN( 123)				if ((pi >= 0)) {
HXLINE( 123)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f3 = false;
            				}
HXDLIN( 123)				if (f3) {
HXLINE( 123)					f2 = pi;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f2 = a;
            					}
            					else {
HXLINE( 123)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f2;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif = theta;
            				}
            				else {
HXLINE( 123)					dif = -(theta);
            				}
HXDLIN( 123)				if ((dif > 0)) {
HXLINE( 123)					dif1 = dif;
            				}
            				else {
HXLINE( 123)					dif1 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 123)				Float f;
HXDLIN( 123)				bool f1;
HXDLIN( 123)				if ((pi_2 >= 0)) {
HXLINE( 123)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f1 = false;
            				}
HXDLIN( 123)				if (f1) {
HXLINE( 123)					f = pi_2;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f2;
HXDLIN( 123)				bool f3;
HXDLIN( 123)				if ((pi >= 0)) {
HXLINE( 123)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f3 = false;
            				}
HXDLIN( 123)				if (f3) {
HXLINE( 123)					f2 = pi;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f2 = a;
            					}
            					else {
HXLINE( 123)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f2;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif = theta;
            				}
            				else {
HXLINE( 123)					dif = -(theta);
            				}
HXDLIN( 123)				if ((dif < 0)) {
HXLINE( 123)					dif1 = dif;
            				}
            				else {
HXLINE( 123)					dif1 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 123)				Float f;
HXDLIN( 123)				bool f1;
HXDLIN( 123)				if ((pi_2 >= 0)) {
HXLINE( 123)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f1 = false;
            				}
HXDLIN( 123)				if (f1) {
HXLINE( 123)					f = pi_2;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f2;
HXDLIN( 123)				bool f3;
HXDLIN( 123)				if ((pi >= 0)) {
HXLINE( 123)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f3 = false;
            				}
HXDLIN( 123)				if (f3) {
HXLINE( 123)					f2 = pi;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f2 = a;
            					}
            					else {
HXLINE( 123)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f2;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif = theta;
            				}
            				else {
HXLINE( 123)					dif = -(theta);
            				}
HXDLIN( 123)				if (smallest) {
HXLINE( 123)					dif1 = dif;
            				}
            				else {
HXLINE( 123)					if (clockwise) {
HXLINE( 123)						dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 123)						dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 123)				Float f;
HXDLIN( 123)				bool f1;
HXDLIN( 123)				if ((pi_2 >= 0)) {
HXLINE( 123)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f1 = false;
            				}
HXDLIN( 123)				if (f1) {
HXLINE( 123)					f = pi_2;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f2;
HXDLIN( 123)				bool f3;
HXDLIN( 123)				if ((pi >= 0)) {
HXLINE( 123)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f3 = false;
            				}
HXDLIN( 123)				if (f3) {
HXLINE( 123)					f2 = pi;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f2 = a;
            					}
            					else {
HXLINE( 123)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f2;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif = theta;
            				}
            				else {
HXLINE( 123)					dif = -(theta);
            				}
HXDLIN( 123)				if (largest) {
HXLINE( 123)					dif1 = dif;
            				}
            				else {
HXLINE( 123)					if (clockwise) {
HXLINE( 123)						dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 123)						dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 123)		bool positive1 = (dif1 >= 0);
HXDLIN( 123)		int totalSteps1 = ::Math_obj::ceil((::Math_obj::abs(dif1) / step2));
HXDLIN( 123)		Float step3 = (dif1 / ( (Float)(totalSteps1) ));
HXDLIN( 123)		Float angle1 = pi_2;
HXDLIN( 123)		Float cx5;
HXDLIN( 123)		Float cy5;
HXDLIN( 123)		Float bx5 = ( (Float)(0) );
HXDLIN( 123)		Float by5 = ( (Float)(0) );
HXDLIN( 123)		{
HXLINE( 123)			int _g2 = 0;
HXDLIN( 123)			int _g3 = (totalSteps1 + 1);
HXDLIN( 123)			while((_g2 < _g3)){
HXLINE( 123)				_g2 = (_g2 + 1);
HXDLIN( 123)				int i = (_g2 - 1);
HXDLIN( 123)				cx5 = (bx + (radius * ::Math_obj::sin(angle1)));
HXDLIN( 123)				cy5 = (by + (radius * ::Math_obj::cos(angle1)));
HXDLIN( 123)				if ((i != 0)) {
HXLINE( 123)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,bx5,by5,0,cx5,cy5,0);
HXDLIN( 123)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 123)					if (::hx::IsNotNull( m )) {
HXLINE( 123)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 123)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 123)				angle1 = (angle1 + step3);
HXDLIN( 123)				bx5 = cx5;
HXDLIN( 123)				by5 = cy5;
            			}
            		}
HXDLIN( 123)		count = (count + totalSteps1);
HXDLIN( 123)		Float pi3 = ::Math_obj::PI;
HXDLIN( 123)		Float step4 = ((pi3 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 123)		Float dif2;
HXDLIN( 123)		switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 123)				Float f;
HXDLIN( 123)				bool f1;
HXDLIN( 123)				if ((pi_2 >= 0)) {
HXLINE( 123)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f1 = false;
            				}
HXDLIN( 123)				if (f1) {
HXLINE( 123)					f = pi_2;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f2;
HXDLIN( 123)				if ((0 > ::Math_obj::PI)) {
HXLINE( 123)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f2 = a;
            					}
            					else {
HXLINE( 123)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f2;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif = theta;
            				}
            				else {
HXLINE( 123)					dif = -(theta);
            				}
HXDLIN( 123)				if ((dif > 0)) {
HXLINE( 123)					dif2 = dif;
            				}
            				else {
HXLINE( 123)					dif2 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 123)				Float f;
HXDLIN( 123)				bool f1;
HXDLIN( 123)				if ((pi_2 >= 0)) {
HXLINE( 123)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f1 = false;
            				}
HXDLIN( 123)				if (f1) {
HXLINE( 123)					f = pi_2;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f2;
HXDLIN( 123)				if ((0 > ::Math_obj::PI)) {
HXLINE( 123)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f2 = a;
            					}
            					else {
HXLINE( 123)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f2;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif = theta;
            				}
            				else {
HXLINE( 123)					dif = -(theta);
            				}
HXDLIN( 123)				if ((dif < 0)) {
HXLINE( 123)					dif2 = dif;
            				}
            				else {
HXLINE( 123)					dif2 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 123)				Float f;
HXDLIN( 123)				bool f1;
HXDLIN( 123)				if ((pi_2 >= 0)) {
HXLINE( 123)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f1 = false;
            				}
HXDLIN( 123)				if (f1) {
HXLINE( 123)					f = pi_2;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f2;
HXDLIN( 123)				if ((0 > ::Math_obj::PI)) {
HXLINE( 123)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f2 = a;
            					}
            					else {
HXLINE( 123)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f2;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif = theta;
            				}
            				else {
HXLINE( 123)					dif = -(theta);
            				}
HXDLIN( 123)				if (smallest) {
HXLINE( 123)					dif2 = dif;
            				}
            				else {
HXLINE( 123)					if (clockwise) {
HXLINE( 123)						dif2 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 123)						dif2 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 123)				Float f;
HXDLIN( 123)				bool f1;
HXDLIN( 123)				if ((pi_2 >= 0)) {
HXLINE( 123)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f1 = false;
            				}
HXDLIN( 123)				if (f1) {
HXLINE( 123)					f = pi_2;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f2;
HXDLIN( 123)				if ((0 > ::Math_obj::PI)) {
HXLINE( 123)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f2 = a;
            					}
            					else {
HXLINE( 123)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f2;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif = theta;
            				}
            				else {
HXLINE( 123)					dif = -(theta);
            				}
HXDLIN( 123)				if (largest) {
HXLINE( 123)					dif2 = dif;
            				}
            				else {
HXLINE( 123)					if (clockwise) {
HXLINE( 123)						dif2 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 123)						dif2 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 123)		bool positive2 = (dif2 >= 0);
HXDLIN( 123)		int totalSteps2 = ::Math_obj::ceil((::Math_obj::abs(dif2) / step4));
HXDLIN( 123)		Float step5 = (dif2 / ( (Float)(totalSteps2) ));
HXDLIN( 123)		Float angle2 = pi_2;
HXDLIN( 123)		Float cx6;
HXDLIN( 123)		Float cy6;
HXDLIN( 123)		Float bx6 = ( (Float)(0) );
HXDLIN( 123)		Float by6 = ( (Float)(0) );
HXDLIN( 123)		{
HXLINE( 123)			int _g4 = 0;
HXDLIN( 123)			int _g5 = (totalSteps2 + 1);
HXDLIN( 123)			while((_g4 < _g5)){
HXLINE( 123)				_g4 = (_g4 + 1);
HXDLIN( 123)				int i = (_g4 - 1);
HXDLIN( 123)				cx6 = (cx + (radius * ::Math_obj::sin(angle2)));
HXDLIN( 123)				cy6 = (cy + (radius * ::Math_obj::cos(angle2)));
HXDLIN( 123)				if ((i != 0)) {
HXLINE( 123)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(cx,cy,0,bx6,by6,0,cx6,cy6,0);
HXDLIN( 123)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 123)					if (::hx::IsNotNull( m )) {
HXLINE( 123)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 123)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 123)				angle2 = (angle2 + step5);
HXDLIN( 123)				bx6 = cx6;
HXDLIN( 123)				by6 = cy6;
            			}
            		}
HXDLIN( 123)		count = (count + totalSteps2);
HXDLIN( 123)		Float gamma1 = -(pi_2);
HXDLIN( 123)		Float pi4 = ::Math_obj::PI;
HXDLIN( 123)		Float step6 = ((pi4 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 123)		Float dif3;
HXDLIN( 123)		switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 123)				Float f;
HXDLIN( 123)				if ((0 > ::Math_obj::PI)) {
HXLINE( 123)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f1;
HXDLIN( 123)				bool f2;
HXDLIN( 123)				if ((gamma1 >= 0)) {
HXLINE( 123)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f2 = false;
            				}
HXDLIN( 123)				if (f2) {
HXLINE( 123)					f1 = gamma1;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f1 = a;
            					}
            					else {
HXLINE( 123)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f1;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif = theta;
            				}
            				else {
HXLINE( 123)					dif = -(theta);
            				}
HXDLIN( 123)				if ((dif > 0)) {
HXLINE( 123)					dif3 = dif;
            				}
            				else {
HXLINE( 123)					dif3 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 123)				Float f;
HXDLIN( 123)				if ((0 > ::Math_obj::PI)) {
HXLINE( 123)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f1;
HXDLIN( 123)				bool f2;
HXDLIN( 123)				if ((gamma1 >= 0)) {
HXLINE( 123)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f2 = false;
            				}
HXDLIN( 123)				if (f2) {
HXLINE( 123)					f1 = gamma1;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f1 = a;
            					}
            					else {
HXLINE( 123)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f1;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif = theta;
            				}
            				else {
HXLINE( 123)					dif = -(theta);
            				}
HXDLIN( 123)				if ((dif < 0)) {
HXLINE( 123)					dif3 = dif;
            				}
            				else {
HXLINE( 123)					dif3 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 123)				Float f;
HXDLIN( 123)				if ((0 > ::Math_obj::PI)) {
HXLINE( 123)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f1;
HXDLIN( 123)				bool f2;
HXDLIN( 123)				if ((gamma1 >= 0)) {
HXLINE( 123)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f2 = false;
            				}
HXDLIN( 123)				if (f2) {
HXLINE( 123)					f1 = gamma1;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f1 = a;
            					}
            					else {
HXLINE( 123)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f1;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif = theta;
            				}
            				else {
HXLINE( 123)					dif = -(theta);
            				}
HXDLIN( 123)				if (smallest) {
HXLINE( 123)					dif3 = dif;
            				}
            				else {
HXLINE( 123)					if (clockwise) {
HXLINE( 123)						dif3 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 123)						dif3 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 123)				Float f;
HXDLIN( 123)				if ((0 > ::Math_obj::PI)) {
HXLINE( 123)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f = a;
            					}
            					else {
HXLINE( 123)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this1 = f;
HXDLIN( 123)				Float za = this1;
HXDLIN( 123)				Float f1;
HXDLIN( 123)				bool f2;
HXDLIN( 123)				if ((gamma1 >= 0)) {
HXLINE( 123)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 123)					f2 = false;
            				}
HXDLIN( 123)				if (f2) {
HXLINE( 123)					f1 = gamma1;
            				}
            				else {
HXLINE( 123)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 123)					if ((a >= 0)) {
HXLINE( 123)						f1 = a;
            					}
            					else {
HXLINE( 123)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 123)				Float this2 = f1;
HXDLIN( 123)				Float zb = this2;
HXDLIN( 123)				Float fa = za;
HXDLIN( 123)				Float fb = zb;
HXDLIN( 123)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 123)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 123)				bool clockwise = (fa < fb);
HXDLIN( 123)				Float dif;
HXDLIN( 123)				if (clockwise) {
HXLINE( 123)					dif = theta;
            				}
            				else {
HXLINE( 123)					dif = -(theta);
            				}
HXDLIN( 123)				if (largest) {
HXLINE( 123)					dif3 = dif;
            				}
            				else {
HXLINE( 123)					if (clockwise) {
HXLINE( 123)						dif3 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 123)						dif3 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 123)		bool positive3 = (dif3 >= 0);
HXDLIN( 123)		int totalSteps3 = ::Math_obj::ceil((::Math_obj::abs(dif3) / step6));
HXDLIN( 123)		Float step7 = (dif3 / ( (Float)(totalSteps3) ));
HXDLIN( 123)		Float angle3 = ( (Float)(0) );
HXDLIN( 123)		Float cx7;
HXDLIN( 123)		Float cy7;
HXDLIN( 123)		Float bx7 = ( (Float)(0) );
HXDLIN( 123)		Float by7 = ( (Float)(0) );
HXDLIN( 123)		{
HXLINE( 123)			int _g6 = 0;
HXDLIN( 123)			int _g7 = (totalSteps3 + 1);
HXDLIN( 123)			while((_g6 < _g7)){
HXLINE( 123)				_g6 = (_g6 + 1);
HXDLIN( 123)				int i = (_g6 - 1);
HXDLIN( 123)				cx7 = (dx + (radius * ::Math_obj::sin(angle3)));
HXDLIN( 123)				cy7 = (dy + (radius * ::Math_obj::cos(angle3)));
HXDLIN( 123)				if ((i != 0)) {
HXLINE( 123)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx,dy,0,bx7,by7,0,cx7,cy7,0);
HXDLIN( 123)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 123)					if (::hx::IsNotNull( m )) {
HXLINE( 123)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 123)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 123)				angle3 = (angle3 + step7);
HXDLIN( 123)				bx7 = cx7;
HXDLIN( 123)				by7 = cy7;
            			}
            		}
HXDLIN( 123)		count = (count + totalSteps3);
HXDLIN( 123)		int len = count;
HXLINE( 125)		{
HXLINE( 125)			int col = rs->color;
HXDLIN( 125)			{
HXLINE( 125)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN( 125)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN( 125)			{
HXLINE( 125)				int color = col;
HXDLIN( 125)				if ((color == -1)) {
HXLINE( 125)					color = this1->currentColor;
            				}
HXDLIN( 125)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXLINE( 126)		int end = ((start + len) - 1);
HXLINE( 127)		return  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,roundedSquare,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::roundedSquare2( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_130_roundedSquare2)
HXLINE( 131)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN( 131)		 ::Dynamic drawType = this1->drawType;
HXDLIN( 131)		Float x = (rs->x - rs->radius);
HXDLIN( 131)		Float y = (rs->y - rs->radius);
HXDLIN( 131)		Float width = (rs->radius * ( (Float)(2) ));
HXDLIN( 131)		Float height = (rs->radius * ( (Float)(2) ));
HXDLIN( 131)		Float radius = this1->rounded;
HXDLIN( 131)		Float pi = ::Math_obj::PI;
HXDLIN( 131)		Float pi_2 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN( 131)		Float ax = (x + radius);
HXDLIN( 131)		Float ay = (y + radius);
HXDLIN( 131)		Float bx = ((x + width) - radius);
HXDLIN( 131)		Float by = (y + radius);
HXDLIN( 131)		Float cx = bx;
HXDLIN( 131)		Float cy = ((y + height) - radius);
HXDLIN( 131)		Float dx = ax;
HXDLIN( 131)		Float dy = cy;
HXDLIN( 131)		int count = 0;
HXDLIN( 131)		Float ax1 = ax;
HXDLIN( 131)		Float ay1 = y;
HXDLIN( 131)		Float bx1 = (ax + (width - (radius * ( (Float)(2) ))));
HXDLIN( 131)		Float by1 = ay1;
HXDLIN( 131)		Float cx1 = bx1;
HXDLIN( 131)		Float cy1 = (ay1 + height);
HXDLIN( 131)		Float dx1 = ax;
HXDLIN( 131)		Float dy1 = cy1;
HXDLIN( 131)		{
HXLINE( 131)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax1,ay1,0,bx1,by1,0,dx1,dy1,0);
HXDLIN( 131)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 131)			if (::hx::IsNotNull( m )) {
HXLINE( 131)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN( 131)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 131)		{
HXLINE( 131)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx1,by1,0,cx1,cy1,0,dx1,dy1,0);
HXDLIN( 131)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 131)			if (::hx::IsNotNull( m1 )) {
HXLINE( 131)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN( 131)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 131)		count = (count + 2);
HXDLIN( 131)		Float dimY = (height - (( (Float)(2) ) * radius));
HXDLIN( 131)		Float ax2 = x;
HXDLIN( 131)		Float ay2 = ay;
HXDLIN( 131)		Float bx2 = (x + radius);
HXDLIN( 131)		Float by2 = ay2;
HXDLIN( 131)		Float cx2 = bx2;
HXDLIN( 131)		Float cy2 = (ay2 + dimY);
HXDLIN( 131)		Float dx2 = x;
HXDLIN( 131)		Float dy2 = cy2;
HXDLIN( 131)		{
HXLINE( 131)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax2,ay2,0,bx2,by2,0,dx2,dy2,0);
HXDLIN( 131)			 ::trilateral3::matrix::MatrixDozen m2 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 131)			if (::hx::IsNotNull( m2 )) {
HXLINE( 131)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m2);
            			}
HXDLIN( 131)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 131)		{
HXLINE( 131)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx2,by2,0,cx2,cy2,0,dx2,dy2,0);
HXDLIN( 131)			 ::trilateral3::matrix::MatrixDozen m3 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 131)			if (::hx::IsNotNull( m3 )) {
HXLINE( 131)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m3);
            			}
HXDLIN( 131)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 131)		count = (count + 2);
HXDLIN( 131)		Float ax3 = bx;
HXDLIN( 131)		Float ay3 = by;
HXDLIN( 131)		Float bx3 = (bx + radius);
HXDLIN( 131)		Float by3 = ay3;
HXDLIN( 131)		Float cx3 = bx3;
HXDLIN( 131)		Float cy3 = (ay3 + dimY);
HXDLIN( 131)		Float dx3 = bx;
HXDLIN( 131)		Float dy3 = cy3;
HXDLIN( 131)		{
HXLINE( 131)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax3,ay3,0,bx3,by3,0,dx3,dy3,0);
HXDLIN( 131)			 ::trilateral3::matrix::MatrixDozen m4 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 131)			if (::hx::IsNotNull( m4 )) {
HXLINE( 131)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m4);
            			}
HXDLIN( 131)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 131)		{
HXLINE( 131)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx3,by3,0,cx3,cy3,0,dx3,dy3,0);
HXDLIN( 131)			 ::trilateral3::matrix::MatrixDozen m5 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 131)			if (::hx::IsNotNull( m5 )) {
HXLINE( 131)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m5);
            			}
HXDLIN( 131)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 131)		count = (count + 2);
HXDLIN( 131)		Float beta = -(pi);
HXDLIN( 131)		Float gamma = -(pi_2);
HXDLIN( 131)		Float pi1 = ::Math_obj::PI;
HXDLIN( 131)		Float step = ((pi1 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 131)		Float dif;
HXDLIN( 131)		switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 131)				Float f;
HXDLIN( 131)				bool f1;
HXDLIN( 131)				if ((beta >= 0)) {
HXLINE( 131)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f1 = false;
            				}
HXDLIN( 131)				if (f1) {
HXLINE( 131)					f = beta;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f2;
HXDLIN( 131)				bool f3;
HXDLIN( 131)				if ((gamma >= 0)) {
HXLINE( 131)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f3 = false;
            				}
HXDLIN( 131)				if (f3) {
HXLINE( 131)					f2 = gamma;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f2 = a;
            					}
            					else {
HXLINE( 131)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f2;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif1;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif1 = theta;
            				}
            				else {
HXLINE( 131)					dif1 = -(theta);
            				}
HXDLIN( 131)				if ((dif1 > 0)) {
HXLINE( 131)					dif = dif1;
            				}
            				else {
HXLINE( 131)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 131)				Float f;
HXDLIN( 131)				bool f1;
HXDLIN( 131)				if ((beta >= 0)) {
HXLINE( 131)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f1 = false;
            				}
HXDLIN( 131)				if (f1) {
HXLINE( 131)					f = beta;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f2;
HXDLIN( 131)				bool f3;
HXDLIN( 131)				if ((gamma >= 0)) {
HXLINE( 131)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f3 = false;
            				}
HXDLIN( 131)				if (f3) {
HXLINE( 131)					f2 = gamma;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f2 = a;
            					}
            					else {
HXLINE( 131)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f2;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif1;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif1 = theta;
            				}
            				else {
HXLINE( 131)					dif1 = -(theta);
            				}
HXDLIN( 131)				if ((dif1 < 0)) {
HXLINE( 131)					dif = dif1;
            				}
            				else {
HXLINE( 131)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 131)				Float f;
HXDLIN( 131)				bool f1;
HXDLIN( 131)				if ((beta >= 0)) {
HXLINE( 131)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f1 = false;
            				}
HXDLIN( 131)				if (f1) {
HXLINE( 131)					f = beta;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f2;
HXDLIN( 131)				bool f3;
HXDLIN( 131)				if ((gamma >= 0)) {
HXLINE( 131)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f3 = false;
            				}
HXDLIN( 131)				if (f3) {
HXLINE( 131)					f2 = gamma;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f2 = a;
            					}
            					else {
HXLINE( 131)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f2;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif1;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif1 = theta;
            				}
            				else {
HXLINE( 131)					dif1 = -(theta);
            				}
HXDLIN( 131)				if (smallest) {
HXLINE( 131)					dif = dif1;
            				}
            				else {
HXLINE( 131)					if (clockwise) {
HXLINE( 131)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 131)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 131)				Float f;
HXDLIN( 131)				bool f1;
HXDLIN( 131)				if ((beta >= 0)) {
HXLINE( 131)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f1 = false;
            				}
HXDLIN( 131)				if (f1) {
HXLINE( 131)					f = beta;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f2;
HXDLIN( 131)				bool f3;
HXDLIN( 131)				if ((gamma >= 0)) {
HXLINE( 131)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f3 = false;
            				}
HXDLIN( 131)				if (f3) {
HXLINE( 131)					f2 = gamma;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f2 = a;
            					}
            					else {
HXLINE( 131)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f2;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif1;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif1 = theta;
            				}
            				else {
HXLINE( 131)					dif1 = -(theta);
            				}
HXDLIN( 131)				if (largest) {
HXLINE( 131)					dif = dif1;
            				}
            				else {
HXLINE( 131)					if (clockwise) {
HXLINE( 131)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 131)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 131)		bool positive = (dif >= 0);
HXDLIN( 131)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 131)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 131)		Float angle = beta;
HXDLIN( 131)		Float cx4;
HXDLIN( 131)		Float cy4;
HXDLIN( 131)		Float bx4 = ( (Float)(0) );
HXDLIN( 131)		Float by4 = ( (Float)(0) );
HXDLIN( 131)		{
HXLINE( 131)			int _g = 0;
HXDLIN( 131)			int _g1 = (totalSteps + 1);
HXDLIN( 131)			while((_g < _g1)){
HXLINE( 131)				_g = (_g + 1);
HXDLIN( 131)				int i = (_g - 1);
HXDLIN( 131)				cx4 = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 131)				cy4 = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 131)				if ((i != 0)) {
HXLINE( 131)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx4,by4,0,cx4,cy4,0);
HXDLIN( 131)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 131)					if (::hx::IsNotNull( m )) {
HXLINE( 131)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 131)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 131)				angle = (angle + step1);
HXDLIN( 131)				bx4 = cx4;
HXDLIN( 131)				by4 = cy4;
            			}
            		}
HXDLIN( 131)		count = (count + totalSteps);
HXDLIN( 131)		Float pi2 = ::Math_obj::PI;
HXDLIN( 131)		Float step2 = ((pi2 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 131)		Float dif1;
HXDLIN( 131)		switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 131)				Float f;
HXDLIN( 131)				bool f1;
HXDLIN( 131)				if ((pi_2 >= 0)) {
HXLINE( 131)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f1 = false;
            				}
HXDLIN( 131)				if (f1) {
HXLINE( 131)					f = pi_2;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f2;
HXDLIN( 131)				bool f3;
HXDLIN( 131)				if ((pi >= 0)) {
HXLINE( 131)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f3 = false;
            				}
HXDLIN( 131)				if (f3) {
HXLINE( 131)					f2 = pi;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f2 = a;
            					}
            					else {
HXLINE( 131)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f2;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif = theta;
            				}
            				else {
HXLINE( 131)					dif = -(theta);
            				}
HXDLIN( 131)				if ((dif > 0)) {
HXLINE( 131)					dif1 = dif;
            				}
            				else {
HXLINE( 131)					dif1 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 131)				Float f;
HXDLIN( 131)				bool f1;
HXDLIN( 131)				if ((pi_2 >= 0)) {
HXLINE( 131)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f1 = false;
            				}
HXDLIN( 131)				if (f1) {
HXLINE( 131)					f = pi_2;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f2;
HXDLIN( 131)				bool f3;
HXDLIN( 131)				if ((pi >= 0)) {
HXLINE( 131)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f3 = false;
            				}
HXDLIN( 131)				if (f3) {
HXLINE( 131)					f2 = pi;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f2 = a;
            					}
            					else {
HXLINE( 131)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f2;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif = theta;
            				}
            				else {
HXLINE( 131)					dif = -(theta);
            				}
HXDLIN( 131)				if ((dif < 0)) {
HXLINE( 131)					dif1 = dif;
            				}
            				else {
HXLINE( 131)					dif1 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 131)				Float f;
HXDLIN( 131)				bool f1;
HXDLIN( 131)				if ((pi_2 >= 0)) {
HXLINE( 131)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f1 = false;
            				}
HXDLIN( 131)				if (f1) {
HXLINE( 131)					f = pi_2;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f2;
HXDLIN( 131)				bool f3;
HXDLIN( 131)				if ((pi >= 0)) {
HXLINE( 131)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f3 = false;
            				}
HXDLIN( 131)				if (f3) {
HXLINE( 131)					f2 = pi;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f2 = a;
            					}
            					else {
HXLINE( 131)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f2;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif = theta;
            				}
            				else {
HXLINE( 131)					dif = -(theta);
            				}
HXDLIN( 131)				if (smallest) {
HXLINE( 131)					dif1 = dif;
            				}
            				else {
HXLINE( 131)					if (clockwise) {
HXLINE( 131)						dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 131)						dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 131)				Float f;
HXDLIN( 131)				bool f1;
HXDLIN( 131)				if ((pi_2 >= 0)) {
HXLINE( 131)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f1 = false;
            				}
HXDLIN( 131)				if (f1) {
HXLINE( 131)					f = pi_2;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f2;
HXDLIN( 131)				bool f3;
HXDLIN( 131)				if ((pi >= 0)) {
HXLINE( 131)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f3 = false;
            				}
HXDLIN( 131)				if (f3) {
HXLINE( 131)					f2 = pi;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f2 = a;
            					}
            					else {
HXLINE( 131)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f2;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif = theta;
            				}
            				else {
HXLINE( 131)					dif = -(theta);
            				}
HXDLIN( 131)				if (largest) {
HXLINE( 131)					dif1 = dif;
            				}
            				else {
HXLINE( 131)					if (clockwise) {
HXLINE( 131)						dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 131)						dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 131)		bool positive1 = (dif1 >= 0);
HXDLIN( 131)		int totalSteps1 = ::Math_obj::ceil((::Math_obj::abs(dif1) / step2));
HXDLIN( 131)		Float step3 = (dif1 / ( (Float)(totalSteps1) ));
HXDLIN( 131)		Float angle1 = pi_2;
HXDLIN( 131)		Float cx5;
HXDLIN( 131)		Float cy5;
HXDLIN( 131)		Float bx5 = ( (Float)(0) );
HXDLIN( 131)		Float by5 = ( (Float)(0) );
HXDLIN( 131)		{
HXLINE( 131)			int _g2 = 0;
HXDLIN( 131)			int _g3 = (totalSteps1 + 1);
HXDLIN( 131)			while((_g2 < _g3)){
HXLINE( 131)				_g2 = (_g2 + 1);
HXDLIN( 131)				int i = (_g2 - 1);
HXDLIN( 131)				cx5 = (bx + (radius * ::Math_obj::sin(angle1)));
HXDLIN( 131)				cy5 = (by + (radius * ::Math_obj::cos(angle1)));
HXDLIN( 131)				if ((i != 0)) {
HXLINE( 131)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,bx5,by5,0,cx5,cy5,0);
HXDLIN( 131)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 131)					if (::hx::IsNotNull( m )) {
HXLINE( 131)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 131)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 131)				angle1 = (angle1 + step3);
HXDLIN( 131)				bx5 = cx5;
HXDLIN( 131)				by5 = cy5;
            			}
            		}
HXDLIN( 131)		count = (count + totalSteps1);
HXDLIN( 131)		Float pi3 = ::Math_obj::PI;
HXDLIN( 131)		Float step4 = ((pi3 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 131)		Float dif2;
HXDLIN( 131)		switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 131)				Float f;
HXDLIN( 131)				bool f1;
HXDLIN( 131)				if ((pi_2 >= 0)) {
HXLINE( 131)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f1 = false;
            				}
HXDLIN( 131)				if (f1) {
HXLINE( 131)					f = pi_2;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f2;
HXDLIN( 131)				if ((0 > ::Math_obj::PI)) {
HXLINE( 131)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f2 = a;
            					}
            					else {
HXLINE( 131)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f2;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif = theta;
            				}
            				else {
HXLINE( 131)					dif = -(theta);
            				}
HXDLIN( 131)				if ((dif > 0)) {
HXLINE( 131)					dif2 = dif;
            				}
            				else {
HXLINE( 131)					dif2 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 131)				Float f;
HXDLIN( 131)				bool f1;
HXDLIN( 131)				if ((pi_2 >= 0)) {
HXLINE( 131)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f1 = false;
            				}
HXDLIN( 131)				if (f1) {
HXLINE( 131)					f = pi_2;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f2;
HXDLIN( 131)				if ((0 > ::Math_obj::PI)) {
HXLINE( 131)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f2 = a;
            					}
            					else {
HXLINE( 131)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f2;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif = theta;
            				}
            				else {
HXLINE( 131)					dif = -(theta);
            				}
HXDLIN( 131)				if ((dif < 0)) {
HXLINE( 131)					dif2 = dif;
            				}
            				else {
HXLINE( 131)					dif2 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 131)				Float f;
HXDLIN( 131)				bool f1;
HXDLIN( 131)				if ((pi_2 >= 0)) {
HXLINE( 131)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f1 = false;
            				}
HXDLIN( 131)				if (f1) {
HXLINE( 131)					f = pi_2;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f2;
HXDLIN( 131)				if ((0 > ::Math_obj::PI)) {
HXLINE( 131)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f2 = a;
            					}
            					else {
HXLINE( 131)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f2;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif = theta;
            				}
            				else {
HXLINE( 131)					dif = -(theta);
            				}
HXDLIN( 131)				if (smallest) {
HXLINE( 131)					dif2 = dif;
            				}
            				else {
HXLINE( 131)					if (clockwise) {
HXLINE( 131)						dif2 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 131)						dif2 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 131)				Float f;
HXDLIN( 131)				bool f1;
HXDLIN( 131)				if ((pi_2 >= 0)) {
HXLINE( 131)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f1 = false;
            				}
HXDLIN( 131)				if (f1) {
HXLINE( 131)					f = pi_2;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f2;
HXDLIN( 131)				if ((0 > ::Math_obj::PI)) {
HXLINE( 131)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f2 = a;
            					}
            					else {
HXLINE( 131)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f2;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif = theta;
            				}
            				else {
HXLINE( 131)					dif = -(theta);
            				}
HXDLIN( 131)				if (largest) {
HXLINE( 131)					dif2 = dif;
            				}
            				else {
HXLINE( 131)					if (clockwise) {
HXLINE( 131)						dif2 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 131)						dif2 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 131)		bool positive2 = (dif2 >= 0);
HXDLIN( 131)		int totalSteps2 = ::Math_obj::ceil((::Math_obj::abs(dif2) / step4));
HXDLIN( 131)		Float step5 = (dif2 / ( (Float)(totalSteps2) ));
HXDLIN( 131)		Float angle2 = pi_2;
HXDLIN( 131)		Float cx6;
HXDLIN( 131)		Float cy6;
HXDLIN( 131)		Float bx6 = ( (Float)(0) );
HXDLIN( 131)		Float by6 = ( (Float)(0) );
HXDLIN( 131)		{
HXLINE( 131)			int _g4 = 0;
HXDLIN( 131)			int _g5 = (totalSteps2 + 1);
HXDLIN( 131)			while((_g4 < _g5)){
HXLINE( 131)				_g4 = (_g4 + 1);
HXDLIN( 131)				int i = (_g4 - 1);
HXDLIN( 131)				cx6 = (cx + (radius * ::Math_obj::sin(angle2)));
HXDLIN( 131)				cy6 = (cy + (radius * ::Math_obj::cos(angle2)));
HXDLIN( 131)				if ((i != 0)) {
HXLINE( 131)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(cx,cy,0,bx6,by6,0,cx6,cy6,0);
HXDLIN( 131)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 131)					if (::hx::IsNotNull( m )) {
HXLINE( 131)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 131)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 131)				angle2 = (angle2 + step5);
HXDLIN( 131)				bx6 = cx6;
HXDLIN( 131)				by6 = cy6;
            			}
            		}
HXDLIN( 131)		count = (count + totalSteps2);
HXDLIN( 131)		Float gamma1 = -(pi_2);
HXDLIN( 131)		Float pi4 = ::Math_obj::PI;
HXDLIN( 131)		Float step6 = ((pi4 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 131)		Float dif3;
HXDLIN( 131)		switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 131)				Float f;
HXDLIN( 131)				if ((0 > ::Math_obj::PI)) {
HXLINE( 131)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f1;
HXDLIN( 131)				bool f2;
HXDLIN( 131)				if ((gamma1 >= 0)) {
HXLINE( 131)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f2 = false;
            				}
HXDLIN( 131)				if (f2) {
HXLINE( 131)					f1 = gamma1;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f1 = a;
            					}
            					else {
HXLINE( 131)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f1;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif = theta;
            				}
            				else {
HXLINE( 131)					dif = -(theta);
            				}
HXDLIN( 131)				if ((dif > 0)) {
HXLINE( 131)					dif3 = dif;
            				}
            				else {
HXLINE( 131)					dif3 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 131)				Float f;
HXDLIN( 131)				if ((0 > ::Math_obj::PI)) {
HXLINE( 131)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f1;
HXDLIN( 131)				bool f2;
HXDLIN( 131)				if ((gamma1 >= 0)) {
HXLINE( 131)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f2 = false;
            				}
HXDLIN( 131)				if (f2) {
HXLINE( 131)					f1 = gamma1;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f1 = a;
            					}
            					else {
HXLINE( 131)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f1;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif = theta;
            				}
            				else {
HXLINE( 131)					dif = -(theta);
            				}
HXDLIN( 131)				if ((dif < 0)) {
HXLINE( 131)					dif3 = dif;
            				}
            				else {
HXLINE( 131)					dif3 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 131)				Float f;
HXDLIN( 131)				if ((0 > ::Math_obj::PI)) {
HXLINE( 131)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f1;
HXDLIN( 131)				bool f2;
HXDLIN( 131)				if ((gamma1 >= 0)) {
HXLINE( 131)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f2 = false;
            				}
HXDLIN( 131)				if (f2) {
HXLINE( 131)					f1 = gamma1;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f1 = a;
            					}
            					else {
HXLINE( 131)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f1;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif = theta;
            				}
            				else {
HXLINE( 131)					dif = -(theta);
            				}
HXDLIN( 131)				if (smallest) {
HXLINE( 131)					dif3 = dif;
            				}
            				else {
HXLINE( 131)					if (clockwise) {
HXLINE( 131)						dif3 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 131)						dif3 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 131)				Float f;
HXDLIN( 131)				if ((0 > ::Math_obj::PI)) {
HXLINE( 131)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f = a;
            					}
            					else {
HXLINE( 131)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this1 = f;
HXDLIN( 131)				Float za = this1;
HXDLIN( 131)				Float f1;
HXDLIN( 131)				bool f2;
HXDLIN( 131)				if ((gamma1 >= 0)) {
HXLINE( 131)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 131)					f2 = false;
            				}
HXDLIN( 131)				if (f2) {
HXLINE( 131)					f1 = gamma1;
            				}
            				else {
HXLINE( 131)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 131)					if ((a >= 0)) {
HXLINE( 131)						f1 = a;
            					}
            					else {
HXLINE( 131)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 131)				Float this2 = f1;
HXDLIN( 131)				Float zb = this2;
HXDLIN( 131)				Float fa = za;
HXDLIN( 131)				Float fb = zb;
HXDLIN( 131)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 131)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 131)				bool clockwise = (fa < fb);
HXDLIN( 131)				Float dif;
HXDLIN( 131)				if (clockwise) {
HXLINE( 131)					dif = theta;
            				}
            				else {
HXLINE( 131)					dif = -(theta);
            				}
HXDLIN( 131)				if (largest) {
HXLINE( 131)					dif3 = dif;
            				}
            				else {
HXLINE( 131)					if (clockwise) {
HXLINE( 131)						dif3 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 131)						dif3 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 131)		bool positive3 = (dif3 >= 0);
HXDLIN( 131)		int totalSteps3 = ::Math_obj::ceil((::Math_obj::abs(dif3) / step6));
HXDLIN( 131)		Float step7 = (dif3 / ( (Float)(totalSteps3) ));
HXDLIN( 131)		Float angle3 = ( (Float)(0) );
HXDLIN( 131)		Float cx7;
HXDLIN( 131)		Float cy7;
HXDLIN( 131)		Float bx7 = ( (Float)(0) );
HXDLIN( 131)		Float by7 = ( (Float)(0) );
HXDLIN( 131)		{
HXLINE( 131)			int _g6 = 0;
HXDLIN( 131)			int _g7 = (totalSteps3 + 1);
HXDLIN( 131)			while((_g6 < _g7)){
HXLINE( 131)				_g6 = (_g6 + 1);
HXDLIN( 131)				int i = (_g6 - 1);
HXDLIN( 131)				cx7 = (dx + (radius * ::Math_obj::sin(angle3)));
HXDLIN( 131)				cy7 = (dy + (radius * ::Math_obj::cos(angle3)));
HXDLIN( 131)				if ((i != 0)) {
HXLINE( 131)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx,dy,0,bx7,by7,0,cx7,cy7,0);
HXDLIN( 131)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 131)					if (::hx::IsNotNull( m )) {
HXLINE( 131)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 131)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 131)				angle3 = (angle3 + step7);
HXDLIN( 131)				bx7 = cx7;
HXDLIN( 131)				by7 = cy7;
            			}
            		}
HXDLIN( 131)		count = (count + totalSteps3);
HXDLIN( 131)		int len = count;
HXDLIN( 131)		{
HXLINE( 131)			int col = rs->color;
HXDLIN( 131)			{
HXLINE( 131)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN( 131)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN( 131)			{
HXLINE( 131)				int color = col;
HXDLIN( 131)				if ((color == -1)) {
HXLINE( 131)					color = this1->currentColor;
            				}
HXDLIN( 131)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN( 131)		int end = ((start + len) - 1);
HXDLIN( 131)		 ::trilateral3::structure::StartEnd se0 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXLINE( 132)		int start1 = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN( 132)		 ::Dynamic drawType1 = this1->drawType;
HXDLIN( 132)		Float x1 = (rs->x - rs->radius);
HXDLIN( 132)		Float y1 = (rs->y - rs->radius);
HXDLIN( 132)		Float width1 = (rs->radius * ( (Float)(2) ));
HXDLIN( 132)		Float height1 = (rs->radius * ( (Float)(2) ));
HXDLIN( 132)		Float radius1 = this1->rounded;
HXDLIN( 132)		Float pi5 = ::Math_obj::PI;
HXDLIN( 132)		Float pi_21 = (::Math_obj::PI / ( (Float)(2) ));
HXDLIN( 132)		Float ax4 = (x1 + radius1);
HXDLIN( 132)		Float ay4 = (y1 + radius1);
HXDLIN( 132)		Float bx8 = ((x1 + width1) - radius1);
HXDLIN( 132)		Float by8 = (y1 + radius1);
HXDLIN( 132)		Float cx8 = bx8;
HXDLIN( 132)		Float cy8 = ((y1 + height1) - radius1);
HXDLIN( 132)		Float dx4 = ax4;
HXDLIN( 132)		Float dy4 = cy8;
HXDLIN( 132)		int count1 = 0;
HXDLIN( 132)		Float ax5 = ax4;
HXDLIN( 132)		Float ay5 = y1;
HXDLIN( 132)		Float bx9 = (ax4 + (width1 - (radius1 * ( (Float)(2) ))));
HXDLIN( 132)		Float by9 = ay5;
HXDLIN( 132)		Float cx9 = bx9;
HXDLIN( 132)		Float cy9 = (ay5 + height1);
HXDLIN( 132)		Float dx5 = ax4;
HXDLIN( 132)		Float dy5 = cy9;
HXDLIN( 132)		{
HXLINE( 132)			drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax5,ay5,0,bx9,by9,0,dx5,dy5,0);
HXDLIN( 132)			 ::trilateral3::matrix::MatrixDozen m6 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 132)			if (::hx::IsNotNull( m6 )) {
HXLINE( 132)				drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m6);
            			}
HXDLIN( 132)			drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 132)		{
HXLINE( 132)			drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx9,by9,0,cx9,cy9,0,dx5,dy5,0);
HXDLIN( 132)			 ::trilateral3::matrix::MatrixDozen m7 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 132)			if (::hx::IsNotNull( m7 )) {
HXLINE( 132)				drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m7);
            			}
HXDLIN( 132)			drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 132)		count1 = (count1 + 2);
HXDLIN( 132)		Float dimY1 = (height1 - (( (Float)(2) ) * radius1));
HXDLIN( 132)		Float ax6 = x1;
HXDLIN( 132)		Float ay6 = ay4;
HXDLIN( 132)		Float bx10 = (x1 + radius1);
HXDLIN( 132)		Float by10 = ay6;
HXDLIN( 132)		Float cx10 = bx10;
HXDLIN( 132)		Float cy10 = (ay6 + dimY1);
HXDLIN( 132)		Float dx6 = x1;
HXDLIN( 132)		Float dy6 = cy10;
HXDLIN( 132)		{
HXLINE( 132)			drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax6,ay6,0,bx10,by10,0,dx6,dy6,0);
HXDLIN( 132)			 ::trilateral3::matrix::MatrixDozen m8 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 132)			if (::hx::IsNotNull( m8 )) {
HXLINE( 132)				drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m8);
            			}
HXDLIN( 132)			drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 132)		{
HXLINE( 132)			drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx10,by10,0,cx10,cy10,0,dx6,dy6,0);
HXDLIN( 132)			 ::trilateral3::matrix::MatrixDozen m9 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 132)			if (::hx::IsNotNull( m9 )) {
HXLINE( 132)				drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m9);
            			}
HXDLIN( 132)			drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 132)		count1 = (count1 + 2);
HXDLIN( 132)		Float ax7 = bx8;
HXDLIN( 132)		Float ay7 = by8;
HXDLIN( 132)		Float bx11 = (bx8 + radius1);
HXDLIN( 132)		Float by11 = ay7;
HXDLIN( 132)		Float cx11 = bx11;
HXDLIN( 132)		Float cy11 = (ay7 + dimY1);
HXDLIN( 132)		Float dx7 = bx8;
HXDLIN( 132)		Float dy7 = cy11;
HXDLIN( 132)		{
HXLINE( 132)			drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax7,ay7,0,bx11,by11,0,dx7,dy7,0);
HXDLIN( 132)			 ::trilateral3::matrix::MatrixDozen m10 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 132)			if (::hx::IsNotNull( m10 )) {
HXLINE( 132)				drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m10);
            			}
HXDLIN( 132)			drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 132)		{
HXLINE( 132)			drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx11,by11,0,cx11,cy11,0,dx7,dy7,0);
HXDLIN( 132)			 ::trilateral3::matrix::MatrixDozen m11 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 132)			if (::hx::IsNotNull( m11 )) {
HXLINE( 132)				drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m11);
            			}
HXDLIN( 132)			drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 132)		count1 = (count1 + 2);
HXDLIN( 132)		Float beta1 = -(pi5);
HXDLIN( 132)		Float gamma2 = -(pi_21);
HXDLIN( 132)		Float pi6 = ::Math_obj::PI;
HXDLIN( 132)		Float step8 = ((pi6 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 132)		Float dif4;
HXDLIN( 132)		switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 132)				Float f;
HXDLIN( 132)				bool f1;
HXDLIN( 132)				if ((beta1 >= 0)) {
HXLINE( 132)					f1 = (beta1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f1 = false;
            				}
HXDLIN( 132)				if (f1) {
HXLINE( 132)					f = beta1;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f2;
HXDLIN( 132)				bool f3;
HXDLIN( 132)				if ((gamma2 >= 0)) {
HXLINE( 132)					f3 = (gamma2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f3 = false;
            				}
HXDLIN( 132)				if (f3) {
HXLINE( 132)					f2 = gamma2;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(gamma2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f2 = a;
            					}
            					else {
HXLINE( 132)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f2;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if ((dif > 0)) {
HXLINE( 132)					dif4 = dif;
            				}
            				else {
HXLINE( 132)					dif4 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 132)				Float f;
HXDLIN( 132)				bool f1;
HXDLIN( 132)				if ((beta1 >= 0)) {
HXLINE( 132)					f1 = (beta1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f1 = false;
            				}
HXDLIN( 132)				if (f1) {
HXLINE( 132)					f = beta1;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f2;
HXDLIN( 132)				bool f3;
HXDLIN( 132)				if ((gamma2 >= 0)) {
HXLINE( 132)					f3 = (gamma2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f3 = false;
            				}
HXDLIN( 132)				if (f3) {
HXLINE( 132)					f2 = gamma2;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(gamma2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f2 = a;
            					}
            					else {
HXLINE( 132)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f2;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if ((dif < 0)) {
HXLINE( 132)					dif4 = dif;
            				}
            				else {
HXLINE( 132)					dif4 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 132)				Float f;
HXDLIN( 132)				bool f1;
HXDLIN( 132)				if ((beta1 >= 0)) {
HXLINE( 132)					f1 = (beta1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f1 = false;
            				}
HXDLIN( 132)				if (f1) {
HXLINE( 132)					f = beta1;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f2;
HXDLIN( 132)				bool f3;
HXDLIN( 132)				if ((gamma2 >= 0)) {
HXLINE( 132)					f3 = (gamma2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f3 = false;
            				}
HXDLIN( 132)				if (f3) {
HXLINE( 132)					f2 = gamma2;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(gamma2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f2 = a;
            					}
            					else {
HXLINE( 132)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f2;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if (smallest) {
HXLINE( 132)					dif4 = dif;
            				}
            				else {
HXLINE( 132)					if (clockwise) {
HXLINE( 132)						dif4 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 132)						dif4 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 132)				Float f;
HXDLIN( 132)				bool f1;
HXDLIN( 132)				if ((beta1 >= 0)) {
HXLINE( 132)					f1 = (beta1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f1 = false;
            				}
HXDLIN( 132)				if (f1) {
HXLINE( 132)					f = beta1;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(beta1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f2;
HXDLIN( 132)				bool f3;
HXDLIN( 132)				if ((gamma2 >= 0)) {
HXLINE( 132)					f3 = (gamma2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f3 = false;
            				}
HXDLIN( 132)				if (f3) {
HXLINE( 132)					f2 = gamma2;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(gamma2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f2 = a;
            					}
            					else {
HXLINE( 132)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f2;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if (largest) {
HXLINE( 132)					dif4 = dif;
            				}
            				else {
HXLINE( 132)					if (clockwise) {
HXLINE( 132)						dif4 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 132)						dif4 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 132)		bool positive4 = (dif4 >= 0);
HXDLIN( 132)		int totalSteps4 = ::Math_obj::ceil((::Math_obj::abs(dif4) / step8));
HXDLIN( 132)		Float step9 = (dif4 / ( (Float)(totalSteps4) ));
HXDLIN( 132)		Float angle4 = beta1;
HXDLIN( 132)		Float cx12;
HXDLIN( 132)		Float cy12;
HXDLIN( 132)		Float bx12 = ( (Float)(0) );
HXDLIN( 132)		Float by12 = ( (Float)(0) );
HXDLIN( 132)		{
HXLINE( 132)			int _g8 = 0;
HXDLIN( 132)			int _g9 = (totalSteps4 + 1);
HXDLIN( 132)			while((_g8 < _g9)){
HXLINE( 132)				_g8 = (_g8 + 1);
HXDLIN( 132)				int i = (_g8 - 1);
HXDLIN( 132)				cx12 = (ax4 + (radius1 * ::Math_obj::sin(angle4)));
HXDLIN( 132)				cy12 = (ay4 + (radius1 * ::Math_obj::cos(angle4)));
HXDLIN( 132)				if ((i != 0)) {
HXLINE( 132)					drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax4,ay4,0,bx12,by12,0,cx12,cy12,0);
HXDLIN( 132)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 132)					if (::hx::IsNotNull( m )) {
HXLINE( 132)						drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 132)					drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 132)				angle4 = (angle4 + step9);
HXDLIN( 132)				bx12 = cx12;
HXDLIN( 132)				by12 = cy12;
            			}
            		}
HXDLIN( 132)		count1 = (count1 + totalSteps4);
HXDLIN( 132)		Float pi7 = ::Math_obj::PI;
HXDLIN( 132)		Float step10 = ((pi7 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 132)		Float dif5;
HXDLIN( 132)		switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 132)				Float f;
HXDLIN( 132)				bool f1;
HXDLIN( 132)				if ((pi_21 >= 0)) {
HXLINE( 132)					f1 = (pi_21 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f1 = false;
            				}
HXDLIN( 132)				if (f1) {
HXLINE( 132)					f = pi_21;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(pi_21,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f2;
HXDLIN( 132)				bool f3;
HXDLIN( 132)				if ((pi5 >= 0)) {
HXLINE( 132)					f3 = (pi5 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f3 = false;
            				}
HXDLIN( 132)				if (f3) {
HXLINE( 132)					f2 = pi5;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(pi5,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f2 = a;
            					}
            					else {
HXLINE( 132)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f2;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if ((dif > 0)) {
HXLINE( 132)					dif5 = dif;
            				}
            				else {
HXLINE( 132)					dif5 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 132)				Float f;
HXDLIN( 132)				bool f1;
HXDLIN( 132)				if ((pi_21 >= 0)) {
HXLINE( 132)					f1 = (pi_21 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f1 = false;
            				}
HXDLIN( 132)				if (f1) {
HXLINE( 132)					f = pi_21;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(pi_21,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f2;
HXDLIN( 132)				bool f3;
HXDLIN( 132)				if ((pi5 >= 0)) {
HXLINE( 132)					f3 = (pi5 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f3 = false;
            				}
HXDLIN( 132)				if (f3) {
HXLINE( 132)					f2 = pi5;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(pi5,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f2 = a;
            					}
            					else {
HXLINE( 132)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f2;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if ((dif < 0)) {
HXLINE( 132)					dif5 = dif;
            				}
            				else {
HXLINE( 132)					dif5 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 132)				Float f;
HXDLIN( 132)				bool f1;
HXDLIN( 132)				if ((pi_21 >= 0)) {
HXLINE( 132)					f1 = (pi_21 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f1 = false;
            				}
HXDLIN( 132)				if (f1) {
HXLINE( 132)					f = pi_21;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(pi_21,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f2;
HXDLIN( 132)				bool f3;
HXDLIN( 132)				if ((pi5 >= 0)) {
HXLINE( 132)					f3 = (pi5 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f3 = false;
            				}
HXDLIN( 132)				if (f3) {
HXLINE( 132)					f2 = pi5;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(pi5,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f2 = a;
            					}
            					else {
HXLINE( 132)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f2;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if (smallest) {
HXLINE( 132)					dif5 = dif;
            				}
            				else {
HXLINE( 132)					if (clockwise) {
HXLINE( 132)						dif5 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 132)						dif5 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 132)				Float f;
HXDLIN( 132)				bool f1;
HXDLIN( 132)				if ((pi_21 >= 0)) {
HXLINE( 132)					f1 = (pi_21 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f1 = false;
            				}
HXDLIN( 132)				if (f1) {
HXLINE( 132)					f = pi_21;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(pi_21,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f2;
HXDLIN( 132)				bool f3;
HXDLIN( 132)				if ((pi5 >= 0)) {
HXLINE( 132)					f3 = (pi5 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f3 = false;
            				}
HXDLIN( 132)				if (f3) {
HXLINE( 132)					f2 = pi5;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(pi5,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f2 = a;
            					}
            					else {
HXLINE( 132)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f2;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if (largest) {
HXLINE( 132)					dif5 = dif;
            				}
            				else {
HXLINE( 132)					if (clockwise) {
HXLINE( 132)						dif5 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 132)						dif5 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 132)		bool positive5 = (dif5 >= 0);
HXDLIN( 132)		int totalSteps5 = ::Math_obj::ceil((::Math_obj::abs(dif5) / step10));
HXDLIN( 132)		Float step11 = (dif5 / ( (Float)(totalSteps5) ));
HXDLIN( 132)		Float angle5 = pi_21;
HXDLIN( 132)		Float cx13;
HXDLIN( 132)		Float cy13;
HXDLIN( 132)		Float bx13 = ( (Float)(0) );
HXDLIN( 132)		Float by13 = ( (Float)(0) );
HXDLIN( 132)		{
HXLINE( 132)			int _g10 = 0;
HXDLIN( 132)			int _g11 = (totalSteps5 + 1);
HXDLIN( 132)			while((_g10 < _g11)){
HXLINE( 132)				_g10 = (_g10 + 1);
HXDLIN( 132)				int i = (_g10 - 1);
HXDLIN( 132)				cx13 = (bx8 + (radius1 * ::Math_obj::sin(angle5)));
HXDLIN( 132)				cy13 = (by8 + (radius1 * ::Math_obj::cos(angle5)));
HXDLIN( 132)				if ((i != 0)) {
HXLINE( 132)					drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx8,by8,0,bx13,by13,0,cx13,cy13,0);
HXDLIN( 132)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 132)					if (::hx::IsNotNull( m )) {
HXLINE( 132)						drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 132)					drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 132)				angle5 = (angle5 + step11);
HXDLIN( 132)				bx13 = cx13;
HXDLIN( 132)				by13 = cy13;
            			}
            		}
HXDLIN( 132)		count1 = (count1 + totalSteps5);
HXDLIN( 132)		Float pi8 = ::Math_obj::PI;
HXDLIN( 132)		Float step12 = ((pi8 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 132)		Float dif6;
HXDLIN( 132)		switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 132)				Float f;
HXDLIN( 132)				bool f1;
HXDLIN( 132)				if ((pi_21 >= 0)) {
HXLINE( 132)					f1 = (pi_21 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f1 = false;
            				}
HXDLIN( 132)				if (f1) {
HXLINE( 132)					f = pi_21;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(pi_21,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f2;
HXDLIN( 132)				if ((0 > ::Math_obj::PI)) {
HXLINE( 132)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f2 = a;
            					}
            					else {
HXLINE( 132)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f2;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if ((dif > 0)) {
HXLINE( 132)					dif6 = dif;
            				}
            				else {
HXLINE( 132)					dif6 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 132)				Float f;
HXDLIN( 132)				bool f1;
HXDLIN( 132)				if ((pi_21 >= 0)) {
HXLINE( 132)					f1 = (pi_21 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f1 = false;
            				}
HXDLIN( 132)				if (f1) {
HXLINE( 132)					f = pi_21;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(pi_21,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f2;
HXDLIN( 132)				if ((0 > ::Math_obj::PI)) {
HXLINE( 132)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f2 = a;
            					}
            					else {
HXLINE( 132)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f2;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if ((dif < 0)) {
HXLINE( 132)					dif6 = dif;
            				}
            				else {
HXLINE( 132)					dif6 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 132)				Float f;
HXDLIN( 132)				bool f1;
HXDLIN( 132)				if ((pi_21 >= 0)) {
HXLINE( 132)					f1 = (pi_21 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f1 = false;
            				}
HXDLIN( 132)				if (f1) {
HXLINE( 132)					f = pi_21;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(pi_21,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f2;
HXDLIN( 132)				if ((0 > ::Math_obj::PI)) {
HXLINE( 132)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f2 = a;
            					}
            					else {
HXLINE( 132)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f2;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if (smallest) {
HXLINE( 132)					dif6 = dif;
            				}
            				else {
HXLINE( 132)					if (clockwise) {
HXLINE( 132)						dif6 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 132)						dif6 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 132)				Float f;
HXDLIN( 132)				bool f1;
HXDLIN( 132)				if ((pi_21 >= 0)) {
HXLINE( 132)					f1 = (pi_21 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f1 = false;
            				}
HXDLIN( 132)				if (f1) {
HXLINE( 132)					f = pi_21;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(pi_21,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f2;
HXDLIN( 132)				if ((0 > ::Math_obj::PI)) {
HXLINE( 132)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f2 = a;
            					}
            					else {
HXLINE( 132)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f2;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if (largest) {
HXLINE( 132)					dif6 = dif;
            				}
            				else {
HXLINE( 132)					if (clockwise) {
HXLINE( 132)						dif6 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 132)						dif6 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 132)		bool positive6 = (dif6 >= 0);
HXDLIN( 132)		int totalSteps6 = ::Math_obj::ceil((::Math_obj::abs(dif6) / step12));
HXDLIN( 132)		Float step13 = (dif6 / ( (Float)(totalSteps6) ));
HXDLIN( 132)		Float angle6 = pi_21;
HXDLIN( 132)		Float cx14;
HXDLIN( 132)		Float cy14;
HXDLIN( 132)		Float bx14 = ( (Float)(0) );
HXDLIN( 132)		Float by14 = ( (Float)(0) );
HXDLIN( 132)		{
HXLINE( 132)			int _g12 = 0;
HXDLIN( 132)			int _g13 = (totalSteps6 + 1);
HXDLIN( 132)			while((_g12 < _g13)){
HXLINE( 132)				_g12 = (_g12 + 1);
HXDLIN( 132)				int i = (_g12 - 1);
HXDLIN( 132)				cx14 = (cx8 + (radius1 * ::Math_obj::sin(angle6)));
HXDLIN( 132)				cy14 = (cy8 + (radius1 * ::Math_obj::cos(angle6)));
HXDLIN( 132)				if ((i != 0)) {
HXLINE( 132)					drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(cx8,cy8,0,bx14,by14,0,cx14,cy14,0);
HXDLIN( 132)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 132)					if (::hx::IsNotNull( m )) {
HXLINE( 132)						drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 132)					drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 132)				angle6 = (angle6 + step13);
HXDLIN( 132)				bx14 = cx14;
HXDLIN( 132)				by14 = cy14;
            			}
            		}
HXDLIN( 132)		count1 = (count1 + totalSteps6);
HXDLIN( 132)		Float gamma3 = -(pi_21);
HXDLIN( 132)		Float pi9 = ::Math_obj::PI;
HXDLIN( 132)		Float step14 = ((pi9 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 132)		Float dif7;
HXDLIN( 132)		switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 132)				Float f;
HXDLIN( 132)				if ((0 > ::Math_obj::PI)) {
HXLINE( 132)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f1;
HXDLIN( 132)				bool f2;
HXDLIN( 132)				if ((gamma3 >= 0)) {
HXLINE( 132)					f2 = (gamma3 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f2 = false;
            				}
HXDLIN( 132)				if (f2) {
HXLINE( 132)					f1 = gamma3;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(gamma3,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f1 = a;
            					}
            					else {
HXLINE( 132)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f1;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if ((dif > 0)) {
HXLINE( 132)					dif7 = dif;
            				}
            				else {
HXLINE( 132)					dif7 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 132)				Float f;
HXDLIN( 132)				if ((0 > ::Math_obj::PI)) {
HXLINE( 132)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f1;
HXDLIN( 132)				bool f2;
HXDLIN( 132)				if ((gamma3 >= 0)) {
HXLINE( 132)					f2 = (gamma3 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f2 = false;
            				}
HXDLIN( 132)				if (f2) {
HXLINE( 132)					f1 = gamma3;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(gamma3,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f1 = a;
            					}
            					else {
HXLINE( 132)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f1;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if ((dif < 0)) {
HXLINE( 132)					dif7 = dif;
            				}
            				else {
HXLINE( 132)					dif7 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 132)				Float f;
HXDLIN( 132)				if ((0 > ::Math_obj::PI)) {
HXLINE( 132)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f1;
HXDLIN( 132)				bool f2;
HXDLIN( 132)				if ((gamma3 >= 0)) {
HXLINE( 132)					f2 = (gamma3 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f2 = false;
            				}
HXDLIN( 132)				if (f2) {
HXLINE( 132)					f1 = gamma3;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(gamma3,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f1 = a;
            					}
            					else {
HXLINE( 132)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f1;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if (smallest) {
HXLINE( 132)					dif7 = dif;
            				}
            				else {
HXLINE( 132)					if (clockwise) {
HXLINE( 132)						dif7 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 132)						dif7 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 132)				Float f;
HXDLIN( 132)				if ((0 > ::Math_obj::PI)) {
HXLINE( 132)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f = a;
            					}
            					else {
HXLINE( 132)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this1 = f;
HXDLIN( 132)				Float za = this1;
HXDLIN( 132)				Float f1;
HXDLIN( 132)				bool f2;
HXDLIN( 132)				if ((gamma3 >= 0)) {
HXLINE( 132)					f2 = (gamma3 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 132)					f2 = false;
            				}
HXDLIN( 132)				if (f2) {
HXLINE( 132)					f1 = gamma3;
            				}
            				else {
HXLINE( 132)					Float a = ::hx::Mod(gamma3,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 132)					if ((a >= 0)) {
HXLINE( 132)						f1 = a;
            					}
            					else {
HXLINE( 132)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 132)				Float this2 = f1;
HXDLIN( 132)				Float zb = this2;
HXDLIN( 132)				Float fa = za;
HXDLIN( 132)				Float fb = zb;
HXDLIN( 132)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 132)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 132)				bool clockwise = (fa < fb);
HXDLIN( 132)				Float dif;
HXDLIN( 132)				if (clockwise) {
HXLINE( 132)					dif = theta;
            				}
            				else {
HXLINE( 132)					dif = -(theta);
            				}
HXDLIN( 132)				if (largest) {
HXLINE( 132)					dif7 = dif;
            				}
            				else {
HXLINE( 132)					if (clockwise) {
HXLINE( 132)						dif7 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 132)						dif7 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 132)		bool positive7 = (dif7 >= 0);
HXDLIN( 132)		int totalSteps7 = ::Math_obj::ceil((::Math_obj::abs(dif7) / step14));
HXDLIN( 132)		Float step15 = (dif7 / ( (Float)(totalSteps7) ));
HXDLIN( 132)		Float angle7 = ( (Float)(0) );
HXDLIN( 132)		Float cx15;
HXDLIN( 132)		Float cy15;
HXDLIN( 132)		Float bx15 = ( (Float)(0) );
HXDLIN( 132)		Float by15 = ( (Float)(0) );
HXDLIN( 132)		{
HXLINE( 132)			int _g14 = 0;
HXDLIN( 132)			int _g15 = (totalSteps7 + 1);
HXDLIN( 132)			while((_g14 < _g15)){
HXLINE( 132)				_g14 = (_g14 + 1);
HXDLIN( 132)				int i = (_g14 - 1);
HXDLIN( 132)				cx15 = (dx4 + (radius1 * ::Math_obj::sin(angle7)));
HXDLIN( 132)				cy15 = (dy4 + (radius1 * ::Math_obj::cos(angle7)));
HXDLIN( 132)				if ((i != 0)) {
HXLINE( 132)					drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx4,dy4,0,bx15,by15,0,cx15,cy15,0);
HXDLIN( 132)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 132)					if (::hx::IsNotNull( m )) {
HXLINE( 132)						drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 132)					drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 132)				angle7 = (angle7 + step15);
HXDLIN( 132)				bx15 = cx15;
HXDLIN( 132)				by15 = cy15;
            			}
            		}
HXDLIN( 132)		count1 = (count1 + totalSteps7);
HXDLIN( 132)		int len1 = count1;
HXDLIN( 132)		{
HXLINE( 132)			int col1 = rs->color;
HXDLIN( 132)			{
HXLINE( 132)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
HXDLIN( 132)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
            			}
HXDLIN( 132)			{
HXLINE( 132)				int color1 = col1;
HXDLIN( 132)				if ((color1 == -1)) {
HXLINE( 132)					color1 = this1->currentColor;
            				}
HXDLIN( 132)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
            			}
            		}
HXDLIN( 132)		int end1 = ((start1 + len1) - 1);
HXDLIN( 132)		 ::trilateral3::structure::StartEnd se1 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start1,end1);
HXLINE( 133)		{
HXLINE( 133)			 ::trilateral3::matrix::MatrixDozen r = ( ( ::trilateral3::matrix::MatrixDozen)(this1->rotateX(::Math_obj::PI)) );
HXDLIN( 133)			 ::trilateral3::matrix::MatrixDozen s = ( ( ::trilateral3::matrix::MatrixDozen)(this1->translateX(this1->dz)) );
HXDLIN( 133)			 ::trilateral3::matrix::MatrixDozen m12 =  ::trilateral3::matrix::MatrixDozen_obj::__alloc( HX_CTX ,(((r->a * s->a) + (r->b * s->e)) + (r->c * s->i)),(((r->a * s->b) + (r->b * s->f)) + (r->c * s->j)),(((r->a * s->c) + (r->b * s->g)) + (r->c * s->k)),((((r->a * s->d) + (r->b * s->h)) + (r->c * s->l)) + r->d),(((r->e * s->a) + (r->f * s->e)) + (r->g * s->i)),(((r->e * s->b) + (r->f * s->f)) + (r->g * s->j)),(((r->e * s->c) + (r->f * s->g)) + (r->g * s->k)),((((r->e * s->d) + (r->f * s->h)) + (r->g * s->l)) + r->h),(((r->i * s->a) + (r->j * s->e)) + (r->k * s->i)),(((r->i * s->b) + (r->j * s->f)) + (r->k * s->j)),(((r->i * s->c) + (r->j * s->g)) + (r->k * s->k)),((((r->i * s->d) + (r->j * s->h)) + (r->k * s->l)) + r->l));
HXDLIN( 133)			this1->drawType->__Field(HX_("transformRange",b1,c0,a1,5a),::hx::paccDynamic)(m12,se1);
            		}
HXLINE( 134)		int begin = ::Std_obj::_hx_int(::Math_obj::min(( (Float)(se0->start) ),( (Float)(se1->start) )));
HXDLIN( 134)		int _hx_tmp;
HXDLIN( 134)		if ((begin == se0->start)) {
HXLINE( 134)			_hx_tmp = se1->end;
            		}
            		else {
HXLINE( 134)			_hx_tmp = se0->end;
            		}
HXDLIN( 134)		return ::trilateral3::shape::_IndexRange::IndexRange_Impl__obj::_new( ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,begin,_hx_tmp));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,roundedSquare2,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::star( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_137_star)
HXLINE( 138)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXLINE( 139)		 ::Dynamic drawType = this1->drawType;
HXDLIN( 139)		Float px = (rs->x - rs->radius);
HXDLIN( 139)		Float py = (rs->y - rs->radius);
HXDLIN( 139)		Float radius = (rs->radius * ( (Float)(2) ));
HXDLIN( 139)		 ::Dynamic theta = (rs->radius * ( (Float)(2) ));
HXLINE( 140)		if (::hx::IsNull( theta )) {
HXLINE( 140)			theta = 0;
            		}
HXLINE( 139)		Float pi = ::Math_obj::PI;
HXDLIN( 139)		Float omega = (-(pi) + theta);
HXDLIN( 139)		radius = (radius / ((Float)1.9));
HXDLIN( 139)		px = (px + radius);
HXDLIN( 139)		py = (py + radius);
HXDLIN( 139)		Float a0x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN( 139)		Float a0y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN( 139)		omega = (omega + (pi / ( (Float)(3) )));
HXDLIN( 139)		Float a1x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN( 139)		Float a1y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN( 139)		omega = (omega + (pi / ( (Float)(3) )));
HXDLIN( 139)		Float b0x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN( 139)		Float b0y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN( 139)		omega = (omega + (pi / ( (Float)(3) )));
HXDLIN( 139)		Float b1x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN( 139)		Float b1y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN( 139)		omega = (omega + (pi / ( (Float)(3) )));
HXDLIN( 139)		Float c0x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN( 139)		Float c0y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN( 139)		omega = (omega + (pi / ( (Float)(3) )));
HXDLIN( 139)		Float c1x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN( 139)		Float c1y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN( 139)		{
HXLINE( 139)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(a0x,a0y,0,b0x,b0y,0,c0x,c0y,0);
HXDLIN( 139)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 139)			if (::hx::IsNotNull( m )) {
HXLINE( 139)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN( 139)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 139)		{
HXLINE( 139)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(a1x,a1y,0,b1x,b1y,0,c1x,c1y,0);
HXDLIN( 139)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 139)			if (::hx::IsNotNull( m1 )) {
HXLINE( 139)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN( 139)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 139)		int len = 2;
HXLINE( 141)		{
HXLINE( 141)			int col = rs->color;
HXDLIN( 141)			{
HXLINE( 141)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN( 141)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN( 141)			{
HXLINE( 141)				int color = col;
HXDLIN( 141)				if ((color == -1)) {
HXLINE( 141)					color = this1->currentColor;
            				}
HXDLIN( 141)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXLINE( 142)		int end = ((start + len) - 1);
HXLINE( 143)		return  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,star,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::star2( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs){
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_146_star2)
HXLINE( 147)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN( 147)		 ::Dynamic drawType = this1->drawType;
HXDLIN( 147)		Float px = (rs->x - rs->radius);
HXDLIN( 147)		Float py = (rs->y - rs->radius);
HXDLIN( 147)		Float radius = (rs->radius * ( (Float)(2) ));
HXDLIN( 147)		 ::Dynamic theta = (rs->radius * ( (Float)(2) ));
HXDLIN( 147)		if (::hx::IsNull( theta )) {
HXLINE( 147)			theta = 0;
            		}
HXDLIN( 147)		Float pi = ::Math_obj::PI;
HXDLIN( 147)		Float omega = (-(pi) + theta);
HXDLIN( 147)		radius = (radius / ((Float)1.9));
HXDLIN( 147)		px = (px + radius);
HXDLIN( 147)		py = (py + radius);
HXDLIN( 147)		Float a0x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN( 147)		Float a0y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN( 147)		omega = (omega + (pi / ( (Float)(3) )));
HXDLIN( 147)		Float a1x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN( 147)		Float a1y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN( 147)		omega = (omega + (pi / ( (Float)(3) )));
HXDLIN( 147)		Float b0x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN( 147)		Float b0y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN( 147)		omega = (omega + (pi / ( (Float)(3) )));
HXDLIN( 147)		Float b1x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN( 147)		Float b1y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN( 147)		omega = (omega + (pi / ( (Float)(3) )));
HXDLIN( 147)		Float c0x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN( 147)		Float c0y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN( 147)		omega = (omega + (pi / ( (Float)(3) )));
HXDLIN( 147)		Float c1x = (px + (radius * ::Math_obj::sin(omega)));
HXDLIN( 147)		Float c1y = (py + (radius * ::Math_obj::cos(omega)));
HXDLIN( 147)		{
HXLINE( 147)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(a0x,a0y,0,b0x,b0y,0,c0x,c0y,0);
HXDLIN( 147)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 147)			if (::hx::IsNotNull( m )) {
HXLINE( 147)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN( 147)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 147)		{
HXLINE( 147)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(a1x,a1y,0,b1x,b1y,0,c1x,c1y,0);
HXDLIN( 147)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 147)			if (::hx::IsNotNull( m1 )) {
HXLINE( 147)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN( 147)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 147)		int len = 2;
HXDLIN( 147)		{
HXLINE( 147)			int col = rs->color;
HXDLIN( 147)			{
HXLINE( 147)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN( 147)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN( 147)			{
HXLINE( 147)				int color = col;
HXDLIN( 147)				if ((color == -1)) {
HXLINE( 147)					color = this1->currentColor;
            				}
HXDLIN( 147)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXDLIN( 147)		int end = ((start + len) - 1);
HXDLIN( 147)		 ::trilateral3::structure::StartEnd se0 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXLINE( 148)		int start1 = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN( 148)		 ::Dynamic drawType1 = this1->drawType;
HXDLIN( 148)		Float px1 = (rs->x - rs->radius);
HXDLIN( 148)		Float py1 = (rs->y - rs->radius);
HXDLIN( 148)		Float radius1 = (rs->radius * ( (Float)(2) ));
HXDLIN( 148)		 ::Dynamic theta1 = (rs->radius * ( (Float)(2) ));
HXDLIN( 148)		if (::hx::IsNull( theta1 )) {
HXLINE( 148)			theta1 = 0;
            		}
HXDLIN( 148)		Float pi1 = ::Math_obj::PI;
HXDLIN( 148)		Float omega1 = (-(pi1) + theta1);
HXDLIN( 148)		radius1 = (radius1 / ((Float)1.9));
HXDLIN( 148)		px1 = (px1 + radius1);
HXDLIN( 148)		py1 = (py1 + radius1);
HXDLIN( 148)		Float a0x1 = (px1 + (radius1 * ::Math_obj::sin(omega1)));
HXDLIN( 148)		Float a0y1 = (py1 + (radius1 * ::Math_obj::cos(omega1)));
HXDLIN( 148)		omega1 = (omega1 + (pi1 / ( (Float)(3) )));
HXDLIN( 148)		Float a1x1 = (px1 + (radius1 * ::Math_obj::sin(omega1)));
HXDLIN( 148)		Float a1y1 = (py1 + (radius1 * ::Math_obj::cos(omega1)));
HXDLIN( 148)		omega1 = (omega1 + (pi1 / ( (Float)(3) )));
HXDLIN( 148)		Float b0x1 = (px1 + (radius1 * ::Math_obj::sin(omega1)));
HXDLIN( 148)		Float b0y1 = (py1 + (radius1 * ::Math_obj::cos(omega1)));
HXDLIN( 148)		omega1 = (omega1 + (pi1 / ( (Float)(3) )));
HXDLIN( 148)		Float b1x1 = (px1 + (radius1 * ::Math_obj::sin(omega1)));
HXDLIN( 148)		Float b1y1 = (py1 + (radius1 * ::Math_obj::cos(omega1)));
HXDLIN( 148)		omega1 = (omega1 + (pi1 / ( (Float)(3) )));
HXDLIN( 148)		Float c0x1 = (px1 + (radius1 * ::Math_obj::sin(omega1)));
HXDLIN( 148)		Float c0y1 = (py1 + (radius1 * ::Math_obj::cos(omega1)));
HXDLIN( 148)		omega1 = (omega1 + (pi1 / ( (Float)(3) )));
HXDLIN( 148)		Float c1x1 = (px1 + (radius1 * ::Math_obj::sin(omega1)));
HXDLIN( 148)		Float c1y1 = (py1 + (radius1 * ::Math_obj::cos(omega1)));
HXDLIN( 148)		{
HXLINE( 148)			drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(a0x1,a0y1,0,b0x1,b0y1,0,c0x1,c0y1,0);
HXDLIN( 148)			 ::trilateral3::matrix::MatrixDozen m2 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 148)			if (::hx::IsNotNull( m2 )) {
HXLINE( 148)				drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m2);
            			}
HXDLIN( 148)			drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 148)		{
HXLINE( 148)			drawType1->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(a1x1,a1y1,0,b1x1,b1y1,0,c1x1,c1y1,0);
HXDLIN( 148)			 ::trilateral3::matrix::MatrixDozen m3 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 148)			if (::hx::IsNotNull( m3 )) {
HXLINE( 148)				drawType1->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m3);
            			}
HXDLIN( 148)			drawType1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 148)		int len1 = 2;
HXDLIN( 148)		{
HXLINE( 148)			int col1 = rs->color;
HXDLIN( 148)			{
HXLINE( 148)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
HXDLIN( 148)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start1);
            			}
HXDLIN( 148)			{
HXLINE( 148)				int color1 = col1;
HXDLIN( 148)				if ((color1 == -1)) {
HXLINE( 148)					color1 = this1->currentColor;
            				}
HXDLIN( 148)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color1,len1);
            			}
            		}
HXDLIN( 148)		int end1 = ((start1 + len1) - 1);
HXDLIN( 148)		 ::trilateral3::structure::StartEnd se1 =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start1,end1);
HXLINE( 149)		{
HXLINE( 149)			 ::trilateral3::matrix::MatrixDozen r = ( ( ::trilateral3::matrix::MatrixDozen)(this1->rotateX(::Math_obj::PI)) );
HXDLIN( 149)			 ::trilateral3::matrix::MatrixDozen s = ( ( ::trilateral3::matrix::MatrixDozen)(this1->translateX(this1->dz)) );
HXDLIN( 149)			 ::trilateral3::matrix::MatrixDozen m4 =  ::trilateral3::matrix::MatrixDozen_obj::__alloc( HX_CTX ,(((r->a * s->a) + (r->b * s->e)) + (r->c * s->i)),(((r->a * s->b) + (r->b * s->f)) + (r->c * s->j)),(((r->a * s->c) + (r->b * s->g)) + (r->c * s->k)),((((r->a * s->d) + (r->b * s->h)) + (r->c * s->l)) + r->d),(((r->e * s->a) + (r->f * s->e)) + (r->g * s->i)),(((r->e * s->b) + (r->f * s->f)) + (r->g * s->j)),(((r->e * s->c) + (r->f * s->g)) + (r->g * s->k)),((((r->e * s->d) + (r->f * s->h)) + (r->g * s->l)) + r->h),(((r->i * s->a) + (r->j * s->e)) + (r->k * s->i)),(((r->i * s->b) + (r->j * s->f)) + (r->k * s->j)),(((r->i * s->c) + (r->j * s->g)) + (r->k * s->k)),((((r->i * s->d) + (r->j * s->h)) + (r->k * s->l)) + r->l));
HXDLIN( 149)			this1->drawType->__Field(HX_("transformRange",b1,c0,a1,5a),::hx::paccDynamic)(m4,se1);
            		}
HXLINE( 150)		int begin = ::Std_obj::_hx_int(::Math_obj::min(( (Float)(se0->start) ),( (Float)(se1->start) )));
HXDLIN( 150)		int _hx_tmp;
HXDLIN( 150)		if ((begin == se0->start)) {
HXLINE( 150)			_hx_tmp = se1->end;
            		}
            		else {
HXLINE( 150)			_hx_tmp = se0->end;
            		}
HXDLIN( 150)		return ::trilateral3::shape::_IndexRange::IndexRange_Impl__obj::_new( ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,begin,_hx_tmp));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Regular_Impl__obj,star2,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::polygon( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs,::hx::Null< int >  __o_sides){
            		int sides = __o_sides.Default(36);
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_153_polygon)
HXLINE( 154)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXLINE( 155)		 ::Dynamic drawType = this1->drawType;
HXDLIN( 155)		Float ax = rs->x;
HXDLIN( 155)		Float ay = rs->y;
HXDLIN( 155)		Float radius = rs->radius;
HXDLIN( 155)		 ::Dynamic sides1 = sides;
HXDLIN( 155)		if (::hx::IsNull( sides1 )) {
HXLINE( 155)			sides1 = 36;
            		}
HXDLIN( 155)		Float pi = ::Math_obj::PI;
HXDLIN( 155)		Float theta = (pi / ( (Float)(2) ));
HXDLIN( 155)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 155)		Float bx;
HXDLIN( 155)		Float by;
HXDLIN( 155)		Float cx;
HXDLIN( 155)		Float cy;
HXDLIN( 155)		{
HXLINE( 155)			int _g = 0;
HXDLIN( 155)			 ::Dynamic _g1 = sides1;
HXDLIN( 155)			while(::hx::IsLess( _g,_g1 )){
HXLINE( 155)				_g = (_g + 1);
HXDLIN( 155)				int i = (_g - 1);
HXDLIN( 155)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN( 155)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN( 155)				theta = (theta + step);
HXDLIN( 155)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXDLIN( 155)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXDLIN( 155)				{
HXLINE( 155)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 155)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 155)					if (::hx::IsNotNull( m )) {
HXLINE( 155)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 155)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXDLIN( 155)		int len = ( (int)(sides1) );
HXLINE( 156)		{
HXLINE( 156)			int col = rs->color;
HXDLIN( 156)			{
HXLINE( 156)				this1->drawType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
HXDLIN( 156)				this1->colorType->__Field(HX_("set_pos",37,b7,cb,19),::hx::paccDynamic)(start);
            			}
HXDLIN( 156)			{
HXLINE( 156)				int color = col;
HXDLIN( 156)				if ((color == -1)) {
HXLINE( 156)					color = this1->currentColor;
            				}
HXDLIN( 156)				this1->colorType->__Field(HX_("colorTriangles",c8,da,ed,e6),::hx::paccDynamic)(color,len);
            			}
            		}
HXLINE( 157)		int end = ((start + len) - 1);
HXLINE( 158)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXLINE( 159)		return startEnd;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Regular_Impl__obj,polygon,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::polygonRadial( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs,int colorCentre,Float rx,Float ry,::hx::Null< int >  __o_sides){
            		int sides = __o_sides.Default(36);
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_162_polygonRadial)
HXLINE( 163)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXLINE( 164)		 ::Dynamic drawType = this1->drawType;
HXDLIN( 164)		Float x = rs->x;
HXDLIN( 164)		Float y = rs->y;
HXDLIN( 164)		Float radius = rs->radius;
HXDLIN( 164)		int len;
HXDLIN( 164)		if (((sides & 1) == 0)) {
HXLINE( 164)			::haxe::Log_obj::trace(HX_("even",1a,6f,1c,43),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),650,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 164)			Float rx1 = rx;
HXDLIN( 164)			Float ry1 = ry;
HXDLIN( 164)			 ::Dynamic sides1 = sides;
HXDLIN( 164)			 ::Dynamic omega = ((Float)0.);
HXDLIN( 164)			if (::hx::IsNull( omega )) {
HXLINE( 164)				omega = ((Float)0.);
            			}
HXDLIN( 164)			if (::hx::IsNull( sides1 )) {
HXLINE( 164)				sides1 = 36;
            			}
HXDLIN( 164)			Float pi = ::Math_obj::PI;
HXDLIN( 164)			Float theta = ((pi / ( (Float)(2) )) + omega);
HXDLIN( 164)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 164)			Float bx;
HXDLIN( 164)			Float by;
HXDLIN( 164)			Float cx;
HXDLIN( 164)			Float cy;
HXDLIN( 164)			if ((rx1 > ((Float)1.))) {
HXLINE( 164)				rx1 = ( (Float)(1) );
            			}
HXDLIN( 164)			if ((rx1 < ((Float)-1.))) {
HXLINE( 164)				rx1 = ( (Float)(-1) );
            			}
HXDLIN( 164)			if ((ry1 > ((Float)1.))) {
HXLINE( 164)				ry1 = ( (Float)(1) );
            			}
HXDLIN( 164)			if ((ry1 < ((Float)-1.))) {
HXLINE( 164)				ry1 = ( (Float)(-1) );
            			}
HXDLIN( 164)			Float mx = (x + (rx1 * radius));
HXDLIN( 164)			Float my = (y - (ry1 * radius));
HXDLIN( 164)			{
HXLINE( 164)				int _g = 0;
HXDLIN( 164)				 ::Dynamic _g1 = sides1;
HXDLIN( 164)				while(::hx::IsLess( _g,_g1 )){
HXLINE( 164)					_g = (_g + 1);
HXDLIN( 164)					int i = (_g - 1);
HXDLIN( 164)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 164)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 164)					theta = (theta + step);
HXDLIN( 164)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 164)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 164)					{
HXLINE( 164)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 164)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 164)						if (::hx::IsNotNull( m )) {
HXLINE( 164)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 164)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 164)			len = ( (int)(sides1) );
            		}
            		else {
HXLINE( 164)			::haxe::Log_obj::trace(HX_("odd",af,91,54,00),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),653,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 164)			::haxe::Log_obj::trace((sides & 1),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),654,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 164)			Float rx1 = rx;
HXDLIN( 164)			Float ry1 = ry;
HXDLIN( 164)			 ::Dynamic sides1 = sides;
HXDLIN( 164)			 ::Dynamic omega = ((Float)0.);
HXDLIN( 164)			if (::hx::IsNull( omega )) {
HXLINE( 164)				omega = ((Float)0.);
            			}
HXDLIN( 164)			if (::hx::IsNull( sides1 )) {
HXLINE( 164)				sides1 = 36;
            			}
HXDLIN( 164)			Float pi = ::Math_obj::PI;
HXDLIN( 164)			Float theta = (pi / ( (Float)(2) ));
HXDLIN( 164)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 164)			theta = (theta - ((step / ( (Float)(2) )) + omega));
HXDLIN( 164)			Float bx = ( (Float)(0) );
HXDLIN( 164)			Float by = ( (Float)(0) );
HXDLIN( 164)			Float cx = ( (Float)(0) );
HXDLIN( 164)			Float cy = ( (Float)(0) );
HXDLIN( 164)			if ((rx1 > ((Float)1.))) {
HXLINE( 164)				rx1 = ( (Float)(1) );
            			}
HXDLIN( 164)			if ((rx1 < ((Float)-1.))) {
HXLINE( 164)				rx1 = ( (Float)(-1) );
            			}
HXDLIN( 164)			if ((ry1 > ((Float)1.))) {
HXLINE( 164)				ry1 = ( (Float)(1) );
            			}
HXDLIN( 164)			if ((ry1 < ((Float)-1.))) {
HXLINE( 164)				ry1 = ( (Float)(-1) );
            			}
HXDLIN( 164)			Float mx = (x + (rx1 * radius));
HXDLIN( 164)			Float my = (y - (ry1 * radius));
HXDLIN( 164)			Float dx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 164)			Float dy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 164)			{
HXLINE( 164)				int _g = 0;
HXDLIN( 164)				int _g1 = (( (int)(sides1) ) - 1);
HXDLIN( 164)				while((_g < _g1)){
HXLINE( 164)					_g = (_g + 1);
HXDLIN( 164)					int i = (_g - 1);
HXDLIN( 164)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 164)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 164)					theta = (theta + step);
HXDLIN( 164)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 164)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 164)					{
HXLINE( 164)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 164)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 164)						if (::hx::IsNotNull( m )) {
HXLINE( 164)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 164)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 164)			{
HXLINE( 164)				drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,cx,cy,0,dx,dy,0);
HXDLIN( 164)				 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 164)				if (::hx::IsNotNull( m )) {
HXLINE( 164)					drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            				}
HXDLIN( 164)				drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 164)			len = ( (int)(sides1) );
            		}
HXLINE( 165)		{
HXLINE( 165)			int colorCentre1 = rs->color;
HXDLIN( 165)			{
HXLINE( 165)				int _g = 0;
HXDLIN( 165)				int _g1 = len;
HXDLIN( 165)				while((_g < _g1)){
HXLINE( 165)					_g = (_g + 1);
HXDLIN( 165)					int i = (_g - 1);
HXDLIN( 165)					this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(colorCentre1,colorCentre,colorCentre);
            				}
            			}
            		}
HXLINE( 166)		int end = ((start + len) - 1);
HXLINE( 167)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXLINE( 168)		return startEnd;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Regular_Impl__obj,polygonRadial,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::circleMultiCorners( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs,::Array< int > arr,::hx::Null< Float >  __o_rx,::hx::Null< Float >  __o_ry){
            		Float rx = __o_rx.Default(0);
            		Float ry = __o_ry.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_172_circleMultiCorners)
HXDLIN( 172)		int sides = 36;
HXDLIN( 172)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXDLIN( 172)		 ::Dynamic drawType = this1->drawType;
HXDLIN( 172)		Float x = rs->x;
HXDLIN( 172)		Float y = rs->y;
HXDLIN( 172)		Float radius = rs->radius;
HXDLIN( 172)		int len;
HXDLIN( 172)		if (((sides & 1) == 0)) {
HXDLIN( 172)			::haxe::Log_obj::trace(HX_("even",1a,6f,1c,43),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),650,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 172)			Float rx1 = rx;
HXDLIN( 172)			Float ry1 = ry;
HXDLIN( 172)			 ::Dynamic sides1 = sides;
HXDLIN( 172)			 ::Dynamic omega = ((Float)0.);
HXDLIN( 172)			if (::hx::IsNull( omega )) {
HXDLIN( 172)				omega = ((Float)0.);
            			}
HXDLIN( 172)			if (::hx::IsNull( sides1 )) {
HXDLIN( 172)				sides1 = 36;
            			}
HXDLIN( 172)			Float pi = ::Math_obj::PI;
HXDLIN( 172)			Float theta = ((pi / ( (Float)(2) )) + omega);
HXDLIN( 172)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 172)			Float bx;
HXDLIN( 172)			Float by;
HXDLIN( 172)			Float cx;
HXDLIN( 172)			Float cy;
HXDLIN( 172)			if ((rx1 > ((Float)1.))) {
HXDLIN( 172)				rx1 = ( (Float)(1) );
            			}
HXDLIN( 172)			if ((rx1 < ((Float)-1.))) {
HXDLIN( 172)				rx1 = ( (Float)(-1) );
            			}
HXDLIN( 172)			if ((ry1 > ((Float)1.))) {
HXDLIN( 172)				ry1 = ( (Float)(1) );
            			}
HXDLIN( 172)			if ((ry1 < ((Float)-1.))) {
HXDLIN( 172)				ry1 = ( (Float)(-1) );
            			}
HXDLIN( 172)			Float mx = (x + (rx1 * radius));
HXDLIN( 172)			Float my = (y - (ry1 * radius));
HXDLIN( 172)			{
HXDLIN( 172)				int _g = 0;
HXDLIN( 172)				 ::Dynamic _g1 = sides1;
HXDLIN( 172)				while(::hx::IsLess( _g,_g1 )){
HXDLIN( 172)					_g = (_g + 1);
HXDLIN( 172)					int i = (_g - 1);
HXDLIN( 172)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 172)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 172)					theta = (theta + step);
HXDLIN( 172)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 172)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 172)					{
HXDLIN( 172)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 172)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 172)						if (::hx::IsNotNull( m )) {
HXDLIN( 172)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 172)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 172)			len = ( (int)(sides1) );
            		}
            		else {
HXDLIN( 172)			::haxe::Log_obj::trace(HX_("odd",af,91,54,00),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),653,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 172)			::haxe::Log_obj::trace((sides & 1),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),654,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 172)			Float rx1 = rx;
HXDLIN( 172)			Float ry1 = ry;
HXDLIN( 172)			 ::Dynamic sides1 = sides;
HXDLIN( 172)			 ::Dynamic omega = ((Float)0.);
HXDLIN( 172)			if (::hx::IsNull( omega )) {
HXDLIN( 172)				omega = ((Float)0.);
            			}
HXDLIN( 172)			if (::hx::IsNull( sides1 )) {
HXDLIN( 172)				sides1 = 36;
            			}
HXDLIN( 172)			Float pi = ::Math_obj::PI;
HXDLIN( 172)			Float theta = (pi / ( (Float)(2) ));
HXDLIN( 172)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 172)			theta = (theta - ((step / ( (Float)(2) )) + omega));
HXDLIN( 172)			Float bx = ( (Float)(0) );
HXDLIN( 172)			Float by = ( (Float)(0) );
HXDLIN( 172)			Float cx = ( (Float)(0) );
HXDLIN( 172)			Float cy = ( (Float)(0) );
HXDLIN( 172)			if ((rx1 > ((Float)1.))) {
HXDLIN( 172)				rx1 = ( (Float)(1) );
            			}
HXDLIN( 172)			if ((rx1 < ((Float)-1.))) {
HXDLIN( 172)				rx1 = ( (Float)(-1) );
            			}
HXDLIN( 172)			if ((ry1 > ((Float)1.))) {
HXDLIN( 172)				ry1 = ( (Float)(1) );
            			}
HXDLIN( 172)			if ((ry1 < ((Float)-1.))) {
HXDLIN( 172)				ry1 = ( (Float)(-1) );
            			}
HXDLIN( 172)			Float mx = (x + (rx1 * radius));
HXDLIN( 172)			Float my = (y - (ry1 * radius));
HXDLIN( 172)			Float dx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 172)			Float dy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 172)			{
HXDLIN( 172)				int _g = 0;
HXDLIN( 172)				int _g1 = (( (int)(sides1) ) - 1);
HXDLIN( 172)				while((_g < _g1)){
HXDLIN( 172)					_g = (_g + 1);
HXDLIN( 172)					int i = (_g - 1);
HXDLIN( 172)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 172)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 172)					theta = (theta + step);
HXDLIN( 172)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 172)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 172)					{
HXDLIN( 172)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 172)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 172)						if (::hx::IsNotNull( m )) {
HXDLIN( 172)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 172)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 172)			{
HXDLIN( 172)				drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,cx,cy,0,dx,dy,0);
HXDLIN( 172)				 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 172)				if (::hx::IsNotNull( m )) {
HXDLIN( 172)					drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            				}
HXDLIN( 172)				drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 172)			len = ( (int)(sides1) );
            		}
HXDLIN( 172)		int k = 1;
HXDLIN( 172)		int arrEnd = (arr->length - 1);
HXDLIN( 172)		int end = ((start + len) - 1);
HXDLIN( 172)		::Array< int > arr_ = arr->copy();
HXDLIN( 172)		{
HXDLIN( 172)			int _g = 0;
HXDLIN( 172)			int _g1 = (len - 1);
HXDLIN( 172)			while((_g < _g1)){
HXDLIN( 172)				_g = (_g + 1);
HXDLIN( 172)				int j = (_g - 1);
HXDLIN( 172)				this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(rs->color,arr_->__get((k - 1)),arr_->__get(k));
HXDLIN( 172)				k = (k + 1);
HXDLIN( 172)				if ((k > arrEnd)) {
HXDLIN( 172)					k = 1;
HXDLIN( 172)					arr_->reverse();
            				}
            			}
            		}
HXDLIN( 172)		this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(rs->color,arr_->__get((k - 1)),arr->__get(0));
HXDLIN( 172)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXDLIN( 172)		return startEnd;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Regular_Impl__obj,circleMultiCorners,return )

 ::trilateral3::structure::StartEnd Regular_Impl__obj::polygonMultiCorners( ::trilateral3::drawing::Pen this1, ::trilateral3::structure::RegularShape rs,::Array< int > arr,::hx::Null< Float >  __o_rx,::hx::Null< Float >  __o_ry,::hx::Null< int >  __o_sides){
            		Float rx = __o_rx.Default(0);
            		Float ry = __o_ry.Default(0);
            		int sides = __o_sides.Default(36);
            	HX_GC_STACKFRAME(&_hx_pos_49840cc5972809fa_175_polygonMultiCorners)
HXLINE( 176)		int start = ( (int)(this1->drawType->__Field(HX_("get_size",4a,5c,0e,cc),::hx::paccDynamic)()) );
HXLINE( 177)		 ::Dynamic drawType = this1->drawType;
HXDLIN( 177)		Float x = rs->x;
HXDLIN( 177)		Float y = rs->y;
HXDLIN( 177)		Float radius = rs->radius;
HXDLIN( 177)		int len;
HXDLIN( 177)		if (((sides & 1) == 0)) {
HXLINE( 177)			::haxe::Log_obj::trace(HX_("even",1a,6f,1c,43),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),650,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 177)			Float rx1 = rx;
HXDLIN( 177)			Float ry1 = ry;
HXDLIN( 177)			 ::Dynamic sides1 = sides;
HXDLIN( 177)			 ::Dynamic omega = ((Float)0.);
HXDLIN( 177)			if (::hx::IsNull( omega )) {
HXLINE( 177)				omega = ((Float)0.);
            			}
HXDLIN( 177)			if (::hx::IsNull( sides1 )) {
HXLINE( 177)				sides1 = 36;
            			}
HXDLIN( 177)			Float pi = ::Math_obj::PI;
HXDLIN( 177)			Float theta = ((pi / ( (Float)(2) )) + omega);
HXDLIN( 177)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 177)			Float bx;
HXDLIN( 177)			Float by;
HXDLIN( 177)			Float cx;
HXDLIN( 177)			Float cy;
HXDLIN( 177)			if ((rx1 > ((Float)1.))) {
HXLINE( 177)				rx1 = ( (Float)(1) );
            			}
HXDLIN( 177)			if ((rx1 < ((Float)-1.))) {
HXLINE( 177)				rx1 = ( (Float)(-1) );
            			}
HXDLIN( 177)			if ((ry1 > ((Float)1.))) {
HXLINE( 177)				ry1 = ( (Float)(1) );
            			}
HXDLIN( 177)			if ((ry1 < ((Float)-1.))) {
HXLINE( 177)				ry1 = ( (Float)(-1) );
            			}
HXDLIN( 177)			Float mx = (x + (rx1 * radius));
HXDLIN( 177)			Float my = (y - (ry1 * radius));
HXDLIN( 177)			{
HXLINE( 177)				int _g = 0;
HXDLIN( 177)				 ::Dynamic _g1 = sides1;
HXDLIN( 177)				while(::hx::IsLess( _g,_g1 )){
HXLINE( 177)					_g = (_g + 1);
HXDLIN( 177)					int i = (_g - 1);
HXDLIN( 177)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 177)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 177)					theta = (theta + step);
HXDLIN( 177)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 177)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 177)					{
HXLINE( 177)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 177)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 177)						if (::hx::IsNotNull( m )) {
HXLINE( 177)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 177)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 177)			len = ( (int)(sides1) );
            		}
            		else {
HXLINE( 177)			::haxe::Log_obj::trace(HX_("odd",af,91,54,00),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),653,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 177)			::haxe::Log_obj::trace((sides & 1),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),654,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 177)			Float rx1 = rx;
HXDLIN( 177)			Float ry1 = ry;
HXDLIN( 177)			 ::Dynamic sides1 = sides;
HXDLIN( 177)			 ::Dynamic omega = ((Float)0.);
HXDLIN( 177)			if (::hx::IsNull( omega )) {
HXLINE( 177)				omega = ((Float)0.);
            			}
HXDLIN( 177)			if (::hx::IsNull( sides1 )) {
HXLINE( 177)				sides1 = 36;
            			}
HXDLIN( 177)			Float pi = ::Math_obj::PI;
HXDLIN( 177)			Float theta = (pi / ( (Float)(2) ));
HXDLIN( 177)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides1) ));
HXDLIN( 177)			theta = (theta - ((step / ( (Float)(2) )) + omega));
HXDLIN( 177)			Float bx = ( (Float)(0) );
HXDLIN( 177)			Float by = ( (Float)(0) );
HXDLIN( 177)			Float cx = ( (Float)(0) );
HXDLIN( 177)			Float cy = ( (Float)(0) );
HXDLIN( 177)			if ((rx1 > ((Float)1.))) {
HXLINE( 177)				rx1 = ( (Float)(1) );
            			}
HXDLIN( 177)			if ((rx1 < ((Float)-1.))) {
HXLINE( 177)				rx1 = ( (Float)(-1) );
            			}
HXDLIN( 177)			if ((ry1 > ((Float)1.))) {
HXLINE( 177)				ry1 = ( (Float)(1) );
            			}
HXDLIN( 177)			if ((ry1 < ((Float)-1.))) {
HXLINE( 177)				ry1 = ( (Float)(-1) );
            			}
HXDLIN( 177)			Float mx = (x + (rx1 * radius));
HXDLIN( 177)			Float my = (y - (ry1 * radius));
HXDLIN( 177)			Float dx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 177)			Float dy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 177)			{
HXLINE( 177)				int _g = 0;
HXDLIN( 177)				int _g1 = (( (int)(sides1) ) - 1);
HXDLIN( 177)				while((_g < _g1)){
HXLINE( 177)					_g = (_g + 1);
HXDLIN( 177)					int i = (_g - 1);
HXDLIN( 177)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 177)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 177)					theta = (theta + step);
HXDLIN( 177)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 177)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 177)					{
HXLINE( 177)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 177)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 177)						if (::hx::IsNotNull( m )) {
HXLINE( 177)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 177)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 177)			{
HXLINE( 177)				drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,cx,cy,0,dx,dy,0);
HXDLIN( 177)				 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 177)				if (::hx::IsNotNull( m )) {
HXLINE( 177)					drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            				}
HXDLIN( 177)				drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 177)			len = ( (int)(sides1) );
            		}
HXLINE( 179)		int k = 1;
HXLINE( 180)		int arrEnd = (arr->length - 1);
HXLINE( 181)		int end = ((start + len) - 1);
HXLINE( 182)		::Array< int > arr_ = arr->copy();
HXLINE( 183)		{
HXLINE( 183)			int _g = 0;
HXDLIN( 183)			int _g1 = (len - 1);
HXDLIN( 183)			while((_g < _g1)){
HXLINE( 183)				_g = (_g + 1);
HXDLIN( 183)				int j = (_g - 1);
HXLINE( 184)				this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(rs->color,arr_->__get((k - 1)),arr_->__get(k));
HXLINE( 185)				k = (k + 1);
HXLINE( 186)				if ((k > arrEnd)) {
HXLINE( 187)					k = 1;
HXLINE( 188)					arr_->reverse();
            				}
            			}
            		}
HXLINE( 191)		this1->colorType->__Field(HX_("cornerColors",65,87,ed,a2),::hx::paccDynamic)(rs->color,arr_->__get((k - 1)),arr->__get(0));
HXLINE( 192)		 ::trilateral3::structure::StartEnd startEnd =  ::trilateral3::structure::StartEnd_obj::__alloc( HX_CTX ,start,end);
HXLINE( 193)		return startEnd;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Regular_Impl__obj,polygonMultiCorners,return )


Regular_Impl__obj::Regular_Impl__obj()
{
}

bool Regular_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"bar") ) { outValue = bar_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"_new") ) { outValue = _new_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"bar2") ) { outValue = bar2_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"star") ) { outValue = star_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"star2") ) { outValue = star2_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"square") ) { outValue = square_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"circle") ) { outValue = circle_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"square2") ) { outValue = square2_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"hexagon") ) { outValue = hexagon_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"circle2") ) { outValue = circle2_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"polygon") ) { outValue = polygon_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"triangle") ) { outValue = triangle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"pentagon") ) { outValue = pentagon_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"hexagon2") ) { outValue = hexagon2_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"triangle2") ) { outValue = triangle2_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"pentagon2") ) { outValue = pentagon2_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"addRegular") ) { outValue = addRegular_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"circleRadial") ) { outValue = circleRadial_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"circleRadial2") ) { outValue = circleRadial2_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"roundedSquare") ) { outValue = roundedSquare_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"polygonRadial") ) { outValue = polygonRadial_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"roundedSquare2") ) { outValue = roundedSquare2_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"colorTrianglesPos") ) { outValue = colorTrianglesPos_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"circleMultiCorners") ) { outValue = circleMultiCorners_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"polygonMultiCorners") ) { outValue = polygonMultiCorners_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Regular_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Regular_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class Regular_Impl__obj::__mClass;

static ::String Regular_Impl__obj_sStaticFields[] = {
	HX_("_new",61,15,1f,3f),
	HX_("addRegular",3b,7e,12,ea),
	HX_("triangle",c8,be,c5,8d),
	HX_("triangle2",6a,30,41,7f),
	HX_("square",9d,00,f2,58),
	HX_("square2",f5,88,ce,7a),
	HX_("bar",d3,b1,4a,00),
	HX_("colorTrianglesPos",ac,27,26,08),
	HX_("bar2",ff,e6,10,41),
	HX_("pentagon",80,fe,32,74),
	HX_("pentagon2",b2,b1,6b,38),
	HX_("hexagon",e0,87,45,9f),
	HX_("hexagon2",52,5c,91,bd),
	HX_("circle",10,72,0d,56),
	HX_("circle2",22,5c,b6,f5),
	HX_("circleRadial",0f,91,91,eb),
	HX_("circleRadial2",43,5c,cd,33),
	HX_("roundedSquare",aa,d4,7b,da),
	HX_("roundedSquare2",48,40,de,51),
	HX_("star",d2,e3,5b,4c),
	HX_("star2",20,74,0b,84),
	HX_("polygon",7a,02,91,12),
	HX_("polygonRadial",f9,4c,04,b7),
	HX_("circleMultiCorners",b5,ff,9d,d0),
	HX_("polygonMultiCorners",1f,87,ed,ed),
	::String(null())
};

void Regular_Impl__obj::__register()
{
	Regular_Impl__obj _hx_dummy;
	Regular_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("trilateral3.shape._Regular.Regular_Impl_",df,e3,a9,6c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Regular_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Regular_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Regular_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Regular_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Regular_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace trilateral3
} // end namespace shape
} // end namespace _Regular
