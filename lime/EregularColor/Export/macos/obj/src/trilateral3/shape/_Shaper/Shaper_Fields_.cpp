// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_fracs_DifferencePreference
#include <fracs/DifferencePreference.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_trilateral3_Trilateral
#include <trilateral3/Trilateral.h>
#endif
#ifndef INCLUDED_trilateral3_matrix_MatrixDozen
#include <trilateral3/matrix/MatrixDozen.h>
#endif
#ifndef INCLUDED_trilateral3_shape__Shaper_Shaper_Fields_
#include <trilateral3/shape/_Shaper/Shaper_Fields_.h>
#endif
#ifndef INCLUDED_trilateral3_structure_Quad2D
#include <trilateral3/structure/Quad2D.h>
#endif
#ifndef INCLUDED_trilateral3_structure_XY
#include <trilateral3/structure/XY.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_19_add2DTriangle,"trilateral3.shape._Shaper.Shaper_Fields_","add2DTriangle",0x5f4a1e57,"trilateral3.shape._Shaper.Shaper_Fields_.add2DTriangle","trilateral3/shape/Shaper.hx",19,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_32_add2DQuad,"trilateral3.shape._Shaper.Shaper_Fields_","add2DQuad",0xd445e4d6,"trilateral3.shape._Shaper.Shaper_Fields_.add2DQuad","trilateral3/shape/Shaper.hx",32,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_39_quad,"trilateral3.shape._Shaper.Shaper_Fields_","quad",0x0b0e200b,"trilateral3.shape._Shaper.Shaper_Fields_.quad","trilateral3/shape/Shaper.hx",39,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_44_lineAB,"trilateral3.shape._Shaper.Shaper_Fields_","lineAB",0xa2df7619,"trilateral3.shape._Shaper.Shaper_Fields_.lineAB","trilateral3/shape/Shaper.hx",44,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_51_lineXY,"trilateral3.shape._Shaper.Shaper_Fields_","lineXY",0xa2df8a39,"trilateral3.shape._Shaper.Shaper_Fields_.lineXY","trilateral3/shape/Shaper.hx",51,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_57_rectangle,"trilateral3.shape._Shaper.Shaper_Fields_","rectangle",0x0f38166b,"trilateral3.shape._Shaper.Shaper_Fields_.rectangle","trilateral3/shape/Shaper.hx",57,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_73_squareOutline,"trilateral3.shape._Shaper.Shaper_Fields_","squareOutline",0x39dc4ca1,"trilateral3.shape._Shaper.Shaper_Fields_.squareOutline","trilateral3/shape/Shaper.hx",73,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_173_square,"trilateral3.shape._Shaper.Shaper_Fields_","square",0x0f3140e1,"trilateral3.shape._Shaper.Shaper_Fields_.square","trilateral3/shape/Shaper.hx",173,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_221_diamond,"trilateral3.shape._Shaper.Shaper_Fields_","diamond",0x1d336290,"trilateral3.shape._Shaper.Shaper_Fields_.diamond","trilateral3/shape/Shaper.hx",221,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_228_diamondOutline,"trilateral3.shape._Shaper.Shaper_Fields_","diamondOutline",0x6a4c4ed2,"trilateral3.shape._Shaper.Shaper_Fields_.diamondOutline","trilateral3/shape/Shaper.hx",228,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_234_overlapStar,"trilateral3.shape._Shaper.Shaper_Fields_","overlapStar",0x88f86c35,"trilateral3.shape._Shaper.Shaper_Fields_.overlapStar","trilateral3/shape/Shaper.hx",234,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_265_circle,"trilateral3.shape._Shaper.Shaper_Fields_","circle",0x0c4cb254,"trilateral3.shape._Shaper.Shaper_Fields_.circle","trilateral3/shape/Shaper.hx",265,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_288_circleRadial,"trilateral3.shape._Shaper.Shaper_Fields_","circleRadial",0xc4745c53,"trilateral3.shape._Shaper.Shaper_Fields_.circleRadial","trilateral3/shape/Shaper.hx",288,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_317_circleRadialOnSide,"trilateral3.shape._Shaper.Shaper_Fields_","circleRadialOnSide",0xe908e709,"trilateral3.shape._Shaper.Shaper_Fields_.circleRadialOnSide","trilateral3/shape/Shaper.hx",317,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_350_ellipse,"trilateral3.shape._Shaper.Shaper_Fields_","ellipse",0xcc9f3c1a,"trilateral3.shape._Shaper.Shaper_Fields_.ellipse","trilateral3/shape/Shaper.hx",350,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_377_pie,"trilateral3.shape._Shaper.Shaper_Fields_","pie",0xcd890588,"trilateral3.shape._Shaper.Shaper_Fields_.pie","trilateral3/shape/Shaper.hx",377,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_414_pieX,"trilateral3.shape._Shaper.Shaper_Fields_","pieX",0x0a5bd1d0,"trilateral3.shape._Shaper.Shaper_Fields_.pieX","trilateral3/shape/Shaper.hx",414,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_453_pieDifX,"trilateral3.shape._Shaper.Shaper_Fields_","pieDifX",0x42b0f19f,"trilateral3.shape._Shaper.Shaper_Fields_.pieDifX","trilateral3/shape/Shaper.hx",453,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_489_ellipsePie,"trilateral3.shape._Shaper.Shaper_Fields_","ellipsePie",0x5afae052,"trilateral3.shape._Shaper.Shaper_Fields_.ellipsePie","trilateral3/shape/Shaper.hx",489,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_523_pieDif,"trilateral3.shape._Shaper.Shaper_Fields_","pieDif",0x36411499,"trilateral3.shape._Shaper.Shaper_Fields_.pieDif","trilateral3/shape/Shaper.hx",523,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_552_arc,"trilateral3.shape._Shaper.Shaper_Fields_","arc",0xcd7dab8e,"trilateral3.shape._Shaper.Shaper_Fields_.arc","trilateral3/shape/Shaper.hx",552,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_592_circleOnSide,"trilateral3.shape._Shaper.Shaper_Fields_","circleOnSide",0x025b33ca,"trilateral3.shape._Shaper.Shaper_Fields_.circleOnSide","trilateral3/shape/Shaper.hx",592,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_615_ellipseOnSide,"trilateral3.shape._Shaper.Shaper_Fields_","ellipseOnSide",0xf2545610,"trilateral3.shape._Shaper.Shaper_Fields_.ellipseOnSide","trilateral3/shape/Shaper.hx",615,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_638_shape,"trilateral3.shape._Shaper.Shaper_Fields_","shape",0xbf83575d,"trilateral3.shape._Shaper.Shaper_Fields_.shape","trilateral3/shape/Shaper.hx",638,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_649_shapeRadial,"trilateral3.shape._Shaper.Shaper_Fields_","shapeRadial",0x8ff5ee1c,"trilateral3.shape._Shaper.Shaper_Fields_.shapeRadial","trilateral3/shape/Shaper.hx",649,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_662_roundedRectangle,"trilateral3.shape._Shaper.Shaper_Fields_","roundedRectangle",0x0e4b0386,"trilateral3.shape._Shaper.Shaper_Fields_.roundedRectangle","trilateral3/shape/Shaper.hx",662,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_692_roundedRectangleOutline,"trilateral3.shape._Shaper.Shaper_Fields_","roundedRectangleOutline",0x57e2589c,"trilateral3.shape._Shaper.Shaper_Fields_.roundedRectangleOutline","trilateral3/shape/Shaper.hx",692,0x7203ae17)
HX_LOCAL_STACK_FRAME(_hx_pos_4887c4b26886bcef_723_spiralLines,"trilateral3.shape._Shaper.Shaper_Fields_","spiralLines",0x4713114a,"trilateral3.shape._Shaper.Shaper_Fields_.spiralLines","trilateral3/shape/Shaper.hx",723,0x7203ae17)
namespace trilateral3{
namespace shape{
namespace _Shaper{

void Shaper_Fields__obj::__construct() { }

Dynamic Shaper_Fields__obj::__CreateEmpty() { return new Shaper_Fields__obj; }

void *Shaper_Fields__obj::_hx_vtable = 0;

Dynamic Shaper_Fields__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Shaper_Fields__obj > _hx_result = new Shaper_Fields__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Shaper_Fields__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x168b9d2e;
}

int Shaper_Fields__obj::add2DTriangle( ::Dynamic drawType,Float ax,Float ay,Float bx,Float by,Float cx,Float cy){
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_19_add2DTriangle)
HXLINE(  21)		drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXLINE(  22)		 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXLINE(  23)		if (::hx::IsNotNull( m )) {
HXLINE(  23)			drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            		}
HXLINE(  24)		drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
HXLINE(  25)		return 1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(Shaper_Fields__obj,add2DTriangle,return )

int Shaper_Fields__obj::add2DQuad( ::Dynamic drawType,Float ax,Float ay,Float bx,Float by,Float cx,Float cy,Float dx,Float dy){
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_32_add2DQuad)
HXLINE(  33)		{
HXLINE(  33)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,dx,dy,0);
HXDLIN(  33)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  33)			if (::hx::IsNotNull( m )) {
HXLINE(  33)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN(  33)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXLINE(  34)		{
HXLINE(  34)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,cx,cy,0,dx,dy,0);
HXDLIN(  34)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  34)			if (::hx::IsNotNull( m1 )) {
HXLINE(  34)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN(  34)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXLINE(  35)		return 2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(Shaper_Fields__obj,add2DQuad,return )

int Shaper_Fields__obj::quad( ::Dynamic drawType, ::trilateral3::structure::Quad2D q){
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_39_quad)
HXDLIN(  39)		Float bx = q->b->x;
HXDLIN(  39)		Float by = q->b->y;
HXDLIN(  39)		Float cx = q->c->x;
HXDLIN(  39)		Float cy = q->c->y;
HXDLIN(  39)		Float dx = q->d->x;
HXDLIN(  39)		Float dy = q->d->y;
HXDLIN(  39)		{
HXDLIN(  39)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(q->a->x,q->a->y,0,bx,by,0,dx,dy,0);
HXDLIN(  39)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  39)			if (::hx::IsNotNull( m )) {
HXDLIN(  39)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN(  39)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  39)		{
HXDLIN(  39)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,cx,cy,0,dx,dy,0);
HXDLIN(  39)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  39)			if (::hx::IsNotNull( m1 )) {
HXDLIN(  39)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN(  39)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  39)		return 2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Shaper_Fields__obj,quad,return )

int Shaper_Fields__obj::lineAB( ::Dynamic drawType, ::trilateral3::structure::XY A, ::trilateral3::structure::XY B,Float width){
            	HX_GC_STACKFRAME(&_hx_pos_4887c4b26886bcef_44_lineAB)
HXLINE(  45)		Float dx = (A->x - B->x);
HXDLIN(  45)		Float dy = (A->y - B->y);
HXDLIN(  45)		 ::trilateral3::structure::XY P =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(A->x - (width / ( (Float)(2) ))),A->y);
HXDLIN(  45)		Float omega = ::Math_obj::atan2(dy,dx);
HXDLIN(  45)		 ::trilateral3::structure::XY dim =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,width,((dx * dx) + (dy * dy)));
HXDLIN(  45)		Float pivotX = (A->x + (width / ( (Float)(2) )));
HXDLIN(  45)		Float pivotY = A->y;
HXDLIN(  45)		Float px = P->x;
HXDLIN(  45)		Float py = P->y;
HXDLIN(  45)		Float dx1 = dim->x;
HXDLIN(  45)		Float dy1 = dim->y;
HXDLIN(  45)		 ::trilateral3::structure::XY A_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,px,py);
HXDLIN(  45)		 ::trilateral3::structure::XY B_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px + dx1),py);
HXDLIN(  45)		 ::trilateral3::structure::XY C_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px + dx1),(py + dy1));
HXDLIN(  45)		 ::trilateral3::structure::XY D_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,px,(py + dy1));
HXDLIN(  45)		if ((omega != ((Float)0.))) {
HXLINE(  45)			Float sin = ::Math_obj::sin(omega);
HXDLIN(  45)			Float cos = ::Math_obj::cos(omega);
HXDLIN(  45)			Float px = (A_->x - pivotX);
HXDLIN(  45)			Float py = (A_->y - pivotY);
HXDLIN(  45)			Float px2 = ((px * cos) - (py * sin));
HXDLIN(  45)			py = ((py * cos) + (px * sin));
HXDLIN(  45)			A_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px2 + pivotX),(py + pivotY));
HXDLIN(  45)			Float px1 = (B_->x - pivotX);
HXDLIN(  45)			Float py1 = (B_->y - pivotY);
HXDLIN(  45)			Float px21 = ((px1 * cos) - (py1 * sin));
HXDLIN(  45)			py1 = ((py1 * cos) + (px1 * sin));
HXDLIN(  45)			B_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px21 + pivotX),(py1 + pivotY));
HXDLIN(  45)			Float px3 = (C_->x - pivotX);
HXDLIN(  45)			Float py2 = (C_->y - pivotY);
HXDLIN(  45)			Float px22 = ((px3 * cos) - (py2 * sin));
HXDLIN(  45)			py2 = ((py2 * cos) + (px3 * sin));
HXDLIN(  45)			C_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px22 + pivotX),(py2 + pivotY));
HXDLIN(  45)			Float px4 = (D_->x - pivotX);
HXDLIN(  45)			Float py3 = (D_->y - pivotY);
HXDLIN(  45)			Float px23 = ((px4 * cos) - (py3 * sin));
HXDLIN(  45)			py3 = ((py3 * cos) + (px4 * sin));
HXDLIN(  45)			D_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px23 + pivotX),(py3 + pivotY));
            		}
HXDLIN(  45)		 ::trilateral3::structure::Quad2D q =  ::trilateral3::structure::Quad2D_obj::__alloc( HX_CTX ,A_,B_,C_,D_);
HXLINE(  46)		Float bx = q->b->x;
HXDLIN(  46)		Float by = q->b->y;
HXDLIN(  46)		Float cx = q->c->x;
HXDLIN(  46)		Float cy = q->c->y;
HXDLIN(  46)		Float dx2 = q->d->x;
HXDLIN(  46)		Float dy2 = q->d->y;
HXDLIN(  46)		{
HXLINE(  46)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(q->a->x,q->a->y,0,bx,by,0,dx2,dy2,0);
HXDLIN(  46)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  46)			if (::hx::IsNotNull( m )) {
HXLINE(  46)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN(  46)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  46)		{
HXLINE(  46)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,cx,cy,0,dx2,dy2,0);
HXDLIN(  46)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  46)			if (::hx::IsNotNull( m1 )) {
HXLINE(  46)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN(  46)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  46)		return 2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Shaper_Fields__obj,lineAB,return )

int Shaper_Fields__obj::lineXY( ::Dynamic drawType,Float ax,Float ay,Float bx,Float by,Float width){
            	HX_GC_STACKFRAME(&_hx_pos_4887c4b26886bcef_51_lineXY)
HXLINE(  52)		Float dx = (ax - bx);
HXDLIN(  52)		Float dy = (ay - by);
HXDLIN(  52)		 ::trilateral3::structure::XY P =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(ax - (width / ( (Float)(2) ))),ay);
HXDLIN(  52)		Float omega = ::Math_obj::atan2(dy,dx);
HXDLIN(  52)		 ::trilateral3::structure::XY dim =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,width,((dx * dx) + (dy * dy)));
HXDLIN(  52)		Float pivotX = (ax + (width / ( (Float)(2) )));
HXDLIN(  52)		Float px = P->x;
HXDLIN(  52)		Float py = P->y;
HXDLIN(  52)		Float dx1 = dim->x;
HXDLIN(  52)		Float dy1 = dim->y;
HXDLIN(  52)		 ::trilateral3::structure::XY A_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,px,py);
HXDLIN(  52)		 ::trilateral3::structure::XY B_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px + dx1),py);
HXDLIN(  52)		 ::trilateral3::structure::XY C_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px + dx1),(py + dy1));
HXDLIN(  52)		 ::trilateral3::structure::XY D_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,px,(py + dy1));
HXDLIN(  52)		if ((omega != ((Float)0.))) {
HXLINE(  52)			Float sin = ::Math_obj::sin(omega);
HXDLIN(  52)			Float cos = ::Math_obj::cos(omega);
HXDLIN(  52)			Float px = (A_->x - pivotX);
HXDLIN(  52)			Float py = (A_->y - ay);
HXDLIN(  52)			Float px2 = ((px * cos) - (py * sin));
HXDLIN(  52)			py = ((py * cos) + (px * sin));
HXDLIN(  52)			A_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px2 + pivotX),(py + ay));
HXDLIN(  52)			Float px1 = (B_->x - pivotX);
HXDLIN(  52)			Float py1 = (B_->y - ay);
HXDLIN(  52)			Float px21 = ((px1 * cos) - (py1 * sin));
HXDLIN(  52)			py1 = ((py1 * cos) + (px1 * sin));
HXDLIN(  52)			B_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px21 + pivotX),(py1 + ay));
HXDLIN(  52)			Float px3 = (C_->x - pivotX);
HXDLIN(  52)			Float py2 = (C_->y - ay);
HXDLIN(  52)			Float px22 = ((px3 * cos) - (py2 * sin));
HXDLIN(  52)			py2 = ((py2 * cos) + (px3 * sin));
HXDLIN(  52)			C_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px22 + pivotX),(py2 + ay));
HXDLIN(  52)			Float px4 = (D_->x - pivotX);
HXDLIN(  52)			Float py3 = (D_->y - ay);
HXDLIN(  52)			Float px23 = ((px4 * cos) - (py3 * sin));
HXDLIN(  52)			py3 = ((py3 * cos) + (px4 * sin));
HXDLIN(  52)			D_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px23 + pivotX),(py3 + ay));
            		}
HXDLIN(  52)		 ::trilateral3::structure::Quad2D q =  ::trilateral3::structure::Quad2D_obj::__alloc( HX_CTX ,A_,B_,C_,D_);
HXLINE(  53)		Float bx1 = q->b->x;
HXDLIN(  53)		Float by1 = q->b->y;
HXDLIN(  53)		Float cx = q->c->x;
HXDLIN(  53)		Float cy = q->c->y;
HXDLIN(  53)		Float dx2 = q->d->x;
HXDLIN(  53)		Float dy2 = q->d->y;
HXDLIN(  53)		{
HXLINE(  53)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(q->a->x,q->a->y,0,bx1,by1,0,dx2,dy2,0);
HXDLIN(  53)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  53)			if (::hx::IsNotNull( m )) {
HXLINE(  53)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN(  53)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  53)		{
HXLINE(  53)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx1,by1,0,cx,cy,0,dx2,dy2,0);
HXDLIN(  53)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  53)			if (::hx::IsNotNull( m1 )) {
HXLINE(  53)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN(  53)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  53)		return 2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Shaper_Fields__obj,lineXY,return )

int Shaper_Fields__obj::rectangle( ::Dynamic drawType,Float x,Float y,Float w,Float h){
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_57_rectangle)
HXLINE(  58)		Float ax = x;
HXLINE(  59)		Float ay = y;
HXLINE(  60)		Float bx = (x + w);
HXLINE(  61)		Float by = ay;
HXLINE(  62)		Float cx = bx;
HXLINE(  63)		Float cy = (ay + h);
HXLINE(  64)		Float dx = x;
HXLINE(  65)		Float dy = cy;
HXLINE(  66)		{
HXLINE(  66)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,dx,dy,0);
HXDLIN(  66)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  66)			if (::hx::IsNotNull( m )) {
HXLINE(  66)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN(  66)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  66)		{
HXLINE(  66)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,cx,cy,0,dx,dy,0);
HXDLIN(  66)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN(  66)			if (::hx::IsNotNull( m1 )) {
HXLINE(  66)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN(  66)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN(  66)		return 2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Shaper_Fields__obj,rectangle,return )

int Shaper_Fields__obj::squareOutline( ::Dynamic drawType,Float px,Float py,Float radius,Float thick, ::Dynamic __o_theta){
            		 ::Dynamic theta = __o_theta;
            		if (::hx::IsNull(__o_theta)) theta = 0;
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_73_squareOutline)
HXLINE(  74)		Float ax = ((Float)0.);
HXLINE(  75)		Float ay = ((Float)0.);
HXLINE(  76)		Float bx = ((Float)0.);
HXLINE(  77)		Float by = ((Float)0.);
HXLINE(  78)		Float cx = ((Float)0.);
HXLINE(  79)		Float cy = ((Float)0.);
HXLINE(  80)		Float dx = ((Float)0.);
HXLINE(  81)		Float dy = ((Float)0.);
HXLINE(  82)		Float a0x = ((Float)0.);
HXLINE(  83)		Float a0y = ((Float)0.);
HXLINE(  84)		Float b0x = ((Float)0.);
HXLINE(  85)		Float b0y = ((Float)0.);
HXLINE(  86)		Float c0x = ((Float)0.);
HXLINE(  87)		Float c0y = ((Float)0.);
HXLINE(  88)		Float d0x = ((Float)0.);
HXLINE(  89)		Float d0y = ((Float)0.);
HXLINE(  90)		if (::hx::IsNotEq( theta,0 )) {
HXLINE(  91)			Float pi = ::Math_obj::PI;
HXLINE(  92)			Float pi4 = (pi / ( (Float)(4) ));
HXLINE(  93)			Float pi2 = (pi / ( (Float)(2) ));
HXLINE(  94)			Float sqrt2 = ::Math_obj::sqrt(( (Float)(2) ));
HXLINE(  95)			Float r = (radius * sqrt2);
HXLINE(  99)			Float aTheta = ((-(pi) + theta) - pi4);
HXLINE( 100)			Float dTheta = (((-(pi) + theta) + (pi / ( (Float)(2) ))) - (pi / ( (Float)(4) )));
HXLINE( 101)			Float cTheta = (( (Float)(theta) ) - pi4);
HXLINE( 102)			Float bTheta = (((-(pi) + theta) - pi2) - pi4);
HXLINE( 103)			Float as = ::Math_obj::sin(aTheta);
HXLINE( 104)			Float ac = ::Math_obj::cos(aTheta);
HXLINE( 105)			Float bs = ::Math_obj::sin(bTheta);
HXLINE( 106)			Float bc = ::Math_obj::cos(bTheta);
HXLINE( 107)			Float cs = ::Math_obj::sin(cTheta);
HXLINE( 108)			Float cc = ::Math_obj::cos(cTheta);
HXLINE( 109)			Float ds = ::Math_obj::sin(dTheta);
HXLINE( 110)			Float dc = ::Math_obj::cos(dTheta);
HXLINE( 111)			Float r0 = (r - thick);
HXLINE( 112)			ax = (px + (r * as));
HXLINE( 113)			ay = (py + (r * ac));
HXLINE( 114)			bx = (px + (r * bs));
HXLINE( 115)			by = (py + (r * bc));
HXLINE( 116)			cx = (px + (r * cs));
HXLINE( 117)			cy = (py + (r * cc));
HXLINE( 118)			dx = (px + (r * ds));
HXLINE( 119)			dy = (py + (r * dc));
HXLINE( 120)			a0x = (px + (r0 * as));
HXLINE( 121)			a0y = (py + (r0 * ac));
HXLINE( 122)			b0x = (px + (r0 * bs));
HXLINE( 123)			b0y = (py + (r0 * bc));
HXLINE( 124)			c0x = (px + (r0 * cs));
HXLINE( 125)			c0y = (py + (r0 * cc));
HXLINE( 126)			d0x = (px + (r0 * ds));
HXLINE( 127)			d0y = (py + (r0 * dc));
            		}
            		else {
HXLINE( 129)			ax = (px - radius);
HXLINE( 130)			ay = (py - radius);
HXLINE( 131)			Float lx = (radius * ( (Float)(2) ));
HXLINE( 132)			Float ly = lx;
HXLINE( 133)			bx = (ax + lx);
HXLINE( 134)			by = ay;
HXLINE( 135)			cx = bx;
HXLINE( 136)			cy = (ay + ly);
HXLINE( 137)			dx = ax;
HXLINE( 138)			dy = cy;
HXLINE( 139)			Float radius0 = (radius - thick);
HXLINE( 140)			a0x = (px - radius0);
HXLINE( 141)			a0y = (py - radius0);
HXLINE( 142)			Float l0x = (radius0 * ( (Float)(2) ));
HXLINE( 143)			Float l0y = l0x;
HXLINE( 144)			b0x = (a0x + l0x);
HXLINE( 145)			b0y = a0y;
HXLINE( 146)			c0x = b0x;
HXLINE( 147)			c0y = (a0y + l0y);
HXLINE( 148)			d0x = a0x;
HXLINE( 149)			d0y = c0y;
            		}
HXLINE( 153)		{
HXLINE( 153)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,a0x,a0y,0);
HXDLIN( 153)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 153)			if (::hx::IsNotNull( m )) {
HXLINE( 153)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN( 153)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXLINE( 154)		{
HXLINE( 154)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,b0x,b0y,0,a0x,a0y,0);
HXDLIN( 154)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 154)			if (::hx::IsNotNull( m1 )) {
HXLINE( 154)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN( 154)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXLINE( 158)		{
HXLINE( 158)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(d0x,d0y,0,c0x,c0y,0,dx,dy,0);
HXDLIN( 158)			 ::trilateral3::matrix::MatrixDozen m2 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 158)			if (::hx::IsNotNull( m2 )) {
HXLINE( 158)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m2);
            			}
HXDLIN( 158)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXLINE( 159)		{
HXLINE( 159)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(c0x,c0y,0,cx,cy,0,dx,dy,0);
HXDLIN( 159)			 ::trilateral3::matrix::MatrixDozen m3 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 159)			if (::hx::IsNotNull( m3 )) {
HXLINE( 159)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m3);
            			}
HXDLIN( 159)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXLINE( 161)		{
HXLINE( 161)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,a0x,a0y,0,d0x,d0y,0);
HXDLIN( 161)			 ::trilateral3::matrix::MatrixDozen m4 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 161)			if (::hx::IsNotNull( m4 )) {
HXLINE( 161)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m4);
            			}
HXDLIN( 161)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXLINE( 162)		{
HXLINE( 162)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,d0x,d0y,0,dx,dy,0);
HXDLIN( 162)			 ::trilateral3::matrix::MatrixDozen m5 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 162)			if (::hx::IsNotNull( m5 )) {
HXLINE( 162)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m5);
            			}
HXDLIN( 162)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXLINE( 164)		{
HXLINE( 164)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(b0x,b0y,0,bx,by,0,c0x,c0y,0);
HXDLIN( 164)			 ::trilateral3::matrix::MatrixDozen m6 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 164)			if (::hx::IsNotNull( m6 )) {
HXLINE( 164)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m6);
            			}
HXDLIN( 164)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXLINE( 165)		{
HXLINE( 165)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,cx,cy,0,c0x,c0y,0);
HXDLIN( 165)			 ::trilateral3::matrix::MatrixDozen m7 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 165)			if (::hx::IsNotNull( m7 )) {
HXLINE( 165)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m7);
            			}
HXDLIN( 165)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXLINE( 166)		return 8;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Shaper_Fields__obj,squareOutline,return )

int Shaper_Fields__obj::square( ::Dynamic drawType,Float px,Float py,Float radius, ::Dynamic __o_theta){
            		 ::Dynamic theta = __o_theta;
            		if (::hx::IsNull(__o_theta)) theta = 0;
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_173_square)
HXLINE( 174)		Float ax = ((Float)0.);
HXLINE( 175)		Float ay = ((Float)0.);
HXLINE( 176)		Float bx = ((Float)0.);
HXLINE( 177)		Float by = ((Float)0.);
HXLINE( 178)		Float cx = ((Float)0.);
HXLINE( 179)		Float cy = ((Float)0.);
HXLINE( 180)		Float dx = ((Float)0.);
HXLINE( 181)		Float dy = ((Float)0.);
HXLINE( 182)		if (::hx::IsNotEq( theta,0 )) {
HXLINE( 183)			Float pi = ::Math_obj::PI;
HXLINE( 184)			Float pi4 = (pi / ( (Float)(4) ));
HXLINE( 185)			Float pi2 = (pi / ( (Float)(2) ));
HXLINE( 186)			Float sqrt2 = ::Math_obj::sqrt(( (Float)(2) ));
HXLINE( 187)			Float r = (radius * sqrt2);
HXLINE( 191)			Float aTheta = ((-(pi) + theta) - pi4);
HXLINE( 192)			Float dTheta = (((-(pi) + theta) + (pi / ( (Float)(2) ))) - (pi / ( (Float)(4) )));
HXLINE( 193)			Float cTheta = (( (Float)(theta) ) - pi4);
HXLINE( 194)			Float bTheta = (((-(pi) + theta) - pi2) - pi4);
HXLINE( 195)			ax = (px + (r * ::Math_obj::sin(aTheta)));
HXLINE( 196)			ay = (py + (r * ::Math_obj::cos(aTheta)));
HXLINE( 197)			bx = (px + (r * ::Math_obj::sin(bTheta)));
HXLINE( 198)			by = (py + (r * ::Math_obj::cos(bTheta)));
HXLINE( 199)			cx = (px + (r * ::Math_obj::sin(cTheta)));
HXLINE( 200)			cy = (py + (r * ::Math_obj::cos(cTheta)));
HXLINE( 201)			dx = (px + (r * ::Math_obj::sin(dTheta)));
HXLINE( 202)			dy = (py + (r * ::Math_obj::cos(dTheta)));
            		}
            		else {
HXLINE( 204)			ax = (px - radius);
HXLINE( 205)			ay = (py - radius);
HXLINE( 206)			Float lx = (radius * ( (Float)(2) ));
HXLINE( 207)			Float ly = lx;
HXLINE( 208)			bx = (ax + lx);
HXLINE( 209)			by = ay;
HXLINE( 210)			cx = bx;
HXLINE( 211)			cy = (ay + ly);
HXLINE( 212)			dx = ax;
HXLINE( 213)			dy = cy;
            		}
HXLINE( 215)		{
HXLINE( 215)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,dx,dy,0);
HXDLIN( 215)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 215)			if (::hx::IsNotNull( m )) {
HXLINE( 215)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN( 215)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 215)		{
HXLINE( 215)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,cx,cy,0,dx,dy,0);
HXDLIN( 215)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 215)			if (::hx::IsNotNull( m1 )) {
HXLINE( 215)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN( 215)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 215)		return 2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Shaper_Fields__obj,square,return )

int Shaper_Fields__obj::diamond( ::Dynamic drawType,Float x,Float y,Float radius, ::Dynamic __o_theta){
            		 ::Dynamic theta = __o_theta;
            		if (::hx::IsNull(__o_theta)) theta = ((Float)0.);
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_221_diamond)
HXDLIN( 221)		 ::Dynamic theta1 = ((::Math_obj::PI / ( (Float)(4) )) + theta);
HXDLIN( 221)		if (::hx::IsNull( theta1 )) {
HXDLIN( 221)			theta1 = 0;
            		}
HXDLIN( 221)		Float ax = ((Float)0.);
HXDLIN( 221)		Float ay = ((Float)0.);
HXDLIN( 221)		Float bx = ((Float)0.);
HXDLIN( 221)		Float by = ((Float)0.);
HXDLIN( 221)		Float cx = ((Float)0.);
HXDLIN( 221)		Float cy = ((Float)0.);
HXDLIN( 221)		Float dx = ((Float)0.);
HXDLIN( 221)		Float dy = ((Float)0.);
HXDLIN( 221)		if (::hx::IsNotEq( theta1,0 )) {
HXDLIN( 221)			Float pi = ::Math_obj::PI;
HXDLIN( 221)			Float pi4 = (pi / ( (Float)(4) ));
HXDLIN( 221)			Float pi2 = (pi / ( (Float)(2) ));
HXDLIN( 221)			Float sqrt2 = ::Math_obj::sqrt(( (Float)(2) ));
HXDLIN( 221)			Float r = (radius * sqrt2);
HXDLIN( 221)			Float aTheta = ((-(pi) + theta1) - pi4);
HXDLIN( 221)			Float dTheta = (((-(pi) + theta1) + (pi / ( (Float)(2) ))) - (pi / ( (Float)(4) )));
HXDLIN( 221)			Float cTheta = (( (Float)(theta1) ) - pi4);
HXDLIN( 221)			Float bTheta = (((-(pi) + theta1) - pi2) - pi4);
HXDLIN( 221)			ax = (x + (r * ::Math_obj::sin(aTheta)));
HXDLIN( 221)			ay = (y + (r * ::Math_obj::cos(aTheta)));
HXDLIN( 221)			bx = (x + (r * ::Math_obj::sin(bTheta)));
HXDLIN( 221)			by = (y + (r * ::Math_obj::cos(bTheta)));
HXDLIN( 221)			cx = (x + (r * ::Math_obj::sin(cTheta)));
HXDLIN( 221)			cy = (y + (r * ::Math_obj::cos(cTheta)));
HXDLIN( 221)			dx = (x + (r * ::Math_obj::sin(dTheta)));
HXDLIN( 221)			dy = (y + (r * ::Math_obj::cos(dTheta)));
            		}
            		else {
HXDLIN( 221)			ax = (x - radius);
HXDLIN( 221)			ay = (y - radius);
HXDLIN( 221)			Float lx = (radius * ( (Float)(2) ));
HXDLIN( 221)			Float ly = lx;
HXDLIN( 221)			bx = (ax + lx);
HXDLIN( 221)			by = ay;
HXDLIN( 221)			cx = bx;
HXDLIN( 221)			cy = (ay + ly);
HXDLIN( 221)			dx = ax;
HXDLIN( 221)			dy = cy;
            		}
HXDLIN( 221)		{
HXDLIN( 221)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,dx,dy,0);
HXDLIN( 221)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 221)			if (::hx::IsNotNull( m )) {
HXDLIN( 221)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN( 221)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 221)		{
HXDLIN( 221)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,cx,cy,0,dx,dy,0);
HXDLIN( 221)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 221)			if (::hx::IsNotNull( m1 )) {
HXDLIN( 221)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN( 221)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 221)		return 2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Shaper_Fields__obj,diamond,return )

int Shaper_Fields__obj::diamondOutline( ::Dynamic drawType,Float x,Float y,Float thick,Float radius, ::Dynamic __o_theta){
            		 ::Dynamic theta = __o_theta;
            		if (::hx::IsNull(__o_theta)) theta = ((Float)0.);
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_228_diamondOutline)
HXDLIN( 228)		 ::Dynamic theta1 = ((::Math_obj::PI / ( (Float)(4) )) + theta);
HXDLIN( 228)		if (::hx::IsNull( theta1 )) {
HXDLIN( 228)			theta1 = 0;
            		}
HXDLIN( 228)		Float ax = ((Float)0.);
HXDLIN( 228)		Float ay = ((Float)0.);
HXDLIN( 228)		Float bx = ((Float)0.);
HXDLIN( 228)		Float by = ((Float)0.);
HXDLIN( 228)		Float cx = ((Float)0.);
HXDLIN( 228)		Float cy = ((Float)0.);
HXDLIN( 228)		Float dx = ((Float)0.);
HXDLIN( 228)		Float dy = ((Float)0.);
HXDLIN( 228)		Float a0x = ((Float)0.);
HXDLIN( 228)		Float a0y = ((Float)0.);
HXDLIN( 228)		Float b0x = ((Float)0.);
HXDLIN( 228)		Float b0y = ((Float)0.);
HXDLIN( 228)		Float c0x = ((Float)0.);
HXDLIN( 228)		Float c0y = ((Float)0.);
HXDLIN( 228)		Float d0x = ((Float)0.);
HXDLIN( 228)		Float d0y = ((Float)0.);
HXDLIN( 228)		if (::hx::IsNotEq( theta1,0 )) {
HXDLIN( 228)			Float pi = ::Math_obj::PI;
HXDLIN( 228)			Float pi4 = (pi / ( (Float)(4) ));
HXDLIN( 228)			Float pi2 = (pi / ( (Float)(2) ));
HXDLIN( 228)			Float sqrt2 = ::Math_obj::sqrt(( (Float)(2) ));
HXDLIN( 228)			Float r = (radius * sqrt2);
HXDLIN( 228)			Float aTheta = ((-(pi) + theta1) - pi4);
HXDLIN( 228)			Float dTheta = (((-(pi) + theta1) + (pi / ( (Float)(2) ))) - (pi / ( (Float)(4) )));
HXDLIN( 228)			Float cTheta = (( (Float)(theta1) ) - pi4);
HXDLIN( 228)			Float bTheta = (((-(pi) + theta1) - pi2) - pi4);
HXDLIN( 228)			Float as = ::Math_obj::sin(aTheta);
HXDLIN( 228)			Float ac = ::Math_obj::cos(aTheta);
HXDLIN( 228)			Float bs = ::Math_obj::sin(bTheta);
HXDLIN( 228)			Float bc = ::Math_obj::cos(bTheta);
HXDLIN( 228)			Float cs = ::Math_obj::sin(cTheta);
HXDLIN( 228)			Float cc = ::Math_obj::cos(cTheta);
HXDLIN( 228)			Float ds = ::Math_obj::sin(dTheta);
HXDLIN( 228)			Float dc = ::Math_obj::cos(dTheta);
HXDLIN( 228)			Float r0 = (r - thick);
HXDLIN( 228)			ax = (x + (r * as));
HXDLIN( 228)			ay = (y + (r * ac));
HXDLIN( 228)			bx = (x + (r * bs));
HXDLIN( 228)			by = (y + (r * bc));
HXDLIN( 228)			cx = (x + (r * cs));
HXDLIN( 228)			cy = (y + (r * cc));
HXDLIN( 228)			dx = (x + (r * ds));
HXDLIN( 228)			dy = (y + (r * dc));
HXDLIN( 228)			a0x = (x + (r0 * as));
HXDLIN( 228)			a0y = (y + (r0 * ac));
HXDLIN( 228)			b0x = (x + (r0 * bs));
HXDLIN( 228)			b0y = (y + (r0 * bc));
HXDLIN( 228)			c0x = (x + (r0 * cs));
HXDLIN( 228)			c0y = (y + (r0 * cc));
HXDLIN( 228)			d0x = (x + (r0 * ds));
HXDLIN( 228)			d0y = (y + (r0 * dc));
            		}
            		else {
HXDLIN( 228)			ax = (x - radius);
HXDLIN( 228)			ay = (y - radius);
HXDLIN( 228)			Float lx = (radius * ( (Float)(2) ));
HXDLIN( 228)			Float ly = lx;
HXDLIN( 228)			bx = (ax + lx);
HXDLIN( 228)			by = ay;
HXDLIN( 228)			cx = bx;
HXDLIN( 228)			cy = (ay + ly);
HXDLIN( 228)			dx = ax;
HXDLIN( 228)			dy = cy;
HXDLIN( 228)			Float radius0 = (radius - thick);
HXDLIN( 228)			a0x = (x - radius0);
HXDLIN( 228)			a0y = (y - radius0);
HXDLIN( 228)			Float l0x = (radius0 * ( (Float)(2) ));
HXDLIN( 228)			Float l0y = l0x;
HXDLIN( 228)			b0x = (a0x + l0x);
HXDLIN( 228)			b0y = a0y;
HXDLIN( 228)			c0x = b0x;
HXDLIN( 228)			c0y = (a0y + l0y);
HXDLIN( 228)			d0x = a0x;
HXDLIN( 228)			d0y = c0y;
            		}
HXDLIN( 228)		{
HXDLIN( 228)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,a0x,a0y,0);
HXDLIN( 228)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 228)			if (::hx::IsNotNull( m )) {
HXDLIN( 228)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN( 228)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 228)		{
HXDLIN( 228)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,b0x,b0y,0,a0x,a0y,0);
HXDLIN( 228)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 228)			if (::hx::IsNotNull( m1 )) {
HXDLIN( 228)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN( 228)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 228)		{
HXDLIN( 228)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(d0x,d0y,0,c0x,c0y,0,dx,dy,0);
HXDLIN( 228)			 ::trilateral3::matrix::MatrixDozen m2 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 228)			if (::hx::IsNotNull( m2 )) {
HXDLIN( 228)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m2);
            			}
HXDLIN( 228)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 228)		{
HXDLIN( 228)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(c0x,c0y,0,cx,cy,0,dx,dy,0);
HXDLIN( 228)			 ::trilateral3::matrix::MatrixDozen m3 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 228)			if (::hx::IsNotNull( m3 )) {
HXDLIN( 228)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m3);
            			}
HXDLIN( 228)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 228)		{
HXDLIN( 228)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,a0x,a0y,0,d0x,d0y,0);
HXDLIN( 228)			 ::trilateral3::matrix::MatrixDozen m4 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 228)			if (::hx::IsNotNull( m4 )) {
HXDLIN( 228)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m4);
            			}
HXDLIN( 228)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 228)		{
HXDLIN( 228)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,d0x,d0y,0,dx,dy,0);
HXDLIN( 228)			 ::trilateral3::matrix::MatrixDozen m5 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 228)			if (::hx::IsNotNull( m5 )) {
HXDLIN( 228)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m5);
            			}
HXDLIN( 228)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 228)		{
HXDLIN( 228)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(b0x,b0y,0,bx,by,0,c0x,c0y,0);
HXDLIN( 228)			 ::trilateral3::matrix::MatrixDozen m6 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 228)			if (::hx::IsNotNull( m6 )) {
HXDLIN( 228)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m6);
            			}
HXDLIN( 228)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 228)		{
HXDLIN( 228)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,cx,cy,0,c0x,c0y,0);
HXDLIN( 228)			 ::trilateral3::matrix::MatrixDozen m7 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 228)			if (::hx::IsNotNull( m7 )) {
HXDLIN( 228)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m7);
            			}
HXDLIN( 228)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 228)		return 8;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Shaper_Fields__obj,diamondOutline,return )

int Shaper_Fields__obj::overlapStar( ::Dynamic drawType,Float px,Float py,Float radius, ::Dynamic __o_theta){
            		 ::Dynamic theta = __o_theta;
            		if (::hx::IsNull(__o_theta)) theta = 0;
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_234_overlapStar)
HXLINE( 235)		Float pi = ::Math_obj::PI;
HXLINE( 236)		Float omega = (-(pi) + theta);
HXLINE( 237)		radius = (radius / ((Float)1.9));
HXLINE( 238)		px = (px + radius);
HXLINE( 239)		py = (py + radius);
HXLINE( 240)		Float a0x = (px + (radius * ::Math_obj::sin(omega)));
HXLINE( 241)		Float a0y = (py + (radius * ::Math_obj::cos(omega)));
HXLINE( 242)		omega = (omega + (pi / ( (Float)(3) )));
HXLINE( 243)		Float a1x = (px + (radius * ::Math_obj::sin(omega)));
HXLINE( 244)		Float a1y = (py + (radius * ::Math_obj::cos(omega)));
HXLINE( 245)		omega = (omega + (pi / ( (Float)(3) )));
HXLINE( 246)		Float b0x = (px + (radius * ::Math_obj::sin(omega)));
HXLINE( 247)		Float b0y = (py + (radius * ::Math_obj::cos(omega)));
HXLINE( 248)		omega = (omega + (pi / ( (Float)(3) )));
HXLINE( 249)		Float b1x = (px + (radius * ::Math_obj::sin(omega)));
HXLINE( 250)		Float b1y = (py + (radius * ::Math_obj::cos(omega)));
HXLINE( 251)		omega = (omega + (pi / ( (Float)(3) )));
HXLINE( 252)		Float c0x = (px + (radius * ::Math_obj::sin(omega)));
HXLINE( 253)		Float c0y = (py + (radius * ::Math_obj::cos(omega)));
HXLINE( 254)		omega = (omega + (pi / ( (Float)(3) )));
HXLINE( 255)		Float c1x = (px + (radius * ::Math_obj::sin(omega)));
HXLINE( 256)		Float c1y = (py + (radius * ::Math_obj::cos(omega)));
HXLINE( 257)		{
HXLINE( 257)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(a0x,a0y,0,b0x,b0y,0,c0x,c0y,0);
HXDLIN( 257)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 257)			if (::hx::IsNotNull( m )) {
HXLINE( 257)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN( 257)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXLINE( 258)		{
HXLINE( 258)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(a1x,a1y,0,b1x,b1y,0,c1x,c1y,0);
HXDLIN( 258)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 258)			if (::hx::IsNotNull( m1 )) {
HXLINE( 258)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN( 258)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXLINE( 259)		return 2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Shaper_Fields__obj,overlapStar,return )

int Shaper_Fields__obj::circle( ::Dynamic drawType,Float ax,Float ay,Float radius, ::Dynamic __o_sides, ::Dynamic __o_omega){
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            		 ::Dynamic omega = __o_omega;
            		if (::hx::IsNull(__o_omega)) omega = ((Float)0.);
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_265_circle)
HXLINE( 266)		Float pi = ::Math_obj::PI;
HXLINE( 267)		Float theta = ((pi / ( (Float)(2) )) + omega);
HXLINE( 268)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 269)		Float bx;
HXLINE( 270)		Float by;
HXLINE( 271)		Float cx;
HXLINE( 272)		Float cy;
HXLINE( 273)		{
HXLINE( 273)			int _g = 0;
HXDLIN( 273)			 ::Dynamic _g1 = sides;
HXDLIN( 273)			while(::hx::IsLess( _g,_g1 )){
HXLINE( 273)				_g = (_g + 1);
HXDLIN( 273)				int i = (_g - 1);
HXLINE( 274)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXLINE( 275)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXLINE( 276)				theta = (theta + step);
HXLINE( 277)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXLINE( 278)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXLINE( 279)				{
HXLINE( 279)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 279)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 279)					if (::hx::IsNotNull( m )) {
HXLINE( 279)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 279)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXLINE( 281)		return ( (int)(sides) );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Shaper_Fields__obj,circle,return )

int Shaper_Fields__obj::circleRadial( ::Dynamic drawType,Float ax,Float ay,Float rx,Float ry,Float radius, ::Dynamic __o_sides, ::Dynamic __o_omega){
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            		 ::Dynamic omega = __o_omega;
            		if (::hx::IsNull(__o_omega)) omega = ((Float)0.);
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_288_circleRadial)
HXLINE( 289)		Float pi = ::Math_obj::PI;
HXLINE( 290)		Float theta = ((pi / ( (Float)(2) )) + omega);
HXLINE( 291)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 292)		Float bx;
HXLINE( 293)		Float by;
HXLINE( 294)		Float cx;
HXLINE( 295)		Float cy;
HXLINE( 296)		if ((rx > ((Float)1.))) {
HXLINE( 296)			rx = ( (Float)(1) );
            		}
HXLINE( 297)		if ((rx < ((Float)-1.))) {
HXLINE( 297)			rx = ( (Float)(-1) );
            		}
HXLINE( 298)		if ((ry > ((Float)1.))) {
HXLINE( 298)			ry = ( (Float)(1) );
            		}
HXLINE( 299)		if ((ry < ((Float)-1.))) {
HXLINE( 299)			ry = ( (Float)(-1) );
            		}
HXLINE( 300)		Float mx = (ax + (rx * radius));
HXLINE( 301)		Float my = (ay - (ry * radius));
HXLINE( 302)		{
HXLINE( 302)			int _g = 0;
HXDLIN( 302)			 ::Dynamic _g1 = sides;
HXDLIN( 302)			while(::hx::IsLess( _g,_g1 )){
HXLINE( 302)				_g = (_g + 1);
HXDLIN( 302)				int i = (_g - 1);
HXLINE( 303)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXLINE( 304)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXLINE( 305)				theta = (theta + step);
HXLINE( 306)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXLINE( 307)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXLINE( 308)				{
HXLINE( 308)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 308)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 308)					if (::hx::IsNotNull( m )) {
HXLINE( 308)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 308)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXLINE( 310)		return ( (int)(sides) );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(Shaper_Fields__obj,circleRadial,return )

int Shaper_Fields__obj::circleRadialOnSide( ::Dynamic drawType,Float ax,Float ay,Float rx,Float ry,Float radius, ::Dynamic __o_sides, ::Dynamic __o_omega){
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            		 ::Dynamic omega = __o_omega;
            		if (::hx::IsNull(__o_omega)) omega = ((Float)0.);
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_317_circleRadialOnSide)
HXLINE( 318)		Float pi = ::Math_obj::PI;
HXLINE( 319)		Float theta = (pi / ( (Float)(2) ));
HXLINE( 320)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 321)		theta = (theta - ((step / ( (Float)(2) )) + omega));
HXLINE( 322)		Float bx = ( (Float)(0) );
HXLINE( 323)		Float by = ( (Float)(0) );
HXLINE( 324)		Float cx = ( (Float)(0) );
HXLINE( 325)		Float cy = ( (Float)(0) );
HXLINE( 326)		if ((rx > ((Float)1.))) {
HXLINE( 326)			rx = ( (Float)(1) );
            		}
HXLINE( 327)		if ((rx < ((Float)-1.))) {
HXLINE( 327)			rx = ( (Float)(-1) );
            		}
HXLINE( 328)		if ((ry > ((Float)1.))) {
HXLINE( 328)			ry = ( (Float)(1) );
            		}
HXLINE( 329)		if ((ry < ((Float)-1.))) {
HXLINE( 329)			ry = ( (Float)(-1) );
            		}
HXLINE( 330)		Float mx = (ax + (rx * radius));
HXLINE( 331)		Float my = (ay - (ry * radius));
HXLINE( 332)		Float dx = (ax + (radius * ::Math_obj::sin(theta)));
HXLINE( 333)		Float dy = (ay + (radius * ::Math_obj::cos(theta)));
HXLINE( 334)		{
HXLINE( 334)			int _g = 0;
HXDLIN( 334)			int _g1 = (( (int)(sides) ) - 1);
HXDLIN( 334)			while((_g < _g1)){
HXLINE( 334)				_g = (_g + 1);
HXDLIN( 334)				int i = (_g - 1);
HXLINE( 335)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXLINE( 336)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXLINE( 337)				theta = (theta + step);
HXLINE( 338)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXLINE( 339)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXLINE( 340)				{
HXLINE( 340)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 340)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 340)					if (::hx::IsNotNull( m )) {
HXLINE( 340)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 340)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXLINE( 342)		{
HXLINE( 342)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,cx,cy,0,dx,dy,0);
HXDLIN( 342)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 342)			if (::hx::IsNotNull( m )) {
HXLINE( 342)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN( 342)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXLINE( 344)		return ( (int)(sides) );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(Shaper_Fields__obj,circleRadialOnSide,return )

int Shaper_Fields__obj::ellipse( ::Dynamic drawType,Float ax,Float ay,Float rx,Float ry,::hx::Null< int >  __o_sides){
            		int sides = __o_sides.Default(36);
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_350_ellipse)
HXLINE( 351)		Float pi = ::Math_obj::PI;
HXLINE( 352)		Float theta = (pi / ( (Float)(2) ));
HXLINE( 353)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 354)		Float bx;
HXLINE( 355)		Float by;
HXLINE( 356)		Float cx;
HXLINE( 357)		Float cy;
HXLINE( 358)		{
HXLINE( 358)			int _g = 0;
HXDLIN( 358)			int _g1 = sides;
HXDLIN( 358)			while((_g < _g1)){
HXLINE( 358)				_g = (_g + 1);
HXDLIN( 358)				int i = (_g - 1);
HXLINE( 359)				bx = (ax + (rx * ::Math_obj::sin(theta)));
HXLINE( 360)				by = (ay + (ry * ::Math_obj::cos(theta)));
HXLINE( 361)				theta = (theta + step);
HXLINE( 362)				cx = (ax + (rx * ::Math_obj::sin(theta)));
HXLINE( 363)				cy = (ay + (ry * ::Math_obj::cos(theta)));
HXLINE( 364)				{
HXLINE( 364)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 364)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 364)					if (::hx::IsNotNull( m )) {
HXLINE( 364)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 364)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXLINE( 366)		return sides;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Shaper_Fields__obj,ellipse,return )

int Shaper_Fields__obj::pie( ::Dynamic drawType,Float ax,Float ay,Float radius,Float beta,Float gamma, ::fracs::DifferencePreference prefer, ::Dynamic __o_sides){
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_377_pie)
HXLINE( 379)		Float pi = ::Math_obj::PI;
HXLINE( 380)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 381)		Float dif;
HXDLIN( 381)		switch((int)(prefer->_hx_getIndex())){
            			case (int)0: {
HXLINE( 381)				Float f;
HXDLIN( 381)				bool f1;
HXDLIN( 381)				if ((beta >= 0)) {
HXLINE( 381)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 381)					f1 = false;
            				}
HXDLIN( 381)				if (f1) {
HXLINE( 381)					f = beta;
            				}
            				else {
HXLINE( 381)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 381)					if ((a >= 0)) {
HXLINE( 381)						f = a;
            					}
            					else {
HXLINE( 381)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 381)				Float this1 = f;
HXDLIN( 381)				Float za = this1;
HXDLIN( 381)				Float f2;
HXDLIN( 381)				bool f3;
HXDLIN( 381)				if ((gamma >= 0)) {
HXLINE( 381)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 381)					f3 = false;
            				}
HXDLIN( 381)				if (f3) {
HXLINE( 381)					f2 = gamma;
            				}
            				else {
HXLINE( 381)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 381)					if ((a >= 0)) {
HXLINE( 381)						f2 = a;
            					}
            					else {
HXLINE( 381)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 381)				Float this2 = f2;
HXDLIN( 381)				Float zb = this2;
HXDLIN( 381)				Float fa = za;
HXDLIN( 381)				Float fb = zb;
HXDLIN( 381)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 381)				bool clockwise = (fa < fb);
HXDLIN( 381)				Float dif1;
HXDLIN( 381)				if (clockwise) {
HXLINE( 381)					dif1 = theta;
            				}
            				else {
HXLINE( 381)					dif1 = -(theta);
            				}
HXDLIN( 381)				if ((dif1 > 0)) {
HXLINE( 381)					dif = dif1;
            				}
            				else {
HXLINE( 381)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 381)				Float f;
HXDLIN( 381)				bool f1;
HXDLIN( 381)				if ((beta >= 0)) {
HXLINE( 381)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 381)					f1 = false;
            				}
HXDLIN( 381)				if (f1) {
HXLINE( 381)					f = beta;
            				}
            				else {
HXLINE( 381)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 381)					if ((a >= 0)) {
HXLINE( 381)						f = a;
            					}
            					else {
HXLINE( 381)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 381)				Float this1 = f;
HXDLIN( 381)				Float za = this1;
HXDLIN( 381)				Float f2;
HXDLIN( 381)				bool f3;
HXDLIN( 381)				if ((gamma >= 0)) {
HXLINE( 381)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 381)					f3 = false;
            				}
HXDLIN( 381)				if (f3) {
HXLINE( 381)					f2 = gamma;
            				}
            				else {
HXLINE( 381)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 381)					if ((a >= 0)) {
HXLINE( 381)						f2 = a;
            					}
            					else {
HXLINE( 381)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 381)				Float this2 = f2;
HXDLIN( 381)				Float zb = this2;
HXDLIN( 381)				Float fa = za;
HXDLIN( 381)				Float fb = zb;
HXDLIN( 381)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 381)				bool clockwise = (fa < fb);
HXDLIN( 381)				Float dif1;
HXDLIN( 381)				if (clockwise) {
HXLINE( 381)					dif1 = theta;
            				}
            				else {
HXLINE( 381)					dif1 = -(theta);
            				}
HXDLIN( 381)				if ((dif1 < 0)) {
HXLINE( 381)					dif = dif1;
            				}
            				else {
HXLINE( 381)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 381)				Float f;
HXDLIN( 381)				bool f1;
HXDLIN( 381)				if ((beta >= 0)) {
HXLINE( 381)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 381)					f1 = false;
            				}
HXDLIN( 381)				if (f1) {
HXLINE( 381)					f = beta;
            				}
            				else {
HXLINE( 381)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 381)					if ((a >= 0)) {
HXLINE( 381)						f = a;
            					}
            					else {
HXLINE( 381)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 381)				Float this1 = f;
HXDLIN( 381)				Float za = this1;
HXDLIN( 381)				Float f2;
HXDLIN( 381)				bool f3;
HXDLIN( 381)				if ((gamma >= 0)) {
HXLINE( 381)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 381)					f3 = false;
            				}
HXDLIN( 381)				if (f3) {
HXLINE( 381)					f2 = gamma;
            				}
            				else {
HXLINE( 381)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 381)					if ((a >= 0)) {
HXLINE( 381)						f2 = a;
            					}
            					else {
HXLINE( 381)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 381)				Float this2 = f2;
HXDLIN( 381)				Float zb = this2;
HXDLIN( 381)				Float fa = za;
HXDLIN( 381)				Float fb = zb;
HXDLIN( 381)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 381)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 381)				bool clockwise = (fa < fb);
HXDLIN( 381)				Float dif1;
HXDLIN( 381)				if (clockwise) {
HXLINE( 381)					dif1 = theta;
            				}
            				else {
HXLINE( 381)					dif1 = -(theta);
            				}
HXDLIN( 381)				if (smallest) {
HXLINE( 381)					dif = dif1;
            				}
            				else {
HXLINE( 381)					if (clockwise) {
HXLINE( 381)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 381)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 381)				Float f;
HXDLIN( 381)				bool f1;
HXDLIN( 381)				if ((beta >= 0)) {
HXLINE( 381)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 381)					f1 = false;
            				}
HXDLIN( 381)				if (f1) {
HXLINE( 381)					f = beta;
            				}
            				else {
HXLINE( 381)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 381)					if ((a >= 0)) {
HXLINE( 381)						f = a;
            					}
            					else {
HXLINE( 381)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 381)				Float this1 = f;
HXDLIN( 381)				Float za = this1;
HXDLIN( 381)				Float f2;
HXDLIN( 381)				bool f3;
HXDLIN( 381)				if ((gamma >= 0)) {
HXLINE( 381)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 381)					f3 = false;
            				}
HXDLIN( 381)				if (f3) {
HXLINE( 381)					f2 = gamma;
            				}
            				else {
HXLINE( 381)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 381)					if ((a >= 0)) {
HXLINE( 381)						f2 = a;
            					}
            					else {
HXLINE( 381)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 381)				Float this2 = f2;
HXDLIN( 381)				Float zb = this2;
HXDLIN( 381)				Float fa = za;
HXDLIN( 381)				Float fb = zb;
HXDLIN( 381)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 381)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 381)				bool clockwise = (fa < fb);
HXDLIN( 381)				Float dif1;
HXDLIN( 381)				if (clockwise) {
HXLINE( 381)					dif1 = theta;
            				}
            				else {
HXLINE( 381)					dif1 = -(theta);
            				}
HXDLIN( 381)				if (largest) {
HXLINE( 381)					dif = dif1;
            				}
            				else {
HXLINE( 381)					if (clockwise) {
HXLINE( 381)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 381)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXLINE( 382)		bool positive = (dif >= 0);
HXLINE( 383)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXLINE( 385)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXLINE( 386)		Float angle = beta;
HXLINE( 387)		Float cx;
HXLINE( 388)		Float cy;
HXLINE( 389)		Float bx = ( (Float)(0) );
HXLINE( 390)		Float by = ( (Float)(0) );
HXLINE( 391)		{
HXLINE( 391)			int _g = 0;
HXDLIN( 391)			int _g1 = (totalSteps + 1);
HXDLIN( 391)			while((_g < _g1)){
HXLINE( 391)				_g = (_g + 1);
HXDLIN( 391)				int i = (_g - 1);
HXLINE( 392)				cx = (ax + (radius * ::Math_obj::sin(angle)));
HXLINE( 393)				cy = (ay + (radius * ::Math_obj::cos(angle)));
HXLINE( 394)				if ((i != 0)) {
HXLINE( 396)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 396)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 396)					if (::hx::IsNotNull( m )) {
HXLINE( 396)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 396)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXLINE( 398)				angle = (angle + step1);
HXLINE( 399)				bx = cx;
HXLINE( 400)				by = cy;
            			}
            		}
HXLINE( 402)		return totalSteps;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(Shaper_Fields__obj,pie,return )

int Shaper_Fields__obj::pieX( ::Dynamic drawType,Float ax,Float ay,Float radius,Float beta,Float gamma, ::fracs::DifferencePreference prefer,::Array< Float > edgePoly, ::Dynamic __o_sides){
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_414_pieX)
HXLINE( 416)		Float pi = ::Math_obj::PI;
HXLINE( 417)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 418)		Float dif;
HXDLIN( 418)		switch((int)(prefer->_hx_getIndex())){
            			case (int)0: {
HXLINE( 418)				Float f;
HXDLIN( 418)				bool f1;
HXDLIN( 418)				if ((beta >= 0)) {
HXLINE( 418)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 418)					f1 = false;
            				}
HXDLIN( 418)				if (f1) {
HXLINE( 418)					f = beta;
            				}
            				else {
HXLINE( 418)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 418)					if ((a >= 0)) {
HXLINE( 418)						f = a;
            					}
            					else {
HXLINE( 418)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 418)				Float this1 = f;
HXDLIN( 418)				Float za = this1;
HXDLIN( 418)				Float f2;
HXDLIN( 418)				bool f3;
HXDLIN( 418)				if ((gamma >= 0)) {
HXLINE( 418)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 418)					f3 = false;
            				}
HXDLIN( 418)				if (f3) {
HXLINE( 418)					f2 = gamma;
            				}
            				else {
HXLINE( 418)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 418)					if ((a >= 0)) {
HXLINE( 418)						f2 = a;
            					}
            					else {
HXLINE( 418)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 418)				Float this2 = f2;
HXDLIN( 418)				Float zb = this2;
HXDLIN( 418)				Float fa = za;
HXDLIN( 418)				Float fb = zb;
HXDLIN( 418)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 418)				bool clockwise = (fa < fb);
HXDLIN( 418)				Float dif1;
HXDLIN( 418)				if (clockwise) {
HXLINE( 418)					dif1 = theta;
            				}
            				else {
HXLINE( 418)					dif1 = -(theta);
            				}
HXDLIN( 418)				if ((dif1 > 0)) {
HXLINE( 418)					dif = dif1;
            				}
            				else {
HXLINE( 418)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 418)				Float f;
HXDLIN( 418)				bool f1;
HXDLIN( 418)				if ((beta >= 0)) {
HXLINE( 418)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 418)					f1 = false;
            				}
HXDLIN( 418)				if (f1) {
HXLINE( 418)					f = beta;
            				}
            				else {
HXLINE( 418)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 418)					if ((a >= 0)) {
HXLINE( 418)						f = a;
            					}
            					else {
HXLINE( 418)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 418)				Float this1 = f;
HXDLIN( 418)				Float za = this1;
HXDLIN( 418)				Float f2;
HXDLIN( 418)				bool f3;
HXDLIN( 418)				if ((gamma >= 0)) {
HXLINE( 418)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 418)					f3 = false;
            				}
HXDLIN( 418)				if (f3) {
HXLINE( 418)					f2 = gamma;
            				}
            				else {
HXLINE( 418)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 418)					if ((a >= 0)) {
HXLINE( 418)						f2 = a;
            					}
            					else {
HXLINE( 418)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 418)				Float this2 = f2;
HXDLIN( 418)				Float zb = this2;
HXDLIN( 418)				Float fa = za;
HXDLIN( 418)				Float fb = zb;
HXDLIN( 418)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 418)				bool clockwise = (fa < fb);
HXDLIN( 418)				Float dif1;
HXDLIN( 418)				if (clockwise) {
HXLINE( 418)					dif1 = theta;
            				}
            				else {
HXLINE( 418)					dif1 = -(theta);
            				}
HXDLIN( 418)				if ((dif1 < 0)) {
HXLINE( 418)					dif = dif1;
            				}
            				else {
HXLINE( 418)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 418)				Float f;
HXDLIN( 418)				bool f1;
HXDLIN( 418)				if ((beta >= 0)) {
HXLINE( 418)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 418)					f1 = false;
            				}
HXDLIN( 418)				if (f1) {
HXLINE( 418)					f = beta;
            				}
            				else {
HXLINE( 418)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 418)					if ((a >= 0)) {
HXLINE( 418)						f = a;
            					}
            					else {
HXLINE( 418)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 418)				Float this1 = f;
HXDLIN( 418)				Float za = this1;
HXDLIN( 418)				Float f2;
HXDLIN( 418)				bool f3;
HXDLIN( 418)				if ((gamma >= 0)) {
HXLINE( 418)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 418)					f3 = false;
            				}
HXDLIN( 418)				if (f3) {
HXLINE( 418)					f2 = gamma;
            				}
            				else {
HXLINE( 418)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 418)					if ((a >= 0)) {
HXLINE( 418)						f2 = a;
            					}
            					else {
HXLINE( 418)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 418)				Float this2 = f2;
HXDLIN( 418)				Float zb = this2;
HXDLIN( 418)				Float fa = za;
HXDLIN( 418)				Float fb = zb;
HXDLIN( 418)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 418)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 418)				bool clockwise = (fa < fb);
HXDLIN( 418)				Float dif1;
HXDLIN( 418)				if (clockwise) {
HXLINE( 418)					dif1 = theta;
            				}
            				else {
HXLINE( 418)					dif1 = -(theta);
            				}
HXDLIN( 418)				if (smallest) {
HXLINE( 418)					dif = dif1;
            				}
            				else {
HXLINE( 418)					if (clockwise) {
HXLINE( 418)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 418)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 418)				Float f;
HXDLIN( 418)				bool f1;
HXDLIN( 418)				if ((beta >= 0)) {
HXLINE( 418)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 418)					f1 = false;
            				}
HXDLIN( 418)				if (f1) {
HXLINE( 418)					f = beta;
            				}
            				else {
HXLINE( 418)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 418)					if ((a >= 0)) {
HXLINE( 418)						f = a;
            					}
            					else {
HXLINE( 418)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 418)				Float this1 = f;
HXDLIN( 418)				Float za = this1;
HXDLIN( 418)				Float f2;
HXDLIN( 418)				bool f3;
HXDLIN( 418)				if ((gamma >= 0)) {
HXLINE( 418)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 418)					f3 = false;
            				}
HXDLIN( 418)				if (f3) {
HXLINE( 418)					f2 = gamma;
            				}
            				else {
HXLINE( 418)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 418)					if ((a >= 0)) {
HXLINE( 418)						f2 = a;
            					}
            					else {
HXLINE( 418)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 418)				Float this2 = f2;
HXDLIN( 418)				Float zb = this2;
HXDLIN( 418)				Float fa = za;
HXDLIN( 418)				Float fb = zb;
HXDLIN( 418)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 418)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 418)				bool clockwise = (fa < fb);
HXDLIN( 418)				Float dif1;
HXDLIN( 418)				if (clockwise) {
HXLINE( 418)					dif1 = theta;
            				}
            				else {
HXLINE( 418)					dif1 = -(theta);
            				}
HXDLIN( 418)				if (largest) {
HXLINE( 418)					dif = dif1;
            				}
            				else {
HXLINE( 418)					if (clockwise) {
HXLINE( 418)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 418)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXLINE( 419)		bool positive = (dif >= 0);
HXLINE( 420)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXLINE( 422)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXLINE( 423)		Float angle = beta;
HXLINE( 424)		Float cx;
HXLINE( 425)		Float cy;
HXLINE( 426)		Float bx = ( (Float)(0) );
HXLINE( 427)		Float by = ( (Float)(0) );
HXLINE( 428)		int p2 = edgePoly->length;
HXLINE( 429)		{
HXLINE( 429)			int _g = 0;
HXDLIN( 429)			int _g1 = (totalSteps + 1);
HXDLIN( 429)			while((_g < _g1)){
HXLINE( 429)				_g = (_g + 1);
HXDLIN( 429)				int i = (_g - 1);
HXLINE( 430)				cx = (ax + (radius * ::Math_obj::sin(angle)));
HXLINE( 431)				cy = (ay + (radius * ::Math_obj::cos(angle)));
HXLINE( 432)				p2 = (p2 + 1);
HXDLIN( 432)				edgePoly[(p2 - 1)] = cx;
HXLINE( 433)				p2 = (p2 + 1);
HXDLIN( 433)				edgePoly[(p2 - 1)] = cy;
HXLINE( 434)				if ((i != 0)) {
HXLINE( 436)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 436)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 436)					if (::hx::IsNotNull( m )) {
HXLINE( 436)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 436)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXLINE( 438)				angle = (angle + step1);
HXLINE( 439)				bx = cx;
HXLINE( 440)				by = cy;
            			}
            		}
HXLINE( 442)		return totalSteps;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(Shaper_Fields__obj,pieX,return )

int Shaper_Fields__obj::pieDifX( ::Dynamic drawType,Float ax,Float ay,Float radius,Float beta,Float dif,::Array< Float > edgePoly, ::Dynamic __o_sides){
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_453_pieDifX)
HXLINE( 455)		Float pi = ::Math_obj::PI;
HXLINE( 456)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 457)		bool positive = (dif >= 0);
HXLINE( 458)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXLINE( 460)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXLINE( 461)		Float angle = beta;
HXLINE( 462)		Float cx;
HXLINE( 463)		Float cy;
HXLINE( 464)		Float bx = ( (Float)(0) );
HXLINE( 465)		Float by = ( (Float)(0) );
HXLINE( 466)		int p2 = edgePoly->length;
HXLINE( 467)		{
HXLINE( 467)			int _g = 0;
HXDLIN( 467)			int _g1 = (totalSteps + 1);
HXDLIN( 467)			while((_g < _g1)){
HXLINE( 467)				_g = (_g + 1);
HXDLIN( 467)				int i = (_g - 1);
HXLINE( 468)				cx = (ax + (radius * ::Math_obj::sin(angle)));
HXLINE( 469)				cy = (ay + (radius * ::Math_obj::cos(angle)));
HXLINE( 470)				p2 = (p2 + 1);
HXDLIN( 470)				edgePoly[(p2 - 1)] = cx;
HXLINE( 471)				p2 = (p2 + 1);
HXDLIN( 471)				edgePoly[(p2 - 1)] = cy;
HXLINE( 472)				if ((i != 0)) {
HXLINE( 474)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 474)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 474)					if (::hx::IsNotNull( m )) {
HXLINE( 474)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 474)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXLINE( 476)				angle = (angle + step1);
HXLINE( 477)				bx = cx;
HXLINE( 478)				by = cy;
            			}
            		}
HXLINE( 480)		return totalSteps;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(Shaper_Fields__obj,pieDifX,return )

int Shaper_Fields__obj::ellipsePie( ::Dynamic drawType,Float ax,Float ay,Float rx,Float ry,Float beta,Float gamma, ::fracs::DifferencePreference prefer, ::Dynamic __o_sides){
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_489_ellipsePie)
HXLINE( 491)		Float pi = ::Math_obj::PI;
HXLINE( 492)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 493)		Float dif;
HXDLIN( 493)		switch((int)(prefer->_hx_getIndex())){
            			case (int)0: {
HXLINE( 493)				Float f;
HXDLIN( 493)				bool f1;
HXDLIN( 493)				if ((beta >= 0)) {
HXLINE( 493)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 493)					f1 = false;
            				}
HXDLIN( 493)				if (f1) {
HXLINE( 493)					f = beta;
            				}
            				else {
HXLINE( 493)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 493)					if ((a >= 0)) {
HXLINE( 493)						f = a;
            					}
            					else {
HXLINE( 493)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 493)				Float this1 = f;
HXDLIN( 493)				Float za = this1;
HXDLIN( 493)				Float f2;
HXDLIN( 493)				bool f3;
HXDLIN( 493)				if ((gamma >= 0)) {
HXLINE( 493)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 493)					f3 = false;
            				}
HXDLIN( 493)				if (f3) {
HXLINE( 493)					f2 = gamma;
            				}
            				else {
HXLINE( 493)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 493)					if ((a >= 0)) {
HXLINE( 493)						f2 = a;
            					}
            					else {
HXLINE( 493)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 493)				Float this2 = f2;
HXDLIN( 493)				Float zb = this2;
HXDLIN( 493)				Float fa = za;
HXDLIN( 493)				Float fb = zb;
HXDLIN( 493)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 493)				bool clockwise = (fa < fb);
HXDLIN( 493)				Float dif1;
HXDLIN( 493)				if (clockwise) {
HXLINE( 493)					dif1 = theta;
            				}
            				else {
HXLINE( 493)					dif1 = -(theta);
            				}
HXDLIN( 493)				if ((dif1 > 0)) {
HXLINE( 493)					dif = dif1;
            				}
            				else {
HXLINE( 493)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 493)				Float f;
HXDLIN( 493)				bool f1;
HXDLIN( 493)				if ((beta >= 0)) {
HXLINE( 493)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 493)					f1 = false;
            				}
HXDLIN( 493)				if (f1) {
HXLINE( 493)					f = beta;
            				}
            				else {
HXLINE( 493)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 493)					if ((a >= 0)) {
HXLINE( 493)						f = a;
            					}
            					else {
HXLINE( 493)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 493)				Float this1 = f;
HXDLIN( 493)				Float za = this1;
HXDLIN( 493)				Float f2;
HXDLIN( 493)				bool f3;
HXDLIN( 493)				if ((gamma >= 0)) {
HXLINE( 493)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 493)					f3 = false;
            				}
HXDLIN( 493)				if (f3) {
HXLINE( 493)					f2 = gamma;
            				}
            				else {
HXLINE( 493)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 493)					if ((a >= 0)) {
HXLINE( 493)						f2 = a;
            					}
            					else {
HXLINE( 493)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 493)				Float this2 = f2;
HXDLIN( 493)				Float zb = this2;
HXDLIN( 493)				Float fa = za;
HXDLIN( 493)				Float fb = zb;
HXDLIN( 493)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 493)				bool clockwise = (fa < fb);
HXDLIN( 493)				Float dif1;
HXDLIN( 493)				if (clockwise) {
HXLINE( 493)					dif1 = theta;
            				}
            				else {
HXLINE( 493)					dif1 = -(theta);
            				}
HXDLIN( 493)				if ((dif1 < 0)) {
HXLINE( 493)					dif = dif1;
            				}
            				else {
HXLINE( 493)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 493)				Float f;
HXDLIN( 493)				bool f1;
HXDLIN( 493)				if ((beta >= 0)) {
HXLINE( 493)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 493)					f1 = false;
            				}
HXDLIN( 493)				if (f1) {
HXLINE( 493)					f = beta;
            				}
            				else {
HXLINE( 493)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 493)					if ((a >= 0)) {
HXLINE( 493)						f = a;
            					}
            					else {
HXLINE( 493)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 493)				Float this1 = f;
HXDLIN( 493)				Float za = this1;
HXDLIN( 493)				Float f2;
HXDLIN( 493)				bool f3;
HXDLIN( 493)				if ((gamma >= 0)) {
HXLINE( 493)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 493)					f3 = false;
            				}
HXDLIN( 493)				if (f3) {
HXLINE( 493)					f2 = gamma;
            				}
            				else {
HXLINE( 493)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 493)					if ((a >= 0)) {
HXLINE( 493)						f2 = a;
            					}
            					else {
HXLINE( 493)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 493)				Float this2 = f2;
HXDLIN( 493)				Float zb = this2;
HXDLIN( 493)				Float fa = za;
HXDLIN( 493)				Float fb = zb;
HXDLIN( 493)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 493)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 493)				bool clockwise = (fa < fb);
HXDLIN( 493)				Float dif1;
HXDLIN( 493)				if (clockwise) {
HXLINE( 493)					dif1 = theta;
            				}
            				else {
HXLINE( 493)					dif1 = -(theta);
            				}
HXDLIN( 493)				if (smallest) {
HXLINE( 493)					dif = dif1;
            				}
            				else {
HXLINE( 493)					if (clockwise) {
HXLINE( 493)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 493)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 493)				Float f;
HXDLIN( 493)				bool f1;
HXDLIN( 493)				if ((beta >= 0)) {
HXLINE( 493)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 493)					f1 = false;
            				}
HXDLIN( 493)				if (f1) {
HXLINE( 493)					f = beta;
            				}
            				else {
HXLINE( 493)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 493)					if ((a >= 0)) {
HXLINE( 493)						f = a;
            					}
            					else {
HXLINE( 493)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 493)				Float this1 = f;
HXDLIN( 493)				Float za = this1;
HXDLIN( 493)				Float f2;
HXDLIN( 493)				bool f3;
HXDLIN( 493)				if ((gamma >= 0)) {
HXLINE( 493)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 493)					f3 = false;
            				}
HXDLIN( 493)				if (f3) {
HXLINE( 493)					f2 = gamma;
            				}
            				else {
HXLINE( 493)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 493)					if ((a >= 0)) {
HXLINE( 493)						f2 = a;
            					}
            					else {
HXLINE( 493)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 493)				Float this2 = f2;
HXDLIN( 493)				Float zb = this2;
HXDLIN( 493)				Float fa = za;
HXDLIN( 493)				Float fb = zb;
HXDLIN( 493)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 493)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 493)				bool clockwise = (fa < fb);
HXDLIN( 493)				Float dif1;
HXDLIN( 493)				if (clockwise) {
HXLINE( 493)					dif1 = theta;
            				}
            				else {
HXLINE( 493)					dif1 = -(theta);
            				}
HXDLIN( 493)				if (largest) {
HXLINE( 493)					dif = dif1;
            				}
            				else {
HXLINE( 493)					if (clockwise) {
HXLINE( 493)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 493)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXLINE( 494)		bool positive = (dif >= 0);
HXLINE( 495)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXLINE( 497)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXLINE( 498)		Float angle = beta;
HXLINE( 499)		Float cx;
HXLINE( 500)		Float cy;
HXLINE( 501)		Float bx = ( (Float)(0) );
HXLINE( 502)		Float by = ( (Float)(0) );
HXLINE( 503)		{
HXLINE( 503)			int _g = 0;
HXDLIN( 503)			int _g1 = (totalSteps + 1);
HXDLIN( 503)			while((_g < _g1)){
HXLINE( 503)				_g = (_g + 1);
HXDLIN( 503)				int i = (_g - 1);
HXLINE( 504)				cx = (ax + (rx * ::Math_obj::sin(angle)));
HXLINE( 505)				cy = (ay + (ry * ::Math_obj::cos(angle)));
HXLINE( 506)				if ((i != 0)) {
HXLINE( 508)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 508)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 508)					if (::hx::IsNotNull( m )) {
HXLINE( 508)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 508)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXLINE( 510)				angle = (angle + step1);
HXLINE( 511)				bx = cx;
HXLINE( 512)				by = cy;
            			}
            		}
HXLINE( 514)		return totalSteps;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(Shaper_Fields__obj,ellipsePie,return )

int Shaper_Fields__obj::pieDif( ::Dynamic drawType,Float ax,Float ay,Float radius,Float beta,Float dif, ::Dynamic __o_sides){
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_523_pieDif)
HXLINE( 525)		Float pi = ::Math_obj::PI;
HXLINE( 526)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 527)		bool positive = (dif >= 0);
HXLINE( 528)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXLINE( 530)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXLINE( 531)		Float angle = beta;
HXLINE( 532)		Float cx;
HXLINE( 533)		Float cy;
HXLINE( 534)		Float bx = ( (Float)(0) );
HXLINE( 535)		Float by = ( (Float)(0) );
HXLINE( 536)		{
HXLINE( 536)			int _g = 0;
HXDLIN( 536)			int _g1 = (totalSteps + 1);
HXDLIN( 536)			while((_g < _g1)){
HXLINE( 536)				_g = (_g + 1);
HXDLIN( 536)				int i = (_g - 1);
HXLINE( 537)				cx = (ax + (radius * ::Math_obj::sin(angle)));
HXLINE( 538)				cy = (ay + (radius * ::Math_obj::cos(angle)));
HXLINE( 539)				if ((i != 0)) {
HXLINE( 540)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 540)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 540)					if (::hx::IsNotNull( m )) {
HXLINE( 540)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 540)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXLINE( 542)				angle = (angle + step1);
HXLINE( 543)				bx = cx;
HXLINE( 544)				by = cy;
            			}
            		}
HXLINE( 546)		return totalSteps;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(Shaper_Fields__obj,pieDif,return )

int Shaper_Fields__obj::arc( ::Dynamic drawType,Float ax,Float ay,Float radius,Float width,Float beta,Float gamma, ::fracs::DifferencePreference prefer, ::Dynamic __o_sides){
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_552_arc)
HXLINE( 554)		Float pi = ::Math_obj::PI;
HXLINE( 555)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 556)		Float dif;
HXDLIN( 556)		switch((int)(prefer->_hx_getIndex())){
            			case (int)0: {
HXLINE( 556)				Float f;
HXDLIN( 556)				bool f1;
HXDLIN( 556)				if ((beta >= 0)) {
HXLINE( 556)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 556)					f1 = false;
            				}
HXDLIN( 556)				if (f1) {
HXLINE( 556)					f = beta;
            				}
            				else {
HXLINE( 556)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 556)					if ((a >= 0)) {
HXLINE( 556)						f = a;
            					}
            					else {
HXLINE( 556)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 556)				Float this1 = f;
HXDLIN( 556)				Float za = this1;
HXDLIN( 556)				Float f2;
HXDLIN( 556)				bool f3;
HXDLIN( 556)				if ((gamma >= 0)) {
HXLINE( 556)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 556)					f3 = false;
            				}
HXDLIN( 556)				if (f3) {
HXLINE( 556)					f2 = gamma;
            				}
            				else {
HXLINE( 556)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 556)					if ((a >= 0)) {
HXLINE( 556)						f2 = a;
            					}
            					else {
HXLINE( 556)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 556)				Float this2 = f2;
HXDLIN( 556)				Float zb = this2;
HXDLIN( 556)				Float fa = za;
HXDLIN( 556)				Float fb = zb;
HXDLIN( 556)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 556)				bool clockwise = (fa < fb);
HXDLIN( 556)				Float dif1;
HXDLIN( 556)				if (clockwise) {
HXLINE( 556)					dif1 = theta;
            				}
            				else {
HXLINE( 556)					dif1 = -(theta);
            				}
HXDLIN( 556)				if ((dif1 > 0)) {
HXLINE( 556)					dif = dif1;
            				}
            				else {
HXLINE( 556)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 556)				Float f;
HXDLIN( 556)				bool f1;
HXDLIN( 556)				if ((beta >= 0)) {
HXLINE( 556)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 556)					f1 = false;
            				}
HXDLIN( 556)				if (f1) {
HXLINE( 556)					f = beta;
            				}
            				else {
HXLINE( 556)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 556)					if ((a >= 0)) {
HXLINE( 556)						f = a;
            					}
            					else {
HXLINE( 556)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 556)				Float this1 = f;
HXDLIN( 556)				Float za = this1;
HXDLIN( 556)				Float f2;
HXDLIN( 556)				bool f3;
HXDLIN( 556)				if ((gamma >= 0)) {
HXLINE( 556)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 556)					f3 = false;
            				}
HXDLIN( 556)				if (f3) {
HXLINE( 556)					f2 = gamma;
            				}
            				else {
HXLINE( 556)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 556)					if ((a >= 0)) {
HXLINE( 556)						f2 = a;
            					}
            					else {
HXLINE( 556)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 556)				Float this2 = f2;
HXDLIN( 556)				Float zb = this2;
HXDLIN( 556)				Float fa = za;
HXDLIN( 556)				Float fb = zb;
HXDLIN( 556)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 556)				bool clockwise = (fa < fb);
HXDLIN( 556)				Float dif1;
HXDLIN( 556)				if (clockwise) {
HXLINE( 556)					dif1 = theta;
            				}
            				else {
HXLINE( 556)					dif1 = -(theta);
            				}
HXDLIN( 556)				if ((dif1 < 0)) {
HXLINE( 556)					dif = dif1;
            				}
            				else {
HXLINE( 556)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 556)				Float f;
HXDLIN( 556)				bool f1;
HXDLIN( 556)				if ((beta >= 0)) {
HXLINE( 556)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 556)					f1 = false;
            				}
HXDLIN( 556)				if (f1) {
HXLINE( 556)					f = beta;
            				}
            				else {
HXLINE( 556)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 556)					if ((a >= 0)) {
HXLINE( 556)						f = a;
            					}
            					else {
HXLINE( 556)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 556)				Float this1 = f;
HXDLIN( 556)				Float za = this1;
HXDLIN( 556)				Float f2;
HXDLIN( 556)				bool f3;
HXDLIN( 556)				if ((gamma >= 0)) {
HXLINE( 556)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 556)					f3 = false;
            				}
HXDLIN( 556)				if (f3) {
HXLINE( 556)					f2 = gamma;
            				}
            				else {
HXLINE( 556)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 556)					if ((a >= 0)) {
HXLINE( 556)						f2 = a;
            					}
            					else {
HXLINE( 556)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 556)				Float this2 = f2;
HXDLIN( 556)				Float zb = this2;
HXDLIN( 556)				Float fa = za;
HXDLIN( 556)				Float fb = zb;
HXDLIN( 556)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 556)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 556)				bool clockwise = (fa < fb);
HXDLIN( 556)				Float dif1;
HXDLIN( 556)				if (clockwise) {
HXLINE( 556)					dif1 = theta;
            				}
            				else {
HXLINE( 556)					dif1 = -(theta);
            				}
HXDLIN( 556)				if (smallest) {
HXLINE( 556)					dif = dif1;
            				}
            				else {
HXLINE( 556)					if (clockwise) {
HXLINE( 556)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 556)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 556)				Float f;
HXDLIN( 556)				bool f1;
HXDLIN( 556)				if ((beta >= 0)) {
HXLINE( 556)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 556)					f1 = false;
            				}
HXDLIN( 556)				if (f1) {
HXLINE( 556)					f = beta;
            				}
            				else {
HXLINE( 556)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 556)					if ((a >= 0)) {
HXLINE( 556)						f = a;
            					}
            					else {
HXLINE( 556)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 556)				Float this1 = f;
HXDLIN( 556)				Float za = this1;
HXDLIN( 556)				Float f2;
HXDLIN( 556)				bool f3;
HXDLIN( 556)				if ((gamma >= 0)) {
HXLINE( 556)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 556)					f3 = false;
            				}
HXDLIN( 556)				if (f3) {
HXLINE( 556)					f2 = gamma;
            				}
            				else {
HXLINE( 556)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 556)					if ((a >= 0)) {
HXLINE( 556)						f2 = a;
            					}
            					else {
HXLINE( 556)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 556)				Float this2 = f2;
HXDLIN( 556)				Float zb = this2;
HXDLIN( 556)				Float fa = za;
HXDLIN( 556)				Float fb = zb;
HXDLIN( 556)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 556)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 556)				bool clockwise = (fa < fb);
HXDLIN( 556)				Float dif1;
HXDLIN( 556)				if (clockwise) {
HXLINE( 556)					dif1 = theta;
            				}
            				else {
HXLINE( 556)					dif1 = -(theta);
            				}
HXDLIN( 556)				if (largest) {
HXLINE( 556)					dif = dif1;
            				}
            				else {
HXLINE( 556)					if (clockwise) {
HXLINE( 556)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 556)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXLINE( 557)		bool positive = (dif >= 0);
HXLINE( 558)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXLINE( 560)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXLINE( 561)		Float angle = beta;
HXLINE( 562)		Float cx;
HXLINE( 563)		Float cy;
HXLINE( 564)		Float bx = ( (Float)(0) );
HXLINE( 565)		Float by = ( (Float)(0) );
HXLINE( 566)		Float dx = ( (Float)(0) );
HXLINE( 567)		Float dy = ( (Float)(0) );
HXLINE( 568)		Float ex = ( (Float)(0) );
HXLINE( 569)		Float ey = ( (Float)(0) );
HXLINE( 570)		Float r2 = (radius - width);
HXLINE( 571)		{
HXLINE( 571)			int _g = 0;
HXDLIN( 571)			int _g1 = (totalSteps + 1);
HXDLIN( 571)			while((_g < _g1)){
HXLINE( 571)				_g = (_g + 1);
HXDLIN( 571)				int i = (_g - 1);
HXLINE( 572)				cx = (ax + (radius * ::Math_obj::sin(angle)));
HXLINE( 573)				cy = (ay + (radius * ::Math_obj::cos(angle)));
HXLINE( 574)				ex = (ax + (r2 * ::Math_obj::sin(angle)));
HXLINE( 575)				ey = (ay + (r2 * ::Math_obj::cos(angle)));
HXLINE( 576)				if ((i != 0)) {
HXLINE( 577)					{
HXLINE( 577)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx,dy,0,bx,by,0,cx,cy,0);
HXDLIN( 577)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 577)						if (::hx::IsNotNull( m )) {
HXLINE( 577)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 577)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXLINE( 578)					{
HXLINE( 578)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx,dy,0,cx,cy,0,ex,ey,0);
HXDLIN( 578)						 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 578)						if (::hx::IsNotNull( m1 )) {
HXLINE( 578)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            						}
HXDLIN( 578)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
HXLINE( 580)				angle = (angle + step1);
HXLINE( 581)				bx = cx;
HXLINE( 582)				by = cy;
HXLINE( 583)				dx = ex;
HXLINE( 584)				dy = ey;
            			}
            		}
HXLINE( 586)		return (totalSteps * 2);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(Shaper_Fields__obj,arc,return )

int Shaper_Fields__obj::circleOnSide( ::Dynamic drawType,Float ax,Float ay,Float radius, ::Dynamic __o_sides, ::Dynamic __o_omega){
            		 ::Dynamic sides = __o_sides;
            		if (::hx::IsNull(__o_sides)) sides = 36;
            		 ::Dynamic omega = __o_omega;
            		if (::hx::IsNull(__o_omega)) omega = ((Float)0.);
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_592_circleOnSide)
HXLINE( 593)		Float pi = ::Math_obj::PI;
HXLINE( 594)		Float theta = (pi / ( (Float)(2) ));
HXLINE( 595)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 596)		theta = (theta - ((step / ( (Float)(2) )) + omega));
HXLINE( 597)		Float bx;
HXLINE( 598)		Float by;
HXLINE( 599)		Float cx;
HXLINE( 600)		Float cy;
HXLINE( 601)		{
HXLINE( 601)			int _g = 0;
HXDLIN( 601)			 ::Dynamic _g1 = sides;
HXDLIN( 601)			while(::hx::IsLess( _g,_g1 )){
HXLINE( 601)				_g = (_g + 1);
HXDLIN( 601)				int i = (_g - 1);
HXLINE( 602)				bx = (ax + (radius * ::Math_obj::sin(theta)));
HXLINE( 603)				by = (ay + (radius * ::Math_obj::cos(theta)));
HXLINE( 604)				theta = (theta + step);
HXLINE( 605)				cx = (ax + (radius * ::Math_obj::sin(theta)));
HXLINE( 606)				cy = (ay + (radius * ::Math_obj::cos(theta)));
HXLINE( 607)				{
HXLINE( 607)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 607)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 607)					if (::hx::IsNotNull( m )) {
HXLINE( 607)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 607)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXLINE( 609)		return ( (int)(sides) );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Shaper_Fields__obj,circleOnSide,return )

int Shaper_Fields__obj::ellipseOnSide( ::Dynamic drawType,Float ax,Float ay,Float rx,Float ry,::hx::Null< int >  __o_sides){
            		int sides = __o_sides.Default(36);
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_615_ellipseOnSide)
HXLINE( 616)		Float pi = ::Math_obj::PI;
HXLINE( 617)		Float theta = (pi / ( (Float)(2) ));
HXLINE( 618)		Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXLINE( 619)		theta = (theta - (step / ( (Float)(2) )));
HXLINE( 620)		Float bx;
HXLINE( 621)		Float by;
HXLINE( 622)		Float cx;
HXLINE( 623)		Float cy;
HXLINE( 624)		{
HXLINE( 624)			int _g = 0;
HXDLIN( 624)			int _g1 = sides;
HXDLIN( 624)			while((_g < _g1)){
HXLINE( 624)				_g = (_g + 1);
HXDLIN( 624)				int i = (_g - 1);
HXLINE( 625)				bx = (ax + (rx * ::Math_obj::sin(theta)));
HXLINE( 626)				by = (ay + (rx * ::Math_obj::cos(theta)));
HXLINE( 627)				theta = (theta + step);
HXLINE( 628)				cx = (ax + (rx * ::Math_obj::sin(theta)));
HXLINE( 629)				cy = (ay + (ry * ::Math_obj::cos(theta)));
HXLINE( 630)				{
HXLINE( 630)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx,by,0,cx,cy,0);
HXDLIN( 630)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 630)					if (::hx::IsNotNull( m )) {
HXLINE( 630)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 630)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
            			}
            		}
HXLINE( 632)		return sides;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Shaper_Fields__obj,ellipseOnSide,return )

int Shaper_Fields__obj::shape( ::Dynamic drawType,Float x,Float y,Float radius,int p, ::Dynamic __o_omega){
            		 ::Dynamic omega = __o_omega;
            		if (::hx::IsNull(__o_omega)) omega = ((Float)0.);
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_638_shape)
HXDLIN( 638)		if (((p & 1) == 0)) {
HXLINE( 639)			 ::Dynamic sides = p;
HXDLIN( 639)			 ::Dynamic omega1 = omega;
HXDLIN( 639)			if (::hx::IsNull( omega1 )) {
HXLINE( 639)				omega1 = ((Float)0.);
            			}
HXDLIN( 639)			if (::hx::IsNull( sides )) {
HXLINE( 639)				sides = 36;
            			}
HXDLIN( 639)			Float pi = ::Math_obj::PI;
HXDLIN( 639)			Float theta = (pi / ( (Float)(2) ));
HXDLIN( 639)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 639)			theta = (theta - ((step / ( (Float)(2) )) + omega1));
HXDLIN( 639)			Float bx;
HXDLIN( 639)			Float by;
HXDLIN( 639)			Float cx;
HXDLIN( 639)			Float cy;
HXDLIN( 639)			{
HXLINE( 639)				int _g = 0;
HXDLIN( 639)				 ::Dynamic _g1 = sides;
HXDLIN( 639)				while(::hx::IsLess( _g,_g1 )){
HXLINE( 639)					_g = (_g + 1);
HXDLIN( 639)					int i = (_g - 1);
HXDLIN( 639)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 639)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 639)					theta = (theta + step);
HXDLIN( 639)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 639)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 639)					{
HXLINE( 639)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(x,y,0,bx,by,0,cx,cy,0);
HXDLIN( 639)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 639)						if (::hx::IsNotNull( m )) {
HXLINE( 639)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 639)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 639)			return ( (int)(sides) );
            		}
            		else {
HXLINE( 641)			 ::Dynamic sides = p;
HXDLIN( 641)			 ::Dynamic omega1 = omega;
HXDLIN( 641)			if (::hx::IsNull( omega1 )) {
HXLINE( 641)				omega1 = ((Float)0.);
            			}
HXDLIN( 641)			if (::hx::IsNull( sides )) {
HXLINE( 641)				sides = 36;
            			}
HXDLIN( 641)			Float pi = ::Math_obj::PI;
HXDLIN( 641)			Float theta = ((pi / ( (Float)(2) )) + omega1);
HXDLIN( 641)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 641)			Float bx;
HXDLIN( 641)			Float by;
HXDLIN( 641)			Float cx;
HXDLIN( 641)			Float cy;
HXDLIN( 641)			{
HXLINE( 641)				int _g = 0;
HXDLIN( 641)				 ::Dynamic _g1 = sides;
HXDLIN( 641)				while(::hx::IsLess( _g,_g1 )){
HXLINE( 641)					_g = (_g + 1);
HXDLIN( 641)					int i = (_g - 1);
HXDLIN( 641)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 641)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 641)					theta = (theta + step);
HXDLIN( 641)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 641)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 641)					{
HXLINE( 641)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(x,y,0,bx,by,0,cx,cy,0);
HXDLIN( 641)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 641)						if (::hx::IsNotNull( m )) {
HXLINE( 641)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 641)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 641)			return ( (int)(sides) );
            		}
HXLINE( 638)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Shaper_Fields__obj,shape,return )

int Shaper_Fields__obj::shapeRadial( ::Dynamic drawType,Float x,Float y,Float rx,Float ry,Float radius,int p, ::Dynamic __o_omega){
            		 ::Dynamic omega = __o_omega;
            		if (::hx::IsNull(__o_omega)) omega = ((Float)0.);
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_649_shapeRadial)
HXDLIN( 649)		if (((p & 1) == 0)) {
HXLINE( 650)			::haxe::Log_obj::trace(HX_("even",1a,6f,1c,43),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),650,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXLINE( 651)			Float rx1 = rx;
HXDLIN( 651)			Float ry1 = ry;
HXDLIN( 651)			 ::Dynamic sides = p;
HXDLIN( 651)			 ::Dynamic omega1 = omega;
HXDLIN( 651)			if (::hx::IsNull( omega1 )) {
HXLINE( 651)				omega1 = ((Float)0.);
            			}
HXDLIN( 651)			if (::hx::IsNull( sides )) {
HXLINE( 651)				sides = 36;
            			}
HXDLIN( 651)			Float pi = ::Math_obj::PI;
HXDLIN( 651)			Float theta = ((pi / ( (Float)(2) )) + omega1);
HXDLIN( 651)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 651)			Float bx;
HXDLIN( 651)			Float by;
HXDLIN( 651)			Float cx;
HXDLIN( 651)			Float cy;
HXDLIN( 651)			if ((rx1 > ((Float)1.))) {
HXLINE( 651)				rx1 = ( (Float)(1) );
            			}
HXDLIN( 651)			if ((rx1 < ((Float)-1.))) {
HXLINE( 651)				rx1 = ( (Float)(-1) );
            			}
HXDLIN( 651)			if ((ry1 > ((Float)1.))) {
HXLINE( 651)				ry1 = ( (Float)(1) );
            			}
HXDLIN( 651)			if ((ry1 < ((Float)-1.))) {
HXLINE( 651)				ry1 = ( (Float)(-1) );
            			}
HXDLIN( 651)			Float mx = (x + (rx1 * radius));
HXDLIN( 651)			Float my = (y - (ry1 * radius));
HXDLIN( 651)			{
HXLINE( 651)				int _g = 0;
HXDLIN( 651)				 ::Dynamic _g1 = sides;
HXDLIN( 651)				while(::hx::IsLess( _g,_g1 )){
HXLINE( 651)					_g = (_g + 1);
HXDLIN( 651)					int i = (_g - 1);
HXDLIN( 651)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 651)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 651)					theta = (theta + step);
HXDLIN( 651)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 651)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 651)					{
HXLINE( 651)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 651)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 651)						if (::hx::IsNotNull( m )) {
HXLINE( 651)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 651)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 651)			return ( (int)(sides) );
            		}
            		else {
HXLINE( 653)			::haxe::Log_obj::trace(HX_("odd",af,91,54,00),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),653,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXLINE( 654)			::haxe::Log_obj::trace((p & 1),::hx::SourceInfo(HX_("trilateral3/shape/Shaper.hx",17,ae,03,72),654,HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f),HX_("shapeRadial",e0,a4,38,43)));
HXDLIN( 654)			Float rx1 = rx;
HXDLIN( 654)			Float ry1 = ry;
HXDLIN( 654)			 ::Dynamic sides = p;
HXDLIN( 654)			 ::Dynamic omega1 = omega;
HXDLIN( 654)			if (::hx::IsNull( omega1 )) {
HXLINE( 654)				omega1 = ((Float)0.);
            			}
HXDLIN( 654)			if (::hx::IsNull( sides )) {
HXLINE( 654)				sides = 36;
            			}
HXDLIN( 654)			Float pi = ::Math_obj::PI;
HXDLIN( 654)			Float theta = (pi / ( (Float)(2) ));
HXDLIN( 654)			Float step = ((pi * ( (Float)(2) )) / ( (Float)(sides) ));
HXDLIN( 654)			theta = (theta - ((step / ( (Float)(2) )) + omega1));
HXDLIN( 654)			Float bx = ( (Float)(0) );
HXDLIN( 654)			Float by = ( (Float)(0) );
HXDLIN( 654)			Float cx = ( (Float)(0) );
HXDLIN( 654)			Float cy = ( (Float)(0) );
HXDLIN( 654)			if ((rx1 > ((Float)1.))) {
HXLINE( 654)				rx1 = ( (Float)(1) );
            			}
HXDLIN( 654)			if ((rx1 < ((Float)-1.))) {
HXLINE( 654)				rx1 = ( (Float)(-1) );
            			}
HXDLIN( 654)			if ((ry1 > ((Float)1.))) {
HXLINE( 654)				ry1 = ( (Float)(1) );
            			}
HXDLIN( 654)			if ((ry1 < ((Float)-1.))) {
HXLINE( 654)				ry1 = ( (Float)(-1) );
            			}
HXDLIN( 654)			Float mx = (x + (rx1 * radius));
HXDLIN( 654)			Float my = (y - (ry1 * radius));
HXDLIN( 654)			Float dx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 654)			Float dy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 654)			{
HXLINE( 654)				int _g = 0;
HXDLIN( 654)				int _g1 = (( (int)(sides) ) - 1);
HXDLIN( 654)				while((_g < _g1)){
HXLINE( 654)					_g = (_g + 1);
HXDLIN( 654)					int i = (_g - 1);
HXDLIN( 654)					bx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 654)					by = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 654)					theta = (theta + step);
HXDLIN( 654)					cx = (x + (radius * ::Math_obj::sin(theta)));
HXDLIN( 654)					cy = (y + (radius * ::Math_obj::cos(theta)));
HXDLIN( 654)					{
HXLINE( 654)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,bx,by,0,cx,cy,0);
HXDLIN( 654)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 654)						if (::hx::IsNotNull( m )) {
HXLINE( 654)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 654)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
            			}
HXDLIN( 654)			{
HXLINE( 654)				drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(mx,my,0,cx,cy,0,dx,dy,0);
HXDLIN( 654)				 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 654)				if (::hx::IsNotNull( m )) {
HXLINE( 654)					drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            				}
HXDLIN( 654)				drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            			}
HXDLIN( 654)			return ( (int)(sides) );
            		}
HXLINE( 649)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(Shaper_Fields__obj,shapeRadial,return )

int Shaper_Fields__obj::roundedRectangle( ::Dynamic drawType,Float x,Float y,Float width,Float height,Float radius){
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_662_roundedRectangle)
HXLINE( 667)		Float pi = ::Math_obj::PI;
HXLINE( 668)		Float pi_2 = (::Math_obj::PI / ( (Float)(2) ));
HXLINE( 669)		Float ax = (x + radius);
HXLINE( 670)		Float ay = (y + radius);
HXLINE( 671)		Float bx = ((x + width) - radius);
HXLINE( 672)		Float by = (y + radius);
HXLINE( 673)		Float cx = bx;
HXLINE( 674)		Float cy = ((y + height) - radius);
HXLINE( 675)		Float dx = ax;
HXLINE( 676)		Float dy = cy;
HXLINE( 677)		int count = 0;
HXLINE( 678)		Float ax1 = ax;
HXDLIN( 678)		Float ay1 = y;
HXDLIN( 678)		Float bx1 = (ax + (width - (radius * ( (Float)(2) ))));
HXDLIN( 678)		Float by1 = ay1;
HXDLIN( 678)		Float cx1 = bx1;
HXDLIN( 678)		Float cy1 = (ay1 + height);
HXDLIN( 678)		Float dx1 = ax;
HXDLIN( 678)		Float dy1 = cy1;
HXDLIN( 678)		{
HXLINE( 678)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax1,ay1,0,bx1,by1,0,dx1,dy1,0);
HXDLIN( 678)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 678)			if (::hx::IsNotNull( m )) {
HXLINE( 678)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN( 678)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 678)		{
HXLINE( 678)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx1,by1,0,cx1,cy1,0,dx1,dy1,0);
HXDLIN( 678)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 678)			if (::hx::IsNotNull( m1 )) {
HXLINE( 678)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN( 678)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 678)		count = (count + 2);
HXLINE( 679)		Float dimY = (height - (( (Float)(2) ) * radius));
HXLINE( 680)		Float ax2 = x;
HXDLIN( 680)		Float ay2 = ay;
HXDLIN( 680)		Float bx2 = (x + radius);
HXDLIN( 680)		Float by2 = ay2;
HXDLIN( 680)		Float cx2 = bx2;
HXDLIN( 680)		Float cy2 = (ay2 + dimY);
HXDLIN( 680)		Float dx2 = x;
HXDLIN( 680)		Float dy2 = cy2;
HXDLIN( 680)		{
HXLINE( 680)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax2,ay2,0,bx2,by2,0,dx2,dy2,0);
HXDLIN( 680)			 ::trilateral3::matrix::MatrixDozen m2 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 680)			if (::hx::IsNotNull( m2 )) {
HXLINE( 680)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m2);
            			}
HXDLIN( 680)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 680)		{
HXLINE( 680)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx2,by2,0,cx2,cy2,0,dx2,dy2,0);
HXDLIN( 680)			 ::trilateral3::matrix::MatrixDozen m3 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 680)			if (::hx::IsNotNull( m3 )) {
HXLINE( 680)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m3);
            			}
HXDLIN( 680)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 680)		count = (count + 2);
HXLINE( 681)		Float ax3 = bx;
HXDLIN( 681)		Float ay3 = by;
HXDLIN( 681)		Float bx3 = (bx + radius);
HXDLIN( 681)		Float by3 = ay3;
HXDLIN( 681)		Float cx3 = bx3;
HXDLIN( 681)		Float cy3 = (ay3 + dimY);
HXDLIN( 681)		Float dx3 = bx;
HXDLIN( 681)		Float dy3 = cy3;
HXDLIN( 681)		{
HXLINE( 681)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax3,ay3,0,bx3,by3,0,dx3,dy3,0);
HXDLIN( 681)			 ::trilateral3::matrix::MatrixDozen m4 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 681)			if (::hx::IsNotNull( m4 )) {
HXLINE( 681)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m4);
            			}
HXDLIN( 681)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 681)		{
HXLINE( 681)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx3,by3,0,cx3,cy3,0,dx3,dy3,0);
HXDLIN( 681)			 ::trilateral3::matrix::MatrixDozen m5 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 681)			if (::hx::IsNotNull( m5 )) {
HXLINE( 681)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m5);
            			}
HXDLIN( 681)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 681)		count = (count + 2);
HXLINE( 682)		Float beta = -(pi);
HXDLIN( 682)		Float gamma = -(pi_2);
HXDLIN( 682)		Float pi1 = ::Math_obj::PI;
HXDLIN( 682)		Float step = ((pi1 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 682)		Float dif;
HXDLIN( 682)		switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 682)				Float f;
HXDLIN( 682)				bool f1;
HXDLIN( 682)				if ((beta >= 0)) {
HXLINE( 682)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 682)					f1 = false;
            				}
HXDLIN( 682)				if (f1) {
HXLINE( 682)					f = beta;
            				}
            				else {
HXLINE( 682)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 682)					if ((a >= 0)) {
HXLINE( 682)						f = a;
            					}
            					else {
HXLINE( 682)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 682)				Float this1 = f;
HXDLIN( 682)				Float za = this1;
HXDLIN( 682)				Float f2;
HXDLIN( 682)				bool f3;
HXDLIN( 682)				if ((gamma >= 0)) {
HXLINE( 682)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 682)					f3 = false;
            				}
HXDLIN( 682)				if (f3) {
HXLINE( 682)					f2 = gamma;
            				}
            				else {
HXLINE( 682)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 682)					if ((a >= 0)) {
HXLINE( 682)						f2 = a;
            					}
            					else {
HXLINE( 682)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 682)				Float this2 = f2;
HXDLIN( 682)				Float zb = this2;
HXDLIN( 682)				Float fa = za;
HXDLIN( 682)				Float fb = zb;
HXDLIN( 682)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 682)				bool clockwise = (fa < fb);
HXDLIN( 682)				Float dif1;
HXDLIN( 682)				if (clockwise) {
HXLINE( 682)					dif1 = theta;
            				}
            				else {
HXLINE( 682)					dif1 = -(theta);
            				}
HXDLIN( 682)				if ((dif1 > 0)) {
HXLINE( 682)					dif = dif1;
            				}
            				else {
HXLINE( 682)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 682)				Float f;
HXDLIN( 682)				bool f1;
HXDLIN( 682)				if ((beta >= 0)) {
HXLINE( 682)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 682)					f1 = false;
            				}
HXDLIN( 682)				if (f1) {
HXLINE( 682)					f = beta;
            				}
            				else {
HXLINE( 682)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 682)					if ((a >= 0)) {
HXLINE( 682)						f = a;
            					}
            					else {
HXLINE( 682)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 682)				Float this1 = f;
HXDLIN( 682)				Float za = this1;
HXDLIN( 682)				Float f2;
HXDLIN( 682)				bool f3;
HXDLIN( 682)				if ((gamma >= 0)) {
HXLINE( 682)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 682)					f3 = false;
            				}
HXDLIN( 682)				if (f3) {
HXLINE( 682)					f2 = gamma;
            				}
            				else {
HXLINE( 682)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 682)					if ((a >= 0)) {
HXLINE( 682)						f2 = a;
            					}
            					else {
HXLINE( 682)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 682)				Float this2 = f2;
HXDLIN( 682)				Float zb = this2;
HXDLIN( 682)				Float fa = za;
HXDLIN( 682)				Float fb = zb;
HXDLIN( 682)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 682)				bool clockwise = (fa < fb);
HXDLIN( 682)				Float dif1;
HXDLIN( 682)				if (clockwise) {
HXLINE( 682)					dif1 = theta;
            				}
            				else {
HXLINE( 682)					dif1 = -(theta);
            				}
HXDLIN( 682)				if ((dif1 < 0)) {
HXLINE( 682)					dif = dif1;
            				}
            				else {
HXLINE( 682)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 682)				Float f;
HXDLIN( 682)				bool f1;
HXDLIN( 682)				if ((beta >= 0)) {
HXLINE( 682)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 682)					f1 = false;
            				}
HXDLIN( 682)				if (f1) {
HXLINE( 682)					f = beta;
            				}
            				else {
HXLINE( 682)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 682)					if ((a >= 0)) {
HXLINE( 682)						f = a;
            					}
            					else {
HXLINE( 682)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 682)				Float this1 = f;
HXDLIN( 682)				Float za = this1;
HXDLIN( 682)				Float f2;
HXDLIN( 682)				bool f3;
HXDLIN( 682)				if ((gamma >= 0)) {
HXLINE( 682)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 682)					f3 = false;
            				}
HXDLIN( 682)				if (f3) {
HXLINE( 682)					f2 = gamma;
            				}
            				else {
HXLINE( 682)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 682)					if ((a >= 0)) {
HXLINE( 682)						f2 = a;
            					}
            					else {
HXLINE( 682)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 682)				Float this2 = f2;
HXDLIN( 682)				Float zb = this2;
HXDLIN( 682)				Float fa = za;
HXDLIN( 682)				Float fb = zb;
HXDLIN( 682)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 682)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 682)				bool clockwise = (fa < fb);
HXDLIN( 682)				Float dif1;
HXDLIN( 682)				if (clockwise) {
HXLINE( 682)					dif1 = theta;
            				}
            				else {
HXLINE( 682)					dif1 = -(theta);
            				}
HXDLIN( 682)				if (smallest) {
HXLINE( 682)					dif = dif1;
            				}
            				else {
HXLINE( 682)					if (clockwise) {
HXLINE( 682)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 682)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 682)				Float f;
HXDLIN( 682)				bool f1;
HXDLIN( 682)				if ((beta >= 0)) {
HXLINE( 682)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 682)					f1 = false;
            				}
HXDLIN( 682)				if (f1) {
HXLINE( 682)					f = beta;
            				}
            				else {
HXLINE( 682)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 682)					if ((a >= 0)) {
HXLINE( 682)						f = a;
            					}
            					else {
HXLINE( 682)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 682)				Float this1 = f;
HXDLIN( 682)				Float za = this1;
HXDLIN( 682)				Float f2;
HXDLIN( 682)				bool f3;
HXDLIN( 682)				if ((gamma >= 0)) {
HXLINE( 682)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 682)					f3 = false;
            				}
HXDLIN( 682)				if (f3) {
HXLINE( 682)					f2 = gamma;
            				}
            				else {
HXLINE( 682)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 682)					if ((a >= 0)) {
HXLINE( 682)						f2 = a;
            					}
            					else {
HXLINE( 682)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 682)				Float this2 = f2;
HXDLIN( 682)				Float zb = this2;
HXDLIN( 682)				Float fa = za;
HXDLIN( 682)				Float fb = zb;
HXDLIN( 682)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 682)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 682)				bool clockwise = (fa < fb);
HXDLIN( 682)				Float dif1;
HXDLIN( 682)				if (clockwise) {
HXLINE( 682)					dif1 = theta;
            				}
            				else {
HXLINE( 682)					dif1 = -(theta);
            				}
HXDLIN( 682)				if (largest) {
HXLINE( 682)					dif = dif1;
            				}
            				else {
HXLINE( 682)					if (clockwise) {
HXLINE( 682)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 682)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 682)		bool positive = (dif >= 0);
HXDLIN( 682)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 682)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 682)		Float angle = beta;
HXDLIN( 682)		Float cx4;
HXDLIN( 682)		Float cy4;
HXDLIN( 682)		Float bx4 = ( (Float)(0) );
HXDLIN( 682)		Float by4 = ( (Float)(0) );
HXDLIN( 682)		{
HXLINE( 682)			int _g = 0;
HXDLIN( 682)			int _g1 = (totalSteps + 1);
HXDLIN( 682)			while((_g < _g1)){
HXLINE( 682)				_g = (_g + 1);
HXDLIN( 682)				int i = (_g - 1);
HXDLIN( 682)				cx4 = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 682)				cy4 = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 682)				if ((i != 0)) {
HXLINE( 682)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax,ay,0,bx4,by4,0,cx4,cy4,0);
HXDLIN( 682)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 682)					if (::hx::IsNotNull( m )) {
HXLINE( 682)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 682)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 682)				angle = (angle + step1);
HXDLIN( 682)				bx4 = cx4;
HXDLIN( 682)				by4 = cy4;
            			}
            		}
HXDLIN( 682)		count = (count + totalSteps);
HXLINE( 683)		Float pi2 = ::Math_obj::PI;
HXDLIN( 683)		Float step2 = ((pi2 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 683)		Float dif1;
HXDLIN( 683)		switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 683)				Float f;
HXDLIN( 683)				bool f1;
HXDLIN( 683)				if ((pi_2 >= 0)) {
HXLINE( 683)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 683)					f1 = false;
            				}
HXDLIN( 683)				if (f1) {
HXLINE( 683)					f = pi_2;
            				}
            				else {
HXLINE( 683)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 683)					if ((a >= 0)) {
HXLINE( 683)						f = a;
            					}
            					else {
HXLINE( 683)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 683)				Float this1 = f;
HXDLIN( 683)				Float za = this1;
HXDLIN( 683)				Float f2;
HXDLIN( 683)				bool f3;
HXDLIN( 683)				if ((pi >= 0)) {
HXLINE( 683)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 683)					f3 = false;
            				}
HXDLIN( 683)				if (f3) {
HXLINE( 683)					f2 = pi;
            				}
            				else {
HXLINE( 683)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 683)					if ((a >= 0)) {
HXLINE( 683)						f2 = a;
            					}
            					else {
HXLINE( 683)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 683)				Float this2 = f2;
HXDLIN( 683)				Float zb = this2;
HXDLIN( 683)				Float fa = za;
HXDLIN( 683)				Float fb = zb;
HXDLIN( 683)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 683)				bool clockwise = (fa < fb);
HXDLIN( 683)				Float dif;
HXDLIN( 683)				if (clockwise) {
HXLINE( 683)					dif = theta;
            				}
            				else {
HXLINE( 683)					dif = -(theta);
            				}
HXDLIN( 683)				if ((dif > 0)) {
HXLINE( 683)					dif1 = dif;
            				}
            				else {
HXLINE( 683)					dif1 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 683)				Float f;
HXDLIN( 683)				bool f1;
HXDLIN( 683)				if ((pi_2 >= 0)) {
HXLINE( 683)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 683)					f1 = false;
            				}
HXDLIN( 683)				if (f1) {
HXLINE( 683)					f = pi_2;
            				}
            				else {
HXLINE( 683)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 683)					if ((a >= 0)) {
HXLINE( 683)						f = a;
            					}
            					else {
HXLINE( 683)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 683)				Float this1 = f;
HXDLIN( 683)				Float za = this1;
HXDLIN( 683)				Float f2;
HXDLIN( 683)				bool f3;
HXDLIN( 683)				if ((pi >= 0)) {
HXLINE( 683)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 683)					f3 = false;
            				}
HXDLIN( 683)				if (f3) {
HXLINE( 683)					f2 = pi;
            				}
            				else {
HXLINE( 683)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 683)					if ((a >= 0)) {
HXLINE( 683)						f2 = a;
            					}
            					else {
HXLINE( 683)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 683)				Float this2 = f2;
HXDLIN( 683)				Float zb = this2;
HXDLIN( 683)				Float fa = za;
HXDLIN( 683)				Float fb = zb;
HXDLIN( 683)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 683)				bool clockwise = (fa < fb);
HXDLIN( 683)				Float dif;
HXDLIN( 683)				if (clockwise) {
HXLINE( 683)					dif = theta;
            				}
            				else {
HXLINE( 683)					dif = -(theta);
            				}
HXDLIN( 683)				if ((dif < 0)) {
HXLINE( 683)					dif1 = dif;
            				}
            				else {
HXLINE( 683)					dif1 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 683)				Float f;
HXDLIN( 683)				bool f1;
HXDLIN( 683)				if ((pi_2 >= 0)) {
HXLINE( 683)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 683)					f1 = false;
            				}
HXDLIN( 683)				if (f1) {
HXLINE( 683)					f = pi_2;
            				}
            				else {
HXLINE( 683)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 683)					if ((a >= 0)) {
HXLINE( 683)						f = a;
            					}
            					else {
HXLINE( 683)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 683)				Float this1 = f;
HXDLIN( 683)				Float za = this1;
HXDLIN( 683)				Float f2;
HXDLIN( 683)				bool f3;
HXDLIN( 683)				if ((pi >= 0)) {
HXLINE( 683)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 683)					f3 = false;
            				}
HXDLIN( 683)				if (f3) {
HXLINE( 683)					f2 = pi;
            				}
            				else {
HXLINE( 683)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 683)					if ((a >= 0)) {
HXLINE( 683)						f2 = a;
            					}
            					else {
HXLINE( 683)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 683)				Float this2 = f2;
HXDLIN( 683)				Float zb = this2;
HXDLIN( 683)				Float fa = za;
HXDLIN( 683)				Float fb = zb;
HXDLIN( 683)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 683)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 683)				bool clockwise = (fa < fb);
HXDLIN( 683)				Float dif;
HXDLIN( 683)				if (clockwise) {
HXLINE( 683)					dif = theta;
            				}
            				else {
HXLINE( 683)					dif = -(theta);
            				}
HXDLIN( 683)				if (smallest) {
HXLINE( 683)					dif1 = dif;
            				}
            				else {
HXLINE( 683)					if (clockwise) {
HXLINE( 683)						dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 683)						dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 683)				Float f;
HXDLIN( 683)				bool f1;
HXDLIN( 683)				if ((pi_2 >= 0)) {
HXLINE( 683)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 683)					f1 = false;
            				}
HXDLIN( 683)				if (f1) {
HXLINE( 683)					f = pi_2;
            				}
            				else {
HXLINE( 683)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 683)					if ((a >= 0)) {
HXLINE( 683)						f = a;
            					}
            					else {
HXLINE( 683)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 683)				Float this1 = f;
HXDLIN( 683)				Float za = this1;
HXDLIN( 683)				Float f2;
HXDLIN( 683)				bool f3;
HXDLIN( 683)				if ((pi >= 0)) {
HXLINE( 683)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 683)					f3 = false;
            				}
HXDLIN( 683)				if (f3) {
HXLINE( 683)					f2 = pi;
            				}
            				else {
HXLINE( 683)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 683)					if ((a >= 0)) {
HXLINE( 683)						f2 = a;
            					}
            					else {
HXLINE( 683)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 683)				Float this2 = f2;
HXDLIN( 683)				Float zb = this2;
HXDLIN( 683)				Float fa = za;
HXDLIN( 683)				Float fb = zb;
HXDLIN( 683)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 683)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 683)				bool clockwise = (fa < fb);
HXDLIN( 683)				Float dif;
HXDLIN( 683)				if (clockwise) {
HXLINE( 683)					dif = theta;
            				}
            				else {
HXLINE( 683)					dif = -(theta);
            				}
HXDLIN( 683)				if (largest) {
HXLINE( 683)					dif1 = dif;
            				}
            				else {
HXLINE( 683)					if (clockwise) {
HXLINE( 683)						dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 683)						dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 683)		bool positive1 = (dif1 >= 0);
HXDLIN( 683)		int totalSteps1 = ::Math_obj::ceil((::Math_obj::abs(dif1) / step2));
HXDLIN( 683)		Float step3 = (dif1 / ( (Float)(totalSteps1) ));
HXDLIN( 683)		Float angle1 = pi_2;
HXDLIN( 683)		Float cx5;
HXDLIN( 683)		Float cy5;
HXDLIN( 683)		Float bx5 = ( (Float)(0) );
HXDLIN( 683)		Float by5 = ( (Float)(0) );
HXDLIN( 683)		{
HXLINE( 683)			int _g2 = 0;
HXDLIN( 683)			int _g3 = (totalSteps1 + 1);
HXDLIN( 683)			while((_g2 < _g3)){
HXLINE( 683)				_g2 = (_g2 + 1);
HXDLIN( 683)				int i = (_g2 - 1);
HXDLIN( 683)				cx5 = (bx + (radius * ::Math_obj::sin(angle1)));
HXDLIN( 683)				cy5 = (by + (radius * ::Math_obj::cos(angle1)));
HXDLIN( 683)				if ((i != 0)) {
HXLINE( 683)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,bx5,by5,0,cx5,cy5,0);
HXDLIN( 683)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 683)					if (::hx::IsNotNull( m )) {
HXLINE( 683)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 683)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 683)				angle1 = (angle1 + step3);
HXDLIN( 683)				bx5 = cx5;
HXDLIN( 683)				by5 = cy5;
            			}
            		}
HXDLIN( 683)		count = (count + totalSteps1);
HXLINE( 684)		Float pi3 = ::Math_obj::PI;
HXDLIN( 684)		Float step4 = ((pi3 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 684)		Float dif2;
HXDLIN( 684)		switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 684)				Float f;
HXDLIN( 684)				bool f1;
HXDLIN( 684)				if ((pi_2 >= 0)) {
HXLINE( 684)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 684)					f1 = false;
            				}
HXDLIN( 684)				if (f1) {
HXLINE( 684)					f = pi_2;
            				}
            				else {
HXLINE( 684)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 684)					if ((a >= 0)) {
HXLINE( 684)						f = a;
            					}
            					else {
HXLINE( 684)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 684)				Float this1 = f;
HXDLIN( 684)				Float za = this1;
HXDLIN( 684)				Float f2;
HXDLIN( 684)				if ((0 > ::Math_obj::PI)) {
HXLINE( 684)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 684)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 684)					if ((a >= 0)) {
HXLINE( 684)						f2 = a;
            					}
            					else {
HXLINE( 684)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 684)				Float this2 = f2;
HXDLIN( 684)				Float zb = this2;
HXDLIN( 684)				Float fa = za;
HXDLIN( 684)				Float fb = zb;
HXDLIN( 684)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 684)				bool clockwise = (fa < fb);
HXDLIN( 684)				Float dif;
HXDLIN( 684)				if (clockwise) {
HXLINE( 684)					dif = theta;
            				}
            				else {
HXLINE( 684)					dif = -(theta);
            				}
HXDLIN( 684)				if ((dif > 0)) {
HXLINE( 684)					dif2 = dif;
            				}
            				else {
HXLINE( 684)					dif2 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 684)				Float f;
HXDLIN( 684)				bool f1;
HXDLIN( 684)				if ((pi_2 >= 0)) {
HXLINE( 684)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 684)					f1 = false;
            				}
HXDLIN( 684)				if (f1) {
HXLINE( 684)					f = pi_2;
            				}
            				else {
HXLINE( 684)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 684)					if ((a >= 0)) {
HXLINE( 684)						f = a;
            					}
            					else {
HXLINE( 684)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 684)				Float this1 = f;
HXDLIN( 684)				Float za = this1;
HXDLIN( 684)				Float f2;
HXDLIN( 684)				if ((0 > ::Math_obj::PI)) {
HXLINE( 684)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 684)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 684)					if ((a >= 0)) {
HXLINE( 684)						f2 = a;
            					}
            					else {
HXLINE( 684)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 684)				Float this2 = f2;
HXDLIN( 684)				Float zb = this2;
HXDLIN( 684)				Float fa = za;
HXDLIN( 684)				Float fb = zb;
HXDLIN( 684)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 684)				bool clockwise = (fa < fb);
HXDLIN( 684)				Float dif;
HXDLIN( 684)				if (clockwise) {
HXLINE( 684)					dif = theta;
            				}
            				else {
HXLINE( 684)					dif = -(theta);
            				}
HXDLIN( 684)				if ((dif < 0)) {
HXLINE( 684)					dif2 = dif;
            				}
            				else {
HXLINE( 684)					dif2 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 684)				Float f;
HXDLIN( 684)				bool f1;
HXDLIN( 684)				if ((pi_2 >= 0)) {
HXLINE( 684)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 684)					f1 = false;
            				}
HXDLIN( 684)				if (f1) {
HXLINE( 684)					f = pi_2;
            				}
            				else {
HXLINE( 684)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 684)					if ((a >= 0)) {
HXLINE( 684)						f = a;
            					}
            					else {
HXLINE( 684)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 684)				Float this1 = f;
HXDLIN( 684)				Float za = this1;
HXDLIN( 684)				Float f2;
HXDLIN( 684)				if ((0 > ::Math_obj::PI)) {
HXLINE( 684)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 684)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 684)					if ((a >= 0)) {
HXLINE( 684)						f2 = a;
            					}
            					else {
HXLINE( 684)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 684)				Float this2 = f2;
HXDLIN( 684)				Float zb = this2;
HXDLIN( 684)				Float fa = za;
HXDLIN( 684)				Float fb = zb;
HXDLIN( 684)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 684)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 684)				bool clockwise = (fa < fb);
HXDLIN( 684)				Float dif;
HXDLIN( 684)				if (clockwise) {
HXLINE( 684)					dif = theta;
            				}
            				else {
HXLINE( 684)					dif = -(theta);
            				}
HXDLIN( 684)				if (smallest) {
HXLINE( 684)					dif2 = dif;
            				}
            				else {
HXLINE( 684)					if (clockwise) {
HXLINE( 684)						dif2 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 684)						dif2 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 684)				Float f;
HXDLIN( 684)				bool f1;
HXDLIN( 684)				if ((pi_2 >= 0)) {
HXLINE( 684)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 684)					f1 = false;
            				}
HXDLIN( 684)				if (f1) {
HXLINE( 684)					f = pi_2;
            				}
            				else {
HXLINE( 684)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 684)					if ((a >= 0)) {
HXLINE( 684)						f = a;
            					}
            					else {
HXLINE( 684)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 684)				Float this1 = f;
HXDLIN( 684)				Float za = this1;
HXDLIN( 684)				Float f2;
HXDLIN( 684)				if ((0 > ::Math_obj::PI)) {
HXLINE( 684)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 684)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 684)					if ((a >= 0)) {
HXLINE( 684)						f2 = a;
            					}
            					else {
HXLINE( 684)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 684)				Float this2 = f2;
HXDLIN( 684)				Float zb = this2;
HXDLIN( 684)				Float fa = za;
HXDLIN( 684)				Float fb = zb;
HXDLIN( 684)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 684)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 684)				bool clockwise = (fa < fb);
HXDLIN( 684)				Float dif;
HXDLIN( 684)				if (clockwise) {
HXLINE( 684)					dif = theta;
            				}
            				else {
HXLINE( 684)					dif = -(theta);
            				}
HXDLIN( 684)				if (largest) {
HXLINE( 684)					dif2 = dif;
            				}
            				else {
HXLINE( 684)					if (clockwise) {
HXLINE( 684)						dif2 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 684)						dif2 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 684)		bool positive2 = (dif2 >= 0);
HXDLIN( 684)		int totalSteps2 = ::Math_obj::ceil((::Math_obj::abs(dif2) / step4));
HXDLIN( 684)		Float step5 = (dif2 / ( (Float)(totalSteps2) ));
HXDLIN( 684)		Float angle2 = pi_2;
HXDLIN( 684)		Float cx6;
HXDLIN( 684)		Float cy6;
HXDLIN( 684)		Float bx6 = ( (Float)(0) );
HXDLIN( 684)		Float by6 = ( (Float)(0) );
HXDLIN( 684)		{
HXLINE( 684)			int _g4 = 0;
HXDLIN( 684)			int _g5 = (totalSteps2 + 1);
HXDLIN( 684)			while((_g4 < _g5)){
HXLINE( 684)				_g4 = (_g4 + 1);
HXDLIN( 684)				int i = (_g4 - 1);
HXDLIN( 684)				cx6 = (cx + (radius * ::Math_obj::sin(angle2)));
HXDLIN( 684)				cy6 = (cy + (radius * ::Math_obj::cos(angle2)));
HXDLIN( 684)				if ((i != 0)) {
HXLINE( 684)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(cx,cy,0,bx6,by6,0,cx6,cy6,0);
HXDLIN( 684)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 684)					if (::hx::IsNotNull( m )) {
HXLINE( 684)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 684)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 684)				angle2 = (angle2 + step5);
HXDLIN( 684)				bx6 = cx6;
HXDLIN( 684)				by6 = cy6;
            			}
            		}
HXDLIN( 684)		count = (count + totalSteps2);
HXLINE( 685)		Float gamma1 = -(pi_2);
HXDLIN( 685)		Float pi4 = ::Math_obj::PI;
HXDLIN( 685)		Float step6 = ((pi4 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 685)		Float dif3;
HXDLIN( 685)		switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 685)				Float f;
HXDLIN( 685)				if ((0 > ::Math_obj::PI)) {
HXLINE( 685)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 685)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 685)					if ((a >= 0)) {
HXLINE( 685)						f = a;
            					}
            					else {
HXLINE( 685)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 685)				Float this1 = f;
HXDLIN( 685)				Float za = this1;
HXDLIN( 685)				Float f1;
HXDLIN( 685)				bool f2;
HXDLIN( 685)				if ((gamma1 >= 0)) {
HXLINE( 685)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 685)					f2 = false;
            				}
HXDLIN( 685)				if (f2) {
HXLINE( 685)					f1 = gamma1;
            				}
            				else {
HXLINE( 685)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 685)					if ((a >= 0)) {
HXLINE( 685)						f1 = a;
            					}
            					else {
HXLINE( 685)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 685)				Float this2 = f1;
HXDLIN( 685)				Float zb = this2;
HXDLIN( 685)				Float fa = za;
HXDLIN( 685)				Float fb = zb;
HXDLIN( 685)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 685)				bool clockwise = (fa < fb);
HXDLIN( 685)				Float dif;
HXDLIN( 685)				if (clockwise) {
HXLINE( 685)					dif = theta;
            				}
            				else {
HXLINE( 685)					dif = -(theta);
            				}
HXDLIN( 685)				if ((dif > 0)) {
HXLINE( 685)					dif3 = dif;
            				}
            				else {
HXLINE( 685)					dif3 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 685)				Float f;
HXDLIN( 685)				if ((0 > ::Math_obj::PI)) {
HXLINE( 685)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 685)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 685)					if ((a >= 0)) {
HXLINE( 685)						f = a;
            					}
            					else {
HXLINE( 685)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 685)				Float this1 = f;
HXDLIN( 685)				Float za = this1;
HXDLIN( 685)				Float f1;
HXDLIN( 685)				bool f2;
HXDLIN( 685)				if ((gamma1 >= 0)) {
HXLINE( 685)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 685)					f2 = false;
            				}
HXDLIN( 685)				if (f2) {
HXLINE( 685)					f1 = gamma1;
            				}
            				else {
HXLINE( 685)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 685)					if ((a >= 0)) {
HXLINE( 685)						f1 = a;
            					}
            					else {
HXLINE( 685)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 685)				Float this2 = f1;
HXDLIN( 685)				Float zb = this2;
HXDLIN( 685)				Float fa = za;
HXDLIN( 685)				Float fb = zb;
HXDLIN( 685)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 685)				bool clockwise = (fa < fb);
HXDLIN( 685)				Float dif;
HXDLIN( 685)				if (clockwise) {
HXLINE( 685)					dif = theta;
            				}
            				else {
HXLINE( 685)					dif = -(theta);
            				}
HXDLIN( 685)				if ((dif < 0)) {
HXLINE( 685)					dif3 = dif;
            				}
            				else {
HXLINE( 685)					dif3 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 685)				Float f;
HXDLIN( 685)				if ((0 > ::Math_obj::PI)) {
HXLINE( 685)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 685)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 685)					if ((a >= 0)) {
HXLINE( 685)						f = a;
            					}
            					else {
HXLINE( 685)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 685)				Float this1 = f;
HXDLIN( 685)				Float za = this1;
HXDLIN( 685)				Float f1;
HXDLIN( 685)				bool f2;
HXDLIN( 685)				if ((gamma1 >= 0)) {
HXLINE( 685)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 685)					f2 = false;
            				}
HXDLIN( 685)				if (f2) {
HXLINE( 685)					f1 = gamma1;
            				}
            				else {
HXLINE( 685)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 685)					if ((a >= 0)) {
HXLINE( 685)						f1 = a;
            					}
            					else {
HXLINE( 685)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 685)				Float this2 = f1;
HXDLIN( 685)				Float zb = this2;
HXDLIN( 685)				Float fa = za;
HXDLIN( 685)				Float fb = zb;
HXDLIN( 685)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 685)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 685)				bool clockwise = (fa < fb);
HXDLIN( 685)				Float dif;
HXDLIN( 685)				if (clockwise) {
HXLINE( 685)					dif = theta;
            				}
            				else {
HXLINE( 685)					dif = -(theta);
            				}
HXDLIN( 685)				if (smallest) {
HXLINE( 685)					dif3 = dif;
            				}
            				else {
HXLINE( 685)					if (clockwise) {
HXLINE( 685)						dif3 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 685)						dif3 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 685)				Float f;
HXDLIN( 685)				if ((0 > ::Math_obj::PI)) {
HXLINE( 685)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 685)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 685)					if ((a >= 0)) {
HXLINE( 685)						f = a;
            					}
            					else {
HXLINE( 685)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 685)				Float this1 = f;
HXDLIN( 685)				Float za = this1;
HXDLIN( 685)				Float f1;
HXDLIN( 685)				bool f2;
HXDLIN( 685)				if ((gamma1 >= 0)) {
HXLINE( 685)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 685)					f2 = false;
            				}
HXDLIN( 685)				if (f2) {
HXLINE( 685)					f1 = gamma1;
            				}
            				else {
HXLINE( 685)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 685)					if ((a >= 0)) {
HXLINE( 685)						f1 = a;
            					}
            					else {
HXLINE( 685)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 685)				Float this2 = f1;
HXDLIN( 685)				Float zb = this2;
HXDLIN( 685)				Float fa = za;
HXDLIN( 685)				Float fb = zb;
HXDLIN( 685)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 685)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 685)				bool clockwise = (fa < fb);
HXDLIN( 685)				Float dif;
HXDLIN( 685)				if (clockwise) {
HXLINE( 685)					dif = theta;
            				}
            				else {
HXLINE( 685)					dif = -(theta);
            				}
HXDLIN( 685)				if (largest) {
HXLINE( 685)					dif3 = dif;
            				}
            				else {
HXLINE( 685)					if (clockwise) {
HXLINE( 685)						dif3 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 685)						dif3 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 685)		bool positive3 = (dif3 >= 0);
HXDLIN( 685)		int totalSteps3 = ::Math_obj::ceil((::Math_obj::abs(dif3) / step6));
HXDLIN( 685)		Float step7 = (dif3 / ( (Float)(totalSteps3) ));
HXDLIN( 685)		Float angle3 = ( (Float)(0) );
HXDLIN( 685)		Float cx7;
HXDLIN( 685)		Float cy7;
HXDLIN( 685)		Float bx7 = ( (Float)(0) );
HXDLIN( 685)		Float by7 = ( (Float)(0) );
HXDLIN( 685)		{
HXLINE( 685)			int _g6 = 0;
HXDLIN( 685)			int _g7 = (totalSteps3 + 1);
HXDLIN( 685)			while((_g6 < _g7)){
HXLINE( 685)				_g6 = (_g6 + 1);
HXDLIN( 685)				int i = (_g6 - 1);
HXDLIN( 685)				cx7 = (dx + (radius * ::Math_obj::sin(angle3)));
HXDLIN( 685)				cy7 = (dy + (radius * ::Math_obj::cos(angle3)));
HXDLIN( 685)				if ((i != 0)) {
HXLINE( 685)					drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx,dy,0,bx7,by7,0,cx7,cy7,0);
HXDLIN( 685)					 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 685)					if (::hx::IsNotNull( m )) {
HXLINE( 685)						drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            					}
HXDLIN( 685)					drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            				}
HXDLIN( 685)				angle3 = (angle3 + step7);
HXDLIN( 685)				bx7 = cx7;
HXDLIN( 685)				by7 = cy7;
            			}
            		}
HXDLIN( 685)		count = (count + totalSteps3);
HXLINE( 686)		return count;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Shaper_Fields__obj,roundedRectangle,return )

int Shaper_Fields__obj::roundedRectangleOutline( ::Dynamic drawType,Float x,Float y,Float width,Float height,Float thick,Float radius){
            	HX_STACKFRAME(&_hx_pos_4887c4b26886bcef_692_roundedRectangleOutline)
HXLINE( 697)		Float pi = ::Math_obj::PI;
HXLINE( 698)		Float pi_2 = (::Math_obj::PI / ( (Float)(2) ));
HXLINE( 699)		Float ax = (x + radius);
HXLINE( 700)		Float ay = (y + radius);
HXLINE( 701)		Float bx = ((x + width) - radius);
HXLINE( 702)		Float by = (y + radius);
HXLINE( 703)		Float cx = bx;
HXLINE( 704)		Float cy = ((y + height) - radius);
HXLINE( 705)		Float dx = ax;
HXLINE( 706)		Float dy = cy;
HXLINE( 707)		int count = 0;
HXLINE( 708)		Float ax1 = ax;
HXDLIN( 708)		Float ay1 = y;
HXDLIN( 708)		Float bx1 = (ax + (width - (radius * ( (Float)(2) ))));
HXDLIN( 708)		Float by1 = ay1;
HXDLIN( 708)		Float cx1 = bx1;
HXDLIN( 708)		Float cy1 = (ay1 + thick);
HXDLIN( 708)		Float dx1 = ax;
HXDLIN( 708)		Float dy1 = cy1;
HXDLIN( 708)		{
HXLINE( 708)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax1,ay1,0,bx1,by1,0,dx1,dy1,0);
HXDLIN( 708)			 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 708)			if (::hx::IsNotNull( m )) {
HXLINE( 708)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            			}
HXDLIN( 708)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 708)		{
HXLINE( 708)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx1,by1,0,cx1,cy1,0,dx1,dy1,0);
HXDLIN( 708)			 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 708)			if (::hx::IsNotNull( m1 )) {
HXLINE( 708)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            			}
HXDLIN( 708)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 708)		count = (count + 2);
HXLINE( 709)		Float ax2 = ax;
HXDLIN( 709)		Float ay2 = ((y + height) - thick);
HXDLIN( 709)		Float bx2 = (ax + (width - (radius * ( (Float)(2) ))));
HXDLIN( 709)		Float by2 = ay2;
HXDLIN( 709)		Float cx2 = bx2;
HXDLIN( 709)		Float cy2 = (ay2 + thick);
HXDLIN( 709)		Float dx2 = ax;
HXDLIN( 709)		Float dy2 = cy2;
HXDLIN( 709)		{
HXLINE( 709)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax2,ay2,0,bx2,by2,0,dx2,dy2,0);
HXDLIN( 709)			 ::trilateral3::matrix::MatrixDozen m2 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 709)			if (::hx::IsNotNull( m2 )) {
HXLINE( 709)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m2);
            			}
HXDLIN( 709)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 709)		{
HXLINE( 709)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx2,by2,0,cx2,cy2,0,dx2,dy2,0);
HXDLIN( 709)			 ::trilateral3::matrix::MatrixDozen m3 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 709)			if (::hx::IsNotNull( m3 )) {
HXLINE( 709)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m3);
            			}
HXDLIN( 709)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 709)		count = (count + 2);
HXLINE( 710)		Float dimY = (height - (( (Float)(2) ) * radius));
HXLINE( 711)		Float ax3 = x;
HXDLIN( 711)		Float ay3 = ay;
HXDLIN( 711)		Float bx3 = (x + thick);
HXDLIN( 711)		Float by3 = ay3;
HXDLIN( 711)		Float cx3 = bx3;
HXDLIN( 711)		Float cy3 = (ay3 + dimY);
HXDLIN( 711)		Float dx3 = x;
HXDLIN( 711)		Float dy3 = cy3;
HXDLIN( 711)		{
HXLINE( 711)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax3,ay3,0,bx3,by3,0,dx3,dy3,0);
HXDLIN( 711)			 ::trilateral3::matrix::MatrixDozen m4 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 711)			if (::hx::IsNotNull( m4 )) {
HXLINE( 711)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m4);
            			}
HXDLIN( 711)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 711)		{
HXLINE( 711)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx3,by3,0,cx3,cy3,0,dx3,dy3,0);
HXDLIN( 711)			 ::trilateral3::matrix::MatrixDozen m5 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 711)			if (::hx::IsNotNull( m5 )) {
HXLINE( 711)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m5);
            			}
HXDLIN( 711)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 711)		count = (count + 2);
HXLINE( 712)		Float x1 = ((x + width) - thick);
HXDLIN( 712)		Float ax4 = x1;
HXDLIN( 712)		Float ay4 = by;
HXDLIN( 712)		Float bx4 = (x1 + thick);
HXDLIN( 712)		Float by4 = ay4;
HXDLIN( 712)		Float cx4 = bx4;
HXDLIN( 712)		Float cy4 = (ay4 + dimY);
HXDLIN( 712)		Float dx4 = x1;
HXDLIN( 712)		Float dy4 = cy4;
HXDLIN( 712)		{
HXLINE( 712)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(ax4,ay4,0,bx4,by4,0,dx4,dy4,0);
HXDLIN( 712)			 ::trilateral3::matrix::MatrixDozen m6 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 712)			if (::hx::IsNotNull( m6 )) {
HXLINE( 712)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m6);
            			}
HXDLIN( 712)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 712)		{
HXLINE( 712)			drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx4,by4,0,cx4,cy4,0,dx4,dy4,0);
HXDLIN( 712)			 ::trilateral3::matrix::MatrixDozen m7 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 712)			if (::hx::IsNotNull( m7 )) {
HXLINE( 712)				drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m7);
            			}
HXDLIN( 712)			drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            		}
HXDLIN( 712)		count = (count + 2);
HXLINE( 713)		Float beta = -(pi);
HXDLIN( 713)		Float gamma = -(pi_2);
HXDLIN( 713)		Float pi1 = ::Math_obj::PI;
HXDLIN( 713)		Float step = ((pi1 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 713)		Float dif;
HXDLIN( 713)		switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 713)				Float f;
HXDLIN( 713)				bool f1;
HXDLIN( 713)				if ((beta >= 0)) {
HXLINE( 713)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 713)					f1 = false;
            				}
HXDLIN( 713)				if (f1) {
HXLINE( 713)					f = beta;
            				}
            				else {
HXLINE( 713)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 713)					if ((a >= 0)) {
HXLINE( 713)						f = a;
            					}
            					else {
HXLINE( 713)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 713)				Float this1 = f;
HXDLIN( 713)				Float za = this1;
HXDLIN( 713)				Float f2;
HXDLIN( 713)				bool f3;
HXDLIN( 713)				if ((gamma >= 0)) {
HXLINE( 713)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 713)					f3 = false;
            				}
HXDLIN( 713)				if (f3) {
HXLINE( 713)					f2 = gamma;
            				}
            				else {
HXLINE( 713)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 713)					if ((a >= 0)) {
HXLINE( 713)						f2 = a;
            					}
            					else {
HXLINE( 713)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 713)				Float this2 = f2;
HXDLIN( 713)				Float zb = this2;
HXDLIN( 713)				Float fa = za;
HXDLIN( 713)				Float fb = zb;
HXDLIN( 713)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 713)				bool clockwise = (fa < fb);
HXDLIN( 713)				Float dif1;
HXDLIN( 713)				if (clockwise) {
HXLINE( 713)					dif1 = theta;
            				}
            				else {
HXLINE( 713)					dif1 = -(theta);
            				}
HXDLIN( 713)				if ((dif1 > 0)) {
HXLINE( 713)					dif = dif1;
            				}
            				else {
HXLINE( 713)					dif = ((( (Float)(2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 713)				Float f;
HXDLIN( 713)				bool f1;
HXDLIN( 713)				if ((beta >= 0)) {
HXLINE( 713)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 713)					f1 = false;
            				}
HXDLIN( 713)				if (f1) {
HXLINE( 713)					f = beta;
            				}
            				else {
HXLINE( 713)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 713)					if ((a >= 0)) {
HXLINE( 713)						f = a;
            					}
            					else {
HXLINE( 713)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 713)				Float this1 = f;
HXDLIN( 713)				Float za = this1;
HXDLIN( 713)				Float f2;
HXDLIN( 713)				bool f3;
HXDLIN( 713)				if ((gamma >= 0)) {
HXLINE( 713)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 713)					f3 = false;
            				}
HXDLIN( 713)				if (f3) {
HXLINE( 713)					f2 = gamma;
            				}
            				else {
HXLINE( 713)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 713)					if ((a >= 0)) {
HXLINE( 713)						f2 = a;
            					}
            					else {
HXLINE( 713)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 713)				Float this2 = f2;
HXDLIN( 713)				Float zb = this2;
HXDLIN( 713)				Float fa = za;
HXDLIN( 713)				Float fb = zb;
HXDLIN( 713)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 713)				bool clockwise = (fa < fb);
HXDLIN( 713)				Float dif1;
HXDLIN( 713)				if (clockwise) {
HXLINE( 713)					dif1 = theta;
            				}
            				else {
HXLINE( 713)					dif1 = -(theta);
            				}
HXDLIN( 713)				if ((dif1 < 0)) {
HXLINE( 713)					dif = dif1;
            				}
            				else {
HXLINE( 713)					dif = ((( (Float)(-2) ) * ::Math_obj::PI) + dif1);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 713)				Float f;
HXDLIN( 713)				bool f1;
HXDLIN( 713)				if ((beta >= 0)) {
HXLINE( 713)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 713)					f1 = false;
            				}
HXDLIN( 713)				if (f1) {
HXLINE( 713)					f = beta;
            				}
            				else {
HXLINE( 713)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 713)					if ((a >= 0)) {
HXLINE( 713)						f = a;
            					}
            					else {
HXLINE( 713)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 713)				Float this1 = f;
HXDLIN( 713)				Float za = this1;
HXDLIN( 713)				Float f2;
HXDLIN( 713)				bool f3;
HXDLIN( 713)				if ((gamma >= 0)) {
HXLINE( 713)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 713)					f3 = false;
            				}
HXDLIN( 713)				if (f3) {
HXLINE( 713)					f2 = gamma;
            				}
            				else {
HXLINE( 713)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 713)					if ((a >= 0)) {
HXLINE( 713)						f2 = a;
            					}
            					else {
HXLINE( 713)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 713)				Float this2 = f2;
HXDLIN( 713)				Float zb = this2;
HXDLIN( 713)				Float fa = za;
HXDLIN( 713)				Float fb = zb;
HXDLIN( 713)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 713)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 713)				bool clockwise = (fa < fb);
HXDLIN( 713)				Float dif1;
HXDLIN( 713)				if (clockwise) {
HXLINE( 713)					dif1 = theta;
            				}
            				else {
HXLINE( 713)					dif1 = -(theta);
            				}
HXDLIN( 713)				if (smallest) {
HXLINE( 713)					dif = dif1;
            				}
            				else {
HXLINE( 713)					if (clockwise) {
HXLINE( 713)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 713)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 713)				Float f;
HXDLIN( 713)				bool f1;
HXDLIN( 713)				if ((beta >= 0)) {
HXLINE( 713)					f1 = (beta > ::Math_obj::PI);
            				}
            				else {
HXLINE( 713)					f1 = false;
            				}
HXDLIN( 713)				if (f1) {
HXLINE( 713)					f = beta;
            				}
            				else {
HXLINE( 713)					Float a = ::hx::Mod(beta,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 713)					if ((a >= 0)) {
HXLINE( 713)						f = a;
            					}
            					else {
HXLINE( 713)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 713)				Float this1 = f;
HXDLIN( 713)				Float za = this1;
HXDLIN( 713)				Float f2;
HXDLIN( 713)				bool f3;
HXDLIN( 713)				if ((gamma >= 0)) {
HXLINE( 713)					f3 = (gamma > ::Math_obj::PI);
            				}
            				else {
HXLINE( 713)					f3 = false;
            				}
HXDLIN( 713)				if (f3) {
HXLINE( 713)					f2 = gamma;
            				}
            				else {
HXLINE( 713)					Float a = ::hx::Mod(gamma,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 713)					if ((a >= 0)) {
HXLINE( 713)						f2 = a;
            					}
            					else {
HXLINE( 713)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 713)				Float this2 = f2;
HXDLIN( 713)				Float zb = this2;
HXDLIN( 713)				Float fa = za;
HXDLIN( 713)				Float fb = zb;
HXDLIN( 713)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 713)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 713)				bool clockwise = (fa < fb);
HXDLIN( 713)				Float dif1;
HXDLIN( 713)				if (clockwise) {
HXLINE( 713)					dif1 = theta;
            				}
            				else {
HXLINE( 713)					dif1 = -(theta);
            				}
HXDLIN( 713)				if (largest) {
HXLINE( 713)					dif = dif1;
            				}
            				else {
HXLINE( 713)					if (clockwise) {
HXLINE( 713)						dif = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 713)						dif = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 713)		bool positive = (dif >= 0);
HXDLIN( 713)		int totalSteps = ::Math_obj::ceil((::Math_obj::abs(dif) / step));
HXDLIN( 713)		Float step1 = (dif / ( (Float)(totalSteps) ));
HXDLIN( 713)		Float angle = beta;
HXDLIN( 713)		Float cx5;
HXDLIN( 713)		Float cy5;
HXDLIN( 713)		Float bx5 = ( (Float)(0) );
HXDLIN( 713)		Float by5 = ( (Float)(0) );
HXDLIN( 713)		Float dx5 = ( (Float)(0) );
HXDLIN( 713)		Float dy5 = ( (Float)(0) );
HXDLIN( 713)		Float ex = ( (Float)(0) );
HXDLIN( 713)		Float ey = ( (Float)(0) );
HXDLIN( 713)		Float r2 = (radius - thick);
HXDLIN( 713)		{
HXLINE( 713)			int _g = 0;
HXDLIN( 713)			int _g1 = (totalSteps + 1);
HXDLIN( 713)			while((_g < _g1)){
HXLINE( 713)				_g = (_g + 1);
HXDLIN( 713)				int i = (_g - 1);
HXDLIN( 713)				cx5 = (ax + (radius * ::Math_obj::sin(angle)));
HXDLIN( 713)				cy5 = (ay + (radius * ::Math_obj::cos(angle)));
HXDLIN( 713)				ex = (ax + (r2 * ::Math_obj::sin(angle)));
HXDLIN( 713)				ey = (ay + (r2 * ::Math_obj::cos(angle)));
HXDLIN( 713)				if ((i != 0)) {
HXLINE( 713)					{
HXLINE( 713)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx5,dy5,0,bx5,by5,0,cx5,cy5,0);
HXDLIN( 713)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 713)						if (::hx::IsNotNull( m )) {
HXLINE( 713)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 713)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 713)					{
HXLINE( 713)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx5,dy5,0,cx5,cy5,0,ex,ey,0);
HXDLIN( 713)						 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 713)						if (::hx::IsNotNull( m1 )) {
HXLINE( 713)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            						}
HXDLIN( 713)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
HXDLIN( 713)				angle = (angle + step1);
HXDLIN( 713)				bx5 = cx5;
HXDLIN( 713)				by5 = cy5;
HXDLIN( 713)				dx5 = ex;
HXDLIN( 713)				dy5 = ey;
            			}
            		}
HXDLIN( 713)		count = (count + (totalSteps * 2));
HXLINE( 714)		Float pi2 = ::Math_obj::PI;
HXDLIN( 714)		Float step2 = ((pi2 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 714)		Float dif1;
HXDLIN( 714)		switch((int)(::fracs::DifferencePreference_obj::CLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 714)				Float f;
HXDLIN( 714)				bool f1;
HXDLIN( 714)				if ((pi_2 >= 0)) {
HXLINE( 714)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 714)					f1 = false;
            				}
HXDLIN( 714)				if (f1) {
HXLINE( 714)					f = pi_2;
            				}
            				else {
HXLINE( 714)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 714)					if ((a >= 0)) {
HXLINE( 714)						f = a;
            					}
            					else {
HXLINE( 714)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 714)				Float this1 = f;
HXDLIN( 714)				Float za = this1;
HXDLIN( 714)				Float f2;
HXDLIN( 714)				bool f3;
HXDLIN( 714)				if ((pi >= 0)) {
HXLINE( 714)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 714)					f3 = false;
            				}
HXDLIN( 714)				if (f3) {
HXLINE( 714)					f2 = pi;
            				}
            				else {
HXLINE( 714)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 714)					if ((a >= 0)) {
HXLINE( 714)						f2 = a;
            					}
            					else {
HXLINE( 714)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 714)				Float this2 = f2;
HXDLIN( 714)				Float zb = this2;
HXDLIN( 714)				Float fa = za;
HXDLIN( 714)				Float fb = zb;
HXDLIN( 714)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 714)				bool clockwise = (fa < fb);
HXDLIN( 714)				Float dif;
HXDLIN( 714)				if (clockwise) {
HXLINE( 714)					dif = theta;
            				}
            				else {
HXLINE( 714)					dif = -(theta);
            				}
HXDLIN( 714)				if ((dif > 0)) {
HXLINE( 714)					dif1 = dif;
            				}
            				else {
HXLINE( 714)					dif1 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 714)				Float f;
HXDLIN( 714)				bool f1;
HXDLIN( 714)				if ((pi_2 >= 0)) {
HXLINE( 714)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 714)					f1 = false;
            				}
HXDLIN( 714)				if (f1) {
HXLINE( 714)					f = pi_2;
            				}
            				else {
HXLINE( 714)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 714)					if ((a >= 0)) {
HXLINE( 714)						f = a;
            					}
            					else {
HXLINE( 714)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 714)				Float this1 = f;
HXDLIN( 714)				Float za = this1;
HXDLIN( 714)				Float f2;
HXDLIN( 714)				bool f3;
HXDLIN( 714)				if ((pi >= 0)) {
HXLINE( 714)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 714)					f3 = false;
            				}
HXDLIN( 714)				if (f3) {
HXLINE( 714)					f2 = pi;
            				}
            				else {
HXLINE( 714)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 714)					if ((a >= 0)) {
HXLINE( 714)						f2 = a;
            					}
            					else {
HXLINE( 714)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 714)				Float this2 = f2;
HXDLIN( 714)				Float zb = this2;
HXDLIN( 714)				Float fa = za;
HXDLIN( 714)				Float fb = zb;
HXDLIN( 714)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 714)				bool clockwise = (fa < fb);
HXDLIN( 714)				Float dif;
HXDLIN( 714)				if (clockwise) {
HXLINE( 714)					dif = theta;
            				}
            				else {
HXLINE( 714)					dif = -(theta);
            				}
HXDLIN( 714)				if ((dif < 0)) {
HXLINE( 714)					dif1 = dif;
            				}
            				else {
HXLINE( 714)					dif1 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 714)				Float f;
HXDLIN( 714)				bool f1;
HXDLIN( 714)				if ((pi_2 >= 0)) {
HXLINE( 714)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 714)					f1 = false;
            				}
HXDLIN( 714)				if (f1) {
HXLINE( 714)					f = pi_2;
            				}
            				else {
HXLINE( 714)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 714)					if ((a >= 0)) {
HXLINE( 714)						f = a;
            					}
            					else {
HXLINE( 714)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 714)				Float this1 = f;
HXDLIN( 714)				Float za = this1;
HXDLIN( 714)				Float f2;
HXDLIN( 714)				bool f3;
HXDLIN( 714)				if ((pi >= 0)) {
HXLINE( 714)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 714)					f3 = false;
            				}
HXDLIN( 714)				if (f3) {
HXLINE( 714)					f2 = pi;
            				}
            				else {
HXLINE( 714)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 714)					if ((a >= 0)) {
HXLINE( 714)						f2 = a;
            					}
            					else {
HXLINE( 714)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 714)				Float this2 = f2;
HXDLIN( 714)				Float zb = this2;
HXDLIN( 714)				Float fa = za;
HXDLIN( 714)				Float fb = zb;
HXDLIN( 714)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 714)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 714)				bool clockwise = (fa < fb);
HXDLIN( 714)				Float dif;
HXDLIN( 714)				if (clockwise) {
HXLINE( 714)					dif = theta;
            				}
            				else {
HXLINE( 714)					dif = -(theta);
            				}
HXDLIN( 714)				if (smallest) {
HXLINE( 714)					dif1 = dif;
            				}
            				else {
HXLINE( 714)					if (clockwise) {
HXLINE( 714)						dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 714)						dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 714)				Float f;
HXDLIN( 714)				bool f1;
HXDLIN( 714)				if ((pi_2 >= 0)) {
HXLINE( 714)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 714)					f1 = false;
            				}
HXDLIN( 714)				if (f1) {
HXLINE( 714)					f = pi_2;
            				}
            				else {
HXLINE( 714)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 714)					if ((a >= 0)) {
HXLINE( 714)						f = a;
            					}
            					else {
HXLINE( 714)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 714)				Float this1 = f;
HXDLIN( 714)				Float za = this1;
HXDLIN( 714)				Float f2;
HXDLIN( 714)				bool f3;
HXDLIN( 714)				if ((pi >= 0)) {
HXLINE( 714)					f3 = (pi > ::Math_obj::PI);
            				}
            				else {
HXLINE( 714)					f3 = false;
            				}
HXDLIN( 714)				if (f3) {
HXLINE( 714)					f2 = pi;
            				}
            				else {
HXLINE( 714)					Float a = ::hx::Mod(pi,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 714)					if ((a >= 0)) {
HXLINE( 714)						f2 = a;
            					}
            					else {
HXLINE( 714)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 714)				Float this2 = f2;
HXDLIN( 714)				Float zb = this2;
HXDLIN( 714)				Float fa = za;
HXDLIN( 714)				Float fb = zb;
HXDLIN( 714)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 714)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 714)				bool clockwise = (fa < fb);
HXDLIN( 714)				Float dif;
HXDLIN( 714)				if (clockwise) {
HXLINE( 714)					dif = theta;
            				}
            				else {
HXLINE( 714)					dif = -(theta);
            				}
HXDLIN( 714)				if (largest) {
HXLINE( 714)					dif1 = dif;
            				}
            				else {
HXLINE( 714)					if (clockwise) {
HXLINE( 714)						dif1 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 714)						dif1 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 714)		bool positive1 = (dif1 >= 0);
HXDLIN( 714)		int totalSteps1 = ::Math_obj::ceil((::Math_obj::abs(dif1) / step2));
HXDLIN( 714)		Float step3 = (dif1 / ( (Float)(totalSteps1) ));
HXDLIN( 714)		Float angle1 = pi_2;
HXDLIN( 714)		Float cx6;
HXDLIN( 714)		Float cy6;
HXDLIN( 714)		Float bx6 = ( (Float)(0) );
HXDLIN( 714)		Float by6 = ( (Float)(0) );
HXDLIN( 714)		Float dx6 = ( (Float)(0) );
HXDLIN( 714)		Float dy6 = ( (Float)(0) );
HXDLIN( 714)		Float ex1 = ( (Float)(0) );
HXDLIN( 714)		Float ey1 = ( (Float)(0) );
HXDLIN( 714)		Float r21 = (radius - thick);
HXDLIN( 714)		{
HXLINE( 714)			int _g2 = 0;
HXDLIN( 714)			int _g3 = (totalSteps1 + 1);
HXDLIN( 714)			while((_g2 < _g3)){
HXLINE( 714)				_g2 = (_g2 + 1);
HXDLIN( 714)				int i = (_g2 - 1);
HXDLIN( 714)				cx6 = (bx + (radius * ::Math_obj::sin(angle1)));
HXDLIN( 714)				cy6 = (by + (radius * ::Math_obj::cos(angle1)));
HXDLIN( 714)				ex1 = (bx + (r21 * ::Math_obj::sin(angle1)));
HXDLIN( 714)				ey1 = (by + (r21 * ::Math_obj::cos(angle1)));
HXDLIN( 714)				if ((i != 0)) {
HXLINE( 714)					{
HXLINE( 714)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx6,dy6,0,bx6,by6,0,cx6,cy6,0);
HXDLIN( 714)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 714)						if (::hx::IsNotNull( m )) {
HXLINE( 714)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 714)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 714)					{
HXLINE( 714)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx6,dy6,0,cx6,cy6,0,ex1,ey1,0);
HXDLIN( 714)						 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 714)						if (::hx::IsNotNull( m1 )) {
HXLINE( 714)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            						}
HXDLIN( 714)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
HXDLIN( 714)				angle1 = (angle1 + step3);
HXDLIN( 714)				bx6 = cx6;
HXDLIN( 714)				by6 = cy6;
HXDLIN( 714)				dx6 = ex1;
HXDLIN( 714)				dy6 = ey1;
            			}
            		}
HXDLIN( 714)		count = (count + (totalSteps1 * 2));
HXLINE( 715)		Float pi3 = ::Math_obj::PI;
HXDLIN( 715)		Float step4 = ((pi3 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 715)		Float dif2;
HXDLIN( 715)		switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 715)				Float f;
HXDLIN( 715)				bool f1;
HXDLIN( 715)				if ((pi_2 >= 0)) {
HXLINE( 715)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 715)					f1 = false;
            				}
HXDLIN( 715)				if (f1) {
HXLINE( 715)					f = pi_2;
            				}
            				else {
HXLINE( 715)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 715)					if ((a >= 0)) {
HXLINE( 715)						f = a;
            					}
            					else {
HXLINE( 715)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 715)				Float this1 = f;
HXDLIN( 715)				Float za = this1;
HXDLIN( 715)				Float f2;
HXDLIN( 715)				if ((0 > ::Math_obj::PI)) {
HXLINE( 715)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 715)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 715)					if ((a >= 0)) {
HXLINE( 715)						f2 = a;
            					}
            					else {
HXLINE( 715)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 715)				Float this2 = f2;
HXDLIN( 715)				Float zb = this2;
HXDLIN( 715)				Float fa = za;
HXDLIN( 715)				Float fb = zb;
HXDLIN( 715)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 715)				bool clockwise = (fa < fb);
HXDLIN( 715)				Float dif;
HXDLIN( 715)				if (clockwise) {
HXLINE( 715)					dif = theta;
            				}
            				else {
HXLINE( 715)					dif = -(theta);
            				}
HXDLIN( 715)				if ((dif > 0)) {
HXLINE( 715)					dif2 = dif;
            				}
            				else {
HXLINE( 715)					dif2 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 715)				Float f;
HXDLIN( 715)				bool f1;
HXDLIN( 715)				if ((pi_2 >= 0)) {
HXLINE( 715)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 715)					f1 = false;
            				}
HXDLIN( 715)				if (f1) {
HXLINE( 715)					f = pi_2;
            				}
            				else {
HXLINE( 715)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 715)					if ((a >= 0)) {
HXLINE( 715)						f = a;
            					}
            					else {
HXLINE( 715)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 715)				Float this1 = f;
HXDLIN( 715)				Float za = this1;
HXDLIN( 715)				Float f2;
HXDLIN( 715)				if ((0 > ::Math_obj::PI)) {
HXLINE( 715)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 715)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 715)					if ((a >= 0)) {
HXLINE( 715)						f2 = a;
            					}
            					else {
HXLINE( 715)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 715)				Float this2 = f2;
HXDLIN( 715)				Float zb = this2;
HXDLIN( 715)				Float fa = za;
HXDLIN( 715)				Float fb = zb;
HXDLIN( 715)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 715)				bool clockwise = (fa < fb);
HXDLIN( 715)				Float dif;
HXDLIN( 715)				if (clockwise) {
HXLINE( 715)					dif = theta;
            				}
            				else {
HXLINE( 715)					dif = -(theta);
            				}
HXDLIN( 715)				if ((dif < 0)) {
HXLINE( 715)					dif2 = dif;
            				}
            				else {
HXLINE( 715)					dif2 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 715)				Float f;
HXDLIN( 715)				bool f1;
HXDLIN( 715)				if ((pi_2 >= 0)) {
HXLINE( 715)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 715)					f1 = false;
            				}
HXDLIN( 715)				if (f1) {
HXLINE( 715)					f = pi_2;
            				}
            				else {
HXLINE( 715)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 715)					if ((a >= 0)) {
HXLINE( 715)						f = a;
            					}
            					else {
HXLINE( 715)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 715)				Float this1 = f;
HXDLIN( 715)				Float za = this1;
HXDLIN( 715)				Float f2;
HXDLIN( 715)				if ((0 > ::Math_obj::PI)) {
HXLINE( 715)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 715)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 715)					if ((a >= 0)) {
HXLINE( 715)						f2 = a;
            					}
            					else {
HXLINE( 715)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 715)				Float this2 = f2;
HXDLIN( 715)				Float zb = this2;
HXDLIN( 715)				Float fa = za;
HXDLIN( 715)				Float fb = zb;
HXDLIN( 715)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 715)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 715)				bool clockwise = (fa < fb);
HXDLIN( 715)				Float dif;
HXDLIN( 715)				if (clockwise) {
HXLINE( 715)					dif = theta;
            				}
            				else {
HXLINE( 715)					dif = -(theta);
            				}
HXDLIN( 715)				if (smallest) {
HXLINE( 715)					dif2 = dif;
            				}
            				else {
HXLINE( 715)					if (clockwise) {
HXLINE( 715)						dif2 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 715)						dif2 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 715)				Float f;
HXDLIN( 715)				bool f1;
HXDLIN( 715)				if ((pi_2 >= 0)) {
HXLINE( 715)					f1 = (pi_2 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 715)					f1 = false;
            				}
HXDLIN( 715)				if (f1) {
HXLINE( 715)					f = pi_2;
            				}
            				else {
HXLINE( 715)					Float a = ::hx::Mod(pi_2,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 715)					if ((a >= 0)) {
HXLINE( 715)						f = a;
            					}
            					else {
HXLINE( 715)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 715)				Float this1 = f;
HXDLIN( 715)				Float za = this1;
HXDLIN( 715)				Float f2;
HXDLIN( 715)				if ((0 > ::Math_obj::PI)) {
HXLINE( 715)					f2 = ( (Float)(0) );
            				}
            				else {
HXLINE( 715)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 715)					if ((a >= 0)) {
HXLINE( 715)						f2 = a;
            					}
            					else {
HXLINE( 715)						f2 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 715)				Float this2 = f2;
HXDLIN( 715)				Float zb = this2;
HXDLIN( 715)				Float fa = za;
HXDLIN( 715)				Float fb = zb;
HXDLIN( 715)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 715)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 715)				bool clockwise = (fa < fb);
HXDLIN( 715)				Float dif;
HXDLIN( 715)				if (clockwise) {
HXLINE( 715)					dif = theta;
            				}
            				else {
HXLINE( 715)					dif = -(theta);
            				}
HXDLIN( 715)				if (largest) {
HXLINE( 715)					dif2 = dif;
            				}
            				else {
HXLINE( 715)					if (clockwise) {
HXLINE( 715)						dif2 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 715)						dif2 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 715)		bool positive2 = (dif2 >= 0);
HXDLIN( 715)		int totalSteps2 = ::Math_obj::ceil((::Math_obj::abs(dif2) / step4));
HXDLIN( 715)		Float step5 = (dif2 / ( (Float)(totalSteps2) ));
HXDLIN( 715)		Float angle2 = pi_2;
HXDLIN( 715)		Float cx7;
HXDLIN( 715)		Float cy7;
HXDLIN( 715)		Float bx7 = ( (Float)(0) );
HXDLIN( 715)		Float by7 = ( (Float)(0) );
HXDLIN( 715)		Float dx7 = ( (Float)(0) );
HXDLIN( 715)		Float dy7 = ( (Float)(0) );
HXDLIN( 715)		Float ex2 = ( (Float)(0) );
HXDLIN( 715)		Float ey2 = ( (Float)(0) );
HXDLIN( 715)		Float r22 = (radius - thick);
HXDLIN( 715)		{
HXLINE( 715)			int _g4 = 0;
HXDLIN( 715)			int _g5 = (totalSteps2 + 1);
HXDLIN( 715)			while((_g4 < _g5)){
HXLINE( 715)				_g4 = (_g4 + 1);
HXDLIN( 715)				int i = (_g4 - 1);
HXDLIN( 715)				cx7 = (cx + (radius * ::Math_obj::sin(angle2)));
HXDLIN( 715)				cy7 = (cy + (radius * ::Math_obj::cos(angle2)));
HXDLIN( 715)				ex2 = (cx + (r22 * ::Math_obj::sin(angle2)));
HXDLIN( 715)				ey2 = (cy + (r22 * ::Math_obj::cos(angle2)));
HXDLIN( 715)				if ((i != 0)) {
HXLINE( 715)					{
HXLINE( 715)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx7,dy7,0,bx7,by7,0,cx7,cy7,0);
HXDLIN( 715)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 715)						if (::hx::IsNotNull( m )) {
HXLINE( 715)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 715)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 715)					{
HXLINE( 715)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx7,dy7,0,cx7,cy7,0,ex2,ey2,0);
HXDLIN( 715)						 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 715)						if (::hx::IsNotNull( m1 )) {
HXLINE( 715)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            						}
HXDLIN( 715)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
HXDLIN( 715)				angle2 = (angle2 + step5);
HXDLIN( 715)				bx7 = cx7;
HXDLIN( 715)				by7 = cy7;
HXDLIN( 715)				dx7 = ex2;
HXDLIN( 715)				dy7 = ey2;
            			}
            		}
HXDLIN( 715)		count = (count + (totalSteps2 * 2));
HXLINE( 716)		Float gamma1 = -(pi_2);
HXDLIN( 716)		Float pi4 = ::Math_obj::PI;
HXDLIN( 716)		Float step6 = ((pi4 * ( (Float)(2) )) / ( (Float)(36) ));
HXDLIN( 716)		Float dif3;
HXDLIN( 716)		switch((int)(::fracs::DifferencePreference_obj::ANTICLOCKWISE_dyn()->_hx_getIndex())){
            			case (int)0: {
HXLINE( 716)				Float f;
HXDLIN( 716)				if ((0 > ::Math_obj::PI)) {
HXLINE( 716)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 716)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 716)					if ((a >= 0)) {
HXLINE( 716)						f = a;
            					}
            					else {
HXLINE( 716)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 716)				Float this1 = f;
HXDLIN( 716)				Float za = this1;
HXDLIN( 716)				Float f1;
HXDLIN( 716)				bool f2;
HXDLIN( 716)				if ((gamma1 >= 0)) {
HXLINE( 716)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 716)					f2 = false;
            				}
HXDLIN( 716)				if (f2) {
HXLINE( 716)					f1 = gamma1;
            				}
            				else {
HXLINE( 716)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 716)					if ((a >= 0)) {
HXLINE( 716)						f1 = a;
            					}
            					else {
HXLINE( 716)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 716)				Float this2 = f1;
HXDLIN( 716)				Float zb = this2;
HXDLIN( 716)				Float fa = za;
HXDLIN( 716)				Float fb = zb;
HXDLIN( 716)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 716)				bool clockwise = (fa < fb);
HXDLIN( 716)				Float dif;
HXDLIN( 716)				if (clockwise) {
HXLINE( 716)					dif = theta;
            				}
            				else {
HXLINE( 716)					dif = -(theta);
            				}
HXDLIN( 716)				if ((dif > 0)) {
HXLINE( 716)					dif3 = dif;
            				}
            				else {
HXLINE( 716)					dif3 = ((( (Float)(2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 716)				Float f;
HXDLIN( 716)				if ((0 > ::Math_obj::PI)) {
HXLINE( 716)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 716)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 716)					if ((a >= 0)) {
HXLINE( 716)						f = a;
            					}
            					else {
HXLINE( 716)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 716)				Float this1 = f;
HXDLIN( 716)				Float za = this1;
HXDLIN( 716)				Float f1;
HXDLIN( 716)				bool f2;
HXDLIN( 716)				if ((gamma1 >= 0)) {
HXLINE( 716)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 716)					f2 = false;
            				}
HXDLIN( 716)				if (f2) {
HXLINE( 716)					f1 = gamma1;
            				}
            				else {
HXLINE( 716)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 716)					if ((a >= 0)) {
HXLINE( 716)						f1 = a;
            					}
            					else {
HXLINE( 716)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 716)				Float this2 = f1;
HXDLIN( 716)				Float zb = this2;
HXDLIN( 716)				Float fa = za;
HXDLIN( 716)				Float fb = zb;
HXDLIN( 716)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 716)				bool clockwise = (fa < fb);
HXDLIN( 716)				Float dif;
HXDLIN( 716)				if (clockwise) {
HXLINE( 716)					dif = theta;
            				}
            				else {
HXLINE( 716)					dif = -(theta);
            				}
HXDLIN( 716)				if ((dif < 0)) {
HXLINE( 716)					dif3 = dif;
            				}
            				else {
HXLINE( 716)					dif3 = ((( (Float)(-2) ) * ::Math_obj::PI) + dif);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 716)				Float f;
HXDLIN( 716)				if ((0 > ::Math_obj::PI)) {
HXLINE( 716)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 716)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 716)					if ((a >= 0)) {
HXLINE( 716)						f = a;
            					}
            					else {
HXLINE( 716)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 716)				Float this1 = f;
HXDLIN( 716)				Float za = this1;
HXDLIN( 716)				Float f1;
HXDLIN( 716)				bool f2;
HXDLIN( 716)				if ((gamma1 >= 0)) {
HXLINE( 716)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 716)					f2 = false;
            				}
HXDLIN( 716)				if (f2) {
HXLINE( 716)					f1 = gamma1;
            				}
            				else {
HXLINE( 716)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 716)					if ((a >= 0)) {
HXLINE( 716)						f1 = a;
            					}
            					else {
HXLINE( 716)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 716)				Float this2 = f1;
HXDLIN( 716)				Float zb = this2;
HXDLIN( 716)				Float fa = za;
HXDLIN( 716)				Float fb = zb;
HXDLIN( 716)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 716)				bool smallest = (theta <= ::Math_obj::PI);
HXDLIN( 716)				bool clockwise = (fa < fb);
HXDLIN( 716)				Float dif;
HXDLIN( 716)				if (clockwise) {
HXLINE( 716)					dif = theta;
            				}
            				else {
HXLINE( 716)					dif = -(theta);
            				}
HXDLIN( 716)				if (smallest) {
HXLINE( 716)					dif3 = dif;
            				}
            				else {
HXLINE( 716)					if (clockwise) {
HXLINE( 716)						dif3 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 716)						dif3 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 716)				Float f;
HXDLIN( 716)				if ((0 > ::Math_obj::PI)) {
HXLINE( 716)					f = ( (Float)(0) );
            				}
            				else {
HXLINE( 716)					Float a = ::hx::Mod(0,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 716)					if ((a >= 0)) {
HXLINE( 716)						f = a;
            					}
            					else {
HXLINE( 716)						f = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 716)				Float this1 = f;
HXDLIN( 716)				Float za = this1;
HXDLIN( 716)				Float f1;
HXDLIN( 716)				bool f2;
HXDLIN( 716)				if ((gamma1 >= 0)) {
HXLINE( 716)					f2 = (gamma1 > ::Math_obj::PI);
            				}
            				else {
HXLINE( 716)					f2 = false;
            				}
HXDLIN( 716)				if (f2) {
HXLINE( 716)					f1 = gamma1;
            				}
            				else {
HXLINE( 716)					Float a = ::hx::Mod(gamma1,(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN( 716)					if ((a >= 0)) {
HXLINE( 716)						f1 = a;
            					}
            					else {
HXLINE( 716)						f1 = (a + (( (Float)(2) ) * ::Math_obj::PI));
            					}
            				}
HXDLIN( 716)				Float this2 = f1;
HXDLIN( 716)				Float zb = this2;
HXDLIN( 716)				Float fa = za;
HXDLIN( 716)				Float fb = zb;
HXDLIN( 716)				Float theta = ::Math_obj::abs((fa - fb));
HXDLIN( 716)				bool largest = (theta > ::Math_obj::PI);
HXDLIN( 716)				bool clockwise = (fa < fb);
HXDLIN( 716)				Float dif;
HXDLIN( 716)				if (clockwise) {
HXLINE( 716)					dif = theta;
            				}
            				else {
HXLINE( 716)					dif = -(theta);
            				}
HXDLIN( 716)				if (largest) {
HXLINE( 716)					dif3 = dif;
            				}
            				else {
HXLINE( 716)					if (clockwise) {
HXLINE( 716)						dif3 = -(((( (Float)(2) ) * ::Math_obj::PI) - theta));
            					}
            					else {
HXLINE( 716)						dif3 = ((( (Float)(2) ) * ::Math_obj::PI) - theta);
            					}
            				}
            			}
            			break;
            		}
HXDLIN( 716)		bool positive3 = (dif3 >= 0);
HXDLIN( 716)		int totalSteps3 = ::Math_obj::ceil((::Math_obj::abs(dif3) / step6));
HXDLIN( 716)		Float step7 = (dif3 / ( (Float)(totalSteps3) ));
HXDLIN( 716)		Float angle3 = ( (Float)(0) );
HXDLIN( 716)		Float cx8;
HXDLIN( 716)		Float cy8;
HXDLIN( 716)		Float bx8 = ( (Float)(0) );
HXDLIN( 716)		Float by8 = ( (Float)(0) );
HXDLIN( 716)		Float dx8 = ( (Float)(0) );
HXDLIN( 716)		Float dy8 = ( (Float)(0) );
HXDLIN( 716)		Float ex3 = ( (Float)(0) );
HXDLIN( 716)		Float ey3 = ( (Float)(0) );
HXDLIN( 716)		Float r23 = (radius - thick);
HXDLIN( 716)		{
HXLINE( 716)			int _g6 = 0;
HXDLIN( 716)			int _g7 = (totalSteps3 + 1);
HXDLIN( 716)			while((_g6 < _g7)){
HXLINE( 716)				_g6 = (_g6 + 1);
HXDLIN( 716)				int i = (_g6 - 1);
HXDLIN( 716)				cx8 = (dx + (radius * ::Math_obj::sin(angle3)));
HXDLIN( 716)				cy8 = (dy + (radius * ::Math_obj::cos(angle3)));
HXDLIN( 716)				ex3 = (dx + (r23 * ::Math_obj::sin(angle3)));
HXDLIN( 716)				ey3 = (dy + (r23 * ::Math_obj::cos(angle3)));
HXDLIN( 716)				if ((i != 0)) {
HXLINE( 716)					{
HXLINE( 716)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx8,dy8,0,bx8,by8,0,cx8,cy8,0);
HXDLIN( 716)						 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 716)						if (::hx::IsNotNull( m )) {
HXLINE( 716)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            						}
HXDLIN( 716)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
HXDLIN( 716)					{
HXLINE( 716)						drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(dx8,dy8,0,cx8,cy8,0,ex3,ey3,0);
HXDLIN( 716)						 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 716)						if (::hx::IsNotNull( m1 )) {
HXLINE( 716)							drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            						}
HXDLIN( 716)						drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            					}
            				}
HXDLIN( 716)				angle3 = (angle3 + step7);
HXDLIN( 716)				bx8 = cx8;
HXDLIN( 716)				by8 = cy8;
HXDLIN( 716)				dx8 = ex3;
HXDLIN( 716)				dy8 = ey3;
            			}
            		}
HXDLIN( 716)		count = (count + (totalSteps3 * 2));
HXLINE( 717)		return count;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(Shaper_Fields__obj,roundedRectangleOutline,return )

int Shaper_Fields__obj::spiralLines( ::Dynamic drawType,Float x,Float y,Float radius,int nolines,Float startWid,Float stepWid){
            	HX_GC_STACKFRAME(&_hx_pos_4887c4b26886bcef_723_spiralLines)
HXLINE( 724)		Float theta = ((Float)0.);
HXLINE( 725)		Float wid = startWid;
HXLINE( 726)		{
HXLINE( 726)			int _g = 0;
HXDLIN( 726)			int _g1 = nolines;
HXDLIN( 726)			while((_g < _g1)){
HXLINE( 726)				_g = (_g + 1);
HXDLIN( 726)				int i = (_g - 1);
HXLINE( 727)				{
HXLINE( 729)					wid = (wid + stepWid);
HXLINE( 727)					Float width = wid;
HXDLIN( 727)					Float dx = (x - (x + (radius * ::Math_obj::sin(theta))));
HXDLIN( 727)					Float dy = (y - (y + (radius * ::Math_obj::cos(theta))));
HXDLIN( 727)					 ::trilateral3::structure::XY P =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(x - (width / ( (Float)(2) ))),y);
HXDLIN( 727)					Float omega = ::Math_obj::atan2(dy,dx);
HXDLIN( 727)					 ::trilateral3::structure::XY dim =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,width,((dx * dx) + (dy * dy)));
HXDLIN( 727)					Float pivotX = (x + (width / ( (Float)(2) )));
HXDLIN( 727)					Float px = P->x;
HXDLIN( 727)					Float py = P->y;
HXDLIN( 727)					Float dx1 = dim->x;
HXDLIN( 727)					Float dy1 = dim->y;
HXDLIN( 727)					 ::trilateral3::structure::XY A_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,px,py);
HXDLIN( 727)					 ::trilateral3::structure::XY B_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px + dx1),py);
HXDLIN( 727)					 ::trilateral3::structure::XY C_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px + dx1),(py + dy1));
HXDLIN( 727)					 ::trilateral3::structure::XY D_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,px,(py + dy1));
HXDLIN( 727)					if ((omega != ((Float)0.))) {
HXLINE( 727)						Float sin = ::Math_obj::sin(omega);
HXDLIN( 727)						Float cos = ::Math_obj::cos(omega);
HXDLIN( 727)						Float px = (A_->x - pivotX);
HXDLIN( 727)						Float py = (A_->y - y);
HXDLIN( 727)						Float px2 = ((px * cos) - (py * sin));
HXDLIN( 727)						py = ((py * cos) + (px * sin));
HXDLIN( 727)						A_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px2 + pivotX),(py + y));
HXDLIN( 727)						Float px1 = (B_->x - pivotX);
HXDLIN( 727)						Float py1 = (B_->y - y);
HXDLIN( 727)						Float px21 = ((px1 * cos) - (py1 * sin));
HXDLIN( 727)						py1 = ((py1 * cos) + (px1 * sin));
HXDLIN( 727)						B_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px21 + pivotX),(py1 + y));
HXDLIN( 727)						Float px3 = (C_->x - pivotX);
HXDLIN( 727)						Float py2 = (C_->y - y);
HXDLIN( 727)						Float px22 = ((px3 * cos) - (py2 * sin));
HXDLIN( 727)						py2 = ((py2 * cos) + (px3 * sin));
HXDLIN( 727)						C_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px22 + pivotX),(py2 + y));
HXDLIN( 727)						Float px4 = (D_->x - pivotX);
HXDLIN( 727)						Float py3 = (D_->y - y);
HXDLIN( 727)						Float px23 = ((px4 * cos) - (py3 * sin));
HXDLIN( 727)						py3 = ((py3 * cos) + (px4 * sin));
HXDLIN( 727)						D_ =  ::trilateral3::structure::XY_obj::__alloc( HX_CTX ,(px23 + pivotX),(py3 + y));
            					}
HXDLIN( 727)					 ::trilateral3::structure::Quad2D q =  ::trilateral3::structure::Quad2D_obj::__alloc( HX_CTX ,A_,B_,C_,D_);
HXDLIN( 727)					{
HXLINE( 727)						Float bx = q->b->x;
HXDLIN( 727)						Float by = q->b->y;
HXDLIN( 727)						Float cx = q->c->x;
HXDLIN( 727)						Float cy = q->c->y;
HXDLIN( 727)						Float dx2 = q->d->x;
HXDLIN( 727)						Float dy2 = q->d->y;
HXDLIN( 727)						{
HXLINE( 727)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(q->a->x,q->a->y,0,bx,by,0,dx2,dy2,0);
HXDLIN( 727)							 ::trilateral3::matrix::MatrixDozen m = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 727)							if (::hx::IsNotNull( m )) {
HXLINE( 727)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m);
            							}
HXDLIN( 727)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
HXDLIN( 727)						{
HXLINE( 727)							drawType->__Field(HX_("triangle",c8,be,c5,8d),::hx::paccDynamic)(bx,by,0,cx,cy,0,dx2,dy2,0);
HXDLIN( 727)							 ::trilateral3::matrix::MatrixDozen m1 = ::trilateral3::Trilateral_obj::transformMatrix;
HXDLIN( 727)							if (::hx::IsNotNull( m1 )) {
HXLINE( 727)								drawType->__Field(HX_("transform",6c,2d,93,45),::hx::paccDynamic)(m1);
            							}
HXDLIN( 727)							drawType->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
            						}
            					}
            				}
HXLINE( 730)				theta = (theta + ((::Math_obj::PI * ( (Float)(2) )) / ( (Float)(nolines) )));
            			}
            		}
HXLINE( 732)		return nolines;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(Shaper_Fields__obj,spiralLines,return )


Shaper_Fields__obj::Shaper_Fields__obj()
{
}

bool Shaper_Fields__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"pie") ) { outValue = pie_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"arc") ) { outValue = arc_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"quad") ) { outValue = quad_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"pieX") ) { outValue = pieX_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"shape") ) { outValue = shape_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"lineAB") ) { outValue = lineAB_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"lineXY") ) { outValue = lineXY_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"square") ) { outValue = square_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"circle") ) { outValue = circle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"pieDif") ) { outValue = pieDif_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"diamond") ) { outValue = diamond_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"ellipse") ) { outValue = ellipse_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"pieDifX") ) { outValue = pieDifX_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"add2DQuad") ) { outValue = add2DQuad_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"rectangle") ) { outValue = rectangle_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"ellipsePie") ) { outValue = ellipsePie_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"overlapStar") ) { outValue = overlapStar_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"shapeRadial") ) { outValue = shapeRadial_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"spiralLines") ) { outValue = spiralLines_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"circleRadial") ) { outValue = circleRadial_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"circleOnSide") ) { outValue = circleOnSide_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"add2DTriangle") ) { outValue = add2DTriangle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"squareOutline") ) { outValue = squareOutline_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"ellipseOnSide") ) { outValue = ellipseOnSide_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"diamondOutline") ) { outValue = diamondOutline_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"roundedRectangle") ) { outValue = roundedRectangle_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"circleRadialOnSide") ) { outValue = circleRadialOnSide_dyn(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"roundedRectangleOutline") ) { outValue = roundedRectangleOutline_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Shaper_Fields__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Shaper_Fields__obj_sStaticStorageInfo = 0;
#endif

::hx::Class Shaper_Fields__obj::__mClass;

static ::String Shaper_Fields__obj_sStaticFields[] = {
	HX_("add2DTriangle",1b,0e,bb,71),
	HX_("add2DQuad",9a,a2,8a,de),
	HX_("quad",c7,38,0a,4b),
	HX_("lineAB",d5,35,a0,ec),
	HX_("lineXY",f5,49,a0,ec),
	HX_("rectangle",2f,d4,7c,19),
	HX_("squareOutline",65,3c,4d,4c),
	HX_("square",9d,00,f2,58),
	HX_("diamond",54,67,1a,5c),
	HX_("diamondOutline",8e,2a,ad,7a),
	HX_("overlapStar",f9,22,3b,3c),
	HX_("circle",10,72,0d,56),
	HX_("circleRadial",0f,91,91,eb),
	HX_("circleRadialOnSide",c5,50,c8,a9),
	HX_("ellipse",de,40,86,0b),
	HX_("pie",4c,58,55,00),
	HX_("pieX",8c,ea,57,4a),
	HX_("pieDifX",63,f6,97,81),
	HX_("ellipsePie",0e,2e,dc,4c),
	HX_("pieDif",55,d4,01,80),
	HX_("arc",52,fe,49,00),
	HX_("circleOnSide",86,68,78,29),
	HX_("ellipseOnSide",d4,45,c5,04),
	HX_("shape",21,e3,1c,7c),
	HX_("shapeRadial",e0,a4,38,43),
	HX_("roundedRectangle",42,46,67,9d),
	HX_("roundedRectangleOutline",60,25,be,26),
	HX_("spiralLines",0e,c8,55,fa),
	::String(null())
};

void Shaper_Fields__obj::__register()
{
	Shaper_Fields__obj _hx_dummy;
	Shaper_Fields__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("trilateral3.shape._Shaper.Shaper_Fields_",aa,bf,61,7f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Shaper_Fields__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Shaper_Fields__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Shaper_Fields__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Shaper_Fields__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Shaper_Fields__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace trilateral3
} // end namespace shape
} // end namespace _Shaper
