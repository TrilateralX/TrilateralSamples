// Generated by Haxe 4.2.0-rc.1+7dc565e63
#ifndef INCLUDED_hxPolyK_PolyK
#define INCLUDED_hxPolyK_PolyK

#ifndef HXCPP_H
#include <hxcpp.h>
#endif

HX_DECLARE_STACK_FRAME(_hx_pos_2fc1aea7af27459c_106_new)
HX_DECLARE_CLASS1(hxPolyK,PolyK)

namespace hxPolyK{


class HXCPP_CLASS_ATTRIBUTES PolyK_obj : public ::hx::Object
{
	public:
		typedef ::hx::Object super;
		typedef PolyK_obj OBJ_;
		PolyK_obj();

	public:
		enum { _hx_ClassId = 0x1828fe1c };

		void __construct();
		inline void *operator new(size_t inSize, bool inContainer=false,const char *inName="hxPolyK.PolyK")
			{ return ::hx::Object::operator new(inSize,inContainer,inName); }
		inline void *operator new(size_t inSize, int extra)
			{ return ::hx::Object::operator new(inSize+extra,false,"hxPolyK.PolyK"); }

		inline static ::hx::ObjectPtr< PolyK_obj > __new() {
			::hx::ObjectPtr< PolyK_obj > __this = new PolyK_obj();
			__this->__construct();
			return __this;
		}

		inline static ::hx::ObjectPtr< PolyK_obj > __alloc(::hx::Ctx *_hx_ctx) {
			PolyK_obj *__this = (PolyK_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(PolyK_obj), false, "hxPolyK.PolyK"));
			*(void **)__this = PolyK_obj::_hx_vtable;
{
            	HX_STACKFRAME(&_hx_pos_2fc1aea7af27459c_106_new)
            	}
		
			return __this;
		}

		static void * _hx_vtable;
		static Dynamic __CreateEmpty();
		static Dynamic __Create(::hx::DynamicArray inArgs);
		//~PolyK_obj();

		HX_DO_RTTI_ALL;
		static bool __GetStatic(const ::String &inString, Dynamic &outValue, ::hx::PropertyAccess inCallProp);
		static void __register();
		bool _hx_isInstanceOf(int inClassId);
		::String __ToString() const { return HX_("PolyK",5f,74,bf,59); }

		static void __boot();
		static Float small;
		static bool isSimple(::Array< Float > p);
		static ::Dynamic isSimple_dyn();

		static bool isConvex(::Array< Float > p);
		static ::Dynamic isConvex_dyn();

		static Float getArea(::Array< Float > p);
		static ::Dynamic getArea_dyn();

		static  ::Dynamic getAABB(::Array< Float > p);
		static ::Dynamic getAABB_dyn();

		static ::Array< Float > reverse(::Array< Float > p);
		static ::Dynamic reverse_dyn();

		static ::Array< Float > triangulate(::Array< Float > p);
		static ::Dynamic triangulate_dyn();

		static bool containsPoint(::Array< Float > p,Float px,Float py);
		static ::Dynamic containsPoint_dyn();

		static ::Array< ::Dynamic> slice(::Array< Float > p,Float ax,Float ay,Float bx,Float by);
		static ::Dynamic slice_dyn();

		static  ::Dynamic raycast(::Array< Float > p,Float x,Float y,Float dx,Float dy, ::Dynamic isc);
		static ::Dynamic raycast_dyn();

		static  ::Dynamic closestEdge(::Array< Float > p,Float x,Float y, ::Dynamic isc);
		static ::Dynamic closestEdge_dyn();

		static void pointLineDist( ::Dynamic p, ::Dynamic a, ::Dynamic b,Float edge, ::Dynamic isc);
		static ::Dynamic pointLineDist_dyn();

		static void updateISC(Float dx,Float dy, ::Dynamic a1, ::Dynamic b1, ::Dynamic b2, ::Dynamic c,Float edge, ::Dynamic isc);
		static ::Dynamic updateISC_dyn();

		static ::Array< ::Dynamic> getPoints(::Array< ::Dynamic> ps,int ind0,int ind1);
		static ::Dynamic getPoints_dyn();

		static int firstWithFlag(::Array< ::Dynamic> ps,int ind);
		static ::Dynamic firstWithFlag_dyn();

		static bool pointInTriangle(Float px,Float py,Float ax,Float ay,Float bx,Float by,Float cx,Float cy);
		static ::Dynamic pointInTriangle_dyn();

		static  ::Dynamic rayLineIntersection( ::Dynamic a1, ::Dynamic a2, ::Dynamic b1, ::Dynamic b2, ::Dynamic c);
		static ::Dynamic rayLineIntersection_dyn();

		static  ::Dynamic getLineIntersection( ::Dynamic a1, ::Dynamic a2, ::Dynamic b1, ::Dynamic b2);
		static ::Dynamic getLineIntersection_dyn();

		static bool inRect( ::Dynamic a, ::Dynamic b, ::Dynamic c);
		static ::Dynamic inRect_dyn();

		static bool convex(Float ax,Float ay,Float bx,Float by,Float cx,Float cy);
		static ::Dynamic convex_dyn();

		static Float dist( ::Dynamic a, ::Dynamic b);
		static ::Dynamic dist_dyn();

};

} // end namespace hxPolyK

#endif /* INCLUDED_hxPolyK_PolyK */ 
