// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_fracs_Fracs
#include <fracs/Fracs.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_510d67125e0c28be_154_grabDecimalInput,"fracs.Fracs","grabDecimalInput",0x6a931e97,"fracs.Fracs.grabDecimalInput","fracs/Fraction.hx",154,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_510d67125e0c28be_160_approximateFractions,"fracs.Fracs","approximateFractions",0xed76252f,"fracs.Fracs.approximateFractions","fracs/Fraction.hx",160,0xf40fb512)
static const int _hx_array_data_b202d9bc_5[] = {
	(int)0,(int)1,
};
static const int _hx_array_data_b202d9bc_6[] = {
	(int)1,(int)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_510d67125e0c28be_186_getMaxNumerator,"fracs.Fracs","getMaxNumerator",0x75c4ae49,"fracs.Fracs.getMaxNumerator","fracs/Fraction.hx",186,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_510d67125e0c28be_219_extractDigitStr,"fracs.Fracs","extractDigitStr",0xdaa30cb3,"fracs.Fracs.extractDigitStr","fracs/Fraction.hx",219,0xf40fb512)
HX_LOCAL_STACK_FRAME(_hx_pos_510d67125e0c28be_240_getMaxNumeratorStr,"fracs.Fracs","getMaxNumeratorStr",0xb05c05e8,"fracs.Fracs.getMaxNumeratorStr","fracs/Fraction.hx",240,0xf40fb512)
namespace fracs{

void Fracs_obj::__construct() { }

Dynamic Fracs_obj::__CreateEmpty() { return new Fracs_obj; }

void *Fracs_obj::_hx_vtable = 0;

Dynamic Fracs_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Fracs_obj > _hx_result = new Fracs_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Fracs_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x07fa29e4;
}

Float Fracs_obj::grabDecimalInput(::String decimalVal){
            	HX_STACKFRAME(&_hx_pos_510d67125e0c28be_154_grabDecimalInput)
HXLINE( 155)		Float decimal = ::Math_obj::abs(::Std_obj::parseFloat(decimalVal));
HXLINE( 156)		if (::Math_obj::isNaN(decimal)) {
HXLINE( 156)			return ((Float)0.);
            		}
            		else {
HXLINE( 156)			return decimal;
            		}
HXDLIN( 156)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fracs_obj,grabDecimalInput,return )

::Array< ::Dynamic> Fracs_obj::approximateFractions(Float f){
            	HX_STACKFRAME(&_hx_pos_510d67125e0c28be_160_approximateFractions)
HXLINE( 161)		bool positive;
HXDLIN( 161)		if ((f <= 0)) {
HXLINE( 161)			positive = false;
            		}
            		else {
HXLINE( 161)			positive = true;
            		}
HXLINE( 162)		::Array< int > numerators = ::Array_obj< int >::fromData( _hx_array_data_b202d9bc_5,2);
HXLINE( 163)		::Array< int > denominators = ::Array_obj< int >::fromData( _hx_array_data_b202d9bc_6,2);
HXLINE( 164)		Float f2;
HXDLIN( 164)		if ((f <= 0)) {
HXLINE( 164)			f2 = -(f);
            		}
            		else {
HXLINE( 164)			f2 = f;
            		}
HXLINE( 165)		::String fStr = ::Std_obj::string(f2);
HXDLIN( 165)		::String digits = HX_("",00,00,00,00);
HXDLIN( 165)		int ix = fStr.indexOf(HX_(".",2e,00,00,00),null());
HXDLIN( 165)		if ((ix == -1)) {
HXLINE( 165)			digits = fStr;
            		}
            		else {
HXLINE( 165)			if ((ix == 0)) {
HXLINE( 165)				digits = fStr.substr(1,fStr.length);
            			}
            			else {
HXLINE( 165)				if ((ix < fStr.length)) {
HXLINE( 165)					::String digits1 = fStr.substr(0,ix);
HXDLIN( 165)					digits = (digits1 + fStr.substr((ix + 1),fStr.length));
            				}
            			}
            		}
HXDLIN( 165)		::String LStr = digits;
HXDLIN( 165)		int numDigits = LStr.length;
HXDLIN( 165)		Float L2 = f2;
HXDLIN( 165)		int numIntDigits = ::Std_obj::string(L2).length;
HXDLIN( 165)		if ((L2 == 0)) {
HXLINE( 165)			numIntDigits = 0;
            		}
HXDLIN( 165)		int numDigitsPastDecimal = (numDigits - numIntDigits);
HXDLIN( 165)		int i = numDigitsPastDecimal;
HXDLIN( 165)		Float L = ::Std_obj::parseFloat(digits);
HXDLIN( 165)		while(true){
HXLINE( 165)			bool _hx_tmp;
HXDLIN( 165)			if ((i > 0)) {
HXLINE( 165)				_hx_tmp = (::hx::Mod(L,2) == 0);
            			}
            			else {
HXLINE( 165)				_hx_tmp = false;
            			}
HXDLIN( 165)			if (!(_hx_tmp)) {
HXLINE( 165)				goto _hx_goto_1;
            			}
HXDLIN( 165)			L = (L / ( (Float)(2) ));
HXDLIN( 165)			i = (i - 1);
            		}
            		_hx_goto_1:;
HXDLIN( 165)		i = numDigitsPastDecimal;
HXDLIN( 165)		while(true){
HXLINE( 165)			bool _hx_tmp;
HXDLIN( 165)			if ((i > 0)) {
HXLINE( 165)				_hx_tmp = (::hx::Mod(L,5) == 0);
            			}
            			else {
HXLINE( 165)				_hx_tmp = false;
            			}
HXDLIN( 165)			if (!(_hx_tmp)) {
HXLINE( 165)				goto _hx_goto_2;
            			}
HXDLIN( 165)			L = (L / ( (Float)(5) ));
HXDLIN( 165)			i = (i - 1);
            		}
            		_hx_goto_2:;
HXDLIN( 165)		Float maxNumerator = L;
HXLINE( 166)		Float d2 = f2;
HXLINE( 167)		Float calcD;
HXLINE( 168)		 ::Dynamic prevCalcD = null();
HXLINE( 169)		::Array< ::Dynamic> val = null();
HXDLIN( 169)		::Array< ::Dynamic> this1;
HXDLIN( 169)		if (::hx::IsNull( val )) {
HXLINE( 169)			this1 = ::Array_obj< ::Dynamic>::__new();
            		}
            		else {
HXLINE( 169)			this1 = val;
            		}
HXDLIN( 169)		::Array< ::Dynamic> arrFraction = this1;
HXLINE( 170)		int j = 0;
HXLINE( 171)		{
HXLINE( 171)			int _g = 2;
HXDLIN( 171)			while((_g < 1000)){
HXLINE( 171)				_g = (_g + 1);
HXDLIN( 171)				int i = (_g - 1);
HXLINE( 172)				int L2 = ::Math_obj::floor(d2);
HXLINE( 173)				numerators[i] = ::Std_obj::_hx_int(( (Float)(((L2 * numerators->__get((i - 1))) + numerators->__get((i - 2)))) ));
HXLINE( 174)				if ((::Math_obj::abs(( (Float)(numerators->__get(i)) )) > maxNumerator)) {
HXLINE( 174)					goto _hx_goto_3;
            				}
HXLINE( 175)				denominators[i] = ::Std_obj::_hx_int(( (Float)(((L2 * denominators->__get((i - 1))) + denominators->__get((i - 2)))) ));
HXLINE( 176)				calcD = (( (Float)(numerators->__get(i)) ) / ( (Float)(denominators->__get(i)) ));
HXLINE( 177)				if (::hx::IsEq( calcD,prevCalcD )) {
HXLINE( 177)					goto _hx_goto_3;
            				}
HXLINE( 178)				{
HXLINE( 178)					int numerator = numerators->__get(i);
HXDLIN( 178)					int denominator = denominators->__get(i);
HXDLIN( 178)					 ::Dynamic positive1 = positive;
HXDLIN( 178)					 ::Dynamic value = f;
HXDLIN( 178)					if (::hx::IsNull( positive1 )) {
HXLINE( 178)						positive1 = true;
            					}
HXDLIN( 178)					bool numNeg = (numerator < 0);
HXDLIN( 178)					bool denoNeg = (denominator < 0);
HXDLIN( 178)					if (::hx::IsNull( value )) {
HXLINE( 178)						if (( (bool)(positive1) )) {
HXLINE( 178)							value = (( (Float)(numerator) ) / ( (Float)(denominator) ));
            						}
            						else {
HXLINE( 178)							value = (( (Float)(-(numerator)) ) / ( (Float)(denominator) ));
            						}
            					}
HXDLIN( 178)					bool _hx_tmp;
HXDLIN( 178)					if (!(numNeg)) {
HXLINE( 178)						_hx_tmp = denoNeg;
            					}
            					else {
HXLINE( 178)						_hx_tmp = true;
            					}
HXDLIN( 178)					if (_hx_tmp) {
HXLINE( 178)						bool _hx_tmp;
HXDLIN( 178)						if (numNeg) {
HXLINE( 178)							_hx_tmp = denoNeg;
            						}
            						else {
HXLINE( 178)							_hx_tmp = false;
            						}
HXDLIN( 178)						if (!(_hx_tmp)) {
HXLINE( 178)							positive1 = !(( (bool)(positive1) ));
            						}
HXDLIN( 178)						if (numNeg) {
HXLINE( 178)							numerator = -(numerator);
            						}
HXDLIN( 178)						if (denoNeg) {
HXLINE( 178)							denominator = -(denominator);
            						}
            					}
HXDLIN( 178)					 ::Dynamic this1 =  ::Dynamic(::hx::Anon_obj::Create(4)
            						->setFixed(0,HX_("numerator",89,82,9c,c2),numerator)
            						->setFixed(1,HX_("positive",b9,a6,fa,ca),positive1)
            						->setFixed(2,HX_("denominator",a6,25,84,eb),denominator)
            						->setFixed(3,HX_("value",71,7f,b8,31),value));
HXDLIN( 178)					arrFraction[arrFraction->length] = this1;
            				}
HXLINE( 179)				if ((calcD == f2)) {
HXLINE( 179)					goto _hx_goto_3;
            				}
HXLINE( 180)				prevCalcD = calcD;
HXLINE( 181)				d2 = (( (Float)(1) ) / (d2 - ( (Float)(L2) )));
            			}
            			_hx_goto_3:;
            		}
HXLINE( 183)		return arrFraction;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fracs_obj,approximateFractions,return )

Float Fracs_obj::getMaxNumerator(Float f){
            	HX_STACKFRAME(&_hx_pos_510d67125e0c28be_186_getMaxNumerator)
HXLINE( 187)		::String fStr = ::Std_obj::string(f);
HXLINE( 188)		::String digits = HX_("",00,00,00,00);
HXLINE( 189)		int ix = fStr.indexOf(HX_(".",2e,00,00,00),null());
HXLINE( 190)		if ((ix == -1)) {
HXLINE( 191)			digits = fStr;
            		}
            		else {
HXLINE( 192)			if ((ix == 0)) {
HXLINE( 193)				digits = fStr.substr(1,fStr.length);
            			}
            			else {
HXLINE( 194)				if ((ix < fStr.length)) {
HXLINE( 195)					::String digits1 = fStr.substr(0,ix);
HXDLIN( 195)					digits = (digits1 + fStr.substr((ix + 1),fStr.length));
            				}
            			}
            		}
HXLINE( 197)		::String LStr = digits;
HXLINE( 198)		int numDigits = LStr.length;
HXLINE( 199)		Float L2 = f;
HXLINE( 200)		int numIntDigits = ::Std_obj::string(L2).length;
HXLINE( 201)		if ((L2 == 0)) {
HXLINE( 201)			numIntDigits = 0;
            		}
HXLINE( 202)		int numDigitsPastDecimal = (numDigits - numIntDigits);
HXLINE( 203)		int i = numDigitsPastDecimal;
HXLINE( 204)		Float L = ::Std_obj::parseFloat(digits);
HXLINE( 205)		while(true){
HXLINE( 205)			bool _hx_tmp;
HXDLIN( 205)			if ((i > 0)) {
HXLINE( 205)				_hx_tmp = (::hx::Mod(L,2) == 0);
            			}
            			else {
HXLINE( 205)				_hx_tmp = false;
            			}
HXDLIN( 205)			if (!(_hx_tmp)) {
HXLINE( 205)				goto _hx_goto_7;
            			}
HXLINE( 206)			L = (L / ( (Float)(2) ));
HXLINE( 207)			i = (i - 1);
            		}
            		_hx_goto_7:;
HXLINE( 209)		i = numDigitsPastDecimal;
HXLINE( 210)		while(true){
HXLINE( 210)			bool _hx_tmp;
HXDLIN( 210)			if ((i > 0)) {
HXLINE( 210)				_hx_tmp = (::hx::Mod(L,5) == 0);
            			}
            			else {
HXLINE( 210)				_hx_tmp = false;
            			}
HXDLIN( 210)			if (!(_hx_tmp)) {
HXLINE( 210)				goto _hx_goto_8;
            			}
HXLINE( 211)			L = (L / ( (Float)(5) ));
HXLINE( 212)			i = (i - 1);
            		}
            		_hx_goto_8:;
HXLINE( 214)		return L;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fracs_obj,getMaxNumerator,return )

::String Fracs_obj::extractDigitStr(::String fStr){
            	HX_STACKFRAME(&_hx_pos_510d67125e0c28be_219_extractDigitStr)
HXLINE( 220)		::String f2 = HX_("",00,00,00,00);
HXLINE( 221)		int ixe = fStr.indexOf(HX_("E",45,00,00,00),null());
HXLINE( 222)		if ((ixe == -1)) {
HXLINE( 222)			ixe = fStr.indexOf(HX_("e",65,00,00,00),null());
            		}
HXLINE( 223)		if ((ixe == -1)) {
HXLINE( 224)			f2 = fStr;
            		}
            		else {
HXLINE( 226)			f2 = fStr.substr(0,ixe);
            		}
HXLINE( 228)		::String digits = HX_("",00,00,00,00);
HXLINE( 229)		int ix = f2.indexOf(HX_(".",2e,00,00,00),null());
HXLINE( 230)		if ((ix == -1)) {
HXLINE( 231)			digits = f2;
            		}
            		else {
HXLINE( 232)			if ((ix == 0)) {
HXLINE( 233)				digits = f2.substr(1,f2.length);
            			}
            			else {
HXLINE( 234)				if ((ix < f2.length)) {
HXLINE( 235)					::String digits1 = f2.substr(0,ix);
HXDLIN( 235)					digits = (digits1 + f2.substr((ix + 1),f2.length));
            				}
            			}
            		}
HXLINE( 237)		return digits;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fracs_obj,extractDigitStr,return )

Float Fracs_obj::getMaxNumeratorStr(::String fStr){
            	HX_STACKFRAME(&_hx_pos_510d67125e0c28be_240_getMaxNumeratorStr)
HXLINE( 241)		::String f2 = HX_("",00,00,00,00);
HXDLIN( 241)		int ixe = fStr.indexOf(HX_("E",45,00,00,00),null());
HXDLIN( 241)		if ((ixe == -1)) {
HXLINE( 241)			ixe = fStr.indexOf(HX_("e",65,00,00,00),null());
            		}
HXDLIN( 241)		if ((ixe == -1)) {
HXLINE( 241)			f2 = fStr;
            		}
            		else {
HXLINE( 241)			f2 = fStr.substr(0,ixe);
            		}
HXDLIN( 241)		::String digits = HX_("",00,00,00,00);
HXDLIN( 241)		int ix = f2.indexOf(HX_(".",2e,00,00,00),null());
HXDLIN( 241)		if ((ix == -1)) {
HXLINE( 241)			digits = f2;
            		}
            		else {
HXLINE( 241)			if ((ix == 0)) {
HXLINE( 241)				digits = f2.substr(1,f2.length);
            			}
            			else {
HXLINE( 241)				if ((ix < f2.length)) {
HXLINE( 241)					::String digits1 = f2.substr(0,ix);
HXDLIN( 241)					digits = (digits1 + f2.substr((ix + 1),f2.length));
            				}
            			}
            		}
HXDLIN( 241)		::String LStr = digits;
HXLINE( 242)		int numDigits = LStr.length;
HXLINE( 243)		::String L2 = fStr;
HXLINE( 244)		int numIntDigits = L2.length;
HXLINE( 245)		if ((L2 == HX_("0",30,00,00,00))) {
HXLINE( 245)			numIntDigits = 0;
            		}
HXLINE( 246)		int numDigitsPastDecimal = (numDigits - numIntDigits);
HXLINE( 247)		int i = numDigitsPastDecimal;
HXLINE( 248)		Float L = ::Std_obj::parseFloat(fStr);
HXLINE( 249)		while(true){
HXLINE( 249)			bool _hx_tmp;
HXDLIN( 249)			if ((i > 0)) {
HXLINE( 249)				_hx_tmp = (::hx::Mod(L,2) == 0);
            			}
            			else {
HXLINE( 249)				_hx_tmp = false;
            			}
HXDLIN( 249)			if (!(_hx_tmp)) {
HXLINE( 249)				goto _hx_goto_11;
            			}
HXLINE( 250)			L = (L / ( (Float)(2) ));
HXLINE( 251)			i = (i - 1);
            		}
            		_hx_goto_11:;
HXLINE( 253)		i = numDigitsPastDecimal;
HXLINE( 254)		while(true){
HXLINE( 254)			bool _hx_tmp;
HXDLIN( 254)			if ((i > 0)) {
HXLINE( 254)				_hx_tmp = (::hx::Mod(L,5) == 0);
            			}
            			else {
HXLINE( 254)				_hx_tmp = false;
            			}
HXDLIN( 254)			if (!(_hx_tmp)) {
HXLINE( 254)				goto _hx_goto_12;
            			}
HXLINE( 255)			L = (L / ( (Float)(5) ));
HXLINE( 256)			i = (i - 1);
            		}
            		_hx_goto_12:;
HXLINE( 258)		return L;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Fracs_obj,getMaxNumeratorStr,return )


Fracs_obj::Fracs_obj()
{
}

bool Fracs_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 15:
		if (HX_FIELD_EQ(inName,"getMaxNumerator") ) { outValue = getMaxNumerator_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"extractDigitStr") ) { outValue = extractDigitStr_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"grabDecimalInput") ) { outValue = grabDecimalInput_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"getMaxNumeratorStr") ) { outValue = getMaxNumeratorStr_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"approximateFractions") ) { outValue = approximateFractions_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Fracs_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Fracs_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Fracs_obj::__mClass;

static ::String Fracs_obj_sStaticFields[] = {
	HX_("grabDecimalInput",a5,ef,26,c0),
	HX_("approximateFractions",3d,95,62,d7),
	HX_("getMaxNumerator",fb,38,0a,7d),
	HX_("extractDigitStr",65,97,e8,e1),
	HX_("getMaxNumeratorStr",76,b6,50,6f),
	::String(null())
};

void Fracs_obj::__register()
{
	Fracs_obj _hx_dummy;
	Fracs_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("fracs.Fracs",bc,d9,02,b2);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Fracs_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Fracs_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Fracs_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Fracs_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Fracs_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace fracs
