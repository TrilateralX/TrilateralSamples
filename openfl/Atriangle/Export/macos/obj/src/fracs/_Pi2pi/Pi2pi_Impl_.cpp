// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_fracs_Fracs
#include <fracs/Fracs.h>
#endif
#ifndef INCLUDED_fracs__Pi2pi_Pi2pi_Impl_
#include <fracs/_Pi2pi/Pi2pi_Impl_.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_5__new,"fracs._Pi2pi.Pi2pi_Impl_","_new",0x2d90286f,"fracs._Pi2pi.Pi2pi_Impl_._new","fracs/Pi2pi.hx",5,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_12_fromFloat,"fracs._Pi2pi.Pi2pi_Impl_","fromFloat",0x2fe8ca04,"fracs._Pi2pi.Pi2pi_Impl_.fromFloat","fracs/Pi2pi.hx",12,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_21_additionPi,"fracs._Pi2pi.Pi2pi_Impl_","additionPi",0xffdfbba3,"fracs._Pi2pi.Pi2pi_Impl_.additionPi","fracs/Pi2pi.hx",21,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_25_subtractionPi,"fracs._Pi2pi.Pi2pi_Impl_","subtractionPi",0xefd6137f,"fracs._Pi2pi.Pi2pi_Impl_.subtractionPi","fracs/Pi2pi.hx",25,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_29_dividePi,"fracs._Pi2pi.Pi2pi_Impl_","dividePi",0x732ab7e0,"fracs._Pi2pi.Pi2pi_Impl_.dividePi","fracs/Pi2pi.hx",29,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_33_timesPi,"fracs._Pi2pi.Pi2pi_Impl_","timesPi",0x5f77cd11,"fracs._Pi2pi.Pi2pi_Impl_.timesPi","fracs/Pi2pi.hx",33,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_37_addition,"fracs._Pi2pi.Pi2pi_Impl_","addition",0xcfd21f0a,"fracs._Pi2pi.Pi2pi_Impl_.addition","fracs/Pi2pi.hx",37,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_41_subtraction,"fracs._Pi2pi.Pi2pi_Impl_","subtraction",0x1cf787e6,"fracs._Pi2pi.Pi2pi_Impl_.subtraction","fracs/Pi2pi.hx",41,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_45_divide,"fracs._Pi2pi.Pi2pi_Impl_","divide",0xfa38a207,"fracs._Pi2pi.Pi2pi_Impl_.divide","fracs/Pi2pi.hx",45,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_49_times,"fracs._Pi2pi.Pi2pi_Impl_","times",0xc4b558f8,"fracs._Pi2pi.Pi2pi_Impl_.times","fracs/Pi2pi.hx",49,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_54_get_degrees,"fracs._Pi2pi.Pi2pi_Impl_","get_degrees",0xd13ece70,"fracs._Pi2pi.Pi2pi_Impl_.get_degrees","fracs/Pi2pi.hx",54,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_57_set_degrees,"fracs._Pi2pi.Pi2pi_Impl_","set_degrees",0xdbabd57c,"fracs._Pi2pi.Pi2pi_Impl_.set_degrees","fracs/Pi2pi.hx",57,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_64_fromFraction,"fracs._Pi2pi.Pi2pi_Impl_","fromFraction",0xc075429a,"fracs._Pi2pi.Pi2pi_Impl_.fromFraction","fracs/Pi2pi.hx",64,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_68_tofraction,"fracs._Pi2pi.Pi2pi_Impl_","tofraction",0x3487400b,"fracs._Pi2pi.Pi2pi_Impl_.tofraction","fracs/Pi2pi.hx",68,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_72_fromString,"fracs._Pi2pi.Pi2pi_Impl_","fromString",0x8ba1ff69,"fracs._Pi2pi.Pi2pi_Impl_.fromString","fracs/Pi2pi.hx",72,0x2a6e4ad6)
HX_LOCAL_STACK_FRAME(_hx_pos_367cabf11006982c_79_toString,"fracs._Pi2pi.Pi2pi_Impl_","toString",0x600182ba,"fracs._Pi2pi.Pi2pi_Impl_.toString","fracs/Pi2pi.hx",79,0x2a6e4ad6)
namespace fracs{
namespace _Pi2pi{

void Pi2pi_Impl__obj::__construct() { }

Dynamic Pi2pi_Impl__obj::__CreateEmpty() { return new Pi2pi_Impl__obj; }

void *Pi2pi_Impl__obj::_hx_vtable = 0;

Dynamic Pi2pi_Impl__obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Pi2pi_Impl__obj > _hx_result = new Pi2pi_Impl__obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Pi2pi_Impl__obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1f28d962;
}

Float Pi2pi_Impl__obj::_new(Float f){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_5__new)
HXDLIN(   5)		Float this1 = f;
HXDLIN(   5)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pi2pi_Impl__obj,_new,return )

Float Pi2pi_Impl__obj::fromFloat(Float f){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_12_fromFloat)
HXDLIN(  12)		Float f1;
HXDLIN(  12)		bool f2;
HXDLIN(  12)		if ((f <= ::Math_obj::PI)) {
HXDLIN(  12)			f2 = (f > -(::Math_obj::PI));
            		}
            		else {
HXDLIN(  12)			f2 = false;
            		}
HXDLIN(  12)		if (f2) {
HXDLIN(  12)			f1 = f;
            		}
            		else {
HXDLIN(  12)			Float a = ::hx::Mod((f + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  12)			if ((a >= 0)) {
HXDLIN(  12)				f1 = (a - ::Math_obj::PI);
            			}
            			else {
HXDLIN(  12)				f1 = (a + ::Math_obj::PI);
            			}
            		}
HXDLIN(  12)		Float this1 = f1;
HXDLIN(  12)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pi2pi_Impl__obj,fromFloat,return )

Float Pi2pi_Impl__obj::additionPi(Float this1,Float b){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_21_additionPi)
HXDLIN(  21)		Float f = (this1 + b);
HXDLIN(  21)		Float f1;
HXDLIN(  21)		bool f2;
HXDLIN(  21)		if ((f <= ::Math_obj::PI)) {
HXDLIN(  21)			f2 = (f > -(::Math_obj::PI));
            		}
            		else {
HXDLIN(  21)			f2 = false;
            		}
HXDLIN(  21)		if (f2) {
HXDLIN(  21)			f1 = f;
            		}
            		else {
HXDLIN(  21)			Float a = ::hx::Mod((f + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  21)			if ((a >= 0)) {
HXDLIN(  21)				f1 = (a - ::Math_obj::PI);
            			}
            			else {
HXDLIN(  21)				f1 = (a + ::Math_obj::PI);
            			}
            		}
HXDLIN(  21)		Float this2 = f1;
HXDLIN(  21)		return this2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pi2pi_Impl__obj,additionPi,return )

Float Pi2pi_Impl__obj::subtractionPi(Float this1,Float b){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_25_subtractionPi)
HXDLIN(  25)		Float f = (this1 - b);
HXDLIN(  25)		Float f1;
HXDLIN(  25)		bool f2;
HXDLIN(  25)		if ((f <= ::Math_obj::PI)) {
HXDLIN(  25)			f2 = (f > -(::Math_obj::PI));
            		}
            		else {
HXDLIN(  25)			f2 = false;
            		}
HXDLIN(  25)		if (f2) {
HXDLIN(  25)			f1 = f;
            		}
            		else {
HXDLIN(  25)			Float a = ::hx::Mod((f + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  25)			if ((a >= 0)) {
HXDLIN(  25)				f1 = (a - ::Math_obj::PI);
            			}
            			else {
HXDLIN(  25)				f1 = (a + ::Math_obj::PI);
            			}
            		}
HXDLIN(  25)		Float this2 = f1;
HXDLIN(  25)		return this2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pi2pi_Impl__obj,subtractionPi,return )

Float Pi2pi_Impl__obj::dividePi(Float this1,Float b){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_29_dividePi)
HXDLIN(  29)		Float f = (this1 / b);
HXDLIN(  29)		Float f1;
HXDLIN(  29)		bool f2;
HXDLIN(  29)		if ((f <= ::Math_obj::PI)) {
HXDLIN(  29)			f2 = (f > -(::Math_obj::PI));
            		}
            		else {
HXDLIN(  29)			f2 = false;
            		}
HXDLIN(  29)		if (f2) {
HXDLIN(  29)			f1 = f;
            		}
            		else {
HXDLIN(  29)			Float a = ::hx::Mod((f + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  29)			if ((a >= 0)) {
HXDLIN(  29)				f1 = (a - ::Math_obj::PI);
            			}
            			else {
HXDLIN(  29)				f1 = (a + ::Math_obj::PI);
            			}
            		}
HXDLIN(  29)		Float this2 = f1;
HXDLIN(  29)		return this2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pi2pi_Impl__obj,dividePi,return )

Float Pi2pi_Impl__obj::timesPi(Float this1,Float b){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_33_timesPi)
HXDLIN(  33)		Float f = (this1 * b);
HXDLIN(  33)		Float f1;
HXDLIN(  33)		bool f2;
HXDLIN(  33)		if ((f <= ::Math_obj::PI)) {
HXDLIN(  33)			f2 = (f > -(::Math_obj::PI));
            		}
            		else {
HXDLIN(  33)			f2 = false;
            		}
HXDLIN(  33)		if (f2) {
HXDLIN(  33)			f1 = f;
            		}
            		else {
HXDLIN(  33)			Float a = ::hx::Mod((f + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  33)			if ((a >= 0)) {
HXDLIN(  33)				f1 = (a - ::Math_obj::PI);
            			}
            			else {
HXDLIN(  33)				f1 = (a + ::Math_obj::PI);
            			}
            		}
HXDLIN(  33)		Float this2 = f1;
HXDLIN(  33)		return this2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pi2pi_Impl__obj,timesPi,return )

Float Pi2pi_Impl__obj::addition(Float this1,Float b){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_37_addition)
HXDLIN(  37)		Float f = (this1 + b);
HXDLIN(  37)		Float f1;
HXDLIN(  37)		bool f2;
HXDLIN(  37)		if ((f <= ::Math_obj::PI)) {
HXDLIN(  37)			f2 = (f > -(::Math_obj::PI));
            		}
            		else {
HXDLIN(  37)			f2 = false;
            		}
HXDLIN(  37)		if (f2) {
HXDLIN(  37)			f1 = f;
            		}
            		else {
HXDLIN(  37)			Float a = ::hx::Mod((f + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  37)			if ((a >= 0)) {
HXDLIN(  37)				f1 = (a - ::Math_obj::PI);
            			}
            			else {
HXDLIN(  37)				f1 = (a + ::Math_obj::PI);
            			}
            		}
HXDLIN(  37)		Float this2 = f1;
HXDLIN(  37)		return this2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pi2pi_Impl__obj,addition,return )

Float Pi2pi_Impl__obj::subtraction(Float this1,Float b){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_41_subtraction)
HXDLIN(  41)		Float f = (this1 - b);
HXDLIN(  41)		Float f1;
HXDLIN(  41)		bool f2;
HXDLIN(  41)		if ((f <= ::Math_obj::PI)) {
HXDLIN(  41)			f2 = (f > -(::Math_obj::PI));
            		}
            		else {
HXDLIN(  41)			f2 = false;
            		}
HXDLIN(  41)		if (f2) {
HXDLIN(  41)			f1 = f;
            		}
            		else {
HXDLIN(  41)			Float a = ::hx::Mod((f + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  41)			if ((a >= 0)) {
HXDLIN(  41)				f1 = (a - ::Math_obj::PI);
            			}
            			else {
HXDLIN(  41)				f1 = (a + ::Math_obj::PI);
            			}
            		}
HXDLIN(  41)		Float this2 = f1;
HXDLIN(  41)		return this2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pi2pi_Impl__obj,subtraction,return )

Float Pi2pi_Impl__obj::divide(Float this1,Float b){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_45_divide)
HXDLIN(  45)		Float f = (this1 / b);
HXDLIN(  45)		Float f1;
HXDLIN(  45)		bool f2;
HXDLIN(  45)		if ((f <= ::Math_obj::PI)) {
HXDLIN(  45)			f2 = (f > -(::Math_obj::PI));
            		}
            		else {
HXDLIN(  45)			f2 = false;
            		}
HXDLIN(  45)		if (f2) {
HXDLIN(  45)			f1 = f;
            		}
            		else {
HXDLIN(  45)			Float a = ::hx::Mod((f + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  45)			if ((a >= 0)) {
HXDLIN(  45)				f1 = (a - ::Math_obj::PI);
            			}
            			else {
HXDLIN(  45)				f1 = (a + ::Math_obj::PI);
            			}
            		}
HXDLIN(  45)		Float this2 = f1;
HXDLIN(  45)		return this2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pi2pi_Impl__obj,divide,return )

Float Pi2pi_Impl__obj::times(Float this1,Float b){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_49_times)
HXDLIN(  49)		Float f = (this1 * b);
HXDLIN(  49)		Float f1;
HXDLIN(  49)		bool f2;
HXDLIN(  49)		if ((f <= ::Math_obj::PI)) {
HXDLIN(  49)			f2 = (f > -(::Math_obj::PI));
            		}
            		else {
HXDLIN(  49)			f2 = false;
            		}
HXDLIN(  49)		if (f2) {
HXDLIN(  49)			f1 = f;
            		}
            		else {
HXDLIN(  49)			Float a = ::hx::Mod((f + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  49)			if ((a >= 0)) {
HXDLIN(  49)				f1 = (a - ::Math_obj::PI);
            			}
            			else {
HXDLIN(  49)				f1 = (a + ::Math_obj::PI);
            			}
            		}
HXDLIN(  49)		Float this2 = f1;
HXDLIN(  49)		return this2;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pi2pi_Impl__obj,times,return )

Float Pi2pi_Impl__obj::get_degrees(Float this1){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_54_get_degrees)
HXDLIN(  54)		return ((this1 * ( (Float)(180) )) / ::Math_obj::PI);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pi2pi_Impl__obj,get_degrees,return )

Float Pi2pi_Impl__obj::set_degrees(Float this1,Float val){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_57_set_degrees)
HXLINE(  58)		this1 = ((::Math_obj::PI * val) / ( (Float)(180) ));
HXLINE(  59)		return val;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Pi2pi_Impl__obj,set_degrees,return )

Float Pi2pi_Impl__obj::fromFraction( ::Dynamic val){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_64_fromFraction)
HXDLIN(  64)		Float f;
HXDLIN(  64)		if (( (bool)(val->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXDLIN(  64)			f = (( (Float)(val->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ) / ( (Float)(val->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            		}
            		else {
HXDLIN(  64)			f = (( (Float)(-(( (int)(val->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ))) ) / ( (Float)(val->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            		}
HXDLIN(  64)		Float f1 = (f * ::Math_obj::PI);
HXDLIN(  64)		Float f2;
HXDLIN(  64)		bool f3;
HXDLIN(  64)		if ((f1 <= ::Math_obj::PI)) {
HXDLIN(  64)			f3 = (f1 > -(::Math_obj::PI));
            		}
            		else {
HXDLIN(  64)			f3 = false;
            		}
HXDLIN(  64)		if (f3) {
HXDLIN(  64)			f2 = f1;
            		}
            		else {
HXDLIN(  64)			Float a = ::hx::Mod((f1 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  64)			if ((a >= 0)) {
HXDLIN(  64)				f2 = (a - ::Math_obj::PI);
            			}
            			else {
HXDLIN(  64)				f2 = (a + ::Math_obj::PI);
            			}
            		}
HXDLIN(  64)		Float this1 = f2;
HXDLIN(  64)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pi2pi_Impl__obj,fromFraction,return )

 ::Dynamic Pi2pi_Impl__obj::tofraction(Float this1){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_68_tofraction)
HXDLIN(  68)		Float f = (this1 / ::Math_obj::PI);
HXDLIN(  68)		::Array< ::Dynamic> arr = ::fracs::Fracs_obj::approximateFractions(f);
HXDLIN(  68)		Float dist = ::Math_obj::POSITIVE_INFINITY;
HXDLIN(  68)		Float dif;
HXDLIN(  68)		int l = arr->length;
HXDLIN(  68)		Float fracFloat;
HXDLIN(  68)		 ::Dynamic frac;
HXDLIN(  68)		 ::Dynamic fracStore = arr->__get(0);
HXDLIN(  68)		{
HXDLIN(  68)			int _g = 0;
HXDLIN(  68)			int _g1 = l;
HXDLIN(  68)			while((_g < _g1)){
HXDLIN(  68)				_g = (_g + 1);
HXDLIN(  68)				int i = (_g - 1);
HXDLIN(  68)				 ::Dynamic frac = arr->__get(i);
HXDLIN(  68)				if (( (bool)(frac->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXDLIN(  68)					fracFloat = (( (Float)(frac->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ) / ( (Float)(frac->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            				}
            				else {
HXDLIN(  68)					fracFloat = (( (Float)(-(( (int)(frac->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ))) ) / ( (Float)(frac->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            				}
HXDLIN(  68)				dif = ::Math_obj::abs((fracFloat - f));
HXDLIN(  68)				if ((dif < dist)) {
HXDLIN(  68)					dist = dif;
HXDLIN(  68)					fracStore = frac;
            				}
            			}
            		}
HXDLIN(  68)		return fracStore;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pi2pi_Impl__obj,tofraction,return )

Float Pi2pi_Impl__obj::fromString(::String val){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_72_fromString)
HXLINE(  73)		int i = val.indexOf(HX_("/",2f,00,00,00),null());
HXDLIN(  73)		 ::Dynamic frac;
HXDLIN(  73)		if ((i != -1)) {
HXLINE(  73)			int numerator = ( (int)(::Std_obj::parseInt(val.substr(0,i))) );
HXDLIN(  73)			int denominator = ( (int)(::Std_obj::parseInt(val.substr((i + 1),val.length))) );
HXDLIN(  73)			 ::Dynamic positive = true;
HXDLIN(  73)			 ::Dynamic value = null();
HXDLIN(  73)			bool numNeg = (numerator < 0);
HXDLIN(  73)			bool denoNeg = (denominator < 0);
HXDLIN(  73)			if (::hx::IsNull( value )) {
HXLINE(  73)				if (( (bool)(positive) )) {
HXLINE(  73)					value = (( (Float)(numerator) ) / ( (Float)(denominator) ));
            				}
            				else {
HXLINE(  73)					value = (( (Float)(-(numerator)) ) / ( (Float)(denominator) ));
            				}
            			}
HXDLIN(  73)			bool frac1;
HXDLIN(  73)			if (!(numNeg)) {
HXLINE(  73)				frac1 = denoNeg;
            			}
            			else {
HXLINE(  73)				frac1 = true;
            			}
HXDLIN(  73)			if (frac1) {
HXLINE(  73)				bool frac;
HXDLIN(  73)				if (numNeg) {
HXLINE(  73)					frac = denoNeg;
            				}
            				else {
HXLINE(  73)					frac = false;
            				}
HXDLIN(  73)				if (!(frac)) {
HXLINE(  73)					positive = !(( (bool)(positive) ));
            				}
HXDLIN(  73)				if (numNeg) {
HXLINE(  73)					numerator = -(numerator);
            				}
HXDLIN(  73)				if (denoNeg) {
HXLINE(  73)					denominator = -(denominator);
            				}
            			}
HXDLIN(  73)			 ::Dynamic this1 =  ::Dynamic(::hx::Anon_obj::Create(4)
            				->setFixed(0,HX_("numerator",89,82,9c,c2),numerator)
            				->setFixed(1,HX_("positive",b9,a6,fa,ca),positive)
            				->setFixed(2,HX_("denominator",a6,25,84,eb),denominator)
            				->setFixed(3,HX_("value",71,7f,b8,31),value));
HXDLIN(  73)			frac = this1;
            		}
            		else {
HXLINE(  73)			Float f = ::Std_obj::parseFloat(val);
HXDLIN(  73)			::Array< ::Dynamic> arr = ::fracs::Fracs_obj::approximateFractions(f);
HXDLIN(  73)			Float dist = ::Math_obj::POSITIVE_INFINITY;
HXDLIN(  73)			Float dif;
HXDLIN(  73)			int l = arr->length;
HXDLIN(  73)			Float fracFloat;
HXDLIN(  73)			 ::Dynamic frac1;
HXDLIN(  73)			 ::Dynamic fracStore = arr->__get(0);
HXDLIN(  73)			{
HXLINE(  73)				int _g = 0;
HXDLIN(  73)				int _g1 = l;
HXDLIN(  73)				while((_g < _g1)){
HXLINE(  73)					_g = (_g + 1);
HXDLIN(  73)					int i = (_g - 1);
HXDLIN(  73)					 ::Dynamic frac = arr->__get(i);
HXDLIN(  73)					if (( (bool)(frac->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXLINE(  73)						fracFloat = (( (Float)(frac->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ) / ( (Float)(frac->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            					}
            					else {
HXLINE(  73)						fracFloat = (( (Float)(-(( (int)(frac->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ))) ) / ( (Float)(frac->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            					}
HXDLIN(  73)					dif = ::Math_obj::abs((fracFloat - f));
HXDLIN(  73)					if ((dif < dist)) {
HXLINE(  73)						dist = dif;
HXDLIN(  73)						fracStore = frac;
            					}
            				}
            			}
HXDLIN(  73)			frac = fracStore;
            		}
HXDLIN(  73)		 ::Dynamic frac1 = frac;
HXLINE(  74)		Float f;
HXDLIN(  74)		if (( (bool)(frac1->__Field(HX_("positive",b9,a6,fa,ca),::hx::paccDynamic)) )) {
HXLINE(  74)			f = (( (Float)(frac1->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ) / ( (Float)(frac1->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            		}
            		else {
HXLINE(  74)			f = (( (Float)(-(( (int)(frac1->__Field(HX_("numerator",89,82,9c,c2),::hx::paccDynamic)) ))) ) / ( (Float)(frac1->__Field(HX_("denominator",a6,25,84,eb),::hx::paccDynamic)) ));
            		}
HXDLIN(  74)		Float f1 = (f * ::Math_obj::PI);
HXDLIN(  74)		Float f2;
HXDLIN(  74)		bool f3;
HXDLIN(  74)		if ((f1 <= ::Math_obj::PI)) {
HXLINE(  74)			f3 = (f1 > -(::Math_obj::PI));
            		}
            		else {
HXLINE(  74)			f3 = false;
            		}
HXDLIN(  74)		if (f3) {
HXLINE(  74)			f2 = f1;
            		}
            		else {
HXLINE(  74)			Float a = ::hx::Mod((f1 + ::Math_obj::PI),(( (Float)(2) ) * ::Math_obj::PI));
HXDLIN(  74)			if ((a >= 0)) {
HXLINE(  74)				f2 = (a - ::Math_obj::PI);
            			}
            			else {
HXLINE(  74)				f2 = (a + ::Math_obj::PI);
            			}
            		}
HXDLIN(  74)		Float this1 = f2;
HXDLIN(  74)		return this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pi2pi_Impl__obj,fromString,return )

::String Pi2pi_Impl__obj::toString(Float this1){
            	HX_STACKFRAME(&_hx_pos_367cabf11006982c_79_toString)
HXDLIN(  79)		return ::Std_obj::string(this1);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Pi2pi_Impl__obj,toString,return )


Pi2pi_Impl__obj::Pi2pi_Impl__obj()
{
}

bool Pi2pi_Impl__obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"_new") ) { outValue = _new_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"times") ) { outValue = times_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"divide") ) { outValue = divide_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"timesPi") ) { outValue = timesPi_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"dividePi") ) { outValue = dividePi_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"addition") ) { outValue = addition_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"toString") ) { outValue = toString_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"fromFloat") ) { outValue = fromFloat_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"additionPi") ) { outValue = additionPi_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"tofraction") ) { outValue = tofraction_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fromString") ) { outValue = fromString_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"subtraction") ) { outValue = subtraction_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"get_degrees") ) { outValue = get_degrees_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"set_degrees") ) { outValue = set_degrees_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"fromFraction") ) { outValue = fromFraction_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"subtractionPi") ) { outValue = subtractionPi_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Pi2pi_Impl__obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Pi2pi_Impl__obj_sStaticStorageInfo = 0;
#endif

::hx::Class Pi2pi_Impl__obj::__mClass;

static ::String Pi2pi_Impl__obj_sStaticFields[] = {
	HX_("_new",61,15,1f,3f),
	HX_("fromFloat",d2,af,1f,b7),
	HX_("additionPi",15,ea,b1,c8),
	HX_("subtractionPi",4d,f8,6e,a9),
	HX_("dividePi",d2,05,98,4b),
	HX_("timesPi",5f,03,fa,d8),
	HX_("addition",fc,6c,3f,a8),
	HX_("subtraction",34,fd,0d,0c),
	HX_("divide",79,2f,12,bf),
	HX_("times",c6,bf,35,10),
	HX_("get_degrees",be,43,55,c0),
	HX_("set_degrees",ca,4a,c2,ca),
	HX_("fromFraction",8c,71,05,05),
	HX_("tofraction",7d,6e,59,fd),
	HX_("fromString",db,2d,74,54),
	HX_("toString",ac,d0,6e,38),
	::String(null())
};

void Pi2pi_Impl__obj::__register()
{
	Pi2pi_Impl__obj _hx_dummy;
	Pi2pi_Impl__obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("fracs._Pi2pi.Pi2pi_Impl_",20,28,d8,90);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Pi2pi_Impl__obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Pi2pi_Impl__obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Pi2pi_Impl__obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Pi2pi_Impl__obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Pi2pi_Impl__obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace fracs
} // end namespace _Pi2pi
