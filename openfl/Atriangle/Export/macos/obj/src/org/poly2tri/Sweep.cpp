// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_org_poly2tri_AdvancingFront
#include <org/poly2tri/AdvancingFront.h>
#endif
#ifndef INCLUDED_org_poly2tri_Basin
#include <org/poly2tri/Basin.h>
#endif
#ifndef INCLUDED_org_poly2tri_Constants
#include <org/poly2tri/Constants.h>
#endif
#ifndef INCLUDED_org_poly2tri_Edge
#include <org/poly2tri/Edge.h>
#endif
#ifndef INCLUDED_org_poly2tri_EdgeEvent
#include <org/poly2tri/EdgeEvent.h>
#endif
#ifndef INCLUDED_org_poly2tri_Node
#include <org/poly2tri/Node.h>
#endif
#ifndef INCLUDED_org_poly2tri_Orientation
#include <org/poly2tri/Orientation.h>
#endif
#ifndef INCLUDED_org_poly2tri_Point
#include <org/poly2tri/Point.h>
#endif
#ifndef INCLUDED_org_poly2tri_Sweep
#include <org/poly2tri/Sweep.h>
#endif
#ifndef INCLUDED_org_poly2tri_SweepContext
#include <org/poly2tri/SweepContext.h>
#endif
#ifndef INCLUDED_org_poly2tri_Triangle
#include <org/poly2tri/Triangle.h>
#endif
#ifndef INCLUDED_org_poly2tri_Utils
#include <org/poly2tri/Utils.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_dde5ac355f43afe6_9_new,"org.poly2tri.Sweep","new",0xcf13abdf,"org.poly2tri.Sweep.new","org/poly2tri/Sweep.hx",9,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_13_triangulate,"org.poly2tri.Sweep","triangulate",0x39f357ab,"org.poly2tri.Sweep.triangulate","org/poly2tri/Sweep.hx",13,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_22_sweepPoints,"org.poly2tri.Sweep","sweepPoints",0xbe29c7ae,"org.poly2tri.Sweep.sweepPoints","org/poly2tri/Sweep.hx",22,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_36_finalizationPolygon,"org.poly2tri.Sweep","finalizationPolygon",0x5ca4552b,"org.poly2tri.Sweep.finalizationPolygon","org/poly2tri/Sweep.hx",36,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_52_pointEvent,"org.poly2tri.Sweep","pointEvent",0xf44b040b,"org.poly2tri.Sweep.pointEvent","org/poly2tri/Sweep.hx",52,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_67_edgeEventByEdge,"org.poly2tri.Sweep","edgeEventByEdge",0xcaeb5a30,"org.poly2tri.Sweep.edgeEventByEdge","org/poly2tri/Sweep.hx",67,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_82_edgeEventByPoints,"org.poly2tri.Sweep","edgeEventByPoints",0x9cc946d6,"org.poly2tri.Sweep.edgeEventByPoints","org/poly2tri/Sweep.hx",82,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_113_newFrontTriangle,"org.poly2tri.Sweep","newFrontTriangle",0x33e54932,"org.poly2tri.Sweep.newFrontTriangle","org/poly2tri/Sweep.hx",113,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_140_fill,"org.poly2tri.Sweep","fill",0x5cdc0224,"org.poly2tri.Sweep.fill","org/poly2tri/Sweep.hx",140,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_167_fillAdvancingFront,"org.poly2tri.Sweep","fillAdvancingFront",0xaff6fb2e,"org.poly2tri.Sweep.fillAdvancingFront","org/poly2tri/Sweep.hx",167,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_204_legalize,"org.poly2tri.Sweep","legalize",0x25cca8dc,"org.poly2tri.Sweep.legalize","org/poly2tri/Sweep.hx",204,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_274_fillBasin,"org.poly2tri.Sweep","fillBasin",0xe21d55f5,"org.poly2tri.Sweep.fillBasin","org/poly2tri/Sweep.hx",274,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_312_fillBasinReq,"org.poly2tri.Sweep","fillBasinReq",0x5f55a269,"org.poly2tri.Sweep.fillBasinReq","org/poly2tri/Sweep.hx",312,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_346_isShallow,"org.poly2tri.Sweep","isShallow",0xce9005c9,"org.poly2tri.Sweep.isShallow","org/poly2tri/Sweep.hx",346,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_358_fillEdgeEvent,"org.poly2tri.Sweep","fillEdgeEvent",0x1ff2ebd9,"org.poly2tri.Sweep.fillEdgeEvent","org/poly2tri/Sweep.hx",358,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_370_fillRightAboveEdgeEvent,"org.poly2tri.Sweep","fillRightAboveEdgeEvent",0x53703cf8,"org.poly2tri.Sweep.fillRightAboveEdgeEvent","org/poly2tri/Sweep.hx",370,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_385_fillRightBelowEdgeEvent,"org.poly2tri.Sweep","fillRightBelowEdgeEvent",0x21483ee4,"org.poly2tri.Sweep.fillRightBelowEdgeEvent","org/poly2tri/Sweep.hx",385,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_400_fillRightConcaveEdgeEvent,"org.poly2tri.Sweep","fillRightConcaveEdgeEvent",0xe5b5e146,"org.poly2tri.Sweep.fillRightConcaveEdgeEvent","org/poly2tri/Sweep.hx",400,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_424_fillRightConvexEdgeEvent,"org.poly2tri.Sweep","fillRightConvexEdgeEvent",0x80f5c1fe,"org.poly2tri.Sweep.fillRightConvexEdgeEvent","org/poly2tri/Sweep.hx",424,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_447_fillLeftAboveEdgeEvent,"org.poly2tri.Sweep","fillLeftAboveEdgeEvent",0xd36cb16b,"org.poly2tri.Sweep.fillLeftAboveEdgeEvent","org/poly2tri/Sweep.hx",447,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_463_fillLeftBelowEdgeEvent,"org.poly2tri.Sweep","fillLeftBelowEdgeEvent",0xa144b357,"org.poly2tri.Sweep.fillLeftBelowEdgeEvent","org/poly2tri/Sweep.hx",463,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_483_fillLeftConvexEdgeEvent,"org.poly2tri.Sweep","fillLeftConvexEdgeEvent",0xfddf322b,"org.poly2tri.Sweep.fillLeftConvexEdgeEvent","org/poly2tri/Sweep.hx",483,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_505_fillLeftConcaveEdgeEvent,"org.poly2tri.Sweep","fillLeftConcaveEdgeEvent",0xb50e9879,"org.poly2tri.Sweep.fillLeftConcaveEdgeEvent","org/poly2tri/Sweep.hx",505,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_529_flipEdgeEvent,"org.poly2tri.Sweep","flipEdgeEvent",0x63bfd26f,"org.poly2tri.Sweep.flipEdgeEvent","org/poly2tri/Sweep.hx",529,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_577_nextFlipTriangle,"org.poly2tri.Sweep","nextFlipTriangle",0xa26d1549,"org.poly2tri.Sweep.nextFlipTriangle","org/poly2tri/Sweep.hx",577,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_618_flipScanEdgeEvent,"org.poly2tri.Sweep","flipScanEdgeEvent",0xfd99ee32,"org.poly2tri.Sweep.flipScanEdgeEvent","org/poly2tri/Sweep.hx",618,0x2b240c51)
HX_LOCAL_STACK_FRAME(_hx_pos_dde5ac355f43afe6_599_nextFlipPoint,"org.poly2tri.Sweep","nextFlipPoint",0xfa21b32f,"org.poly2tri.Sweep.nextFlipPoint","org/poly2tri/Sweep.hx",599,0x2b240c51)
namespace org{
namespace poly2tri{

void Sweep_obj::__construct( ::org::poly2tri::SweepContext context){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_9_new)
HXDLIN(   9)		this->context = context;
            	}

Dynamic Sweep_obj::__CreateEmpty() { return new Sweep_obj; }

void *Sweep_obj::_hx_vtable = 0;

Dynamic Sweep_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Sweep_obj > _hx_result = new Sweep_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Sweep_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x127976c3;
}

void Sweep_obj::triangulate(){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_13_triangulate)
HXLINE(  14)		this->context->initTriangulation();
HXLINE(  15)		this->context->createAdvancingFront();
HXLINE(  16)		this->sweepPoints();
HXLINE(  17)		this->finalizationPolygon();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sweep_obj,triangulate,(void))

void Sweep_obj::sweepPoints(){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_22_sweepPoints)
HXDLIN(  22)		int _g = 1;
HXDLIN(  22)		int _g1 = this->context->points->length;
HXDLIN(  22)		while((_g < _g1)){
HXDLIN(  22)			_g = (_g + 1);
HXDLIN(  22)			int i = (_g - 1);
HXLINE(  25)			 ::org::poly2tri::Point point = this->context->points->__get(i).StaticCast<  ::org::poly2tri::Point >();
HXLINE(  26)			 ::org::poly2tri::Node node = this->pointEvent(point);
HXLINE(  27)			{
HXLINE(  27)				int _g1 = 0;
HXDLIN(  27)				int _g2 = point->get_edge_list()->length;
HXDLIN(  27)				while((_g1 < _g2)){
HXLINE(  27)					_g1 = (_g1 + 1);
HXDLIN(  27)					int j = (_g1 - 1);
HXLINE(  30)					this->edgeEventByEdge(point->get_edge_list()->__get(j).StaticCast<  ::org::poly2tri::Edge >(),node);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sweep_obj,sweepPoints,(void))

void Sweep_obj::finalizationPolygon(){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_36_finalizationPolygon)
HXLINE(  38)		 ::org::poly2tri::Triangle t = this->context->front->head->next->triangle;
HXLINE(  39)		 ::org::poly2tri::Point p = this->context->front->head->next->point;
HXLINE(  40)		while(!(t->getConstrainedEdgeCW(p))){
HXLINE(  40)			t = t->neighborCCW(p);
            		}
HXLINE(  43)		this->context->meshClean(t);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Sweep_obj,finalizationPolygon,(void))

 ::org::poly2tri::Node Sweep_obj::pointEvent( ::org::poly2tri::Point point){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_52_pointEvent)
HXLINE(  54)		 ::org::poly2tri::Node node = this->context->locateNode(point);
HXLINE(  55)		 ::org::poly2tri::Node new_node = this->newFrontTriangle(point,node);
HXLINE(  59)		if ((point->x <= (node->point->x + ::org::poly2tri::Constants_obj::EPSILON))) {
HXLINE(  59)			this->fill(node);
            		}
HXLINE(  61)		this->fillAdvancingFront(new_node);
HXLINE(  62)		return new_node;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Sweep_obj,pointEvent,return )

void Sweep_obj::edgeEventByEdge( ::org::poly2tri::Edge edge, ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_67_edgeEventByEdge)
HXLINE(  68)		this->context->edge_event->constrained_edge = edge;
HXLINE(  69)		this->context->edge_event->right = (edge->p->x > edge->q->x);
HXLINE(  71)		if (node->triangle->isEdgeSide(edge->p,edge->q)) {
HXLINE(  71)			return;
            		}
HXLINE(  76)		this->fillEdgeEvent(edge,node);
HXLINE(  78)		this->edgeEventByPoints(edge->p,edge->q,node->triangle,edge->q);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sweep_obj,edgeEventByEdge,(void))

void Sweep_obj::edgeEventByPoints( ::org::poly2tri::Point ep, ::org::poly2tri::Point eq, ::org::poly2tri::Triangle triangle, ::org::poly2tri::Point point){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_82_edgeEventByPoints)
HXLINE(  83)		if (triangle->isEdgeSide(ep,eq)) {
HXLINE(  83)			return;
            		}
HXLINE(  85)		 ::org::poly2tri::Point p1 = triangle->pointCCW(point);
HXLINE(  86)		int o1 = ::org::poly2tri::Orientation_obj::orient2d(eq,p1,ep);
HXLINE(  87)		if ((o1 == 0)) {
HXLINE(  87)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Sweep.edgeEvent: Collinear not supported!",bc,73,c0,8a)));
            		}
HXLINE(  89)		 ::org::poly2tri::Point p2 = triangle->pointCW(point);
HXLINE(  90)		int o2 = ::org::poly2tri::Orientation_obj::orient2d(eq,p2,ep);
HXLINE(  91)		if ((o2 == 0)) {
HXLINE(  91)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Sweep.edgeEvent: Collinear not supported!",bc,73,c0,8a)));
            		}
HXLINE(  93)		if ((o1 == o2)) {
HXLINE(  97)			if ((o1 == 1)) {
HXLINE(  98)				triangle = triangle->neighborCCW(point);
            			}
            			else {
HXLINE(  99)				triangle = triangle->neighborCW(point);
            			}
HXLINE( 101)			this->edgeEventByPoints(ep,eq,triangle,point);
            		}
            		else {
HXLINE( 106)			this->flipEdgeEvent(ep,eq,triangle,point);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Sweep_obj,edgeEventByPoints,(void))

 ::org::poly2tri::Node Sweep_obj::newFrontTriangle( ::org::poly2tri::Point point, ::org::poly2tri::Node node){
            	HX_GC_STACKFRAME(&_hx_pos_dde5ac355f43afe6_113_newFrontTriangle)
HXLINE( 114)		 ::org::poly2tri::Triangle triangle =  ::org::poly2tri::Triangle_obj::__alloc( HX_CTX ,point,node->point,node->next->point,null(),null());
HXLINE( 118)		triangle->markNeighborTriangle(node->triangle);
HXLINE( 119)		this->context->addToMap(triangle);
HXLINE( 121)		 ::org::poly2tri::Node new_node =  ::org::poly2tri::Node_obj::__alloc( HX_CTX ,point,null());
HXLINE( 122)		new_node->next = node->next;
HXLINE( 123)		new_node->prev = node;
HXLINE( 124)		node->next->prev = new_node;
HXLINE( 125)		node->next = new_node;
HXLINE( 127)		if (!(this->legalize(triangle))) {
HXLINE( 127)			this->context->mapTriangleToNodes(triangle);
            		}
HXLINE( 129)		return new_node;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sweep_obj,newFrontTriangle,return )

void Sweep_obj::fill( ::org::poly2tri::Node node){
            	HX_GC_STACKFRAME(&_hx_pos_dde5ac355f43afe6_140_fill)
HXLINE( 141)		 ::org::poly2tri::Triangle triangle =  ::org::poly2tri::Triangle_obj::__alloc( HX_CTX ,node->prev->point,node->point,node->next->point,null(),null());
HXLINE( 145)		triangle->markNeighborTriangle(node->prev->triangle);
HXLINE( 146)		triangle->markNeighborTriangle(node->triangle);
HXLINE( 148)		this->context->addToMap(triangle);
HXLINE( 151)		node->prev->next = node->next;
HXLINE( 152)		node->next->prev = node->prev;
HXLINE( 155)		if (!(this->legalize(triangle))) {
HXLINE( 157)			this->context->mapTriangleToNodes(triangle);
            		}
HXLINE( 160)		this->context->removeNode(node);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Sweep_obj,fill,(void))

void Sweep_obj::fillAdvancingFront( ::org::poly2tri::Node n){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_167_fillAdvancingFront)
HXLINE( 169)		Float angle;
HXLINE( 168)		 ::org::poly2tri::Node node = n->next;
HXLINE( 173)		while(::hx::IsNotNull( node->next )){
HXLINE( 175)			angle = node->getHoleAngle();
HXLINE( 176)			bool _hx_tmp;
HXDLIN( 176)			if (!((angle > ::org::poly2tri::Constants_obj::PI_2))) {
HXLINE( 176)				_hx_tmp = (angle < -(::org::poly2tri::Constants_obj::PI_2));
            			}
            			else {
HXLINE( 176)				_hx_tmp = true;
            			}
HXDLIN( 176)			if (_hx_tmp) {
HXLINE( 176)				goto _hx_goto_12;
            			}
HXLINE( 177)			this->fill(node);
HXLINE( 178)			node = node->next;
            		}
            		_hx_goto_12:;
HXLINE( 182)		node = n->prev;
HXLINE( 183)		while(::hx::IsNotNull( node->prev )){
HXLINE( 185)			angle = node->getHoleAngle();
HXLINE( 186)			bool _hx_tmp;
HXDLIN( 186)			if (!((angle > ::org::poly2tri::Constants_obj::PI_2))) {
HXLINE( 186)				_hx_tmp = (angle < -(::org::poly2tri::Constants_obj::PI_2));
            			}
            			else {
HXLINE( 186)				_hx_tmp = true;
            			}
HXDLIN( 186)			if (_hx_tmp) {
HXLINE( 186)				goto _hx_goto_13;
            			}
HXLINE( 187)			this->fill(node);
HXLINE( 188)			node = node->prev;
            		}
            		_hx_goto_13:;
HXLINE( 192)		bool _hx_tmp;
HXDLIN( 192)		if (::hx::IsNotNull( n->next )) {
HXLINE( 192)			_hx_tmp = ::hx::IsNotNull( n->next->next );
            		}
            		else {
HXLINE( 192)			_hx_tmp = false;
            		}
HXDLIN( 192)		if (_hx_tmp) {
HXLINE( 194)			angle = n->getBasinAngle();
HXLINE( 195)			if ((angle < ::org::poly2tri::Constants_obj::PI_3div4)) {
HXLINE( 195)				this->fillBasin(n);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Sweep_obj,fillAdvancingFront,(void))

bool Sweep_obj::legalize( ::org::poly2tri::Triangle t){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_204_legalize)
HXLINE( 205)		{
HXLINE( 205)			int _g = 0;
HXDLIN( 205)			while((_g < 3)){
HXLINE( 205)				_g = (_g + 1);
HXDLIN( 205)				int i = (_g - 1);
HXLINE( 207)				if (t->delaunay_edge->__get(i)) {
HXLINE( 207)					continue;
            				}
HXLINE( 209)				 ::org::poly2tri::Triangle ot = t->neighbors->__get(i).StaticCast<  ::org::poly2tri::Triangle >();
HXLINE( 210)				if (::hx::IsNotNull( ot )) {
HXLINE( 212)					 ::org::poly2tri::Point p = t->points->__get(i).StaticCast<  ::org::poly2tri::Point >();
HXLINE( 213)					 ::org::poly2tri::Point op = ot->oppositePoint(t,p);
HXLINE( 214)					int oi = ot->index(op);
HXLINE( 218)					bool _hx_tmp;
HXDLIN( 218)					if (!(ot->constrained_edge->__get(oi))) {
HXLINE( 218)						_hx_tmp = ot->delaunay_edge->__get(oi);
            					}
            					else {
HXLINE( 218)						_hx_tmp = true;
            					}
HXDLIN( 218)					if (_hx_tmp) {
HXLINE( 220)						t->constrained_edge[i] = ot->constrained_edge->__get(oi);
HXLINE( 221)						continue;
            					}
HXLINE( 225)					 ::org::poly2tri::Point _hx_tmp1 = t->pointCCW(p);
HXDLIN( 225)					if (::org::poly2tri::Utils_obj::insideIncircle(p,_hx_tmp1,t->pointCW(p),op)) {
HXLINE( 228)						t->delaunay_edge[i] = true;
HXLINE( 229)						ot->delaunay_edge[oi] = true;
HXLINE( 232)						::org::poly2tri::Triangle_obj::rotateTrianglePair(t,p,ot,op);
HXLINE( 237)						bool not_legalized = !(this->legalize(t));
HXLINE( 241)						if (not_legalized) {
HXLINE( 241)							this->context->mapTriangleToNodes(t);
            						}
HXLINE( 243)						not_legalized = !(this->legalize(ot));
HXLINE( 244)						if (not_legalized) {
HXLINE( 244)							this->context->mapTriangleToNodes(ot);
            						}
HXLINE( 250)						t->delaunay_edge[i] = false;
HXLINE( 251)						ot->delaunay_edge[oi] = false;
HXLINE( 255)						return true;
            					}
            				}
            			}
            		}
HXLINE( 261)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Sweep_obj,legalize,return )

void Sweep_obj::fillBasin( ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_274_fillBasin)
HXLINE( 275)		 ::org::poly2tri::Node _hx_tmp;
HXDLIN( 275)		if ((::org::poly2tri::Orientation_obj::orient2d(node->point,node->next->point,node->next->next->point) == -1)) {
HXLINE( 275)			_hx_tmp = node->next->next;
            		}
            		else {
HXLINE( 275)			_hx_tmp = node->next;
            		}
HXDLIN( 275)		this->context->basin->left_node = _hx_tmp;
HXLINE( 281)		this->context->basin->bottom_node = this->context->basin->left_node;
HXLINE( 282)		while(true){
HXLINE( 282)			bool _hx_tmp;
HXDLIN( 282)			if (::hx::IsNotNull( this->context->basin->bottom_node->next )) {
HXLINE( 282)				_hx_tmp = (this->context->basin->bottom_node->point->y >= this->context->basin->bottom_node->next->point->y);
            			}
            			else {
HXLINE( 282)				_hx_tmp = false;
            			}
HXDLIN( 282)			if (!(_hx_tmp)) {
HXLINE( 282)				goto _hx_goto_17;
            			}
HXLINE( 284)			this->context->basin->bottom_node = this->context->basin->bottom_node->next;
            		}
            		_hx_goto_17:;
HXLINE( 288)		if (::hx::IsInstanceEq( this->context->basin->bottom_node,this->context->basin->left_node )) {
HXLINE( 288)			return;
            		}
HXLINE( 290)		this->context->basin->right_node = this->context->basin->bottom_node;
HXLINE( 291)		while(true){
HXLINE( 291)			bool _hx_tmp;
HXDLIN( 291)			if (::hx::IsNotNull( this->context->basin->right_node->next )) {
HXLINE( 291)				_hx_tmp = (this->context->basin->right_node->point->y < this->context->basin->right_node->next->point->y);
            			}
            			else {
HXLINE( 291)				_hx_tmp = false;
            			}
HXDLIN( 291)			if (!(_hx_tmp)) {
HXLINE( 291)				goto _hx_goto_18;
            			}
HXLINE( 293)			this->context->basin->right_node = this->context->basin->right_node->next;
            		}
            		_hx_goto_18:;
HXLINE( 297)		if (::hx::IsInstanceEq( this->context->basin->right_node,this->context->basin->bottom_node )) {
HXLINE( 297)			return;
            		}
HXLINE( 299)		this->context->basin->width = (this->context->basin->right_node->point->x - this->context->basin->left_node->point->x);
HXLINE( 300)		this->context->basin->left_highest = (this->context->basin->left_node->point->y > this->context->basin->right_node->point->y);
HXLINE( 302)		this->fillBasinReq(this->context->basin->bottom_node);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Sweep_obj,fillBasin,(void))

void Sweep_obj::fillBasinReq( ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_312_fillBasinReq)
HXLINE( 314)		if (this->isShallow(node)) {
HXLINE( 314)			return;
            		}
HXLINE( 316)		this->fill(node);
HXLINE( 318)		bool _hx_tmp;
HXDLIN( 318)		if (::hx::IsInstanceEq( node->prev,this->context->basin->left_node )) {
HXLINE( 318)			_hx_tmp = ::hx::IsInstanceEq( node->next,this->context->basin->right_node );
            		}
            		else {
HXLINE( 318)			_hx_tmp = false;
            		}
HXDLIN( 318)		if (_hx_tmp) {
HXLINE( 320)			return;
            		}
            		else {
HXLINE( 322)			if (::hx::IsInstanceEq( node->prev,this->context->basin->left_node )) {
HXLINE( 324)				if ((::org::poly2tri::Orientation_obj::orient2d(node->point,node->next->point,node->next->next->point) == 1)) {
HXLINE( 324)					return;
            				}
HXLINE( 325)				node = node->next;
            			}
            			else {
HXLINE( 327)				if (::hx::IsInstanceEq( node->next,this->context->basin->right_node )) {
HXLINE( 329)					if ((::org::poly2tri::Orientation_obj::orient2d(node->point,node->prev->point,node->prev->prev->point) == -1)) {
HXLINE( 329)						return;
            					}
HXLINE( 330)					node = node->prev;
            				}
            				else {
HXLINE( 335)					if ((node->prev->point->y < node->next->point->y)) {
HXLINE( 336)						node = node->prev;
            					}
            					else {
HXLINE( 337)						node = node->next;
            					}
            				}
            			}
            		}
HXLINE( 341)		this->fillBasinReq(node);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Sweep_obj,fillBasinReq,(void))

bool Sweep_obj::isShallow( ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_346_isShallow)
HXLINE( 347)		Float height;
HXDLIN( 347)		if (this->context->basin->left_highest) {
HXLINE( 347)			height = (this->context->basin->left_node->point->y - node->point->y);
            		}
            		else {
HXLINE( 347)			height = (this->context->basin->right_node->point->y - node->point->y);
            		}
HXLINE( 353)		return (this->context->basin->width > height);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Sweep_obj,isShallow,return )

void Sweep_obj::fillEdgeEvent( ::org::poly2tri::Edge edge, ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_358_fillEdgeEvent)
HXDLIN( 358)		if (this->context->edge_event->right) {
HXLINE( 360)			this->fillRightAboveEdgeEvent(edge,node);
            		}
            		else {
HXLINE( 364)			this->fillLeftAboveEdgeEvent(edge,node);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sweep_obj,fillEdgeEvent,(void))

void Sweep_obj::fillRightAboveEdgeEvent( ::org::poly2tri::Edge edge, ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_370_fillRightAboveEdgeEvent)
HXDLIN( 370)		while((node->next->point->x < edge->p->x)){
HXLINE( 373)			if ((::org::poly2tri::Orientation_obj::orient2d(edge->q,node->next->point,edge->p) == -1)) {
HXLINE( 375)				this->fillRightBelowEdgeEvent(edge,node);
            			}
            			else {
HXLINE( 379)				node = node->next;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sweep_obj,fillRightAboveEdgeEvent,(void))

void Sweep_obj::fillRightBelowEdgeEvent( ::org::poly2tri::Edge edge, ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_385_fillRightBelowEdgeEvent)
HXLINE( 386)		if ((node->point->x >= edge->p->x)) {
HXLINE( 386)			return;
            		}
HXLINE( 387)		if ((::org::poly2tri::Orientation_obj::orient2d(node->point,node->next->point,node->next->next->point) == -1)) {
HXLINE( 390)			this->fillRightConcaveEdgeEvent(edge,node);
            		}
            		else {
HXLINE( 394)			this->fillRightConvexEdgeEvent(edge,node);
HXLINE( 395)			this->fillRightBelowEdgeEvent(edge,node);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sweep_obj,fillRightBelowEdgeEvent,(void))

void Sweep_obj::fillRightConcaveEdgeEvent( ::org::poly2tri::Edge edge, ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_400_fillRightConcaveEdgeEvent)
HXLINE( 401)		this->fill(node->next);
HXLINE( 402)		if (::hx::IsInstanceNotEq( node->next->point,edge->p )) {
HXLINE( 405)			if ((::org::poly2tri::Orientation_obj::orient2d(edge->q,node->next->point,edge->p) == -1)) {
HXLINE( 408)				if ((::org::poly2tri::Orientation_obj::orient2d(node->point,node->next->point,node->next->next->point) == -1)) {
HXLINE( 411)					this->fillRightConcaveEdgeEvent(edge,node);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sweep_obj,fillRightConcaveEdgeEvent,(void))

void Sweep_obj::fillRightConvexEdgeEvent( ::org::poly2tri::Edge edge, ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_424_fillRightConvexEdgeEvent)
HXDLIN( 424)		if ((::org::poly2tri::Orientation_obj::orient2d(node->next->point,node->next->next->point,node->next->next->next->point) == -1)) {
HXLINE( 427)			this->fillRightConcaveEdgeEvent(edge,node->next);
            		}
            		else {
HXLINE( 433)			if ((::org::poly2tri::Orientation_obj::orient2d(edge->q,node->next->next->point,edge->p) == -1)) {
HXLINE( 436)				this->fillRightConvexEdgeEvent(edge,node->next);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sweep_obj,fillRightConvexEdgeEvent,(void))

void Sweep_obj::fillLeftAboveEdgeEvent( ::org::poly2tri::Edge edge, ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_447_fillLeftAboveEdgeEvent)
HXDLIN( 447)		while((node->prev->point->x > edge->p->x)){
HXLINE( 450)			if ((::org::poly2tri::Orientation_obj::orient2d(edge->q,node->prev->point,edge->p) == 1)) {
HXLINE( 452)				this->fillLeftBelowEdgeEvent(edge,node);
            			}
            			else {
HXLINE( 456)				node = node->prev;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sweep_obj,fillLeftAboveEdgeEvent,(void))

void Sweep_obj::fillLeftBelowEdgeEvent( ::org::poly2tri::Edge edge, ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_463_fillLeftBelowEdgeEvent)
HXDLIN( 463)		if ((node->point->x > edge->p->x)) {
HXLINE( 465)			if ((::org::poly2tri::Orientation_obj::orient2d(node->point,node->prev->point,node->prev->prev->point) == 1)) {
HXLINE( 468)				this->fillLeftConcaveEdgeEvent(edge,node);
            			}
            			else {
HXLINE( 473)				this->fillLeftConvexEdgeEvent(edge,node);
HXLINE( 475)				this->fillLeftBelowEdgeEvent(edge,node);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sweep_obj,fillLeftBelowEdgeEvent,(void))

void Sweep_obj::fillLeftConvexEdgeEvent( ::org::poly2tri::Edge edge, ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_483_fillLeftConvexEdgeEvent)
HXDLIN( 483)		if ((::org::poly2tri::Orientation_obj::orient2d(node->prev->point,node->prev->prev->point,node->prev->prev->prev->point) == 1)) {
HXLINE( 486)			this->fillLeftConcaveEdgeEvent(edge,node->prev);
            		}
            		else {
HXLINE( 492)			if ((::org::poly2tri::Orientation_obj::orient2d(edge->q,node->prev->prev->point,edge->p) == 1)) {
HXLINE( 495)				this->fillLeftConvexEdgeEvent(edge,node->prev);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sweep_obj,fillLeftConvexEdgeEvent,(void))

void Sweep_obj::fillLeftConcaveEdgeEvent( ::org::poly2tri::Edge edge, ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_505_fillLeftConcaveEdgeEvent)
HXLINE( 506)		this->fill(node->prev);
HXLINE( 507)		if (::hx::IsInstanceNotEq( node->prev->point,edge->p )) {
HXLINE( 510)			if ((::org::poly2tri::Orientation_obj::orient2d(edge->q,node->prev->point,edge->p) == 1)) {
HXLINE( 513)				if ((::org::poly2tri::Orientation_obj::orient2d(node->point,node->prev->point,node->prev->prev->point) == 1)) {
HXLINE( 516)					this->fillLeftConcaveEdgeEvent(edge,node);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Sweep_obj,fillLeftConcaveEdgeEvent,(void))

void Sweep_obj::flipEdgeEvent( ::org::poly2tri::Point ep, ::org::poly2tri::Point eq, ::org::poly2tri::Triangle t, ::org::poly2tri::Point p){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_529_flipEdgeEvent)
HXLINE( 530)		 ::org::poly2tri::Triangle ot = t->neighborAcross(p);
HXLINE( 531)		if (::hx::IsNull( ot )) {
HXLINE( 535)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Sweep::[BUG:FIXME] FLIP failed due to missing triangle!",d1,f1,9e,b7)));
            		}
HXLINE( 537)		 ::org::poly2tri::Point op = ot->oppositePoint(t,p);
HXLINE( 539)		 ::org::poly2tri::Point _hx_tmp = t->pointCCW(p);
HXDLIN( 539)		if (::org::poly2tri::Utils_obj::inScanArea(p,_hx_tmp,t->pointCW(p),op)) {
HXLINE( 542)			::org::poly2tri::Triangle_obj::rotateTrianglePair(t,p,ot,op);
HXLINE( 543)			this->context->mapTriangleToNodes(t);
HXLINE( 544)			this->context->mapTriangleToNodes(ot);
HXLINE( 547)			bool _hx_tmp;
HXDLIN( 547)			if (::hx::IsInstanceEq( p,eq )) {
HXLINE( 547)				_hx_tmp = ::hx::IsInstanceEq( op,ep );
            			}
            			else {
HXLINE( 547)				_hx_tmp = false;
            			}
HXDLIN( 547)			if (_hx_tmp) {
HXLINE( 549)				bool _hx_tmp;
HXDLIN( 549)				if (::hx::IsInstanceEq( eq,this->context->edge_event->constrained_edge->q )) {
HXLINE( 549)					_hx_tmp = ::hx::IsInstanceEq( ep,this->context->edge_event->constrained_edge->p );
            				}
            				else {
HXLINE( 549)					_hx_tmp = false;
            				}
HXDLIN( 549)				if (_hx_tmp) {
HXLINE( 550)					t->markConstrainedEdgeByPoints(ep,eq);
HXLINE( 551)					ot->markConstrainedEdgeByPoints(ep,eq);
HXLINE( 552)					this->legalize(t);
HXLINE( 553)					this->legalize(ot);
            				}
            			}
            			else {
HXLINE( 562)				int o = ::org::poly2tri::Orientation_obj::orient2d(eq,op,ep);
HXLINE( 563)				t = this->nextFlipTriangle(o,t,ot,p,op);
HXLINE( 564)				this->flipEdgeEvent(ep,eq,t,p);
            			}
            		}
            		else {
HXLINE( 569)			 ::org::poly2tri::Point newP = ::org::poly2tri::Sweep_obj::nextFlipPoint(ep,eq,ot,op);
HXLINE( 570)			this->flipScanEdgeEvent(ep,eq,t,ot,newP);
HXLINE( 571)			this->edgeEventByPoints(ep,eq,t,p);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(Sweep_obj,flipEdgeEvent,(void))

 ::org::poly2tri::Triangle Sweep_obj::nextFlipTriangle(int o, ::org::poly2tri::Triangle t, ::org::poly2tri::Triangle ot, ::org::poly2tri::Point p, ::org::poly2tri::Point op){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_577_nextFlipTriangle)
HXLINE( 578)		int edge_index;
HXLINE( 579)		if ((o == -1)) {
HXLINE( 582)			edge_index = ot->edgeIndex(p,op);
HXLINE( 583)			ot->delaunay_edge[edge_index] = true;
HXLINE( 584)			this->legalize(ot);
HXLINE( 585)			ot->clearDelunayEdges();
HXLINE( 586)			return t;
            		}
HXLINE( 590)		edge_index = t->edgeIndex(p,op);
HXLINE( 592)		t->delaunay_edge[edge_index] = true;
HXLINE( 593)		this->legalize(t);
HXLINE( 594)		t->clearDelunayEdges();
HXLINE( 595)		return ot;
            	}


HX_DEFINE_DYNAMIC_FUNC5(Sweep_obj,nextFlipTriangle,return )

void Sweep_obj::flipScanEdgeEvent( ::org::poly2tri::Point ep, ::org::poly2tri::Point eq, ::org::poly2tri::Triangle flip_triangle, ::org::poly2tri::Triangle t, ::org::poly2tri::Point p){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_618_flipScanEdgeEvent)
HXLINE( 619)		 ::org::poly2tri::Triangle ot = t->neighborAcross(p);
HXLINE( 623)		if (::hx::IsNull( ot )) {
HXLINE( 623)			HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Sweep::[BUG:FIXME] FLIP failed due to missing triangle",50,d4,da,27)));
            		}
HXLINE( 624)		 ::org::poly2tri::Point op = ot->oppositePoint(t,p);
HXLINE( 626)		 ::org::poly2tri::Point _hx_tmp = flip_triangle->pointCCW(eq);
HXDLIN( 626)		if (::org::poly2tri::Utils_obj::inScanArea(eq,_hx_tmp,flip_triangle->pointCW(eq),op)) {
HXLINE( 629)			this->flipEdgeEvent(eq,op,ot,op);
            		}
            		else {
HXLINE( 640)			 ::org::poly2tri::Point newP = ::org::poly2tri::Sweep_obj::nextFlipPoint(ep,eq,ot,op);
HXLINE( 641)			this->flipScanEdgeEvent(ep,eq,flip_triangle,ot,newP);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(Sweep_obj,flipScanEdgeEvent,(void))

 ::org::poly2tri::Point Sweep_obj::nextFlipPoint( ::org::poly2tri::Point ep, ::org::poly2tri::Point eq, ::org::poly2tri::Triangle ot, ::org::poly2tri::Point op){
            	HX_STACKFRAME(&_hx_pos_dde5ac355f43afe6_599_nextFlipPoint)
HXLINE( 600)		int o2d = ::org::poly2tri::Orientation_obj::orient2d(eq,op,ep);
HXLINE( 601)		if ((o2d == 1)) {
HXLINE( 604)			return ot->pointCCW(op);
            		}
            		else {
HXLINE( 606)			if ((o2d == -1)) {
HXLINE( 609)				return ot->pointCW(op);
            			}
            			else {
HXLINE( 613)				HX_STACK_DO_THROW(::haxe::Exception_obj::thrown(HX_("Sweep:: [Unsupported] Sweep.NextFlipPoint: opposing point on constrained edge!",d7,7d,a0,e0)));
            			}
            		}
HXLINE( 601)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Sweep_obj,nextFlipPoint,return )


::hx::ObjectPtr< Sweep_obj > Sweep_obj::__new( ::org::poly2tri::SweepContext context) {
	::hx::ObjectPtr< Sweep_obj > __this = new Sweep_obj();
	__this->__construct(context);
	return __this;
}

::hx::ObjectPtr< Sweep_obj > Sweep_obj::__alloc(::hx::Ctx *_hx_ctx, ::org::poly2tri::SweepContext context) {
	Sweep_obj *__this = (Sweep_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Sweep_obj), true, "org.poly2tri.Sweep"));
	*(void **)__this = Sweep_obj::_hx_vtable;
	__this->__construct(context);
	return __this;
}

Sweep_obj::Sweep_obj()
{
}

void Sweep_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Sweep);
	HX_MARK_MEMBER_NAME(context,"context");
	HX_MARK_END_CLASS();
}

void Sweep_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(context,"context");
}

::hx::Val Sweep_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"fill") ) { return ::hx::Val( fill_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"context") ) { return ::hx::Val( context ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"legalize") ) { return ::hx::Val( legalize_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"fillBasin") ) { return ::hx::Val( fillBasin_dyn() ); }
		if (HX_FIELD_EQ(inName,"isShallow") ) { return ::hx::Val( isShallow_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"pointEvent") ) { return ::hx::Val( pointEvent_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"triangulate") ) { return ::hx::Val( triangulate_dyn() ); }
		if (HX_FIELD_EQ(inName,"sweepPoints") ) { return ::hx::Val( sweepPoints_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"fillBasinReq") ) { return ::hx::Val( fillBasinReq_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"fillEdgeEvent") ) { return ::hx::Val( fillEdgeEvent_dyn() ); }
		if (HX_FIELD_EQ(inName,"flipEdgeEvent") ) { return ::hx::Val( flipEdgeEvent_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"edgeEventByEdge") ) { return ::hx::Val( edgeEventByEdge_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"newFrontTriangle") ) { return ::hx::Val( newFrontTriangle_dyn() ); }
		if (HX_FIELD_EQ(inName,"nextFlipTriangle") ) { return ::hx::Val( nextFlipTriangle_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"edgeEventByPoints") ) { return ::hx::Val( edgeEventByPoints_dyn() ); }
		if (HX_FIELD_EQ(inName,"flipScanEdgeEvent") ) { return ::hx::Val( flipScanEdgeEvent_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"fillAdvancingFront") ) { return ::hx::Val( fillAdvancingFront_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"finalizationPolygon") ) { return ::hx::Val( finalizationPolygon_dyn() ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"fillLeftAboveEdgeEvent") ) { return ::hx::Val( fillLeftAboveEdgeEvent_dyn() ); }
		if (HX_FIELD_EQ(inName,"fillLeftBelowEdgeEvent") ) { return ::hx::Val( fillLeftBelowEdgeEvent_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"fillRightAboveEdgeEvent") ) { return ::hx::Val( fillRightAboveEdgeEvent_dyn() ); }
		if (HX_FIELD_EQ(inName,"fillRightBelowEdgeEvent") ) { return ::hx::Val( fillRightBelowEdgeEvent_dyn() ); }
		if (HX_FIELD_EQ(inName,"fillLeftConvexEdgeEvent") ) { return ::hx::Val( fillLeftConvexEdgeEvent_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"fillRightConvexEdgeEvent") ) { return ::hx::Val( fillRightConvexEdgeEvent_dyn() ); }
		if (HX_FIELD_EQ(inName,"fillLeftConcaveEdgeEvent") ) { return ::hx::Val( fillLeftConcaveEdgeEvent_dyn() ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"fillRightConcaveEdgeEvent") ) { return ::hx::Val( fillRightConcaveEdgeEvent_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Sweep_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"nextFlipPoint") ) { outValue = nextFlipPoint_dyn(); return true; }
	}
	return false;
}

::hx::Val Sweep_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"context") ) { context=inValue.Cast<  ::org::poly2tri::SweepContext >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Sweep_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("context",ef,95,77,19));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Sweep_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::org::poly2tri::SweepContext */ ,(int)offsetof(Sweep_obj,context),HX_("context",ef,95,77,19)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Sweep_obj_sStaticStorageInfo = 0;
#endif

static ::String Sweep_obj_sMemberFields[] = {
	HX_("context",ef,95,77,19),
	HX_("triangulate",2c,65,9d,e9),
	HX_("sweepPoints",2f,d5,d3,6d),
	HX_("finalizationPolygon",ac,4b,49,54),
	HX_("pointEvent",aa,e1,82,55),
	HX_("edgeEventByEdge",31,bc,d0,13),
	HX_("edgeEventByPoints",17,eb,4b,f3),
	HX_("newFrontTriangle",11,a8,b5,b3),
	HX_("fill",83,ce,bb,43),
	HX_("fillAdvancingFront",cd,0f,c4,0b),
	HX_("legalize",bb,90,93,d9),
	HX_("fillBasin",36,51,61,7c),
	HX_("fillBasinReq",c8,65,77,64),
	HX_("isShallow",0a,01,d4,68),
	HX_("fillEdgeEvent",9a,1b,5c,98),
	HX_("fillRightAboveEdgeEvent",f9,07,79,c6),
	HX_("fillRightBelowEdgeEvent",e5,09,51,94),
	HX_("fillRightConcaveEdgeEvent",87,2e,c8,c4),
	HX_("fillRightConvexEdgeEvent",dd,97,9e,b5),
	HX_("fillLeftAboveEdgeEvent",8a,01,0a,2a),
	HX_("fillLeftBelowEdgeEvent",76,03,e2,f7),
	HX_("fillLeftConvexEdgeEvent",2c,fd,e7,70),
	HX_("fillLeftConcaveEdgeEvent",58,6e,b7,e9),
	HX_("flipEdgeEvent",30,02,29,dc),
	HX_("nextFlipTriangle",28,74,3d,22),
	HX_("flipScanEdgeEvent",73,92,1c,54),
	::String(null()) };

::hx::Class Sweep_obj::__mClass;

static ::String Sweep_obj_sStaticFields[] = {
	HX_("nextFlipPoint",f0,e2,8a,72),
	::String(null())
};

void Sweep_obj::__register()
{
	Sweep_obj _hx_dummy;
	Sweep_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("org.poly2tri.Sweep",6d,d0,02,6c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Sweep_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Sweep_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Sweep_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Sweep_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Sweep_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Sweep_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace org
} // end namespace poly2tri
