// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_org_poly2tri_Node
#include <org/poly2tri/Node.h>
#endif
#ifndef INCLUDED_org_poly2tri_Point
#include <org/poly2tri/Point.h>
#endif
#ifndef INCLUDED_org_poly2tri_Triangle
#include <org/poly2tri/Triangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_1c6848e66fc2ad65_14_new,"org.poly2tri.Node","new",0x495be013,"org.poly2tri.Node.new","org/poly2tri/Node.hx",14,0xb47146dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1c6848e66fc2ad65_27_getHoleAngle,"org.poly2tri.Node","getHoleAngle",0x5881e0ea,"org.poly2tri.Node.getHoleAngle","org/poly2tri/Node.hx",27,0xb47146dd)
HX_LOCAL_STACK_FRAME(_hx_pos_1c6848e66fc2ad65_48_getBasinAngle,"org.poly2tri.Node","getBasinAngle",0x5e8b3403,"org.poly2tri.Node.getBasinAngle","org/poly2tri/Node.hx",48,0xb47146dd)
namespace org{
namespace poly2tri{

void Node_obj::__construct( ::org::poly2tri::Point point, ::org::poly2tri::Triangle triangle){
            	HX_STACKFRAME(&_hx_pos_1c6848e66fc2ad65_14_new)
HXLINE(  16)		this->point = point;
HXLINE(  17)		this->triangle = triangle;
HXLINE(  18)		this->value = this->point->x;
            	}

Dynamic Node_obj::__CreateEmpty() { return new Node_obj; }

void *Node_obj::_hx_vtable = 0;

Dynamic Node_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Node_obj > _hx_result = new Node_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Node_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x48b2eb43;
}

Float Node_obj::getHoleAngle(){
            	HX_STACKFRAME(&_hx_pos_1c6848e66fc2ad65_27_getHoleAngle)
HXLINE(  36)		Float ax = (this->next->point->x - this->point->x);
HXLINE(  37)		Float ay = (this->next->point->y - this->point->y);
HXLINE(  38)		Float bx = (this->prev->point->x - this->point->x);
HXLINE(  39)		Float by = (this->prev->point->y - this->point->y);
HXLINE(  40)		return ::Math_obj::atan2(((ax * by) - (ay * bx)),((ax * bx) + (ay * by)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Node_obj,getHoleAngle,return )

Float Node_obj::getBasinAngle(){
            	HX_STACKFRAME(&_hx_pos_1c6848e66fc2ad65_48_getBasinAngle)
HXDLIN(  48)		return ::Math_obj::atan2((this->point->y - this->next->next->point->y),(this->point->x - this->next->next->point->x));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Node_obj,getBasinAngle,return )


::hx::ObjectPtr< Node_obj > Node_obj::__new( ::org::poly2tri::Point point, ::org::poly2tri::Triangle triangle) {
	::hx::ObjectPtr< Node_obj > __this = new Node_obj();
	__this->__construct(point,triangle);
	return __this;
}

::hx::ObjectPtr< Node_obj > Node_obj::__alloc(::hx::Ctx *_hx_ctx, ::org::poly2tri::Point point, ::org::poly2tri::Triangle triangle) {
	Node_obj *__this = (Node_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Node_obj), true, "org.poly2tri.Node"));
	*(void **)__this = Node_obj::_hx_vtable;
	__this->__construct(point,triangle);
	return __this;
}

Node_obj::Node_obj()
{
}

void Node_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Node);
	HX_MARK_MEMBER_NAME(point,"point");
	HX_MARK_MEMBER_NAME(triangle,"triangle");
	HX_MARK_MEMBER_NAME(prev,"prev");
	HX_MARK_MEMBER_NAME(next,"next");
	HX_MARK_MEMBER_NAME(value,"value");
	HX_MARK_END_CLASS();
}

void Node_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(point,"point");
	HX_VISIT_MEMBER_NAME(triangle,"triangle");
	HX_VISIT_MEMBER_NAME(prev,"prev");
	HX_VISIT_MEMBER_NAME(next,"next");
	HX_VISIT_MEMBER_NAME(value,"value");
}

::hx::Val Node_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"prev") ) { return ::hx::Val( prev ); }
		if (HX_FIELD_EQ(inName,"next") ) { return ::hx::Val( next ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"point") ) { return ::hx::Val( point ); }
		if (HX_FIELD_EQ(inName,"value") ) { return ::hx::Val( value ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"triangle") ) { return ::hx::Val( triangle ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"getHoleAngle") ) { return ::hx::Val( getHoleAngle_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getBasinAngle") ) { return ::hx::Val( getBasinAngle_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Node_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"prev") ) { prev=inValue.Cast<  ::org::poly2tri::Node >(); return inValue; }
		if (HX_FIELD_EQ(inName,"next") ) { next=inValue.Cast<  ::org::poly2tri::Node >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"point") ) { point=inValue.Cast<  ::org::poly2tri::Point >(); return inValue; }
		if (HX_FIELD_EQ(inName,"value") ) { value=inValue.Cast< Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"triangle") ) { triangle=inValue.Cast<  ::org::poly2tri::Triangle >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Node_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("point",50,b4,8f,c6));
	outFields->push(HX_("triangle",c8,be,c5,8d));
	outFields->push(HX_("prev",f3,be,5e,4a));
	outFields->push(HX_("next",f3,84,02,49));
	outFields->push(HX_("value",71,7f,b8,31));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Node_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::org::poly2tri::Point */ ,(int)offsetof(Node_obj,point),HX_("point",50,b4,8f,c6)},
	{::hx::fsObject /*  ::org::poly2tri::Triangle */ ,(int)offsetof(Node_obj,triangle),HX_("triangle",c8,be,c5,8d)},
	{::hx::fsObject /*  ::org::poly2tri::Node */ ,(int)offsetof(Node_obj,prev),HX_("prev",f3,be,5e,4a)},
	{::hx::fsObject /*  ::org::poly2tri::Node */ ,(int)offsetof(Node_obj,next),HX_("next",f3,84,02,49)},
	{::hx::fsFloat,(int)offsetof(Node_obj,value),HX_("value",71,7f,b8,31)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Node_obj_sStaticStorageInfo = 0;
#endif

static ::String Node_obj_sMemberFields[] = {
	HX_("point",50,b4,8f,c6),
	HX_("triangle",c8,be,c5,8d),
	HX_("prev",f3,be,5e,4a),
	HX_("next",f3,84,02,49),
	HX_("value",71,7f,b8,31),
	HX_("getHoleAngle",fd,fe,71,31),
	HX_("getBasinAngle",90,66,b5,57),
	::String(null()) };

::hx::Class Node_obj::__mClass;

void Node_obj::__register()
{
	Node_obj _hx_dummy;
	Node_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("org.poly2tri.Node",a1,da,27,fd);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Node_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Node_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Node_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Node_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace org
} // end namespace poly2tri
