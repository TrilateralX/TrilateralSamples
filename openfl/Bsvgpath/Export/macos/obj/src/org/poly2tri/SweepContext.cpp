// Generated by Haxe 4.2.0-rc.1+7dc565e63
#include <hxcpp.h>

#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_org_poly2tri_AdvancingFront
#include <org/poly2tri/AdvancingFront.h>
#endif
#ifndef INCLUDED_org_poly2tri_Basin
#include <org/poly2tri/Basin.h>
#endif
#ifndef INCLUDED_org_poly2tri_Constants
#include <org/poly2tri/Constants.h>
#endif
#ifndef INCLUDED_org_poly2tri_Edge
#include <org/poly2tri/Edge.h>
#endif
#ifndef INCLUDED_org_poly2tri_EdgeEvent
#include <org/poly2tri/EdgeEvent.h>
#endif
#ifndef INCLUDED_org_poly2tri_Node
#include <org/poly2tri/Node.h>
#endif
#ifndef INCLUDED_org_poly2tri_Point
#include <org/poly2tri/Point.h>
#endif
#ifndef INCLUDED_org_poly2tri_SweepContext
#include <org/poly2tri/SweepContext.h>
#endif
#ifndef INCLUDED_org_poly2tri_Triangle
#include <org/poly2tri/Triangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_88acf6e30216e476_25_new,"org.poly2tri.SweepContext","new",0x6be9cef4,"org.poly2tri.SweepContext.new","org/poly2tri/SweepContext.hx",25,0xa513af1c)
HX_LOCAL_STACK_FRAME(_hx_pos_88acf6e30216e476_44_addPoints,"org.poly2tri.SweepContext","addPoints",0xcee36cb8,"org.poly2tri.SweepContext.addPoints","org/poly2tri/SweepContext.hx",44,0xa513af1c)
HX_LOCAL_STACK_FRAME(_hx_pos_88acf6e30216e476_54_addPolyline,"org.poly2tri.SweepContext","addPolyline",0x634b9615,"org.poly2tri.SweepContext.addPolyline","org/poly2tri/SweepContext.hx",54,0xa513af1c)
HX_LOCAL_STACK_FRAME(_hx_pos_88acf6e30216e476_65_initEdges,"org.poly2tri.SweepContext","initEdges",0xa503adfa,"org.poly2tri.SweepContext.initEdges","org/poly2tri/SweepContext.hx",65,0xa513af1c)
HX_LOCAL_STACK_FRAME(_hx_pos_88acf6e30216e476_77_addToMap,"org.poly2tri.SweepContext","addToMap",0xd8348aec,"org.poly2tri.SweepContext.addToMap","org/poly2tri/SweepContext.hx",77,0xa513af1c)
HX_LOCAL_STACK_FRAME(_hx_pos_88acf6e30216e476_82_initTriangulation,"org.poly2tri.SweepContext","initTriangulation",0xee55b6b3,"org.poly2tri.SweepContext.initTriangulation","org/poly2tri/SweepContext.hx",82,0xa513af1c)
HX_LOCAL_STACK_FRAME(_hx_pos_88acf6e30216e476_112_locateNode,"org.poly2tri.SweepContext","locateNode",0xb26c9ea0,"org.poly2tri.SweepContext.locateNode","org/poly2tri/SweepContext.hx",112,0xa513af1c)
HX_LOCAL_STACK_FRAME(_hx_pos_88acf6e30216e476_116_createAdvancingFront,"org.poly2tri.SweepContext","createAdvancingFront",0xe6b284f2,"org.poly2tri.SweepContext.createAdvancingFront","org/poly2tri/SweepContext.hx",116,0xa513af1c)
HX_LOCAL_STACK_FRAME(_hx_pos_88acf6e30216e476_136_removeNode,"org.poly2tri.SweepContext","removeNode",0x45990052,"org.poly2tri.SweepContext.removeNode","org/poly2tri/SweepContext.hx",136,0xa513af1c)
HX_LOCAL_STACK_FRAME(_hx_pos_88acf6e30216e476_142_mapTriangleToNodes,"org.poly2tri.SweepContext","mapTriangleToNodes",0x0bc82b7e,"org.poly2tri.SweepContext.mapTriangleToNodes","org/poly2tri/SweepContext.hx",142,0xa513af1c)
HX_LOCAL_STACK_FRAME(_hx_pos_88acf6e30216e476_153_meshClean,"org.poly2tri.SweepContext","meshClean",0xa00ca1f0,"org.poly2tri.SweepContext.meshClean","org/poly2tri/SweepContext.hx",153,0xa513af1c)
namespace org{
namespace poly2tri{

void SweepContext_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_88acf6e30216e476_25_new)
HXLINE(  26)		this->triangles = ::Array_obj< ::Dynamic>::__new();
HXLINE(  27)		this->points = ::Array_obj< ::Dynamic>::__new();
HXLINE(  28)		this->edge_list = ::Array_obj< ::Dynamic>::__new();
HXLINE(  30)		this->map =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  36)		this->basin =  ::org::poly2tri::Basin_obj::__alloc( HX_CTX );
HXLINE(  37)		this->edge_event =  ::org::poly2tri::EdgeEvent_obj::__alloc( HX_CTX );
            	}

Dynamic SweepContext_obj::__CreateEmpty() { return new SweepContext_obj; }

void *SweepContext_obj::_hx_vtable = 0;

Dynamic SweepContext_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< SweepContext_obj > _hx_result = new SweepContext_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool SweepContext_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x181a07a4;
}

void SweepContext_obj::addPoints(::Array< ::Dynamic> points){
            	HX_STACKFRAME(&_hx_pos_88acf6e30216e476_44_addPoints)
HXDLIN(  44)		int _g = 0;
HXDLIN(  44)		while((_g < points->length)){
HXDLIN(  44)			 ::org::poly2tri::Point point = points->__get(_g).StaticCast<  ::org::poly2tri::Point >();
HXDLIN(  44)			_g = (_g + 1);
HXLINE(  47)			this->points->push(point);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(SweepContext_obj,addPoints,(void))

void SweepContext_obj::addPolyline(::Array< ::Dynamic> polyline){
            	HX_STACKFRAME(&_hx_pos_88acf6e30216e476_54_addPolyline)
HXLINE(  55)		this->initEdges(polyline);
HXLINE(  56)		this->addPoints(polyline);
            	}


HX_DEFINE_DYNAMIC_FUNC1(SweepContext_obj,addPolyline,(void))

void SweepContext_obj::initEdges(::Array< ::Dynamic> polyline){
            	HX_GC_STACKFRAME(&_hx_pos_88acf6e30216e476_65_initEdges)
HXDLIN(  65)		int _g = 0;
HXDLIN(  65)		int _g1 = polyline->length;
HXDLIN(  65)		while((_g < _g1)){
HXDLIN(  65)			_g = (_g + 1);
HXDLIN(  65)			int n = (_g - 1);
HXLINE(  68)			 ::org::poly2tri::Point nx = polyline->__get(::hx::Mod((n + 1),polyline->length)).StaticCast<  ::org::poly2tri::Point >();
HXLINE(  69)			::Array< ::Dynamic> _hx_tmp = this->edge_list;
HXDLIN(  69)			_hx_tmp->push( ::org::poly2tri::Edge_obj::__alloc( HX_CTX ,polyline->__get(n).StaticCast<  ::org::poly2tri::Point >(),nx));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(SweepContext_obj,initEdges,(void))

void SweepContext_obj::addToMap( ::org::poly2tri::Triangle triangle){
            	HX_STACKFRAME(&_hx_pos_88acf6e30216e476_77_addToMap)
HXDLIN(  77)		::Dynamic this1 = this->map;
HXDLIN(  77)		( ( ::haxe::ds::StringMap)(this1) )->set(triangle->toString(),triangle);
            	}


HX_DEFINE_DYNAMIC_FUNC1(SweepContext_obj,addToMap,(void))

void SweepContext_obj::initTriangulation(){
            	HX_GC_STACKFRAME(&_hx_pos_88acf6e30216e476_82_initTriangulation)
HXLINE(  84)		Float xmin = this->points->__get(0).StaticCast<  ::org::poly2tri::Point >()->x;
HXLINE(  85)		Float xmax = this->points->__get(0).StaticCast<  ::org::poly2tri::Point >()->x;
HXLINE(  86)		Float ymin = this->points->__get(0).StaticCast<  ::org::poly2tri::Point >()->y;
HXLINE(  87)		Float ymax = this->points->__get(0).StaticCast<  ::org::poly2tri::Point >()->y;
HXLINE(  90)		{
HXLINE(  90)			int _g = 0;
HXDLIN(  90)			::Array< ::Dynamic> _g1 = this->points;
HXDLIN(  90)			while((_g < _g1->length)){
HXLINE(  90)				 ::org::poly2tri::Point p = _g1->__get(_g).StaticCast<  ::org::poly2tri::Point >();
HXDLIN(  90)				_g = (_g + 1);
HXLINE(  92)				if ((p->x > xmax)) {
HXLINE(  92)					xmax = p->x;
            				}
HXLINE(  93)				if ((p->x < xmin)) {
HXLINE(  93)					xmin = p->x;
            				}
HXLINE(  94)				if ((p->y > ymax)) {
HXLINE(  94)					ymax = p->y;
            				}
HXLINE(  95)				if ((p->y < ymin)) {
HXLINE(  95)					ymin = p->y;
            				}
            			}
            		}
HXLINE(  98)		Float dx = (::org::poly2tri::Constants_obj::kAlpha * (xmax - xmin));
HXLINE(  99)		Float dy = (::org::poly2tri::Constants_obj::kAlpha * (ymax - ymin));
HXLINE( 101)		this->head =  ::org::poly2tri::Point_obj::__alloc( HX_CTX ,(xmax + dx),(ymin - dy));
HXLINE( 102)		this->tail =  ::org::poly2tri::Point_obj::__alloc( HX_CTX ,(xmin - dy),(ymin - dy));
HXLINE( 106)		::org::poly2tri::Point_obj::sortPoints(this->points);
            	}


HX_DEFINE_DYNAMIC_FUNC0(SweepContext_obj,initTriangulation,(void))

 ::org::poly2tri::Node SweepContext_obj::locateNode( ::org::poly2tri::Point point){
            	HX_STACKFRAME(&_hx_pos_88acf6e30216e476_112_locateNode)
HXDLIN( 112)		return this->front->locateNode(point->x);
            	}


HX_DEFINE_DYNAMIC_FUNC1(SweepContext_obj,locateNode,return )

void SweepContext_obj::createAdvancingFront(){
            	HX_GC_STACKFRAME(&_hx_pos_88acf6e30216e476_116_createAdvancingFront)
HXLINE( 118)		 ::org::poly2tri::Triangle triangle =  ::org::poly2tri::Triangle_obj::__alloc( HX_CTX ,this->points->__get(0).StaticCast<  ::org::poly2tri::Point >(),this->tail,this->head,null(),null());
HXLINE( 120)		this->addToMap(triangle);
HXLINE( 122)		 ::org::poly2tri::Node head =  ::org::poly2tri::Node_obj::__alloc( HX_CTX ,triangle->points->__get(1).StaticCast<  ::org::poly2tri::Point >(),triangle);
HXLINE( 123)		 ::org::poly2tri::Node middle =  ::org::poly2tri::Node_obj::__alloc( HX_CTX ,triangle->points->__get(0).StaticCast<  ::org::poly2tri::Point >(),triangle);
HXLINE( 124)		 ::org::poly2tri::Node tail =  ::org::poly2tri::Node_obj::__alloc( HX_CTX ,triangle->points->__get(2).StaticCast<  ::org::poly2tri::Point >(),null());
HXLINE( 126)		this->front =  ::org::poly2tri::AdvancingFront_obj::__alloc( HX_CTX ,head,tail);
HXLINE( 128)		head->next = middle;
HXLINE( 129)		middle->next = tail;
HXLINE( 130)		middle->prev = head;
HXLINE( 131)		tail->prev = middle;
            	}


HX_DEFINE_DYNAMIC_FUNC0(SweepContext_obj,createAdvancingFront,(void))

void SweepContext_obj::removeNode( ::org::poly2tri::Node node){
            	HX_STACKFRAME(&_hx_pos_88acf6e30216e476_136_removeNode)
            	}


HX_DEFINE_DYNAMIC_FUNC1(SweepContext_obj,removeNode,(void))

void SweepContext_obj::mapTriangleToNodes( ::org::poly2tri::Triangle triangle){
            	HX_STACKFRAME(&_hx_pos_88acf6e30216e476_142_mapTriangleToNodes)
HXLINE( 144)		if (::hx::IsNull( triangle->neighbors->__get(0).StaticCast<  ::org::poly2tri::Triangle >() )) {
HXLINE( 146)			 ::org::poly2tri::AdvancingFront neighbor = this->front;
HXDLIN( 146)			 ::org::poly2tri::Node neighbor1 = neighbor->locatePoint(triangle->pointCW(triangle->points->__get(0).StaticCast<  ::org::poly2tri::Point >()));
HXLINE( 147)			if (::hx::IsNotNull( neighbor1 )) {
HXLINE( 147)				neighbor1->triangle = triangle;
            			}
            		}
HXLINE( 144)		if (::hx::IsNull( triangle->neighbors->__get(1).StaticCast<  ::org::poly2tri::Triangle >() )) {
HXLINE( 146)			 ::org::poly2tri::AdvancingFront neighbor = this->front;
HXDLIN( 146)			 ::org::poly2tri::Node neighbor1 = neighbor->locatePoint(triangle->pointCW(triangle->points->__get(1).StaticCast<  ::org::poly2tri::Point >()));
HXLINE( 147)			if (::hx::IsNotNull( neighbor1 )) {
HXLINE( 147)				neighbor1->triangle = triangle;
            			}
            		}
HXLINE( 144)		if (::hx::IsNull( triangle->neighbors->__get(2).StaticCast<  ::org::poly2tri::Triangle >() )) {
HXLINE( 146)			 ::org::poly2tri::AdvancingFront neighbor = this->front;
HXDLIN( 146)			 ::org::poly2tri::Node neighbor1 = neighbor->locatePoint(triangle->pointCW(triangle->points->__get(2).StaticCast<  ::org::poly2tri::Point >()));
HXLINE( 147)			if (::hx::IsNotNull( neighbor1 )) {
HXLINE( 147)				neighbor1->triangle = triangle;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(SweepContext_obj,mapTriangleToNodes,(void))

void SweepContext_obj::meshClean( ::org::poly2tri::Triangle t){
            	HX_STACKFRAME(&_hx_pos_88acf6e30216e476_153_meshClean)
HXLINE( 154)		::Array< ::Dynamic> tmp = ::Array_obj< ::Dynamic>::__new(1)->init(0,t);
HXLINE( 155)		while(true){
HXLINE( 156)			 ::org::poly2tri::Triangle t = tmp->pop().StaticCast<  ::org::poly2tri::Triangle >();
HXLINE( 157)			if (::hx::IsNull( t )) {
HXLINE( 157)				goto _hx_goto_13;
            			}
HXLINE( 158)			if (t->interior) {
HXLINE( 158)				continue;
            			}
HXLINE( 159)			t->interior = true;
HXLINE( 160)			this->triangles->push(t);
HXLINE( 161)			{
HXLINE( 162)				if (!(t->constrained_edge->__get(0))) {
HXLINE( 163)					tmp->push(t->neighbors->__get(0).StaticCast<  ::org::poly2tri::Triangle >());
            				}
HXLINE( 162)				if (!(t->constrained_edge->__get(1))) {
HXLINE( 163)					tmp->push(t->neighbors->__get(1).StaticCast<  ::org::poly2tri::Triangle >());
            				}
HXLINE( 162)				if (!(t->constrained_edge->__get(2))) {
HXLINE( 163)					tmp->push(t->neighbors->__get(2).StaticCast<  ::org::poly2tri::Triangle >());
            				}
            			}
            		}
            		_hx_goto_13:;
            	}


HX_DEFINE_DYNAMIC_FUNC1(SweepContext_obj,meshClean,(void))


::hx::ObjectPtr< SweepContext_obj > SweepContext_obj::__new() {
	::hx::ObjectPtr< SweepContext_obj > __this = new SweepContext_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< SweepContext_obj > SweepContext_obj::__alloc(::hx::Ctx *_hx_ctx) {
	SweepContext_obj *__this = (SweepContext_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(SweepContext_obj), true, "org.poly2tri.SweepContext"));
	*(void **)__this = SweepContext_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

SweepContext_obj::SweepContext_obj()
{
}

void SweepContext_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(SweepContext);
	HX_MARK_MEMBER_NAME(triangles,"triangles");
	HX_MARK_MEMBER_NAME(points,"points");
	HX_MARK_MEMBER_NAME(edge_list,"edge_list");
	HX_MARK_MEMBER_NAME(map,"map");
	HX_MARK_MEMBER_NAME(front,"front");
	HX_MARK_MEMBER_NAME(head,"head");
	HX_MARK_MEMBER_NAME(tail,"tail");
	HX_MARK_MEMBER_NAME(basin,"basin");
	HX_MARK_MEMBER_NAME(edge_event,"edge_event");
	HX_MARK_END_CLASS();
}

void SweepContext_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(triangles,"triangles");
	HX_VISIT_MEMBER_NAME(points,"points");
	HX_VISIT_MEMBER_NAME(edge_list,"edge_list");
	HX_VISIT_MEMBER_NAME(map,"map");
	HX_VISIT_MEMBER_NAME(front,"front");
	HX_VISIT_MEMBER_NAME(head,"head");
	HX_VISIT_MEMBER_NAME(tail,"tail");
	HX_VISIT_MEMBER_NAME(basin,"basin");
	HX_VISIT_MEMBER_NAME(edge_event,"edge_event");
}

::hx::Val SweepContext_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"map") ) { return ::hx::Val( map ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"head") ) { return ::hx::Val( head ); }
		if (HX_FIELD_EQ(inName,"tail") ) { return ::hx::Val( tail ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"front") ) { return ::hx::Val( front ); }
		if (HX_FIELD_EQ(inName,"basin") ) { return ::hx::Val( basin ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { return ::hx::Val( points ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"addToMap") ) { return ::hx::Val( addToMap_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"triangles") ) { return ::hx::Val( triangles ); }
		if (HX_FIELD_EQ(inName,"edge_list") ) { return ::hx::Val( edge_list ); }
		if (HX_FIELD_EQ(inName,"addPoints") ) { return ::hx::Val( addPoints_dyn() ); }
		if (HX_FIELD_EQ(inName,"initEdges") ) { return ::hx::Val( initEdges_dyn() ); }
		if (HX_FIELD_EQ(inName,"meshClean") ) { return ::hx::Val( meshClean_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"edge_event") ) { return ::hx::Val( edge_event ); }
		if (HX_FIELD_EQ(inName,"locateNode") ) { return ::hx::Val( locateNode_dyn() ); }
		if (HX_FIELD_EQ(inName,"removeNode") ) { return ::hx::Val( removeNode_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"addPolyline") ) { return ::hx::Val( addPolyline_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"initTriangulation") ) { return ::hx::Val( initTriangulation_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"mapTriangleToNodes") ) { return ::hx::Val( mapTriangleToNodes_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"createAdvancingFront") ) { return ::hx::Val( createAdvancingFront_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val SweepContext_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"map") ) { map=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"head") ) { head=inValue.Cast<  ::org::poly2tri::Point >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tail") ) { tail=inValue.Cast<  ::org::poly2tri::Point >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"front") ) { front=inValue.Cast<  ::org::poly2tri::AdvancingFront >(); return inValue; }
		if (HX_FIELD_EQ(inName,"basin") ) { basin=inValue.Cast<  ::org::poly2tri::Basin >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"points") ) { points=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"triangles") ) { triangles=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"edge_list") ) { edge_list=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"edge_event") ) { edge_event=inValue.Cast<  ::org::poly2tri::EdgeEvent >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void SweepContext_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("triangles",ab,30,41,7f));
	outFields->push(HX_("points",23,12,2e,f7));
	outFields->push(HX_("edge_list",e0,72,e5,a8));
	outFields->push(HX_("map",9c,0a,53,00));
	outFields->push(HX_("front",a9,18,8e,06));
	outFields->push(HX_("head",20,29,0b,45));
	outFields->push(HX_("tail",90,b6,f6,4c));
	outFields->push(HX_("basin",b9,2a,ba,ad));
	outFields->push(HX_("edge_event",58,23,9e,20));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo SweepContext_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(SweepContext_obj,triangles),HX_("triangles",ab,30,41,7f)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(SweepContext_obj,points),HX_("points",23,12,2e,f7)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(SweepContext_obj,edge_list),HX_("edge_list",e0,72,e5,a8)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(SweepContext_obj,map),HX_("map",9c,0a,53,00)},
	{::hx::fsObject /*  ::org::poly2tri::AdvancingFront */ ,(int)offsetof(SweepContext_obj,front),HX_("front",a9,18,8e,06)},
	{::hx::fsObject /*  ::org::poly2tri::Point */ ,(int)offsetof(SweepContext_obj,head),HX_("head",20,29,0b,45)},
	{::hx::fsObject /*  ::org::poly2tri::Point */ ,(int)offsetof(SweepContext_obj,tail),HX_("tail",90,b6,f6,4c)},
	{::hx::fsObject /*  ::org::poly2tri::Basin */ ,(int)offsetof(SweepContext_obj,basin),HX_("basin",b9,2a,ba,ad)},
	{::hx::fsObject /*  ::org::poly2tri::EdgeEvent */ ,(int)offsetof(SweepContext_obj,edge_event),HX_("edge_event",58,23,9e,20)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *SweepContext_obj_sStaticStorageInfo = 0;
#endif

static ::String SweepContext_obj_sMemberFields[] = {
	HX_("triangles",ab,30,41,7f),
	HX_("points",23,12,2e,f7),
	HX_("edge_list",e0,72,e5,a8),
	HX_("map",9c,0a,53,00),
	HX_("front",a9,18,8e,06),
	HX_("head",20,29,0b,45),
	HX_("tail",90,b6,f6,4c),
	HX_("basin",b9,2a,ba,ad),
	HX_("edge_event",58,23,9e,20),
	HX_("addPoints",24,47,52,af),
	HX_("addPolyline",81,e3,f6,60),
	HX_("initEdges",66,88,72,85),
	HX_("addToMap",00,e2,71,8d),
	HX_("initTriangulation",1f,dd,06,7e),
	HX_("locateNode",b4,e2,fc,32),
	HX_("createAdvancingFront",06,2a,20,e1),
	HX_("removeNode",66,44,29,c6),
	HX_("mapTriangleToNodes",92,a3,18,37),
	HX_("meshClean",5c,7c,7b,80),
	::String(null()) };

::hx::Class SweepContext_obj::__mClass;

void SweepContext_obj::__register()
{
	SweepContext_obj _hx_dummy;
	SweepContext_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("org.poly2tri.SweepContext",02,85,3a,36);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(SweepContext_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< SweepContext_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = SweepContext_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = SweepContext_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace org
} // end namespace poly2tri
