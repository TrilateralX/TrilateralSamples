// Generated by Haxe 4.2.0-rc.1+3ef20749a
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var kitGL_glWeb_InterleaveAlterGL = function(width_,height_) {
	this.width = width_;
	this.height = height_;
	var mainTexture = new kitGL_glWeb_Texture();
	mainTexture.create(this.width,this.height,true);
	this.gl = mainTexture.gl;
	var gl = this.gl;
	var program = gl.createProgram();
	var shader = gl.createShader(35633);
	gl.shaderSource(shader,"attribute vec3 vertexPosition;" + "attribute vec4 vertexColor;" + "varying vec4 vcol;" + "void main(void) {" + " gl_Position = vec4(vertexPosition, 1.0);" + " vcol = vertexColor;" + "}");
	gl.compileShader(shader);
	var tmp;
	if(!gl.getShaderParameter(shader,35713)) {
		throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
	} else {
		tmp = shader;
	}
	gl.attachShader(program,tmp);
	var shader = gl.createShader(35632);
	gl.shaderSource(shader,"precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + " gl_FragColor = vcol;" + "}");
	gl.compileShader(shader);
	var tmp;
	if(!gl.getShaderParameter(shader,35713)) {
		throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
	} else {
		tmp = shader;
	}
	gl.attachShader(program,tmp);
	gl.linkProgram(program);
	var tmp;
	if(!gl.getProgramParameter(program,35714)) {
		throw haxe_Exception.thrown("Error linking program. " + gl.getProgramInfoLog(program));
	} else {
		gl.validateProgram(program);
		if(!gl.getProgramParameter(program,35715)) {
			throw haxe_Exception.thrown("Error validating program. " + gl.getProgramInfoLog(program));
		} else {
			gl.useProgram(program);
			tmp = program;
		}
	}
	this.program = tmp;
	this.draw();
	var gl = this.gl;
	var program = this.program;
	var data = this.interleaveDataGL.get_data();
	var isDynamic = true;
	if(isDynamic == null) {
		isDynamic = false;
	}
	var isDynamic1 = isDynamic;
	if(isDynamic1 == null) {
		isDynamic1 = false;
	}
	var buf = gl.createBuffer();
	gl.bindBuffer(34962,buf);
	if(isDynamic1) {
		gl.bufferData(34962,data,35048);
	} else {
		gl.bufferData(34962,data,35044);
	}
	var vbo = buf;
	var posLoc = gl.getAttribLocation(program,"vertexPosition");
	var colorLoc = gl.getAttribLocation(program,"vertexColor");
	gl.vertexAttribPointer(posLoc,3,5126,false,28,0);
	gl.vertexAttribPointer(colorLoc,4,5126,false,28,12);
	gl.enableVertexAttribArray(posLoc);
	gl.enableVertexAttribArray(colorLoc);
	this.buf = vbo;
	var _gthis = this;
	if(kitGL_glWeb_AnimateTimer.s == null) {
		kitGL_glWeb_AnimateTimer.s = window.document.createElement("style");
		kitGL_glWeb_AnimateTimer.s.innerHTML = "@keyframes spin { from { transform:rotate( 0deg ); } to { transform:rotate( 360deg ); } }";
		window.document.getElementsByTagName("head")[0].appendChild(kitGL_glWeb_AnimateTimer.s);
		kitGL_glWeb_AnimateTimer.s.animation = "spin 1s linear infinite";
		kitGL_glWeb_AnimateTimer.loop(60.0);
	}
	kitGL_glWeb_AnimateTimer.onFrame = function(v) {
		var gl = _gthis.gl;
		gl.viewport(0,0,_gthis.width,_gthis.height);
		gl.clearColor(0.0,0.0,0.0,1.0);
		gl.clear(16384);
		_gthis.renderDraw();
		_gthis.gl.bindBuffer(34962,_gthis.buf);
		_gthis.gl.bufferSubData(34962,0,_gthis.interleaveDataGL.get_data());
		_gthis.gl.useProgram(_gthis.program);
		_gthis.gl.drawArrays(4,0,_gthis.interleaveDataGL.get_size());
	};
};
kitGL_glWeb_InterleaveAlterGL.__name__ = true;
kitGL_glWeb_InterleaveAlterGL.prototype = {
	draw: function() {
	}
	,renderDraw: function() {
	}
};
var TrilateralTriangle = function(width,height) {
	this.penNodule = new trilateral3_nodule_PenNodule();
	kitGL_glWeb_InterleaveAlterGL.call(this,width,height);
};
TrilateralTriangle.__name__ = true;
TrilateralTriangle.__super__ = kitGL_glWeb_InterleaveAlterGL;
TrilateralTriangle.prototype = $extend(kitGL_glWeb_InterleaveAlterGL.prototype,{
	draw: function() {
		this.interleaveDataGL = { get_data : ($_=this.penNodule,$bind($_,$_.get_data)), get_size : ($_=this.penNodule,$bind($_,$_.get_size))};
		this.pen = this.penNodule.pen;
		var _this = this.pen;
		_this.drawType.triangle(100,100,0,500,500,0,100,500,0);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
		}
		_this.drawType.next();
		var _this = this.pen;
		_this.drawType.triangle(100,100,0,500,100,0,500,500,0);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
		}
		_this.drawType.next();
		var _this = this.pen;
		_this.drawType.triangle(300,300,0,400,300,0,400,400,0);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
		}
		_this.drawType.next();
		var _this = this.pen;
		_this.drawType.set_pos(1);
		_this.colorType.set_pos(1);
		var _this = this.pen;
		var color = -65536;
		if(color == -1) {
			color = _this.currentColor;
		}
		_this.colorType.colorTriangles(color,1);
		var _this = this.pen;
		var color = -256;
		if(color == -1) {
			color = _this.currentColor;
		}
		_this.colorType.colorTriangles(color,1);
		var sketch = new trilateral3_drawing_Sketch(this.pen,4,3);
		sketch.width = 30;
		var start = this.pen.drawType.get_pos();
		sketch.moveTo(50,50);
		var repeat = sketch.x == 550 && sketch.y == 50;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,550,50);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,550,50);
			}
			sketch.line(550,50);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = 550;
			p[l2 + 1] = 50;
			var d = sketch.dim[sketch.dim.length - 1];
			if(550 < d.minX) {
				d.minX = 550;
			}
			if(550 > d.maxX) {
				d.maxX = 550;
			}
			if(50 < d.minY) {
				d.minY = 50;
			}
			if(50 > d.maxY) {
				d.maxY = 50;
			}
			sketch.x = 550;
			sketch.y = 50;
		}
		var repeat = sketch.x == 550 && sketch.y == 550;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,550,550);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,550,550);
			}
			sketch.line(550,550);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = 550;
			p[l2 + 1] = 550;
			var d = sketch.dim[sketch.dim.length - 1];
			if(550 < d.minX) {
				d.minX = 550;
			}
			if(550 > d.maxX) {
				d.maxX = 550;
			}
			if(550 < d.minY) {
				d.minY = 550;
			}
			if(550 > d.maxY) {
				d.maxY = 550;
			}
			sketch.x = 550;
			sketch.y = 550;
		}
		var repeat = sketch.x == 50 && sketch.y == 550;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,50,550);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,50,550);
			}
			sketch.line(50,550);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = 50;
			p[l2 + 1] = 550;
			var d = sketch.dim[sketch.dim.length - 1];
			if(50 < d.minX) {
				d.minX = 50;
			}
			if(50 > d.maxX) {
				d.maxX = 50;
			}
			if(550 < d.minY) {
				d.minY = 550;
			}
			if(550 > d.maxY) {
				d.maxY = 550;
			}
			sketch.x = 50;
			sketch.y = 550;
		}
		var repeat = sketch.x == 50 && sketch.y == 50;
		if(!repeat) {
			if(sketch.widthFunction != null) {
				sketch.width = sketch.widthFunction(sketch.width,sketch.x,sketch.y,50,50);
			}
			if(sketch.colourFunction != null) {
				sketch.pen.currentColor = sketch.colourFunction(sketch.pen.currentColor,sketch.x,sketch.y,50,50);
			}
			sketch.line(50,50);
			var l = sketch.points.length;
			var p = sketch.points[l - 1];
			var l2 = p.length;
			p[l2] = 50;
			p[l2 + 1] = 50;
			var d = sketch.dim[sketch.dim.length - 1];
			if(50 < d.minX) {
				d.minX = 50;
			}
			if(50 > d.maxX) {
				d.maxX = 50;
			}
			if(50 < d.minY) {
				d.minY = 50;
			}
			if(50 > d.maxY) {
				d.maxY = 50;
			}
			sketch.x = 50;
			sketch.y = 50;
		}
		var end = this.pen.drawType.get_pos();
		var _this = this.pen;
		_this.drawType.set_pos(start);
		_this.colorType.set_pos(start);
		var numberTriangles = end - start | 0;
		var _this = this.pen;
		var color = -16776961;
		if(color == -1) {
			color = _this.currentColor;
		}
		_this.colorType.colorTriangles(color,numberTriangles);
	}
	,renderDraw: function() {
	}
});
function TrilateralTriangle_main() {
	new TrilateralTriangle(1000,1000);
	var divertTrace = new kitGL_glWeb_DivertTrace();
	haxe_Log.trace("TrilateralTriangle example",{ fileName : "TrilateralTriangle.hx", lineNumber : 19, className : "_TrilateralTriangle.TrilateralTriangle_Fields_", methodName : "main"});
}
var dsHelper_flat_io_Float32Flat = {};
dsHelper_flat_io_Float32Flat.get_size = function(this1) {
	return this1[1] | 0;
};
dsHelper_flat_io_Float32Flat.set_size = function(this1,id) {
	var pos_ = id;
	this1[0] = pos_;
	if(this1[0] > this1[1] - 1) {
		this1[1] = this1[0];
	}
	return id;
};
var dsHelper_flatInterleave_FloatColorTriangles = {};
dsHelper_flatInterleave_FloatColorTriangles.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 21 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 21 + 1 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 1 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_az = function(this1) {
	return this1[(this1[0] | 0) * 21 + 2 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_az = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 2 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_redA = function(this1) {
	return this1[(this1[0] | 0) * 21 + 3 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_redA = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 3 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 21 + 7 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 7 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_by = function(this1) {
	return this1[(this1[0] | 0) * 21 + 8 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 8 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_bz = function(this1) {
	return this1[(this1[0] | 0) * 21 + 9 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_bz = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 9 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.set_redB = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 10 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 21 + 14 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 14 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 21 + 15 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 15 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_cz = function(this1) {
	return this1[(this1[0] | 0) * 21 + 16 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_cz = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 16 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.set_redC = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 17 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.triangle = function(this1,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
	dsHelper_flatInterleave_FloatColorTriangles.set_ax(this1,ax_);
	dsHelper_flatInterleave_FloatColorTriangles.set_ay(this1,ay_);
	dsHelper_flatInterleave_FloatColorTriangles.set_az(this1,az_);
	dsHelper_flatInterleave_FloatColorTriangles.set_bx(this1,bx_);
	dsHelper_flatInterleave_FloatColorTriangles.set_by(this1,by_);
	dsHelper_flatInterleave_FloatColorTriangles.set_bz(this1,bz_);
	dsHelper_flatInterleave_FloatColorTriangles.set_cx(this1,cx_);
	dsHelper_flatInterleave_FloatColorTriangles.set_cy(this1,cy_);
	dsHelper_flatInterleave_FloatColorTriangles.set_cz(this1,cz_);
	var windingAdjusted = dsHelper_flatInterleave_FloatColorTriangles.adjustWinding(this1);
	if(windingAdjusted) {
		dsHelper_flatInterleave_FloatColorTriangles.set_ax(this1,ax_);
		dsHelper_flatInterleave_FloatColorTriangles.set_ay(this1,ay_);
		dsHelper_flatInterleave_FloatColorTriangles.set_bx(this1,cx_);
		dsHelper_flatInterleave_FloatColorTriangles.set_by(this1,cy_);
		dsHelper_flatInterleave_FloatColorTriangles.set_cx(this1,bx_);
		dsHelper_flatInterleave_FloatColorTriangles.set_cy(this1,by_);
	}
	return windingAdjusted;
};
dsHelper_flatInterleave_FloatColorTriangles.adjustWinding = function(this1) {
	return dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1) * dsHelper_flatInterleave_FloatColorTriangles.get_by(this1) - dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1) * dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1) + (dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1) * dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1) - dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1) * dsHelper_flatInterleave_FloatColorTriangles.get_by(this1)) + (dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1) * dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1) - dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1) * dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1)) > 0;
};
dsHelper_flatInterleave_FloatColorTriangles.moveDelta = function(this1,dx,dy) {
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTriangles.set_ax(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ax(_g) + dx);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTriangles.set_ay(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ay(_g) + dy);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTriangles.set_bx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_bx(_g) + dx);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTriangles.set_by(_g,dsHelper_flatInterleave_FloatColorTriangles.get_by(_g) + dy);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTriangles.set_cx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cx(_g) + dx);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTriangles.set_cy(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cy(_g) + dy);
};
dsHelper_flatInterleave_FloatColorTriangles.fullHit = function(this1,px,py) {
	if(px > Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1),dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1)),dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1)) && px < Math.max(Math.max(dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1),dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1)),dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1)) && py > Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1),dsHelper_flatInterleave_FloatColorTriangles.get_by(this1)),dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1)) && py < Math.max(Math.max(dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1),dsHelper_flatInterleave_FloatColorTriangles.get_by(this1)),dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1))) {
		return true;
	}
	var planeAB = (dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_by(this1) - py) - (dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1) - py);
	var planeBC = (dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1) - py) - (dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_by(this1) - py);
	var planeCA = (dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1) - py) - (dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1) - py);
	if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
		return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
	} else {
		return false;
	}
};
var fracs_DifferencePreference = $hxEnums["fracs.DifferencePreference"] = { __ename__ : true, __constructs__ : ["CLOCKWISE","ANTICLOCKWISE","SMALL","LARGE"]
	,CLOCKWISE: {_hx_index:0,__enum__:"fracs.DifferencePreference",toString:$estr}
	,ANTICLOCKWISE: {_hx_index:1,__enum__:"fracs.DifferencePreference",toString:$estr}
	,SMALL: {_hx_index:2,__enum__:"fracs.DifferencePreference",toString:$estr}
	,LARGE: {_hx_index:3,__enum__:"fracs.DifferencePreference",toString:$estr}
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	get_native: function() {
		return this.__nativeException;
	}
});
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
});
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_html__$CanvasElement_CanvasUtil = function() { };
js_html__$CanvasElement_CanvasUtil.__name__ = true;
js_html__$CanvasElement_CanvasUtil.getContextWebGL = function(canvas,attribs) {
	var name = "webgl";
	var ctx = canvas.getContext(name,attribs);
	if(ctx != null) {
		return ctx;
	}
	var name = "experimental-webgl";
	var ctx = canvas.getContext(name,attribs);
	if(ctx != null) {
		return ctx;
	}
	return null;
};
var kitGL_glWeb_AnimateTimer = function() { };
kitGL_glWeb_AnimateTimer.__name__ = true;
kitGL_glWeb_AnimateTimer.loop = function(tim) {
	window.requestAnimationFrame(kitGL_glWeb_AnimateTimer.loop);
	if(kitGL_glWeb_AnimateTimer.onFrame != null) {
		kitGL_glWeb_AnimateTimer.onFrame(kitGL_glWeb_AnimateTimer.counter);
	}
	kitGL_glWeb_AnimateTimer.counter++;
	return true;
};
var kitGL_glWeb_DivertTrace = function(left_) {
	if(left_ == null) {
		left_ = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	var doc = window.document;
	this.traceDiv = doc.createElement("div");
	doc.body.appendChild(this.traceDiv);
	var dom = this.traceDiv;
	var style = dom.style;
	style.position = "absolute";
	style.top = Std.string(0 + "px");
	style.left = Std.string(left_ + "px");
	style.height = Std.string(500 + "px");
	style.width = Std.string(500 + "px");
	style.zIndex = "99";
	style.overflow = "auto";
	haxe_Log.trace = $bind(this,this.myTrace);
};
kitGL_glWeb_DivertTrace.__name__ = true;
kitGL_glWeb_DivertTrace.prototype = {
	myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
};
var kitGL_glWeb_Texture = function() {
};
kitGL_glWeb_Texture.__name__ = true;
kitGL_glWeb_Texture.prototype = {
	create: function(width_,height_,autoChild) {
		if(autoChild == null) {
			autoChild = false;
		}
		if(height_ == null) {
			height_ = 600;
		}
		if(width_ == null) {
			width_ = 600;
		}
		this.width = width_;
		this.height = height_;
		this.canvasElement = window.document.createElement("canvas");
		this.canvasElement.width = this.width;
		this.canvasElement.height = this.height;
		this.dom = this.canvasElement;
		var style = this.dom.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			window.document.body.appendChild(this.canvasElement);
		}
		this.gl = js_html__$CanvasElement_CanvasUtil.getContextWebGL(this.canvasElement,null);
		this.cx = this.canvasElement.getContext("2d");
	}
};
var trilateral3_Trilateral = function() { };
trilateral3_Trilateral.__name__ = true;
var trilateral3_drawing_Contour = function(pen_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.count = 0;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.pen = pen_;
	this.endLine = endLine_;
};
trilateral3_drawing_Contour.__name__ = true;
trilateral3_drawing_Contour.prototype = {
	reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
		this.pointsClock.length = 0;
		this.pointsAnti.length = 0;
	}
	,endEdges: function() {
		var pC = this.pointsClock.length;
		var pA = this.pointsAnti.length;
		this.pointsClock[pC++] = this.penultimateCX;
		this.pointsClock[pC++] = this.penultimateCY;
		this.pointsClock[pC++] = this.lastClockX;
		this.pointsClock[pC++] = this.lastClockY;
		this.pointsAnti[pA++] = this.penultimateAX;
		this.pointsAnti[pA++] = this.penultimateAY;
		this.pointsAnti[pA++] = this.lastAntiX;
		this.pointsAnti[pA++] = this.lastAntiY;
	}
	,addQuads: function(clockWise,width_) {
		var currQuadIndex = this.pen.drawType.get_pos();
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				var _this = this.pen;
				var v = this.quadIndex + 1;
				_this.drawType.set_pos(v);
				_this.colorType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				_this.drawType.triangle(this.kax,this.kay,0,this.kbx,this.kby,0,this.ncx,this.ncy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this.drawType.next();
				_this.colorType.cornerColors(color,color,color);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				var _this = this.pen;
				var v = this.quadIndex + 1;
				_this.drawType.set_pos(v);
				_this.colorType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				_this.drawType.triangle(this.kax,this.kay,0,this.kbx,this.kby,0,this.jxOld,this.jyOld,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this.drawType.next();
				_this.colorType.cornerColors(color,color,color);
			}
			var _this = this.pen;
			var v = this.quadIndex;
			_this.drawType.set_pos(v);
			_this.colorType.set_pos(v);
			var _this = this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this.currentColor;
			}
			_this.drawType.triangle(this.kax,this.kay,0,this.kbx,this.kby,0,this.jx,this.jy,0);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
			}
			_this.drawType.next();
			_this.colorType.cornerColors(color,color,color);
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				var _this = this.pen;
				var v = this.quadIndex;
				_this.drawType.set_pos(v);
				_this.colorType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				_this.drawType.triangle(this.kax,this.kay,0,this.kbx,this.kby,0,this.jx,this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this.drawType.next();
				_this.colorType.cornerColors(color,color,color);
				var _this = this.pen;
				var v = this.quadIndex + 1;
				_this.drawType.set_pos(v);
				_this.colorType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				_this.drawType.triangle(this.kax,this.kay,0,this.kbx,this.kby,0,this.ncx,this.ncy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this.drawType.next();
				_this.colorType.cornerColors(color,color,color);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				var _this = this.pen;
				var v = this.quadIndex;
				_this.drawType.set_pos(v);
				_this.colorType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				_this.drawType.triangle(this.jxOld,this.jyOld,0,this.kbx,this.kby,0,this.jx,this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this.drawType.next();
				_this.colorType.cornerColors(color,color,color);
				var _this = this.pen;
				var v = this.quadIndex + 1;
				_this.drawType.set_pos(v);
				_this.colorType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				_this.drawType.triangle(this.jxOld,this.jyOld,0,this.kbx,this.kby,0,this.ncx,this.ncy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this.drawType.next();
				_this.colorType.cornerColors(color,color,color);
			}
		}
		if(!clockWise && !this.lastClock) {
			var _this = this.pen;
			var v = this.quadIndex;
			_this.drawType.set_pos(v);
			_this.colorType.set_pos(v);
			var _this = this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this.currentColor;
			}
			_this.drawType.triangle(this.kax,this.kay,0,this.jx,this.jy,0,this.kcx,this.kcy,0);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
			}
			_this.drawType.next();
			_this.colorType.cornerColors(color,color,color);
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				var _this = this.pen;
				var v = this.quadIndex + 1;
				_this.drawType.set_pos(v);
				_this.colorType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				_this.drawType.triangle(this.kax,this.kay,0,this.jx,this.jy,0,this.ncx,this.ncy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this.drawType.next();
				_this.colorType.cornerColors(color,color,color);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				var _this = this.pen;
				var v = this.quadIndex + 1;
				_this.drawType.set_pos(v);
				_this.colorType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				_this.drawType.triangle(this.kax,this.kay,0,this.jx,this.jy,0,this.jxOld,this.jyOld,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this.drawType.next();
				_this.colorType.cornerColors(color,color,color);
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				var _this = this.pen;
				var v = this.quadIndex;
				_this.drawType.set_pos(v);
				_this.colorType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				_this.drawType.triangle(this.kax,this.kay,0,this.jx,this.jy,0,this.kcx,this.kcy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this.drawType.next();
				_this.colorType.cornerColors(color,color,color);
				var _this = this.pen;
				var v = this.quadIndex + 1;
				_this.drawType.set_pos(v);
				_this.colorType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				_this.drawType.triangle(this.kax,this.kay,0,this.jx,this.jy,0,this.ncx,this.ncy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this.drawType.next();
				_this.colorType.cornerColors(color,color,color);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				var _this = this.pen;
				var v = this.quadIndex;
				_this.drawType.set_pos(v);
				_this.colorType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				_this.drawType.triangle(this.jxOld,this.jyOld,0,this.jx,this.jy,0,this.kcx,this.kcy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this.drawType.next();
				_this.colorType.cornerColors(color,color,color);
				var _this = this.pen;
				var v = this.quadIndex + 1;
				_this.drawType.set_pos(v);
				_this.colorType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				_this.drawType.triangle(this.jxOld,this.jyOld,0,this.jx,this.jy,0,this.ncx,this.ncy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this.drawType.next();
				_this.colorType.cornerColors(color,color,color);
			}
		}
		var _this = this.pen;
		_this.drawType.set_pos(currQuadIndex);
		_this.colorType.set_pos(currQuadIndex);
	}
};
var trilateral3_drawing_Pen = function(drawType_,colorType_) {
	this.currentColor = 16435934;
	this.drawType = drawType_;
	this.colorType = colorType_;
};
trilateral3_drawing_Pen.__name__ = true;
var trilateral3_drawing_Sketch = function(pen_,sketchForm_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.width = 0.01;
	this.y = 0.;
	this.x = 0.;
	this.contour = new trilateral3_drawing_Contour(pen_,endLine_);
	this.pen = pen_;
	this.endLine = endLine_;
	this.sketchForm = sketchForm_;
	switch(sketchForm_) {
	case 0:
		this.line = $bind(this,this.tracerLine);
		break;
	case 1:
		this.line = $bind(this,this.baseLine);
		break;
	case 2:
		this.line = $bind(this,this.crudeLine);
		break;
	case 3:
		this.line = $bind(this,this.fillOnlyLine);
		break;
	case 4:
		this.line = $bind(this,this.fineLine);
		break;
	case 5:
		this.line = $bind(this,this.fineOverlapLine);
		break;
	case 6:
		this.line = $bind(this,this.mediumLine);
		break;
	case 7:
		this.line = $bind(this,this.mediumOverlapLine);
		break;
	case 8:
		this.line = $bind(this,this.roundEndLine);
		break;
	}
	this.points = [];
	this.pointsClock = [];
	this.pointsAnti = [];
	this.points[0] = [];
	this.dim = [];
};
trilateral3_drawing_Sketch.__name__ = true;
trilateral3_drawing_Sketch.prototype = {
	tracerLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "trilateral3/drawing/Sketch.hx", lineNumber : 38, className : "trilateral3.drawing.Sketch", methodName : "tracerLine"});
	}
	,fillOnlyLine: function(x_,y_) {
	}
	,baseLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "trilateral3/drawing/Sketch.hx", lineNumber : 38, className : "trilateral3.drawing.Sketch", methodName : "tracerLine"});
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.halfA = Math.PI / 2;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var dxPrev_ = _this.dx;
		var dyPrev_ = _this.dy;
		var exPrev_ = _this.ex;
		var eyPrev_ = _this.ey;
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		_this1.drawType.triangle(dxPrev_,dyPrev_,0,_this.dx,_this.dy,0,exPrev_,eyPrev_,0);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
		}
		_this1.drawType.next();
		_this1.colorType.cornerColors(color,color,color);
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		_this1.drawType.triangle(dxPrev_,dyPrev_,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
		}
		_this1.drawType.next();
		_this1.colorType.cornerColors(color,color,color);
	}
	,crudeLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.halfA = Math.PI / 2;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var dxPrev_ = _this.dx;
		var dyPrev_ = _this.dy;
		var exPrev_ = _this.ex;
		var eyPrev_ = _this.ey;
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		_this1.drawType.triangle(dxPrev_,dyPrev_,0,_this.dx,_this.dy,0,exPrev_,eyPrev_,0);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
		}
		_this1.drawType.next();
		_this1.colorType.cornerColors(color,color,color);
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		_this1.drawType.triangle(dxPrev_,dyPrev_,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
		}
		_this1.drawType.next();
		_this1.colorType.cornerColors(color,color,color);
	}
	,roundEndLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var endLineCurve = 3;
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.halfA = Math.PI / 2;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var dxPrev_ = _this.dx;
		var dyPrev_ = _this.dy;
		var exPrev_ = _this.ex;
		var eyPrev_ = _this.ey;
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var drawType = _this.pen.drawType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _this1 = _this.pen;
			var color = 0;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.colorType.colorTriangles(color,len);
			break;
		case 2:
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 - Math.PI;
			var drawType = _this.pen.drawType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = x_ + radius * Math.sin(angle);
				cy = y_ + radius * Math.cos(angle);
				if(i != 0) {
					drawType.triangle(x_,y_,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _this1 = _this.pen;
			var color = 0;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.colorType.colorTriangles(color,len);
			break;
		case 3:
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var drawType = _this.pen.drawType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _this1 = _this.pen;
			var color = 0;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.colorType.colorTriangles(color,len);
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 - Math.PI;
			var drawType = _this.pen.drawType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = x_ + radius * Math.sin(angle);
				cy = y_ + radius * Math.cos(angle);
				if(i != 0) {
					drawType.triangle(x_,y_,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _this1 = _this.pen;
			var color = 0;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.colorType.colorTriangles(color,len);
			break;
		}
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		_this1.drawType.triangle(dxPrev_,dyPrev_,0,_this.dx,_this.dy,0,exPrev_,eyPrev_,0);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
		}
		_this1.drawType.next();
		_this1.colorType.cornerColors(color,color,color);
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		_this1.drawType.triangle(dxPrev_,dyPrev_,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
		}
		_this1.drawType.next();
		_this1.colorType.cornerColors(color,color,color);
	}
	,mediumLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var curveEnds = false;
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(_this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var drawType = _this.pen.drawType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					drawType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.colorType.colorTriangles(color,len);
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = _this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsClock[pC++] = temp[i * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(_this.count != 0) {
			_this.addQuads(clockWise,width_);
		}
		_this.quadIndex = _this.pen.drawType.get_pos();
		if(_this.count == 0) {
			_this.penultimateAX = _this.dxPrev;
			_this.penultimateAY = _this.dyPrev;
			_this.lastAntiX = _this.ex;
			_this.lastAntiY = _this.ey;
			_this.penultimateCX = _this.dx;
			_this.penultimateCY = _this.dy;
			_this.lastClockX = _this.exPrev;
			_this.lastClockY = _this.eyPrev;
			var _this1 = _this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
			}
			_this1.drawType.next();
			_this1.colorType.cornerColors(color,color,color);
			var _this1 = _this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
			}
			_this1.drawType.next();
			_this1.colorType.cornerColors(color,color,color);
		} else {
			if(clockWise && !_this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
			if(clockWise && _this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
			if(!clockWise && !_this.lastClock) {
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.jx;
				_this.lastClockY = _this.jy;
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
			if(!clockWise && _this.lastClock) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.jx;
				_this.penultimateCY = _this.jy;
				_this.lastClockX = _this.dx;
				_this.lastClockY = _this.dy;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.jx,_this.jy,0,_this.ex,_this.ey,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var drawType = _this.pen.drawType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.colorType.colorTriangles(color,len);
			} else {
				var drawType = _this.pen.drawType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.colorType.colorTriangles(color,len);
			}
		} else if(_this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxOld,_this.dyOld,0,_this.exPrev,_this.eyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.exOld,_this.eyOld,0,_this.dxPrev,_this.dyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(curveEnds && _this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.dxOld,_this.dyOld,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.exPrev,_this.eyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.exOld,_this.eyOld,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.dxPrev,_this.dyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
	,mediumOverlapLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var curveEnds = false;
		var overlap = true;
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && _this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var drawType = _this.pen.drawType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					drawType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.colorType.colorTriangles(color,len);
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = _this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsClock[pC++] = temp[i * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
			}
			_this1.drawType.next();
			_this1.colorType.cornerColors(color,color,color);
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
			}
			_this1.drawType.next();
			_this1.colorType.cornerColors(color,color,color);
		} else {
			if(_this.count != 0) {
				_this.addQuads(clockWise,width_);
			}
			_this.quadIndex = _this.pen.drawType.get_pos();
			if(_this.count == 0) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			} else {
				if(clockWise && !_this.lastClock) {
					_this.penultimateAX = _this.jx;
					_this.penultimateAY = _this.jy;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.exPrev;
					_this.lastClockY = _this.eyPrev;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
				}
				if(clockWise && _this.lastClock) {
					_this.penultimateAX = _this.jx;
					_this.penultimateAY = _this.jy;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.exPrev;
					_this.lastClockY = _this.eyPrev;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
				}
				if(!clockWise && !_this.lastClock) {
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.jx;
					_this.lastClockY = _this.jy;
					_this.penultimateAX = _this.dxPrev;
					_this.penultimateAY = _this.dyPrev;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.jx,_this.jy,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
				}
				if(!clockWise && _this.lastClock) {
					_this.penultimateAX = _this.dxPrev;
					_this.penultimateAY = _this.dyPrev;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.jx;
					_this.penultimateCY = _this.jy;
					_this.lastClockX = _this.dx;
					_this.lastClockY = _this.dy;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.jx,_this.jy,0,_this.ex,_this.ey,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var drawType = _this.pen.drawType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.colorType.colorTriangles(color,len);
			} else {
				var drawType = _this.pen.drawType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.colorType.colorTriangles(color,len);
			}
		} else if(_this.count != 0) {
			if(overlap) {
				if(clockWise) {
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.dxOld,_this.dyOld,0,_this.exPrev,_this.eyPrev,0,_this.ax,_this.ay,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
				} else {
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.exOld,_this.eyOld,0,_this.dxPrev,_this.dyPrev,0,_this.ax,_this.ay,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
				}
			} else if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxOld,_this.dyOld,0,_this.exPrev,_this.eyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.exOld,_this.eyOld,0,_this.dxPrev,_this.dyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(curveEnds && !overlap && _this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.dxOld,_this.dyOld,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.exPrev,_this.eyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.exOld,_this.eyOld,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.dxPrev,_this.dyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
	,fineLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var curveEnds = true;
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(_this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var drawType = _this.pen.drawType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					drawType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.colorType.colorTriangles(color,len);
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = _this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsClock[pC++] = temp[i * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(_this.count != 0) {
			_this.addQuads(clockWise,width_);
		}
		_this.quadIndex = _this.pen.drawType.get_pos();
		if(_this.count == 0) {
			_this.penultimateAX = _this.dxPrev;
			_this.penultimateAY = _this.dyPrev;
			_this.lastAntiX = _this.ex;
			_this.lastAntiY = _this.ey;
			_this.penultimateCX = _this.dx;
			_this.penultimateCY = _this.dy;
			_this.lastClockX = _this.exPrev;
			_this.lastClockY = _this.eyPrev;
			var _this1 = _this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
			}
			_this1.drawType.next();
			_this1.colorType.cornerColors(color,color,color);
			var _this1 = _this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
			}
			_this1.drawType.next();
			_this1.colorType.cornerColors(color,color,color);
		} else {
			if(clockWise && !_this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
			if(clockWise && _this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
			if(!clockWise && !_this.lastClock) {
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.jx;
				_this.lastClockY = _this.jy;
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
			if(!clockWise && _this.lastClock) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.jx;
				_this.penultimateCY = _this.jy;
				_this.lastClockX = _this.dx;
				_this.lastClockY = _this.dy;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.jx,_this.jy,0,_this.ex,_this.ey,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var drawType = _this.pen.drawType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.colorType.colorTriangles(color,len);
			} else {
				var drawType = _this.pen.drawType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.colorType.colorTriangles(color,len);
			}
		} else if(_this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxOld,_this.dyOld,0,_this.exPrev,_this.eyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.exOld,_this.eyOld,0,_this.dxPrev,_this.dyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(curveEnds && _this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.dxOld,_this.dyOld,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.exPrev,_this.eyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.exOld,_this.eyOld,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.dxPrev,_this.dyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
	,fineOverlapLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var curveEnds = true;
		var overlap = true;
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && _this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var drawType = _this.pen.drawType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					drawType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.colorType.colorTriangles(color,len);
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = _this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsClock[pC++] = temp[i * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
			}
			_this1.drawType.next();
			_this1.colorType.cornerColors(color,color,color);
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
			}
			_this1.drawType.next();
			_this1.colorType.cornerColors(color,color,color);
		} else {
			if(_this.count != 0) {
				_this.addQuads(clockWise,width_);
			}
			_this.quadIndex = _this.pen.drawType.get_pos();
			if(_this.count == 0) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			} else {
				if(clockWise && !_this.lastClock) {
					_this.penultimateAX = _this.jx;
					_this.penultimateAY = _this.jy;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.exPrev;
					_this.lastClockY = _this.eyPrev;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
				}
				if(clockWise && _this.lastClock) {
					_this.penultimateAX = _this.jx;
					_this.penultimateAY = _this.jy;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.exPrev;
					_this.lastClockY = _this.eyPrev;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.exPrev,_this.eyPrev,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
				}
				if(!clockWise && !_this.lastClock) {
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.jx;
					_this.lastClockY = _this.jy;
					_this.penultimateAX = _this.dxPrev;
					_this.penultimateAY = _this.dyPrev;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.jx,_this.jy,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
				}
				if(!clockWise && _this.lastClock) {
					_this.penultimateAX = _this.dxPrev;
					_this.penultimateAY = _this.dyPrev;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.jx;
					_this.penultimateCY = _this.jy;
					_this.lastClockX = _this.dx;
					_this.lastClockY = _this.dy;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.jx,_this.jy,0,_this.dx,_this.dy,0,_this.ex,_this.ey,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.dxPrev,_this.dyPrev,0,_this.jx,_this.jy,0,_this.ex,_this.ey,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var drawType = _this.pen.drawType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.colorType.colorTriangles(color,len);
			} else {
				var drawType = _this.pen.drawType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.colorType.colorTriangles(color,len);
			}
		} else if(_this.count != 0) {
			if(overlap) {
				if(clockWise) {
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.dxOld,_this.dyOld,0,_this.exPrev,_this.eyPrev,0,_this.ax,_this.ay,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
				} else {
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					_this1.drawType.triangle(_this.exOld,_this.eyOld,0,_this.dxPrev,_this.dyPrev,0,_this.ax,_this.ay,0);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
					}
					_this1.drawType.next();
					_this1.colorType.cornerColors(color,color,color);
				}
			} else if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.dxOld,_this.dyOld,0,_this.exPrev,_this.eyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.exOld,_this.eyOld,0,_this.dxPrev,_this.dyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(curveEnds && !overlap && _this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.dxOld,_this.dyOld,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.exPrev,_this.eyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.exOld,_this.eyOld,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.drawType.triangle(_this.ax,_this.ay,0,_this.dxPrev,_this.dyPrev,0,_this.jx,_this.jy,0);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.drawType.transform(trilateral3_Trilateral.transformMatrix);
				}
				_this1.drawType.next();
				_this1.colorType.cornerColors(color,color,color);
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
	,moveTo: function(x_,y_) {
		if(this.endLine == 2 || this.endLine == 3) {
			var _this = this.contour;
			var width_ = this.width;
			_this.endEdges();
			if(_this.count != 0) {
				var ax = _this.bx;
				var ay = _this.by;
				var radius = width_ / 2;
				var beta = -_this.angle1 - Math.PI / 2;
				var gamma = -_this.angle1 - Math.PI / 2 - Math.PI;
				var temp = [];
				var drawType = _this.pen.drawType;
				var sides = 36;
				if(sides == null) {
					sides = 36;
				}
				var pi = Math.PI;
				var step = pi * 2 / sides;
				var dif;
				switch(fracs_DifferencePreference.SMALL._hx_index) {
				case 0:
					var f;
					if(beta >= 0 && beta > Math.PI) {
						f = beta;
					} else {
						var a = beta % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var za = this1;
					var f;
					if(gamma >= 0 && gamma > Math.PI) {
						f = gamma;
					} else {
						var a = gamma % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var zb = this1;
					var fa = za;
					var fb = zb;
					var theta = Math.abs(fa - fb);
					var clockwise = fa < fb;
					var dif1 = clockwise ? theta : -theta;
					dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
					break;
				case 1:
					var f;
					if(beta >= 0 && beta > Math.PI) {
						f = beta;
					} else {
						var a = beta % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var za = this1;
					var f;
					if(gamma >= 0 && gamma > Math.PI) {
						f = gamma;
					} else {
						var a = gamma % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var zb = this1;
					var fa = za;
					var fb = zb;
					var theta = Math.abs(fa - fb);
					var clockwise = fa < fb;
					var dif1 = clockwise ? theta : -theta;
					dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
					break;
				case 2:
					var f;
					if(beta >= 0 && beta > Math.PI) {
						f = beta;
					} else {
						var a = beta % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var za = this1;
					var f;
					if(gamma >= 0 && gamma > Math.PI) {
						f = gamma;
					} else {
						var a = gamma % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var zb = this1;
					var fa = za;
					var fb = zb;
					var theta = Math.abs(fa - fb);
					var smallest = theta <= Math.PI;
					var clockwise = fa < fb;
					var dif1 = clockwise ? theta : -theta;
					dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
					break;
				case 3:
					var f;
					if(beta >= 0 && beta > Math.PI) {
						f = beta;
					} else {
						var a = beta % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var za = this1;
					var f;
					if(gamma >= 0 && gamma > Math.PI) {
						f = gamma;
					} else {
						var a = gamma % (2 * Math.PI);
						f = a >= 0 ? a : a + 2 * Math.PI;
					}
					var this1 = f;
					var zb = this1;
					var fa = za;
					var fb = zb;
					var theta = Math.abs(fa - fb);
					var largest = theta > Math.PI;
					var clockwise = fa < fb;
					var dif1 = clockwise ? theta : -theta;
					dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
					break;
				}
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = beta;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = temp.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = 0;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.colorType.colorTriangles(color,len);
				var pA = _this.pointsAnti.length;
				var len = temp.length / 2 | 0;
				var _g = 0;
				var _g1 = len + 2;
				while(_g < _g1) {
					var i = _g++;
					_this.pointsAnti[pA++] = temp[i];
				}
				var pC = _this.pointsClock.length;
				var _g = 1;
				var _g1 = len / 2 + 1 | 0;
				while(_g < _g1) {
					var i = _g++;
					_this.pointsClock[pC++] = temp[temp.length - 2 * i];
					_this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
				}
			}
		}
		this.x = x_;
		this.y = y_;
		var l = this.points.length;
		this.points[l] = [];
		this.points[l][0] = x_;
		this.points[l][1] = y_;
		this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
		this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
		this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
		var d = this.dim[this.dim.length - 1];
		if(x_ < d.minX) {
			d.minX = x_;
		}
		if(x_ > d.maxX) {
			d.maxX = x_;
		}
		if(y_ < d.minY) {
			d.minY = y_;
		}
		if(y_ > d.maxY) {
			d.maxY = y_;
		}
		this.contour.reset();
	}
};
var trilateral3_geom_FlatColorTriangles = {};
trilateral3_geom_FlatColorTriangles.transform = function(this1,m) {
	var pa = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1),dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1),dsHelper_flatInterleave_FloatColorTriangles.get_az(this1),1.);
	var pb = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1),dsHelper_flatInterleave_FloatColorTriangles.get_by(this1),dsHelper_flatInterleave_FloatColorTriangles.get_bz(this1),1.);
	var pc = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1),dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1),dsHelper_flatInterleave_FloatColorTriangles.get_cz(this1),1.);
	var v2 = { x : m.a * pa.x + m.b * pa.y + m.c * pa.z + m.d, y : m.e * pa.x + m.f * pa.y + m.g * pa.z + m.h, z : m.i * pa.x + m.j * pa.y + m.k * pa.z + m.l, w : 1.};
	pa = v2;
	var v2 = { x : m.a * pb.x + m.b * pb.y + m.c * pb.z + m.d, y : m.e * pb.x + m.f * pb.y + m.g * pb.z + m.h, z : m.i * pb.x + m.j * pb.y + m.k * pb.z + m.l, w : 1.};
	pb = v2;
	var v2 = { x : m.a * pc.x + m.b * pc.y + m.c * pc.z + m.d, y : m.e * pc.x + m.f * pc.y + m.g * pc.z + m.h, z : m.i * pc.x + m.j * pc.y + m.k * pc.z + m.l, w : 1.};
	pc = v2;
	dsHelper_flatInterleave_FloatColorTriangles.set_ax(this1,pa.x);
	dsHelper_flatInterleave_FloatColorTriangles.set_ay(this1,pa.y);
	dsHelper_flatInterleave_FloatColorTriangles.set_az(this1,pa.z);
	dsHelper_flatInterleave_FloatColorTriangles.set_bx(this1,pb.x);
	dsHelper_flatInterleave_FloatColorTriangles.set_by(this1,pb.y);
	dsHelper_flatInterleave_FloatColorTriangles.set_bz(this1,pb.z);
	dsHelper_flatInterleave_FloatColorTriangles.set_cx(this1,pc.x);
	dsHelper_flatInterleave_FloatColorTriangles.set_cy(this1,pc.y);
	dsHelper_flatInterleave_FloatColorTriangles.set_cz(this1,pc.z);
};
trilateral3_geom_FlatColorTriangles.transformRange = function(this1,m,startEnd) {
	var start = startEnd.start;
	var end = startEnd.end;
	this1[0] = start;
	if(this1[0] > this1[1] - 1) {
		this1[1] = this1[0];
	}
	if(end > dsHelper_flat_io_Float32Flat.get_size(this1) - 1) {
		dsHelper_flat_io_Float32Flat.get_size(this1);
	}
	var _g = start;
	var _g1 = end + 1;
	while(_g < _g1) {
		var i = _g++;
		trilateral3_geom_FlatColorTriangles.transform(this1,m);
		var pos_ = this1[0] + 1.;
		this1[0] = pos_;
		if(this1[0] > this1[1] - 1) {
			this1[1] = this1[0];
		}
	}
};
var trilateral3_matrix_MatrixDozen = function(a,b,c,d,e,f,g,h,i,j,k,l) {
	this.l = 0.;
	this.k = 0.;
	this.j = 0.;
	this.i = 0.;
	this.h = 0.;
	this.g = 0.;
	this.f = 0.;
	this.e = 0.;
	this.d = 0.;
	this.c = 0.;
	this.b = 0.;
	this.a = 0.;
	this.a = a;
	this.b = b;
	this.c = c;
	this.d = d;
	this.e = e;
	this.f = f;
	this.g = g;
	this.h = h;
	this.i = i;
	this.j = j;
	this.k = k;
	this.l = l;
};
trilateral3_matrix_MatrixDozen.__name__ = true;
var trilateral3_matrix_Vertex = function(x,y,z,w) {
	if(w == null) {
		w = 1.;
	}
	this.w = 1.;
	this.z = 0.;
	this.y = 0.;
	this.x = 0.;
	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
};
trilateral3_matrix_Vertex.__name__ = true;
var trilateral3_nodule_PenNodule = function(useGLScale) {
	if(useGLScale == null) {
		useGLScale = true;
	}
	var this1 = new Float32Array(trilateral3_nodule_PenNodule.largeEnough + 2);
	this1[0] = 0.;
	this1[1] = 0.;
	this.colorTriangles = this1;
	if(useGLScale) {
		var transform1000 = new trilateral3_matrix_MatrixDozen(0.001,0,0,-1,0,-0.001,0,1,0,0,0.001,0);
		trilateral3_Trilateral.transformMatrix = transform1000;
	}
	this.createPen();
};
trilateral3_nodule_PenNodule.__name__ = true;
trilateral3_nodule_PenNodule.prototype = {
	createPen: function() {
		var t = this.colorTriangles;
		var _e = t;
		var _e1 = t;
		var _e2 = t;
		var _e3 = t;
		var _e4 = t;
		var _e5 = t;
		var _e6 = t;
		var _e7 = t;
		var _e8 = t;
		var _e9 = t;
		var _e10 = t;
		var _e11 = t;
		var _e12 = t;
		var _e13 = t;
		var _e14 = t;
		var _e15 = t;
		var _e16 = t;
		var triangleAbstract = { rotate : function(x,y,theta) {
			var cos = Math.cos(theta);
			var sin = Math.sin(theta);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ax(_g) - x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ay(_g) - y);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_bx(_g) - x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_g,dsHelper_flatInterleave_FloatColorTriangles.get_by(_g) - y);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cx(_g) - x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cy(_g) - y);
			var dx = dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e);
			var dy = dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e);
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_e,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_e,dx * sin + dy * cos);
			dx = dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e);
			dy = dsHelper_flatInterleave_FloatColorTriangles.get_by(_e);
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_e,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_e,dx * sin + dy * cos);
			dx = dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e);
			dy = dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e);
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_e,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_e,dx * sin + dy * cos);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ax(_g) + x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ay(_g) + y);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_bx(_g) + x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_g,dsHelper_flatInterleave_FloatColorTriangles.get_by(_g) + y);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cx(_g) + x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cy(_g) + y);
		}, moveDelta : function(dx,dy) {
			dsHelper_flatInterleave_FloatColorTriangles.moveDelta(_e1,dx,dy);
		}, rotateTrig : function(x,y,cos,sin) {
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ax(_g) - x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ay(_g) - y);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_bx(_g) - x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_g,dsHelper_flatInterleave_FloatColorTriangles.get_by(_g) - y);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cx(_g) - x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cy(_g) - y);
			var dx = dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e2);
			var dy = dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e2);
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_e2,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_e2,dx * sin + dy * cos);
			dx = dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e2);
			dy = dsHelper_flatInterleave_FloatColorTriangles.get_by(_e2);
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_e2,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_e2,dx * sin + dy * cos);
			dx = dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e2);
			dy = dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e2);
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_e2,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_e2,dx * sin + dy * cos);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ax(_g) + x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ay(_g) + y);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_bx(_g) + x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_g,dsHelper_flatInterleave_FloatColorTriangles.get_by(_g) + y);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cx(_g) + x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cy(_g) + y);
		}, fullHit : function(px,py) {
			return dsHelper_flatInterleave_FloatColorTriangles.fullHit(_e3,px,py);
		}, liteHit : function(px,py) {
			var planeAB = (dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e4) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_by(_e4) - py) - (dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e4) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e4) - py);
			var planeBC = (dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e4) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e4) - py) - (dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e4) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_by(_e4) - py);
			var planeCA = (dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e4) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e4) - py) - (dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e4) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e4) - py);
			if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
				return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
			} else {
				return false;
			}
		}, get_bottom : function() {
			return Math.max(Math.max(dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e5),dsHelper_flatInterleave_FloatColorTriangles.get_by(_e5)),dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e5));
		}, get_back : function() {
			return Math.max(Math.max(dsHelper_flatInterleave_FloatColorTriangles.get_az(_e6),dsHelper_flatInterleave_FloatColorTriangles.get_bz(_e6)),dsHelper_flatInterleave_FloatColorTriangles.get_cz(_e6));
		}, get_right : function() {
			return Math.max(Math.max(dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e7),dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e7)),dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e7));
		}, get_x : function() {
			return Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e8),dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e8)),dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e8));
		}, set_x : function(x) {
			var dx = x - Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e9),dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e9)),dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e9));
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_e9,dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e9) + dx);
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_e9,dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e9) + dx);
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_e9,dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e9) + dx);
			return x;
		}, get_y : function() {
			return Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e10),dsHelper_flatInterleave_FloatColorTriangles.get_by(_e10)),dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e10));
		}, set_y : function(y) {
			var dy = y - Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e11),dsHelper_flatInterleave_FloatColorTriangles.get_by(_e11)),dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e11));
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_e11,dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e11) + dy);
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_e11,dsHelper_flatInterleave_FloatColorTriangles.get_by(_e11) + dy);
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_e11,dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e11) + dy);
			return y;
		}, get_z : function() {
			return Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_az(_e12),dsHelper_flatInterleave_FloatColorTriangles.get_bz(_e12)),dsHelper_flatInterleave_FloatColorTriangles.get_cz(_e12));
		}, set_z : function(z) {
			var dz = z - Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_az(_e13),dsHelper_flatInterleave_FloatColorTriangles.get_bz(_e13)),dsHelper_flatInterleave_FloatColorTriangles.get_cz(_e13));
			dsHelper_flatInterleave_FloatColorTriangles.set_az(_e13,dsHelper_flatInterleave_FloatColorTriangles.get_az(_e13) + dz);
			dsHelper_flatInterleave_FloatColorTriangles.set_bz(_e13,dsHelper_flatInterleave_FloatColorTriangles.get_bz(_e13) + dz);
			dsHelper_flatInterleave_FloatColorTriangles.set_cz(_e13,dsHelper_flatInterleave_FloatColorTriangles.get_cz(_e13) + dz);
			return z;
		}, triangle : function(ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
			return dsHelper_flatInterleave_FloatColorTriangles.triangle(_e14,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_);
		}, getTriangle3D : function() {
			var pa = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e15),dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e15),dsHelper_flatInterleave_FloatColorTriangles.get_az(_e15),1.);
			var pb = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e15),dsHelper_flatInterleave_FloatColorTriangles.get_by(_e15),dsHelper_flatInterleave_FloatColorTriangles.get_bz(_e15),1.);
			var pc = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e15),dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e15),dsHelper_flatInterleave_FloatColorTriangles.get_cz(_e15),1.);
			return new trilateral3_structure_Triangle3D(pa,pb,pc);
		}, transform : function(m) {
			trilateral3_geom_FlatColorTriangles.transform(_e16,m);
		}};
		var _e17 = t;
		var _e18 = t;
		var _e19 = t;
		var _e20 = t;
		var _e21 = t;
		var _e22 = t;
		var _e23 = t;
		var _e24 = t;
		var _e25 = t;
		var _e26 = t;
		var drawAbstract = { triangle : function(ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
			return dsHelper_flatInterleave_FloatColorTriangles.triangle(_e17,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_);
		}, transform : function(m) {
			trilateral3_geom_FlatColorTriangles.transform(_e18,m);
		}, transformRange : function(m,startEnd) {
			trilateral3_geom_FlatColorTriangles.transformRange(_e19,m,startEnd);
		}, getTriangle3D : function() {
			var pa = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e20),dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e20),dsHelper_flatInterleave_FloatColorTriangles.get_az(_e20),1.);
			var pb = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e20),dsHelper_flatInterleave_FloatColorTriangles.get_by(_e20),dsHelper_flatInterleave_FloatColorTriangles.get_bz(_e20),1.);
			var pc = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e20),dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e20),dsHelper_flatInterleave_FloatColorTriangles.get_cz(_e20),1.);
			return new trilateral3_structure_Triangle3D(pa,pb,pc);
		}, next : function() {
			var pos_ = _e21[0] + 1.;
			_e21[0] = pos_;
			if(_e21[0] > _e21[1] - 1) {
				_e21[1] = _e21[0];
			}
			return _e21[0];
		}, hasNext : function() {
			return _e22[0] < dsHelper_flat_io_Float32Flat.get_size(_e22);
		}, get_pos : function() {
			return _e23[0];
		}, set_pos : function(pos_) {
			_e24[0] = pos_;
			if(_e24[0] > _e24[1] - 1) {
				_e24[1] = _e24[0];
			}
			return pos_;
		}, get_size : function() {
			return dsHelper_flat_io_Float32Flat.get_size(_e25);
		}, set_size : function(id) {
			return dsHelper_flat_io_Float32Flat.set_size(_e26,id);
		}, triangleCurrent : triangleAbstract};
		var _e27 = t;
		var _e28 = t;
		var _e29 = t;
		var _e30 = t;
		var _e31 = t;
		var _e32 = t;
		var _e33 = t;
		var color3Abstract = { set_argb : function(col) {
			dsHelper_flatInterleave_FloatColorTriangles.set_redA(_e27,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e27[(_e27[0] | 0) * 21 + 5 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e27[(_e27[0] | 0) * 21 + 4 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e27[(_e27[0] | 0) * 21 + 6 + 2] = v;
			dsHelper_flatInterleave_FloatColorTriangles.set_redB(_e27,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e27[(_e27[0] | 0) * 21 + 12 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e27[(_e27[0] | 0) * 21 + 11 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e27[(_e27[0] | 0) * 21 + 13 + 2] = v;
			dsHelper_flatInterleave_FloatColorTriangles.set_redC(_e27,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e27[(_e27[0] | 0) * 21 + 19 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e27[(_e27[0] | 0) * 21 + 18 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e27[(_e27[0] | 0) * 21 + 20 + 2] = v;
			return col;
		}, set_argbA : function(col) {
			dsHelper_flatInterleave_FloatColorTriangles.set_redA(_e28,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e28[(_e28[0] | 0) * 21 + 5 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e28[(_e28[0] | 0) * 21 + 4 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e28[(_e28[0] | 0) * 21 + 6 + 2] = v;
			return col;
		}, get_argbA : function() {
			return Math.round(_e29[(_e29[0] | 0) * 21 + 6 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTriangles.get_redA(_e29) * 255) << 16 | Math.round(_e29[(_e29[0] | 0) * 21 + 4 + 2] * 255) << 8 | Math.round(_e29[(_e29[0] | 0) * 21 + 5 + 2] * 255);
		}, set_argbB : function(col) {
			dsHelper_flatInterleave_FloatColorTriangles.set_redB(_e30,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e30[(_e30[0] | 0) * 21 + 12 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e30[(_e30[0] | 0) * 21 + 11 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e30[(_e30[0] | 0) * 21 + 13 + 2] = v;
			return col;
		}, get_argbB : function() {
			return Math.round(_e31[(_e31[0] | 0) * 21 + 6 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTriangles.get_redA(_e31) * 255) << 16 | Math.round(_e31[(_e31[0] | 0) * 21 + 4 + 2] * 255) << 8 | Math.round(_e31[(_e31[0] | 0) * 21 + 5 + 2] * 255);
		}, set_argbC : function(col) {
			dsHelper_flatInterleave_FloatColorTriangles.set_redC(_e32,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e32[(_e32[0] | 0) * 21 + 19 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e32[(_e32[0] | 0) * 21 + 18 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e32[(_e32[0] | 0) * 21 + 20 + 2] = v;
			return col;
		}, get_argbC : function() {
			return Math.round(_e33[(_e33[0] | 0) * 21 + 6 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTriangles.get_redA(_e33) * 255) << 16 | Math.round(_e33[(_e33[0] | 0) * 21 + 4 + 2] * 255) << 8 | Math.round(_e33[(_e33[0] | 0) * 21 + 5 + 2] * 255);
		}};
		var _e34 = t;
		var _e35 = t;
		var _e36 = t;
		var _e37 = t;
		var _e38 = t;
		var _e39 = t;
		var _e40 = t;
		var colorAbstract = { cornerColors : function(colorA,colorB,colorC) {
			dsHelper_flatInterleave_FloatColorTriangles.set_redA(_e34,(colorA >> 16 & 255) / 255);
			var v = (colorA & 255) / 255;
			_e34[(_e34[0] | 0) * 21 + 5 + 2] = v;
			var v = (colorA >> 8 & 255) / 255;
			_e34[(_e34[0] | 0) * 21 + 4 + 2] = v;
			var v = (colorA >> 24 & 255) / 255;
			_e34[(_e34[0] | 0) * 21 + 6 + 2] = v;
			dsHelper_flatInterleave_FloatColorTriangles.set_redB(_e34,(colorB >> 16 & 255) / 255);
			var v = (colorB & 255) / 255;
			_e34[(_e34[0] | 0) * 21 + 12 + 2] = v;
			var v = (colorB >> 8 & 255) / 255;
			_e34[(_e34[0] | 0) * 21 + 11 + 2] = v;
			var v = (colorB >> 24 & 255) / 255;
			_e34[(_e34[0] | 0) * 21 + 13 + 2] = v;
			dsHelper_flatInterleave_FloatColorTriangles.set_redC(_e34,(colorC >> 16 & 255) / 255);
			var v = (colorC & 255) / 255;
			_e34[(_e34[0] | 0) * 21 + 19 + 2] = v;
			var v = (colorC >> 8 & 255) / 255;
			_e34[(_e34[0] | 0) * 21 + 18 + 2] = v;
			var v = (colorC >> 24 & 255) / 255;
			_e34[(_e34[0] | 0) * 21 + 20 + 2] = v;
		}, colorTriangles : function(color,times) {
			var _g = 0;
			var _g1 = times;
			while(_g < _g1) {
				var i = _g++;
				dsHelper_flatInterleave_FloatColorTriangles.set_redA(_e35,(color >> 16 & 255) / 255);
				var v = (color & 255) / 255;
				_e35[(_e35[0] | 0) * 21 + 5 + 2] = v;
				var v1 = (color >> 8 & 255) / 255;
				_e35[(_e35[0] | 0) * 21 + 4 + 2] = v1;
				var v2 = (color >> 24 & 255) / 255;
				_e35[(_e35[0] | 0) * 21 + 6 + 2] = v2;
				dsHelper_flatInterleave_FloatColorTriangles.set_redB(_e35,(color >> 16 & 255) / 255);
				var v3 = (color & 255) / 255;
				_e35[(_e35[0] | 0) * 21 + 12 + 2] = v3;
				var v4 = (color >> 8 & 255) / 255;
				_e35[(_e35[0] | 0) * 21 + 11 + 2] = v4;
				var v5 = (color >> 24 & 255) / 255;
				_e35[(_e35[0] | 0) * 21 + 13 + 2] = v5;
				dsHelper_flatInterleave_FloatColorTriangles.set_redC(_e35,(color >> 16 & 255) / 255);
				var v6 = (color & 255) / 255;
				_e35[(_e35[0] | 0) * 21 + 19 + 2] = v6;
				var v7 = (color >> 8 & 255) / 255;
				_e35[(_e35[0] | 0) * 21 + 18 + 2] = v7;
				var v8 = (color >> 24 & 255) / 255;
				_e35[(_e35[0] | 0) * 21 + 20 + 2] = v8;
				var pos_ = _e35[0] + 1;
				_e35[0] = pos_;
				if(_e35[0] > _e35[1] - 1) {
					_e35[1] = _e35[0];
				}
			}
		}, getTriInt : function() {
			return new trilateral3_structure_TriInt(Math.round(_e36[(_e36[0] | 0) * 21 + 6 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTriangles.get_redA(_e36) * 255) << 16 | Math.round(_e36[(_e36[0] | 0) * 21 + 4 + 2] * 255) << 8 | Math.round(_e36[(_e36[0] | 0) * 21 + 5 + 2] * 255),Math.round(_e36[(_e36[0] | 0) * 21 + 6 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTriangles.get_redA(_e36) * 255) << 16 | Math.round(_e36[(_e36[0] | 0) * 21 + 4 + 2] * 255) << 8 | Math.round(_e36[(_e36[0] | 0) * 21 + 5 + 2] * 255),Math.round(_e36[(_e36[0] | 0) * 21 + 6 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTriangles.get_redA(_e36) * 255) << 16 | Math.round(_e36[(_e36[0] | 0) * 21 + 4 + 2] * 255) << 8 | Math.round(_e36[(_e36[0] | 0) * 21 + 5 + 2] * 255));
		}, get_pos : function() {
			return _e37[0];
		}, set_pos : function(pos_) {
			_e38[0] = pos_;
			if(_e38[0] > _e38[1] - 1) {
				_e38[1] = _e38[0];
			}
			return pos_;
		}, get_size : function() {
			return dsHelper_flat_io_Float32Flat.get_size(_e39);
		}, set_size : function(id) {
			return dsHelper_flat_io_Float32Flat.set_size(_e40,id);
		}, color3current : color3Abstract};
		this.pen = new trilateral3_drawing_Pen(drawAbstract,colorAbstract);
	}
	,get_data: function() {
		var this1 = this.colorTriangles;
		return this1.subarray(2,this1.length - 2);
	}
	,get_size: function() {
		return dsHelper_flat_io_Float32Flat.get_size(this.colorTriangles) * 3 | 0;
	}
};
var trilateral3_structure_StartEnd = function(start,end) {
	this.start = start;
	this.end = end;
};
trilateral3_structure_StartEnd.__name__ = true;
var trilateral3_structure_TriInt = function(a,b,c) {
	this.a = a;
	this.b = b;
	this.c = c;
};
trilateral3_structure_TriInt.__name__ = true;
var trilateral3_structure_Triangle3D = function(a,b,c) {
	this.a = a;
	this.b = b;
	this.c = c;
};
trilateral3_structure_Triangle3D.__name__ = true;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
kitGL_glWeb_AnimateTimer.counter = 0;
trilateral3_nodule_PenNodule.largeEnough = 20000000;
TrilateralTriangle_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
