// Generated by Haxe 4.2.0-rc.1+7dc565e63
(function ($hx_exports, $global) { "use strict";
$hx_exports["hxGeomAlgo"] = $hx_exports["hxGeomAlgo"] || {};
$hx_exports["hxGeomAlgo"]["_HxPoint"] = $hx_exports["hxGeomAlgo"]["_HxPoint"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.now = function() {
	return Date.now();
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var kitGL_glWeb_PlyMix = function(width_,height_) {
	this.mode = 0;
	this.uvTransform = "uvTransform";
	this.uniformColor = "bgColor";
	this.uniformImage = "uImage0";
	this.vertexTexture = "vertexTexture";
	this.transformUVArr = [1.,0.,0.,0.,1.,0.,0.,0.,1.];
	this.indicesTexture = [];
	this.vertexColor = "vertexColor";
	this.vertexPosition = "vertexPosition";
	this.width = width_;
	this.height = height_;
	this.mainSheet = new kitGL_glWeb_Sheet();
	this.mainSheet.create(this.width,this.height,true);
	this.gl = this.mainSheet.gl;
	this.imageLoader = new kitGL_glWeb_ImageLoader([],$bind(this,this.setup));
};
kitGL_glWeb_PlyMix.__name__ = true;
kitGL_glWeb_PlyMix.prototype = {
	setProgramMode: function(modeNew) {
		if(this.mode == modeNew) {
			return false;
		} else {
			this.gl.bindBuffer(34962,null);
			switch(modeNew) {
			case 1:
				this.gl.useProgram(this.programColor);
				this.gl.bindBuffer(34962,this.bufColor);
				var gl = this.gl;
				var program = this.programColor;
				var rgbaName = this.vertexColor;
				var inp = gl.getAttribLocation(program,this.vertexPosition);
				var elementBytes = 4;
				var fp = 5126;
				var strideBytes = 7 * elementBytes;
				var offBytes = 0 * elementBytes;
				gl.vertexAttribPointer(inp,3,fp,false,strideBytes,offBytes);
				gl.enableVertexAttribArray(inp);
				var inp = gl.getAttribLocation(program,rgbaName);
				var elementBytes = 4;
				var fp = 5126;
				var strideBytes = 7 * elementBytes;
				var offBytes = 3 * elementBytes;
				gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
				gl.enableVertexAttribArray(inp);
				this.mode = 1;
				break;
			case 2:
				this.gl.useProgram(this.programTexture);
				this.gl.bindBuffer(34962,this.bufTexture);
				var gl = this.gl;
				var program = this.programTexture;
				var rgbaName = this.vertexColor;
				var uvName = this.vertexTexture;
				var inp = gl.getAttribLocation(program,this.vertexPosition);
				var elementBytes = 4;
				var fp = 5126;
				var strideBytes = 9 * elementBytes;
				var offBytes = 0 * elementBytes;
				gl.vertexAttribPointer(inp,3,fp,false,strideBytes,offBytes);
				gl.enableVertexAttribArray(inp);
				var inp = gl.getAttribLocation(program,rgbaName);
				var elementBytes = 4;
				var fp = 5126;
				var strideBytes = 9 * elementBytes;
				var offBytes = 3 * elementBytes;
				gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
				gl.enableVertexAttribArray(inp);
				var inp = gl.getAttribLocation(program,uvName);
				var elementBytes = 4;
				var fp = 5126;
				var strideBytes = 9 * elementBytes;
				var offBytes = 7 * elementBytes;
				gl.vertexAttribPointer(inp,2,fp,false,strideBytes,offBytes);
				gl.enableVertexAttribArray(inp);
				this.mode = 2;
				break;
			default:
				this.mode = 0;
			}
			return true;
		}
	}
	,setup: function() {
		haxe_Log.trace(" setup ",{ fileName : "kitGL/glWeb/PlyMix.js.hx", lineNumber : 104, className : "kitGL.glWeb.PlyMix", methodName : "setup"});
		var gl = this.gl;
		var program = gl.createProgram();
		var shader = gl.createShader(35633);
		gl.shaderSource(shader,"attribute vec3 vertexPosition;" + "attribute vec4 vertexColor;" + "attribute vec2 vertexTexture;" + "varying vec4 vcol;" + "varying vec2 vtexture;" + "uniform mat3 uvTransform;" + "void main(void) {" + " gl_Position = vec4( vertexPosition, 1.0);" + " vec3 texChange = uvTransform * vec3(vertexTexture, 1.0);" + " vtexture = vec2( texChange );" + " vcol = vertexColor;" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		var shader = gl.createShader(35632);
		gl.shaderSource(shader,"precision mediump float;" + "precision mediump int;" + "varying vec4 vcol;" + "varying vec2 vtexture;" + "uniform sampler2D uImage0;" + "uniform vec4 bgColor;" + "void main(void) {" + "if (vtexture.x < 0.0 || vtexture.y < 0.0 || vtexture.x > 1.0 || vtexture.y > 1.0) {" + " gl_FragColor = bgColor; " + "} else {" + "vec4 texcolor = texture2D( uImage0, vec2( vtexture.s, vtexture.t ) ).rgba * vcol;" + "texcolor.rgb *= vcol.a; " + "if( texcolor.a < 1. ){" + "texcolor = mix( bgColor, texcolor, texcolor.a ); " + "}" + "gl_FragColor = texcolor;" + "}" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		gl.linkProgram(program);
		var tmp;
		if(!gl.getProgramParameter(program,35714)) {
			throw haxe_Exception.thrown("Error linking program. " + gl.getProgramInfoLog(program));
		} else {
			gl.validateProgram(program);
			if(!gl.getProgramParameter(program,35715)) {
				throw haxe_Exception.thrown("Error validating program. " + gl.getProgramInfoLog(program));
			} else {
				gl.useProgram(program);
				tmp = program;
			}
		}
		this.programTexture = tmp;
		var gl = this.gl;
		var program = gl.createProgram();
		var shader = gl.createShader(35633);
		gl.shaderSource(shader,"attribute vec3 vertexPosition;" + "attribute vec4 vertexColor;" + "varying vec4 vcol;" + "void main(void) {" + " gl_Position = vec4(vertexPosition, 1.0);" + " vcol = vertexColor;" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		var shader = gl.createShader(35632);
		gl.shaderSource(shader,"precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + " gl_FragColor = vcol;" + "}");
		gl.compileShader(shader);
		var tmp;
		if(!gl.getShaderParameter(shader,35713)) {
			throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
		} else {
			tmp = shader;
		}
		gl.attachShader(program,tmp);
		gl.linkProgram(program);
		var tmp;
		if(!gl.getProgramParameter(program,35714)) {
			throw haxe_Exception.thrown("Error linking program. " + gl.getProgramInfoLog(program));
		} else {
			gl.validateProgram(program);
			if(!gl.getProgramParameter(program,35715)) {
				throw haxe_Exception.thrown("Error validating program. " + gl.getProgramInfoLog(program));
			} else {
				gl.useProgram(program);
				tmp = program;
			}
		}
		this.programColor = tmp;
		this.draw();
		var gl = this.gl;
		var image = this.img;
		var _2D = 3553;
		var texture = gl.createTexture();
		gl.bindTexture(_2D,texture);
		var pixel = new Uint8Array([255,255,255,255]);
		var _2D1 = 3553;
		gl.texImage2D(_2D1,0,6408,1,1,0,6408,5121,pixel);
		var midMap;
		var value = image.width;
		if((value & value - 1) == 0) {
			var value = image.height;
			midMap = (value & value - 1) == 0;
		} else {
			midMap = false;
		}
		if(!midMap) {
			var _2D1 = 3553;
			var linear = 9729;
			var mag = 10240;
			var min = 10241;
			gl.texParameteri(_2D1,mag,linear);
			gl.texParameteri(_2D1,min,linear);
			var _2D1 = 3553;
			var clamp = 33071;
			var _S = 10242;
			var _T = 10243;
			gl.texParameteri(_2D1,_S,clamp);
			gl.texParameteri(_2D1,_T,clamp);
		}
		gl.texImage2D(3553,0,6408,6408,5121,image);
		if(midMap) {
			gl.generateMipmap(_2D);
		}
		var _2D = 3553;
		gl.activeTexture(33984);
		gl.bindTexture(_2D,texture);
		this.tex = texture;
		var gl = this.gl;
		var program = this.programTexture;
		var data = this.dataGLtexture.get_data();
		var xyzName = this.vertexPosition;
		var rgbaName = this.vertexColor;
		var uvName = this.vertexTexture;
		var isDynamic = true;
		if(isDynamic == null) {
			isDynamic = false;
		}
		var isDynamic1 = isDynamic;
		if(isDynamic1 == null) {
			isDynamic1 = false;
		}
		var buf = gl.createBuffer();
		var staticDraw = 35044;
		var dynamicDraw = 35048;
		var arrayBuffer = 34962;
		gl.bindBuffer(arrayBuffer,buf);
		if(isDynamic1) {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,dynamicDraw);
		} else {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,staticDraw);
		}
		var vbo = buf;
		var inp = gl.getAttribLocation(program,xyzName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 9 * elementBytes;
		var offBytes = 0 * elementBytes;
		gl.vertexAttribPointer(inp,3,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		var inp = gl.getAttribLocation(program,rgbaName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 9 * elementBytes;
		var offBytes = 3 * elementBytes;
		gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		var inp = gl.getAttribLocation(program,uvName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 9 * elementBytes;
		var offBytes = 7 * elementBytes;
		gl.vertexAttribPointer(inp,2,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		this.bufTexture = vbo;
		var count = 0;
		var _g = 0;
		var _g1 = this.dataGLtexture.get_size();
		while(_g < _g1) {
			var i = _g++;
			this.indicesTexture.push(count++);
			this.indicesTexture.push(count++);
			this.indicesTexture.push(count++);
		}
		var gl = this.gl;
		var indices = this.indicesTexture;
		var indexBuffer = gl.createBuffer();
		var arrBuffer = 34963;
		gl.bindBuffer(arrBuffer,indexBuffer);
		gl.bufferData(arrBuffer,new Uint16Array(indices),35044);
		gl.bindBuffer(arrBuffer,null);
		var gl = this.gl;
		var program = this.programColor;
		var data = this.dataGLcolor.get_data();
		var xyzName = this.vertexPosition;
		var rgbaName = this.vertexColor;
		var isDynamic = true;
		if(isDynamic == null) {
			isDynamic = false;
		}
		var isDynamic1 = isDynamic;
		if(isDynamic1 == null) {
			isDynamic1 = false;
		}
		var buf = gl.createBuffer();
		var staticDraw = 35044;
		var dynamicDraw = 35048;
		var arrayBuffer = 34962;
		gl.bindBuffer(arrayBuffer,buf);
		if(isDynamic1) {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,dynamicDraw);
		} else {
			var arrayBuffer = 34962;
			gl.bufferData(arrayBuffer,data,staticDraw);
		}
		var vbo = buf;
		var inp = gl.getAttribLocation(program,xyzName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 7 * elementBytes;
		var offBytes = 0 * elementBytes;
		gl.vertexAttribPointer(inp,3,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		var inp = gl.getAttribLocation(program,rgbaName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 7 * elementBytes;
		var offBytes = 3 * elementBytes;
		gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		this.bufColor = vbo;
		var _gthis = this;
		if(kitGL_glWeb_AnimateTimer.s == null) {
			kitGL_glWeb_AnimateTimer.s = window.document.createElement("style");
			kitGL_glWeb_AnimateTimer.s.innerHTML = "@keyframes spin { from { transform:rotate( 0deg ); } to { transform:rotate( 360deg ); } }";
			window.document.getElementsByTagName("head")[0].appendChild(kitGL_glWeb_AnimateTimer.s);
			kitGL_glWeb_AnimateTimer.s.animation = "spin 1s linear infinite";
			kitGL_glWeb_AnimateTimer.loop(60.0);
		}
		kitGL_glWeb_AnimateTimer.onFrame = function(v) {
			var gl = _gthis.gl;
			var width = _gthis.width;
			var height = _gthis.height;
			gl.clearColor(0.5,0.0,0.5,0.9);
			gl.enable(2929);
			gl.clear(16384);
			gl.viewport(0,0,width,height);
			gl.enable(3042);
			gl.blendFunc(1,771);
			gl.enable(2929);
			_gthis.gl.bindBuffer(34962,_gthis.bufColor);
			_gthis.renderDraw();
		};
	}
	,draw: function() {
		haxe_Log.trace("parent draw",{ fileName : "kitGL/glWeb/PlyMix.js.hx", lineNumber : 149, className : "kitGL.glWeb.PlyMix", methodName : "draw"});
	}
	,drawTextureShape: function(start,end,bgColor) {
		var modeChange = this.setProgramMode(2);
		var gl = this.gl;
		var a = (bgColor >> 24 & 255) / 255;
		var r = (bgColor >> 16 & 255) / 255;
		var g = (bgColor >> 8 & 255) / 255;
		var b = (bgColor & 255) / 255;
		var argb_a = a;
		var argb_r = r;
		var argb_g = g;
		var argb_b = b;
		var colUniform = gl.getUniformLocation(this.programTexture,this.uniformColor);
		gl.uniform4f(colUniform,argb_r,argb_g,argb_b,argb_a);
		if(modeChange) {
			var gl = this.gl;
			var imgUniform = gl.getUniformLocation(this.programTexture,this.uniformImage);
			gl.uniform1i(imgUniform,0);
			gl.enable(2929);
			gl.enable(3042);
			gl.blendFunc(770,771);
			gl.depthMask(false);
			gl.disable(2884);
			var gl = this.gl;
			var val = this.transformUVArr;
			var uvTransform = gl.getUniformLocation(this.programTexture,this.uvTransform);
			if(val == null) {
				val = [1.,0.,0.,0.,1.,0.,0.,0.,1.];
			}
			gl.uniformMatrix3fv(uvTransform,false,val);
		}
		this.drawData(this.programTexture,this.dataGLtexture,start,end,27);
	}
	,drawColorShape: function(start,end) {
		this.setProgramMode(1);
		this.drawData(this.programColor,this.dataGLcolor,start,end,21);
	}
	,drawData: function(program,dataGL,start,end,len) {
		var partData = dataGL.get_data().subarray(start * len,end * len);
		this.gl.bufferSubData(34962,0,partData);
		this.gl.useProgram(program);
		this.gl.drawArrays(4,0,(end - start) * 3 | 0);
	}
	,renderDraw: function() {
	}
};
var TrilateralTextureBasic = function(width,height) {
	this.theta = 0.;
	this.scale = 2;
	this.penNoduleTexture = new trilateral3_nodule_PenPaint();
	this.penNoduleColor = new trilateral3_nodule_PenNodule();
	kitGL_glWeb_PlyMix.call(this,width,height);
	haxe_Log.trace("draw",{ fileName : "TrilateralTileSheetTexture.hx", lineNumber : 71, className : "TrilateralTextureBasic", methodName : "new"});
	this.imageLoader.loadEncoded(["data:image/png;base64,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"],["font1AlphaWhite"]);
};
TrilateralTextureBasic.__name__ = true;
TrilateralTextureBasic.__super__ = kitGL_glWeb_PlyMix;
TrilateralTextureBasic.prototype = $extend(kitGL_glWeb_PlyMix.prototype,{
	draw: function() {
		this.img = this.imageLoader.imageArr[0];
		var w = this.img.width;
		var h = this.img.height;
		this.dataGLcolor = { get_data : ($_=this.penNoduleColor,$bind($_,$_.get_data)), get_size : ($_=this.penNoduleColor,$bind($_,$_.get_size))};
		this.dataGLtexture = { get_data : ($_=this.penNoduleTexture,$bind($_,$_.get_data)), get_size : ($_=this.penNoduleTexture,$bind($_,$_.get_size))};
		this.penColor = this.penNoduleColor.pen;
		this.penColor.currentColor = -1;
		this.penTexture = this.penNoduleTexture.pen;
		this.penTexture.useTexture = true;
		this.penTexture.currentColor = -1;
		this.penTexture.currentColor = -16777216;
		var start = this.penTexture.paintType.get_pos();
		var sketch = new trilateral3_drawing_Sketch(this.penTexture,4,0);
		sketch.width = 8;
		this.penTexture.z2D = -0.1;
		var posMin = this.penTexture.paintType.get_pos();
		var inputStr = "The quick brown fox jumps over the lazy dog";
		var img = this.img;
		var noW = 10;
		var noH = 10;
		var dw = img.width * 2 / 11 / this.scale;
		var dh = img.height * 2 / 11 / this.scale;
		var _g = 0;
		var _g1 = inputStr.length;
		while(_g < _g1) {
			var charNo = _g++;
			var charCode = HxOverrides.cca(inputStr,charNo);
			var id = charCode - 97 + 65;
			var row = Math.floor(id / noW);
			var col = id - row * noH;
			var dx = col * dw - 6;
			var dy = row * dw - 6;
			var A_x = dx;
			var A_y = dy;
			var B_x = dx + dw;
			var B_y = dy;
			var C_x = dx + dw;
			var C_y = dy + dh - 4;
			var D_x = dx;
			var D_y = dy + dh - 4;
			var _this = this.penTexture;
			var color = -1;
			if(color == -1) {
				color = _this.currentColor;
			}
			var ax = A_x;
			var ay = A_y;
			var bx = B_x;
			var by = B_y;
			var cx = D_x;
			var cy = D_y;
			var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this.paintType.cornerColors(color,color,color);
			_this.paintType.next();
			var _this1 = this.penTexture;
			var color1 = -1;
			if(color1 == -1) {
				color1 = _this1.currentColor;
			}
			var ax1 = B_x;
			var ay1 = B_y;
			var bx1 = C_x;
			var by1 = C_y;
			var cx1 = D_x;
			var cy1 = D_y;
			var windAdjust1 = _this1.paintType.triangle(ax1,ay1,_this1.z2D,bx1,by1,_this1.z2D,cx1,cy1,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax1 /= 2000;
				ay1 /= 2000;
				bx1 /= 2000;
				by1 /= 2000;
				cx1 /= 2000;
				cy1 /= 2000;
				_this1.paintType.triangleUV(ax1,ay1,bx1,by1,cx1,cy1,windAdjust1);
			}
			_this1.paintType.cornerColors(color1,color1,color1);
			_this1.paintType.next();
		}
		var ii_min = posMin;
		var ii_max = (this.penTexture.paintType.get_pos() | 0) - 1;
		var this1 = new trilateral3_shape_IntIterStart(ii_min,ii_max);
		this.allRange = this1;
		var count = 0;
		var val;
		var curr = this.penTexture.paintType.triangleCurrent;
		var letterSpace = 40 / this.scale;
		var this1 = this.allRange;
		var _g_min = this1.start;
		var _g_max = this1.max;
		while(_g_min < _g_max) {
			var i = _g_min++;
			count = Math.floor(i / 2);
			this.penTexture.paintType.set_pos(i);
			val = 100 + letterSpace * count;
			curr.set_x((val - 1000) / 1000);
			val = 500;
			curr.set_y(-(val - 1000) / 1000);
		}
		this.transformUVArr = [this.scale * 2.,0.,0.,0.,this.scale * 2.,0.,0.,0.,1.];
	}
	,renderDraw: function() {
		haxe_Log.trace("renderDraw",{ fileName : "TrilateralTileSheetTexture.hx", lineNumber : 152, className : "TrilateralTextureBasic", methodName : "renderDraw"});
		var curr = this.penTexture.paintType.triangleCurrent;
		var val = 0.;
		var thetaStart = this.theta;
		var this1 = this.allRange;
		var _g_min = this1.start;
		var _g_max = this1.max;
		while(_g_min < _g_max) {
			var i = _g_min++;
			this.penTexture.paintType.set_pos(i);
			val = 500 + 20 * Math.sin(this.theta);
			curr.set_y(-(val - 1000) / 1000);
			this.theta += Math.PI / 10;
		}
		this.theta = thetaStart + Math.PI / 10;
		this.drawTextureShape(this.allRange.start,this.allRange.max,0);
		this.tempHackFix();
	}
	,tempHackFix: function() {
		this.drawColorShape(0,0);
	}
});
function TrilateralTileSheetTexture_main() {
	new TrilateralTextureBasic(1000,1000);
	var divertTrace = new kitGL_glWeb_DivertTrace();
}
var dsHelper_flat_io_Float32Flat = {};
dsHelper_flat_io_Float32Flat.get_size = function(this1) {
	return this1[1] | 0;
};
dsHelper_flat_io_Float32Flat.set_size = function(this1,id) {
	var pos_ = id;
	this1[0] = pos_;
	if(this1[0] > this1[1] - 1) {
		this1[1] = this1[0];
	}
	return id;
};
var dsHelper_flat_io_Float32FlatDepth = {};
dsHelper_flat_io_Float32FlatDepth.rangeToEnd = function(this1,starting,totalLen,section) {
	var ending = starting + totalLen;
	var temp = [];
	var count = 0;
	var _g = starting;
	var _g1 = ending;
	while(_g < _g1) {
		var i = _g++;
		temp[count++] = this1[i + 2];
	}
	var left = section * dsHelper_flat_io_Float32Flat.get_size(this1) - ending;
	var _g = 0;
	var _g1 = left;
	while(_g < _g1) {
		var i = _g++;
		var v = this1[ending + i + 2];
		this1[starting + i + 2] = v;
	}
	var last = section * dsHelper_flat_io_Float32Flat.get_size(this1);
	var reserveTop = last - totalLen;
	count = 0;
	var _g = reserveTop;
	var _g1 = last;
	while(_g < _g1) {
		var i = _g++;
		var v = temp[count++];
		this1[i + 2] = v;
	}
	temp = null;
	return true;
};
var dsHelper_flatInterleave_FloatColorTriangles = {};
dsHelper_flatInterleave_FloatColorTriangles.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 21 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 21 + 1 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 1 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_az = function(this1) {
	return this1[(this1[0] | 0) * 21 + 2 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_az = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 2 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_redA = function(this1) {
	return this1[(this1[0] | 0) * 21 + 3 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_redA = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 3 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 21 + 7 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 7 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_by = function(this1) {
	return this1[(this1[0] | 0) * 21 + 8 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 8 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_bz = function(this1) {
	return this1[(this1[0] | 0) * 21 + 9 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_bz = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 9 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_redB = function(this1) {
	return this1[(this1[0] | 0) * 21 + 10 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_redB = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 10 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 21 + 14 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 14 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 21 + 15 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 15 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_cz = function(this1) {
	return this1[(this1[0] | 0) * 21 + 16 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_cz = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 16 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.get_redC = function(this1) {
	return this1[(this1[0] | 0) * 21 + 17 + 2];
};
dsHelper_flatInterleave_FloatColorTriangles.set_redC = function(this1,v) {
	this1[(this1[0] | 0) * 21 + 17 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTriangles.triangle = function(this1,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
	dsHelper_flatInterleave_FloatColorTriangles.set_ax(this1,ax_);
	dsHelper_flatInterleave_FloatColorTriangles.set_ay(this1,ay_);
	dsHelper_flatInterleave_FloatColorTriangles.set_az(this1,az_);
	dsHelper_flatInterleave_FloatColorTriangles.set_bx(this1,bx_);
	dsHelper_flatInterleave_FloatColorTriangles.set_by(this1,by_);
	dsHelper_flatInterleave_FloatColorTriangles.set_bz(this1,bz_);
	dsHelper_flatInterleave_FloatColorTriangles.set_cx(this1,cx_);
	dsHelper_flatInterleave_FloatColorTriangles.set_cy(this1,cy_);
	dsHelper_flatInterleave_FloatColorTriangles.set_cz(this1,cz_);
	var windingAdjusted = dsHelper_flatInterleave_FloatColorTriangles.adjustWinding(this1);
	if(windingAdjusted) {
		dsHelper_flatInterleave_FloatColorTriangles.set_ax(this1,ax_);
		dsHelper_flatInterleave_FloatColorTriangles.set_ay(this1,ay_);
		dsHelper_flatInterleave_FloatColorTriangles.set_bx(this1,cx_);
		dsHelper_flatInterleave_FloatColorTriangles.set_by(this1,cy_);
		dsHelper_flatInterleave_FloatColorTriangles.set_cx(this1,bx_);
		dsHelper_flatInterleave_FloatColorTriangles.set_cy(this1,by_);
	}
	return windingAdjusted;
};
dsHelper_flatInterleave_FloatColorTriangles.adjustWinding = function(this1) {
	return dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1) * dsHelper_flatInterleave_FloatColorTriangles.get_by(this1) - dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1) * dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1) + (dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1) * dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1) - dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1) * dsHelper_flatInterleave_FloatColorTriangles.get_by(this1)) + (dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1) * dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1) - dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1) * dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1)) > 0;
};
dsHelper_flatInterleave_FloatColorTriangles.moveDelta = function(this1,dx,dy) {
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTriangles.set_ax(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ax(_g) + dx);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTriangles.set_ay(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ay(_g) + dy);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTriangles.set_bx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_bx(_g) + dx);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTriangles.set_by(_g,dsHelper_flatInterleave_FloatColorTriangles.get_by(_g) + dy);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTriangles.set_cx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cx(_g) + dx);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTriangles.set_cy(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cy(_g) + dy);
};
dsHelper_flatInterleave_FloatColorTriangles.fullHit = function(this1,px,py) {
	if(px > Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1),dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1)),dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1)) && px < Math.max(Math.max(dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1),dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1)),dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1)) && py > Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1),dsHelper_flatInterleave_FloatColorTriangles.get_by(this1)),dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1)) && py < Math.max(Math.max(dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1),dsHelper_flatInterleave_FloatColorTriangles.get_by(this1)),dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1))) {
		return true;
	}
	var planeAB = (dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_by(this1) - py) - (dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1) - py);
	var planeBC = (dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1) - py) - (dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_by(this1) - py);
	var planeCA = (dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1) - py) - (dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1) - py);
	if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
		return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
	} else {
		return false;
	}
};
var dsHelper_flatInterleave_FloatColorTrianglesUV = {};
dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 27 + 2];
};
dsHelper_flatInterleave_FloatColorTrianglesUV.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 27 + 1 + 2];
};
dsHelper_flatInterleave_FloatColorTrianglesUV.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 1 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.get_az = function(this1) {
	return this1[(this1[0] | 0) * 27 + 2 + 2];
};
dsHelper_flatInterleave_FloatColorTrianglesUV.set_az = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 2 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.get_redA = function(this1) {
	return this1[(this1[0] | 0) * 27 + 3 + 2];
};
dsHelper_flatInterleave_FloatColorTrianglesUV.set_redA = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 3 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 27 + 9 + 2];
};
dsHelper_flatInterleave_FloatColorTrianglesUV.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 9 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.get_by = function(this1) {
	return this1[(this1[0] | 0) * 27 + 10 + 2];
};
dsHelper_flatInterleave_FloatColorTrianglesUV.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 10 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.get_bz = function(this1) {
	return this1[(this1[0] | 0) * 27 + 11 + 2];
};
dsHelper_flatInterleave_FloatColorTrianglesUV.set_bz = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 11 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.get_redB = function(this1) {
	return this1[(this1[0] | 0) * 27 + 12 + 2];
};
dsHelper_flatInterleave_FloatColorTrianglesUV.set_redB = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 12 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 27 + 18 + 2];
};
dsHelper_flatInterleave_FloatColorTrianglesUV.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 18 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 27 + 19 + 2];
};
dsHelper_flatInterleave_FloatColorTrianglesUV.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 19 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.get_cz = function(this1) {
	return this1[(this1[0] | 0) * 27 + 20 + 2];
};
dsHelper_flatInterleave_FloatColorTrianglesUV.set_cz = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 20 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.get_redC = function(this1) {
	return this1[(this1[0] | 0) * 27 + 21 + 2];
};
dsHelper_flatInterleave_FloatColorTrianglesUV.set_redC = function(this1,v) {
	this1[(this1[0] | 0) * 27 + 21 + 2] = v;
	return v;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.triangle = function(this1,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_ax(this1,ax_);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_ay(this1,ay_);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_az(this1,az_);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_bx(this1,bx_);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_by(this1,by_);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_bz(this1,bz_);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_cx(this1,cx_);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_cy(this1,cy_);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_cz(this1,cz_);
	var windingAdjusted = dsHelper_flatInterleave_FloatColorTrianglesUV.adjustWinding(this1);
	if(windingAdjusted) {
		dsHelper_flatInterleave_FloatColorTrianglesUV.set_bx(this1,cx_);
		dsHelper_flatInterleave_FloatColorTrianglesUV.set_by(this1,cy_);
		dsHelper_flatInterleave_FloatColorTrianglesUV.set_cx(this1,bx_);
		dsHelper_flatInterleave_FloatColorTrianglesUV.set_cy(this1,by_);
	}
	return windingAdjusted;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.triangleUV = function(this1,uA_,vA_,uB_,vB_,uC_,vC_,windAdjust_) {
	var windAdjust = windAdjust_ == null ? dsHelper_flatInterleave_FloatColorTrianglesUV.adjustWinding(this1) : windAdjust_;
	this1[(this1[0] | 0) * 27 + 7 + 2] = uA_;
	this1[(this1[0] | 0) * 27 + 8 + 2] = vA_;
	if(windAdjust) {
		this1[(this1[0] | 0) * 27 + 16 + 2] = uC_;
		this1[(this1[0] | 0) * 27 + 17 + 2] = vC_;
		this1[(this1[0] | 0) * 27 + 25 + 2] = uB_;
		this1[(this1[0] | 0) * 27 + 26 + 2] = vB_;
	} else {
		this1[(this1[0] | 0) * 27 + 16 + 2] = uB_;
		this1[(this1[0] | 0) * 27 + 17 + 2] = vB_;
		this1[(this1[0] | 0) * 27 + 25 + 2] = uC_;
		this1[(this1[0] | 0) * 27 + 26 + 2] = vC_;
	}
	return windAdjust;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.adjustWinding = function(this1) {
	return dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(this1) * dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(this1) - dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(this1) * dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(this1) + (dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(this1) * dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(this1) - dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(this1) * dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(this1)) + (dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(this1) * dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(this1) - dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(this1) * dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(this1)) > 0;
};
dsHelper_flatInterleave_FloatColorTrianglesUV.moveDelta = function(this1,dx,dy) {
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_ax(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_g) + dx);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_ay(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_g) + dy);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_bx(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_g) + dx);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_by(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_g) + dy);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_cx(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_g) + dx);
	var _g = this1;
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_cy(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_g) + dy);
};
dsHelper_flatInterleave_FloatColorTrianglesUV.fullHit = function(this1,px,py) {
	if(px > Math.min(Math.min(dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(this1),dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(this1)),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(this1)) && px < Math.max(Math.max(dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(this1),dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(this1)),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(this1)) && py > Math.min(Math.min(dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(this1),dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(this1)),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(this1)) && py < Math.max(Math.max(dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(this1),dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(this1)),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(this1))) {
		return true;
	}
	var planeAB = (dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(this1) - px) * (dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(this1) - py) - (dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(this1) - px) * (dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(this1) - py);
	var planeBC = (dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(this1) - px) * (dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(this1) - py) - (dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(this1) - px) * (dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(this1) - py);
	var planeCA = (dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(this1) - px) * (dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(this1) - py) - (dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(this1) - px) * (dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(this1) - py);
	if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
		return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
	} else {
		return false;
	}
};
dsHelper_flatInterleave_FloatColorTrianglesUV.moveDeltaUV = function(this1,du,dv) {
	var _g = this1;
	var v = _g[(_g[0] | 0) * 27 + 7 + 2] + du;
	_g[(_g[0] | 0) * 27 + 7 + 2] = v;
	var _g = this1;
	var v = _g[(_g[0] | 0) * 27 + 8 + 2] + dv;
	_g[(_g[0] | 0) * 27 + 8 + 2] = v;
	var _g = this1;
	var v = _g[(_g[0] | 0) * 27 + 16 + 2] + du;
	_g[(_g[0] | 0) * 27 + 16 + 2] = v;
	var _g = this1;
	var v = _g[(_g[0] | 0) * 27 + 17 + 2] + dv;
	_g[(_g[0] | 0) * 27 + 17 + 2] = v;
	var _g = this1;
	var v = _g[(_g[0] | 0) * 27 + 25 + 2] + du;
	_g[(_g[0] | 0) * 27 + 25 + 2] = v;
	var _g = this1;
	var v = _g[(_g[0] | 0) * 27 + 26 + 2] + dv;
	_g[(_g[0] | 0) * 27 + 26 + 2] = v;
};
var fracs_DifferencePreference = $hxEnums["fracs.DifferencePreference"] = { __ename__:"fracs.DifferencePreference",__constructs__:null
	,CLOCKWISE: {_hx_name:"CLOCKWISE",_hx_index:0,__enum__:"fracs.DifferencePreference",toString:$estr}
	,ANTICLOCKWISE: {_hx_name:"ANTICLOCKWISE",_hx_index:1,__enum__:"fracs.DifferencePreference",toString:$estr}
	,SMALL: {_hx_name:"SMALL",_hx_index:2,__enum__:"fracs.DifferencePreference",toString:$estr}
	,LARGE: {_hx_name:"LARGE",_hx_index:3,__enum__:"fracs.DifferencePreference",toString:$estr}
};
fracs_DifferencePreference.__constructs__ = [fracs_DifferencePreference.CLOCKWISE,fracs_DifferencePreference.ANTICLOCKWISE,fracs_DifferencePreference.SMALL,fracs_DifferencePreference.LARGE];
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	get_native: function() {
		return this.__nativeException;
	}
});
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
});
var haxe_ds_Either = $hxEnums["haxe.ds.Either"] = { __ename__:"haxe.ds.Either",__constructs__:null
	,Left: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Left",$_.__params__ = ["v"],$_)
	,Right: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Right",$_.__params__ = ["v"],$_)
};
haxe_ds_Either.__constructs__ = [haxe_ds_Either.Left,haxe_ds_Either.Right];
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = true;
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var hxGeomAlgo_HomogCoord = function(x,y,w) {
	if(w == null) {
		w = 1;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.w = w;
};
hxGeomAlgo_HomogCoord.__name__ = true;
var hxGeomAlgo_HxPointData = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
hxGeomAlgo_HxPointData.__name__ = true;
var hxGeomAlgo_HxPoint = $hx_exports["hxGeomAlgo"]["HxPoint"] = {};
hxGeomAlgo_HxPoint.get_x = function(this1) {
	return this1.x;
};
hxGeomAlgo_HxPoint.set_x = function(this1,value) {
	return this1.x = value;
};
hxGeomAlgo_HxPoint.get_y = function(this1) {
	return this1.y;
};
hxGeomAlgo_HxPoint.set_y = function(this1,value) {
	return this1.y = value;
};
hxGeomAlgo_HxPoint._new = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var this1 = new hxGeomAlgo_HxPointData(x,y);
	return this1;
};
hxGeomAlgo_HxPoint.setTo = function(this1,newX,newY) {
	this1.x = newX;
	this1.y = newY;
};
hxGeomAlgo_HxPoint.equals = function(this1,p) {
	if(p != null && this1.x == p.x) {
		return this1.y == p.y;
	} else {
		return false;
	}
};
hxGeomAlgo_HxPoint.clone = function(this1) {
	return hxGeomAlgo_HxPoint._new(this1.x,this1.y);
};
hxGeomAlgo_HxPoint.toString = function(this1) {
	return "(" + this1.x + ", " + this1.y + ")";
};
hxGeomAlgo_HxPoint.fromPointStruct = function(p) {
	return hxGeomAlgo_HxPoint._new(p.x,p.y);
};
hxGeomAlgo_HxPoint.toPointStruct = function(this1) {
	return { x : this1.x, y : this1.y};
};
var hxGeomAlgo_PolyTools = $hx_exports["hxGeomAlgo"]["PolyTools"] = function() { };
hxGeomAlgo_PolyTools.__name__ = true;
hxGeomAlgo_PolyTools.isCCW = function(poly) {
	if(poly.length <= 2) {
		return true;
	}
	var signedArea = 0.;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		var idx = i - 1;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		var idx2 = i - 1;
		var idx3 = idx2;
		var len1 = poly.length;
		if(idx3 < 0) {
			idx3 += len1;
		}
		idx2 = idx3 % len1;
		signedArea += poly[idx].x * poly[i].y - poly[i].x * poly[idx2].y;
	}
	return signedArea < 0;
};
hxGeomAlgo_PolyTools.isCW = function(poly) {
	if(poly.length <= 2) {
		return true;
	}
	var signedArea = 0.;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		var idx = i - 1;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		var idx2 = i - 1;
		var idx3 = idx2;
		var len1 = poly.length;
		if(idx3 < 0) {
			idx3 += len1;
		}
		idx2 = idx3 % len1;
		signedArea += poly[idx].x * poly[i].y - poly[i].x * poly[idx2].y;
	}
	return signedArea > 0;
};
hxGeomAlgo_PolyTools.makeCCW = function(poly) {
	var reversed = false;
	if(!hxGeomAlgo_PolyTools.isCCW(poly)) {
		poly.reverse();
		reversed = true;
	}
	return reversed;
};
hxGeomAlgo_PolyTools.makeCW = function(poly) {
	var reversed = false;
	if(hxGeomAlgo_PolyTools.isCCW(poly)) {
		poly.reverse();
		reversed = true;
	}
	return reversed;
};
hxGeomAlgo_PolyTools.isConvex = function(poly) {
	var isPositive = null;
	var _g = 0;
	var _g1 = poly.length;
	while(_g < _g1) {
		var i = _g++;
		var lower = i == 0 ? poly.length - 1 : i - 1;
		var middle = i;
		var upper = i == poly.length - 1 ? 0 : i + 1;
		var dx0 = poly[middle].x - poly[lower].x;
		var dy0 = poly[middle].y - poly[lower].y;
		var dx1 = poly[upper].x - poly[middle].x;
		var dy1 = poly[upper].y - poly[middle].y;
		var cross = dx0 * dy1 - dx1 * dy0;
		var newIsPositive = cross > 0;
		if(cross == 0) {
			continue;
		}
		if(isPositive == null) {
			isPositive = newIsPositive;
		} else if(isPositive != newIsPositive) {
			return false;
		}
	}
	return true;
};
hxGeomAlgo_PolyTools.isSimple = function(poly) {
	var len = poly.length;
	if(len <= 3) {
		return true;
	}
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		var p0 = i;
		var p1 = i == len - 1 ? 0 : i + 1;
		var _g2 = i + 1;
		var _g3 = len;
		while(_g2 < _g3) {
			var j = _g2++;
			var q0 = j;
			var q1 = j == len - 1 ? 0 : j + 1;
			var intersection = hxGeomAlgo_PolyTools.segmentIntersect(poly[p0],poly[p1],poly[q0],poly[q1]);
			var tmp;
			var tmp1;
			if(intersection != null) {
				var tmp2;
				var w = poly[p0];
				var x = intersection.x - w.x;
				var x1 = intersection.y - w.y;
				if(!(Math.sqrt(x * x + x1 * x1) < hxGeomAlgo_PolyTools.EPSILON)) {
					var w1 = poly[p1];
					var x2 = intersection.x - w1.x;
					var x3 = intersection.y - w1.y;
					tmp2 = Math.sqrt(x2 * x2 + x3 * x3) < hxGeomAlgo_PolyTools.EPSILON;
				} else {
					tmp2 = true;
				}
				tmp1 = !tmp2;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var tmp3;
				var w2 = poly[q0];
				var x4 = intersection.x - w2.x;
				var x5 = intersection.y - w2.y;
				if(!(Math.sqrt(x4 * x4 + x5 * x5) < hxGeomAlgo_PolyTools.EPSILON)) {
					var w3 = poly[q1];
					var x6 = intersection.x - w3.x;
					var x7 = intersection.y - w3.y;
					tmp3 = Math.sqrt(x6 * x6 + x7 * x7) < hxGeomAlgo_PolyTools.EPSILON;
				} else {
					tmp3 = true;
				}
				tmp = !tmp3;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
		}
	}
	return true;
};
hxGeomAlgo_PolyTools.segmentIntersect = function(p0,p1,q0,q1) {
	var a1 = p1.y - p0.y;
	var b1 = p0.x - p1.x;
	var c1 = p1.x * p0.y - p0.x * p1.y;
	var a2 = q1.y - q0.y;
	var b2 = q0.x - q1.x;
	var c2 = q1.x * q0.y - q0.x * q1.y;
	var denom = a1 * b2 - a2 * b1;
	if(denom == 0) {
		return null;
	}
	var intersectionPoint = hxGeomAlgo_HxPoint._new();
	intersectionPoint.x = (b1 * c2 - b2 * c1) / denom;
	intersectionPoint.y = (a2 * c1 - a1 * c2) / denom;
	var x = p0.x - p1.x;
	var x1 = p0.y - p1.y;
	var p0p1 = x * x + x1 * x1;
	var x = q0.x - q1.x;
	var x1 = q0.y - q1.y;
	var q0q1 = x * x + x1 * x1;
	var x = intersectionPoint.x - p1.x;
	var x1 = intersectionPoint.y - p1.y;
	if(x * x + x1 * x1 > p0p1) {
		return null;
	}
	var x = intersectionPoint.x - p0.x;
	var x1 = intersectionPoint.y - p0.y;
	if(x * x + x1 * x1 > p0p1) {
		return null;
	}
	var x = intersectionPoint.x - q1.x;
	var x1 = intersectionPoint.y - q1.y;
	if(x * x + x1 * x1 > q0q1) {
		return null;
	}
	var x = intersectionPoint.x - q0.x;
	var x1 = intersectionPoint.y - q0.y;
	if(x * x + x1 * x1 > q0q1) {
		return null;
	}
	return intersectionPoint;
};
hxGeomAlgo_PolyTools.findDuplicatePoints = function(poly,consecutiveOnly,wrapAround) {
	if(wrapAround == null) {
		wrapAround = true;
	}
	if(consecutiveOnly == null) {
		consecutiveOnly = true;
	}
	var len = poly.length;
	if(len <= 1) {
		return [];
	}
	var dupIndices = [];
	var _g = 0;
	var _g1 = len - 1;
	while(_g < _g1) {
		var i = _g++;
		var j = i + 1;
		while(j < len) {
			var this1 = poly[i];
			var p = poly[j];
			var foundDup = p != null && this1.x == p.x && this1.y == p.y;
			if(foundDup) {
				dupIndices.push(i);
			}
			if(consecutiveOnly || foundDup && !consecutiveOnly) {
				break;
			}
			++j;
		}
	}
	var tmp;
	if(wrapAround && consecutiveOnly) {
		var this1 = poly[0];
		var p = poly[len - 1];
		tmp = p != null && this1.x == p.x && this1.y == p.y;
	} else {
		tmp = false;
	}
	if(tmp) {
		dupIndices.push(len - 1);
	}
	return dupIndices;
};
hxGeomAlgo_PolyTools.intersection = function(p1,p2,q1,q2) {
	var res = null;
	var a1 = p2.y - p1.y;
	var b1 = p1.x - p2.x;
	var c1 = a1 * p1.x + b1 * p1.y;
	var a2 = q2.y - q1.y;
	var b2 = q1.x - q2.x;
	var c2 = a2 * q1.x + b2 * q1.y;
	var det = a1 * b2 - a2 * b1;
	if(!(Math.abs(det) <= hxGeomAlgo_PolyTools.EPSILON)) {
		res = hxGeomAlgo_HxPoint._new();
		res.x = (b2 * c1 - b1 * c2) / det;
		res.y = (a1 * c2 - a2 * c1) / det;
	}
	return res;
};
hxGeomAlgo_PolyTools.isReflex = function(poly,idx) {
	var idx1 = idx - 1;
	var idx2 = idx1;
	var len = poly.length;
	if(idx2 < 0) {
		idx2 += len;
	}
	idx1 = idx2 % len;
	var p = poly[idx1];
	var idx1 = idx;
	var idx2 = idx1;
	var len = poly.length;
	if(idx2 < 0) {
		idx2 += len;
	}
	idx1 = idx2 % len;
	var a = poly[idx1];
	var idx1 = idx + 1;
	var idx = idx1;
	var len = poly.length;
	if(idx < 0) {
		idx += len;
	}
	idx1 = idx % len;
	var b = poly[idx1];
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0;
};
hxGeomAlgo_PolyTools.at = function(poly,idx) {
	var idx1 = idx;
	var len = poly.length;
	if(idx1 < 0) {
		idx1 += len;
	}
	idx = idx1 % len;
	return poly[idx];
};
hxGeomAlgo_PolyTools.wrappedIdx = function(poly,idx) {
	var len = poly.length;
	if(idx < 0) {
		idx += len;
	}
	return idx % len;
};
hxGeomAlgo_PolyTools.side = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y);
};
hxGeomAlgo_PolyTools.isLeft = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) > 0;
};
hxGeomAlgo_PolyTools.isLeftOrOn = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) >= 0;
};
hxGeomAlgo_PolyTools.isRight = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0;
};
hxGeomAlgo_PolyTools.isRightOrOn = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) <= 0;
};
hxGeomAlgo_PolyTools.isCollinear = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) == 0;
};
hxGeomAlgo_PolyTools.distance = function(v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	return Math.sqrt(x * x + x1 * x1);
};
hxGeomAlgo_PolyTools.distanceToSegment = function(p,v,w) {
	return Math.sqrt(hxGeomAlgo_PolyTools.distanceToSegmentSquared(p,v,w));
};
hxGeomAlgo_PolyTools.distanceSquared = function(v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	return x * x + x1 * x1;
};
hxGeomAlgo_PolyTools.distanceToSegmentSquared = function(p,v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	var l2 = x * x + x1 * x1;
	if(l2 == 0) {
		var x = p.x - v.x;
		var x1 = p.y - v.y;
		return x * x + x1 * x1;
	}
	var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
	if(t < 0) {
		var x = p.x - v.x;
		var x1 = p.y - v.y;
		return x * x + x1 * x1;
	}
	if(t > 1) {
		var x = p.x - w.x;
		var x1 = p.y - w.y;
		return x * x + x1 * x1;
	}
	hxGeomAlgo_HxPoint.setTo(hxGeomAlgo_PolyTools.point,v.x + t * (w.x - v.x),v.y + t * (w.y - v.y));
	var w = hxGeomAlgo_PolyTools.point;
	var x = p.x - w.x;
	var x1 = p.y - w.y;
	return x * x + x1 * x1;
};
hxGeomAlgo_PolyTools.getCentroid = function(poly) {
	var c = hxGeomAlgo_HxPoint._new();
	var area = hxGeomAlgo_PolyTools.getArea(poly);
	if(area != 0) {
		var len = poly.length;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			var p0 = poly[i];
			var p1 = poly[(i + 1) % len];
			var m = p0.x * p1.y - p1.x * p0.y;
			c.x += (p0.x + p1.x) * m;
			c.y += (p0.y + p1.y) * m;
		}
		c.x /= 6 * area;
		c.y /= 6 * area;
	} else {
		c = hxGeomAlgo_HxPoint.EMPTY;
	}
	return c;
};
hxGeomAlgo_PolyTools.getArea = function(poly) {
	var area = 0.0;
	var len = poly.length;
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		var p0 = poly[i];
		var p1 = poly[(i + 1) % len];
		area += p0.x * p1.y - p1.x * p0.y;
	}
	area = .5 * area;
	return area;
};
hxGeomAlgo_PolyTools.meet = function(p,q) {
	return new hxGeomAlgo_HomogCoord(p.y - q.y,q.x - p.x,p.x * q.y - p.y * q.x);
};
hxGeomAlgo_PolyTools.dot = function(p,q) {
	return p.x * q.x + p.y * q.y;
};
hxGeomAlgo_PolyTools.sqr = function(x) {
	return x * x;
};
hxGeomAlgo_PolyTools.eq = function(a,b) {
	return Math.abs(a - b) <= hxGeomAlgo_PolyTools.EPSILON;
};
hxGeomAlgo_PolyTools.clear = function(array) {
	array.length = 0;
};
hxGeomAlgo_PolyTools.toFloatArray = function(poly,out) {
	if(out == null) {
		out = [];
	}
	var _g = 0;
	while(_g < poly.length) {
		var p = poly[_g];
		++_g;
		out.push(p.x);
		out.push(p.y);
	}
	return out;
};
hxGeomAlgo_PolyTools.reverseFloatArray = function(poly,inPlace) {
	if(inPlace == null) {
		inPlace = false;
	}
	var res = inPlace ? poly : [];
	var nPoints = poly.length >> 1;
	var _g = 0;
	var _g1 = nPoints;
	while(_g < _g1) {
		var i = _g++;
		var xPos = (nPoints - i - 1) * 2;
		res[i * 2] = poly[xPos];
		res[i * 2 + 1] = poly[xPos + 1];
	}
	return res;
};
hxGeomAlgo_PolyTools.flatten = function(array,out) {
	var res = out != null ? out : [];
	var _g = 0;
	while(_g < array.length) {
		var arr = array[_g];
		++_g;
		var _g1 = 0;
		while(_g1 < arr.length) {
			var item = arr[_g1];
			++_g1;
			res.push(item);
		}
	}
	return res;
};
hxGeomAlgo_PolyTools.toPointArray = function(poly,out) {
	if(out == null) {
		out = [];
	}
	var size = poly.length;
	if(poly.length % 2 == 1) {
		--size;
	}
	var _g = 0;
	var _g1 = size >> 1;
	while(_g < _g1) {
		var i = _g++;
		out.push(hxGeomAlgo_HxPoint._new(poly[i * 2],poly[i * 2 + 1]));
	}
	return out;
};
hxGeomAlgo_PolyTools.inflateLine = function(start,end,thickness) {
	var halfWidth = thickness / 2;
	var dx = end.x - start.x;
	var dy = end.y - start.y;
	var len = Math.sqrt(dx * dx + dy * dy);
	var nx = dx / len * halfWidth;
	var ny = dy / len * halfWidth;
	return [hxGeomAlgo_HxPoint._new(start.x - ny,start.y + nx),hxGeomAlgo_HxPoint._new(end.x - ny,end.y + nx),hxGeomAlgo_HxPoint._new(end.x + ny,end.y - nx),hxGeomAlgo_HxPoint._new(start.x + ny,start.y - nx)];
};
hxGeomAlgo_PolyTools.clip = function(subjPoly,clipPoly) {
	var cond = clipPoly.length >= 3 && hxGeomAlgo_PolyTools.isConvex(clipPoly);
	var res = [];
	var output = subjPoly;
	var isInside = hxGeomAlgo_PolyTools.isCCW(clipPoly) ? hxGeomAlgo_PolyTools.isRight : hxGeomAlgo_PolyTools.isLeft;
	var clipEdgeStart;
	var clipEdgeEnd;
	var inputEdgeStart;
	var inputEdgeEnd;
	var clipLen = clipPoly.length;
	var i = 0;
	var _g = 0;
	var _g1 = clipLen;
	while(_g < _g1) {
		var i = _g++;
		clipEdgeStart = clipPoly[i];
		var idx = i + 1;
		var len = clipPoly.length;
		if(idx < 0) {
			idx += len;
		}
		clipEdgeEnd = clipPoly[idx % len];
		var input = output;
		output = [];
		inputEdgeStart = input[input.length - 1];
		var _g2 = 0;
		var _g3 = input.length;
		while(_g2 < _g3) {
			var j = _g2++;
			inputEdgeEnd = input[j];
			if(isInside(inputEdgeEnd,clipEdgeStart,clipEdgeEnd)) {
				if(!isInside(inputEdgeStart,clipEdgeStart,clipEdgeEnd)) {
					var intersectionPoint = hxGeomAlgo_PolyTools.intersection(inputEdgeStart,inputEdgeEnd,clipEdgeStart,clipEdgeEnd);
					if(intersectionPoint != null) {
						output.push(intersectionPoint);
					}
				}
				output.push(inputEdgeEnd);
			} else if(isInside(inputEdgeStart,clipEdgeStart,clipEdgeEnd)) {
				var intersectionPoint1 = hxGeomAlgo_PolyTools.intersection(inputEdgeStart,inputEdgeEnd,clipEdgeStart,clipEdgeEnd);
				if(intersectionPoint1 != null) {
					output.push(intersectionPoint1);
				}
			}
			inputEdgeStart = inputEdgeEnd;
		}
		res.push(output);
	}
	return res;
};
hxGeomAlgo_PolyTools.exposeEnum = function(enumClass,as) {
	var dotPath = (as != null ? as : enumClass.__ename__).split(".");
	var exports = $hx_exports;
	var i = 0;
	while(i < dotPath.length - 1) {
		var currPath = dotPath[i];
		exports[currPath] = exports[currPath] || { };
		exports = exports[currPath];
		++i;
	}
	exports[dotPath[i]] = enumClass;
};
var hxGeomAlgo_WindingRule = $hxEnums["hxGeomAlgo.WindingRule"] = { __ename__:"hxGeomAlgo.WindingRule",__constructs__:null
	,ODD: {_hx_name:"ODD",_hx_index:0,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,NON_ZERO: {_hx_name:"NON_ZERO",_hx_index:1,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,POSITIVE: {_hx_name:"POSITIVE",_hx_index:2,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,NEGATIVE: {_hx_name:"NEGATIVE",_hx_index:3,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
	,ABS_GEQ_TWO: {_hx_name:"ABS_GEQ_TWO",_hx_index:4,__enum__:"hxGeomAlgo.WindingRule",toString:$estr}
};
hxGeomAlgo_WindingRule.__constructs__ = [hxGeomAlgo_WindingRule.ODD,hxGeomAlgo_WindingRule.NON_ZERO,hxGeomAlgo_WindingRule.POSITIVE,hxGeomAlgo_WindingRule.NEGATIVE,hxGeomAlgo_WindingRule.ABS_GEQ_TWO];
var hxGeomAlgo_ResultType = $hxEnums["hxGeomAlgo.ResultType"] = { __ename__:"hxGeomAlgo.ResultType",__constructs__:null
	,POLYGONS: {_hx_name:"POLYGONS",_hx_index:0,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
	,CONNECTED_POLYGONS: {_hx_name:"CONNECTED_POLYGONS",_hx_index:1,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
	,BOUNDARY_CONTOURS: {_hx_name:"BOUNDARY_CONTOURS",_hx_index:2,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
	,EXPERIMENTAL_DELAUNAY: {_hx_name:"EXPERIMENTAL_DELAUNAY",_hx_index:3,__enum__:"hxGeomAlgo.ResultType",toString:$estr}
};
hxGeomAlgo_ResultType.__constructs__ = [hxGeomAlgo_ResultType.POLYGONS,hxGeomAlgo_ResultType.CONNECTED_POLYGONS,hxGeomAlgo_ResultType.BOUNDARY_CONTOURS,hxGeomAlgo_ResultType.EXPERIMENTAL_DELAUNAY];
var hxGeomAlgo_Tess2 = $hx_exports["hxGeomAlgo"]["Tess2"] = function() { };
hxGeomAlgo_Tess2.__name__ = true;
hxGeomAlgo_Tess2.tesselate = function(contours,windingRule,resultType,polySize,vertexDim,normal) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var tess = new hxGeomAlgo_Tesselator();
	var _g = 0;
	var _g1 = contours.length;
	while(_g < _g1) {
		var i = _g++;
		tess.addContour(vertexDim,contours[i]);
	}
	tess.tesselate(windingRule == null ? hxGeomAlgo_WindingRule.ODD : windingRule,resultType == null ? hxGeomAlgo_ResultType.POLYGONS : resultType,polySize,vertexDim,normal == null ? [0,0,1] : normal);
	return { vertices : tess.vertices, vertexIndices : tess.vertexIndices, vertexCount : tess.vertexCount, elements : tess.elements, elementCount : tess.elementCount};
};
hxGeomAlgo_Tess2.union = function(contoursA,contoursB,resultType,polySize,vertexDim) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var contours = contoursA.concat(contoursB);
	return hxGeomAlgo_Tess2.tesselate(contours,hxGeomAlgo_WindingRule.NON_ZERO,resultType,polySize,vertexDim);
};
hxGeomAlgo_Tess2.intersection = function(contoursA,contoursB,resultType,polySize,vertexDim) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var contours = contoursA.concat(contoursB);
	return hxGeomAlgo_Tess2.tesselate(contours,hxGeomAlgo_WindingRule.ABS_GEQ_TWO,resultType,polySize,vertexDim);
};
hxGeomAlgo_Tess2.difference = function(contoursA,contoursB,resultType,polySize,vertexDim) {
	if(vertexDim == null) {
		vertexDim = 2;
	}
	if(polySize == null) {
		polySize = 3;
	}
	var _g = [];
	var _g1 = 0;
	while(_g1 < contoursB.length) {
		var poly = contoursB[_g1];
		++_g1;
		_g.push(hxGeomAlgo_PolyTools.reverseFloatArray(poly));
	}
	var diffB = _g;
	var contours = contoursA.concat(diffB);
	return hxGeomAlgo_Tess2.tesselate(contours,hxGeomAlgo_WindingRule.POSITIVE,resultType,polySize,vertexDim);
};
hxGeomAlgo_Tess2.convertResult = function(vertices,elements,resultType,polySize,out) {
	if(out == null) {
		out = [];
	}
	var tmp = resultType._hx_index != 2;
	var i = 0;
	switch(resultType._hx_index) {
	case 1:
		while(i < elements.length) {
			var poly = [];
			var _g = 0;
			var _g1 = polySize;
			while(_g < _g1) {
				var j = _g++;
				var idx = elements[i + j];
				if(idx == -1) {
					continue;
				}
				poly.push(hxGeomAlgo_HxPoint._new(vertices[idx * 2],vertices[idx * 2 + 1]));
			}
			out.push(poly);
			i += polySize * 2;
		}
		break;
	case 2:
		while(i < elements.length) {
			var poly = [];
			var start = elements[i];
			var count = elements[i + 1];
			var _g = 0;
			var _g1 = count;
			while(_g < _g1) {
				var j = _g++;
				var idx = start + j;
				poly.push(hxGeomAlgo_HxPoint._new(vertices[idx * 2],vertices[idx * 2 + 1]));
			}
			out.push(poly);
			i += 2;
		}
		break;
	case 0:case 3:
		while(i < elements.length) {
			var poly = [];
			var _g = 0;
			var _g1 = polySize;
			while(_g < _g1) {
				var j = _g++;
				var idx = elements[i + j];
				if(idx == -1) {
					continue;
				}
				poly.push(hxGeomAlgo_HxPoint._new(vertices[idx * 2],vertices[idx * 2 + 1]));
			}
			out.push(poly);
			i += polySize;
		}
		break;
	}
	return out;
};
var hxGeomAlgo__$Tess2_TessVertex = function() {
	this.idx = 0;
	this.n = 0;
	this.pqHandle = 0;
	this.t = 0.0;
	this.s = 0.0;
	this.coords = [0,0,0];
	this.anEdge = null;
	this.prev = null;
	this.next = null;
};
hxGeomAlgo__$Tess2_TessVertex.__name__ = true;
var hxGeomAlgo__$Tess2_TessFace = function() {
	this.inside = false;
	this.marked = false;
	this.n = 0;
	this.trail = null;
	this.anEdge = null;
	this.prev = null;
	this.next = null;
};
hxGeomAlgo__$Tess2_TessFace.__name__ = true;
var hxGeomAlgo__$Tess2_TessHalfEdge = function(side) {
	this.winding = 0;
	this.activeRegion = null;
	this.Lface = null;
	this.Org = null;
	this.Lnext = null;
	this.Onext = null;
	this.Sym = null;
	this.next = null;
	this.side = side;
};
hxGeomAlgo__$Tess2_TessHalfEdge.__name__ = true;
hxGeomAlgo__$Tess2_TessHalfEdge.prototype = {
	get_Rface: function() {
		return this.Sym.Lface;
	}
	,set_Rface: function(v) {
		return this.Sym.Lface = v;
	}
	,get_Dst: function() {
		return this.Sym.Org;
	}
	,set_Dst: function(v) {
		return this.Sym.Org = v;
	}
	,get_Oprev: function() {
		return this.Sym.Lnext;
	}
	,get_Lprev: function() {
		return this.Onext.Sym;
	}
	,get_Rprev: function() {
		return this.Sym.Onext;
	}
	,get_Dnext: function() {
		return this.Sym.Onext.Sym;
	}
};
var hxGeomAlgo__$Tess2_TessMesh = function() {
	this.eSym = new hxGeomAlgo__$Tess2_TessHalfEdge(1);
	this.e = new hxGeomAlgo__$Tess2_TessHalfEdge(0);
	this.f = new hxGeomAlgo__$Tess2_TessFace();
	this.v = new hxGeomAlgo__$Tess2_TessVertex();
	this.v.next = this.v.prev = this.v;
	this.v.anEdge = null;
	this.f.next = this.f.prev = this.f;
	this.f.anEdge = null;
	this.f.trail = null;
	this.f.marked = false;
	this.f.inside = false;
	this.e.next = this.e;
	this.e.Sym = this.eSym;
	this.e.Onext = null;
	this.e.Lnext = null;
	this.e.Org = null;
	this.e.Lface = null;
	this.e.winding = 0;
	this.e.activeRegion = null;
	this.e.mark = false;
	this.eSym.next = this.eSym;
	this.eSym.Sym = this.e;
	this.eSym.Onext = null;
	this.eSym.Lnext = null;
	this.eSym.Org = null;
	this.eSym.Lface = null;
	this.eSym.winding = 0;
	this.eSym.activeRegion = null;
	this.e.Sym.mark = false;
	this.vHead = this.v;
	this.fHead = this.f;
	this.eHead = this.e;
	this.eHeadSym = this.eSym;
};
hxGeomAlgo__$Tess2_TessMesh.__name__ = true;
hxGeomAlgo__$Tess2_TessMesh.flipEdge = function(mesh,edge) {
	var a0 = edge;
	var a1 = a0.Lnext;
	var a2 = a1.Lnext;
	var b0 = edge.Sym;
	var b1 = b0.Lnext;
	var b2 = b1.Lnext;
	var aOrg = a0.Org;
	var aOpp = a2.Org;
	var bOrg = b0.Org;
	var bOpp = b2.Org;
	var fa = a0.Lface;
	var fb = b0.Lface;
	var cond = hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edge);
	a0.Org = bOpp;
	a0.Onext = b1.Sym;
	b0.Org = aOpp;
	b0.Onext = a1.Sym;
	a2.Onext = b0;
	b2.Onext = a0;
	b1.Onext = a2.Sym;
	a1.Onext = b2.Sym;
	a0.Lnext = a2;
	a2.Lnext = b1;
	b1.Lnext = a0;
	b0.Lnext = b2;
	b2.Lnext = a1;
	a1.Lnext = b0;
	a1.Lface = fb;
	b1.Lface = fa;
	fa.anEdge = a0;
	fb.anEdge = b0;
	if(aOrg.anEdge == a0) {
		aOrg.anEdge = b1;
	}
	if(bOrg.anEdge == b0) {
		bOrg.anEdge = a1;
	}
	var cond = a0.get_Oprev().Onext.Org == a0.Org;
};
hxGeomAlgo__$Tess2_TessMesh.prototype = {
	makeEdge_: function(eNext) {
		var e = new hxGeomAlgo__$Tess2_TessHalfEdge(0);
		var eSym = new hxGeomAlgo__$Tess2_TessHalfEdge(1);
		if(eNext.Sym.side < eNext.side) {
			eNext = eNext.Sym;
		}
		var ePrev = eNext.Sym.next;
		eSym.next = ePrev;
		ePrev.Sym.next = e;
		e.next = eNext;
		eNext.Sym.next = eSym;
		e.Sym = eSym;
		e.Onext = e;
		e.Lnext = eSym;
		e.Org = null;
		e.Lface = null;
		e.winding = 0;
		e.activeRegion = null;
		eSym.Sym = e;
		eSym.Onext = eSym;
		eSym.Lnext = e;
		eSym.Org = null;
		eSym.Lface = null;
		eSym.winding = 0;
		eSym.activeRegion = null;
		return e;
	}
	,splice_: function(a,b) {
		var aOnext = a.Onext;
		var bOnext = b.Onext;
		aOnext.Sym.Lnext = b;
		bOnext.Sym.Lnext = a;
		a.Onext = bOnext;
		b.Onext = aOnext;
	}
	,makeVertex_: function(newVertex,eOrig,vNext) {
		var vNew = newVertex;
		var vPrev = vNext.prev;
		vNew.prev = vPrev;
		vPrev.next = vNew;
		vNew.next = vNext;
		vNext.prev = vNew;
		vNew.anEdge = eOrig;
		var e = eOrig;
		while(true) {
			e.Org = vNew;
			e = e.Onext;
			if(!(e != eOrig)) {
				break;
			}
		}
	}
	,makeFace_: function(newFace,eOrig,fNext) {
		var fNew = newFace;
		var fPrev = fNext.prev;
		fNew.prev = fPrev;
		fPrev.next = fNew;
		fNew.next = fNext;
		fNext.prev = fNew;
		fNew.anEdge = eOrig;
		fNew.trail = null;
		fNew.marked = false;
		fNew.inside = fNext.inside;
		var e = eOrig;
		while(true) {
			e.Lface = fNew;
			e = e.Lnext;
			if(!(e != eOrig)) {
				break;
			}
		}
	}
	,killEdge_: function(eDel) {
		if(eDel.Sym.side < eDel.side) {
			eDel = eDel.Sym;
		}
		var eNext = eDel.next;
		var ePrev = eDel.Sym.next;
		eNext.Sym.next = ePrev;
		ePrev.Sym.next = eNext;
	}
	,killVertex_: function(vDel,newOrg) {
		var eStart = vDel.anEdge;
		var e = eStart;
		while(true) {
			e.Org = newOrg;
			e = e.Onext;
			if(!(e != eStart)) {
				break;
			}
		}
		var vPrev = vDel.prev;
		var vNext = vDel.next;
		vNext.prev = vPrev;
		vPrev.next = vNext;
	}
	,killFace_: function(fDel,newLface) {
		var eStart = fDel.anEdge;
		var e = eStart;
		while(true) {
			e.Lface = newLface;
			e = e.Lnext;
			if(!(e != eStart)) {
				break;
			}
		}
		var fPrev = fDel.prev;
		var fNext = fDel.next;
		fNext.prev = fPrev;
		fPrev.next = fNext;
	}
	,makeEdge: function() {
		var newVertex1 = new hxGeomAlgo__$Tess2_TessVertex();
		var newVertex2 = new hxGeomAlgo__$Tess2_TessVertex();
		var newFace = new hxGeomAlgo__$Tess2_TessFace();
		var e = this.makeEdge_(this.eHead);
		this.makeVertex_(newVertex1,e,this.vHead);
		this.makeVertex_(newVertex2,e.Sym,this.vHead);
		this.makeFace_(newFace,e,this.fHead);
		return e;
	}
	,splice: function(eOrg,eDst) {
		var joiningLoops = false;
		var joiningVertices = false;
		if(eOrg == eDst) {
			return;
		}
		if(eDst.Org != eOrg.Org) {
			joiningVertices = true;
			this.killVertex_(eDst.Org,eOrg.Org);
		}
		if(eDst.Lface != eOrg.Lface) {
			joiningLoops = true;
			this.killFace_(eDst.Lface,eOrg.Lface);
		}
		this.splice_(eDst,eOrg);
		if(!joiningVertices) {
			var newVertex = new hxGeomAlgo__$Tess2_TessVertex();
			this.makeVertex_(newVertex,eDst,eOrg.Org);
			eOrg.Org.anEdge = eOrg;
		}
		if(!joiningLoops) {
			var newFace = new hxGeomAlgo__$Tess2_TessFace();
			this.makeFace_(newFace,eDst,eOrg.Lface);
			eOrg.Lface.anEdge = eOrg;
		}
	}
	,'delete': function(eDel) {
		var eDelSym = eDel.Sym;
		var joiningLoops = false;
		if(eDel.Lface != eDel.get_Rface()) {
			joiningLoops = true;
			this.killFace_(eDel.Lface,eDel.get_Rface());
		}
		if(eDel.Onext == eDel) {
			this.killVertex_(eDel.Org,null);
		} else {
			eDel.get_Rface().anEdge = eDel.get_Oprev();
			eDel.Org.anEdge = eDel.Onext;
			this.splice_(eDel,eDel.get_Oprev());
			if(!joiningLoops) {
				var newFace = new hxGeomAlgo__$Tess2_TessFace();
				this.makeFace_(newFace,eDel,eDel.Lface);
			}
		}
		if(eDelSym.Onext == eDelSym) {
			this.killVertex_(eDelSym.Org,null);
			this.killFace_(eDelSym.Lface,null);
		} else {
			eDel.Lface.anEdge = eDelSym.get_Oprev();
			eDelSym.Org.anEdge = eDelSym.Onext;
			this.splice_(eDelSym,eDelSym.get_Oprev());
		}
		this.killEdge_(eDel);
	}
	,addEdgeVertex: function(eOrg) {
		var eNew = this.makeEdge_(eOrg);
		var eNewSym = eNew.Sym;
		this.splice_(eNew,eOrg.Lnext);
		eNew.Org = eOrg.get_Dst();
		var newVertex = new hxGeomAlgo__$Tess2_TessVertex();
		this.makeVertex_(newVertex,eNewSym,eNew.Org);
		eNew.Lface = eNewSym.Lface = eOrg.Lface;
		return eNew;
	}
	,splitEdge: function(eOrg) {
		var tempHalfEdge = this.addEdgeVertex(eOrg);
		var eNew = tempHalfEdge.Sym;
		this.splice_(eOrg.Sym,eOrg.Sym.get_Oprev());
		this.splice_(eOrg.Sym,eNew);
		eOrg.set_Dst(eNew.Org);
		eNew.get_Dst().anEdge = eNew.Sym;
		eNew.set_Rface(eOrg.get_Rface());
		eNew.winding = eOrg.winding;
		eNew.Sym.winding = eOrg.Sym.winding;
		return eNew;
	}
	,connect: function(eOrg,eDst) {
		var joiningLoops = false;
		var eNew = this.makeEdge_(eOrg);
		var eNewSym = eNew.Sym;
		if(eDst.Lface != eOrg.Lface) {
			joiningLoops = true;
			this.killFace_(eDst.Lface,eOrg.Lface);
		}
		this.splice_(eNew,eOrg.Lnext);
		this.splice_(eNewSym,eDst);
		eNew.Org = eOrg.get_Dst();
		eNewSym.Org = eDst.Org;
		eNew.Lface = eNewSym.Lface = eOrg.Lface;
		eOrg.Lface.anEdge = eNewSym;
		if(!joiningLoops) {
			var newFace = new hxGeomAlgo__$Tess2_TessFace();
			this.makeFace_(newFace,eNew,eOrg.Lface);
		}
		return eNew;
	}
	,zapFace: function(fZap) {
		var eStart = fZap.anEdge;
		var e;
		var eSym;
		var eNext = eStart.Lnext;
		while(true) {
			e = eNext;
			eNext = e.Lnext;
			e.Lface = null;
			if(e.get_Rface() == null) {
				if(e.Onext == e) {
					this.killVertex_(e.Org,null);
				} else {
					e.Org.anEdge = e.Onext;
					this.splice_(e,e.get_Oprev());
				}
				eSym = e.Sym;
				if(eSym.Onext == eSym) {
					this.killVertex_(eSym.Org,null);
				} else {
					eSym.Org.anEdge = eSym.Onext;
					this.splice_(eSym,eSym.get_Oprev());
				}
				this.killEdge_(e);
			}
			if(!(e != eStart)) {
				break;
			}
		}
		var fPrev = fZap.prev;
		var fNext = fZap.next;
		fNext.prev = fPrev;
		fPrev.next = fNext;
	}
	,countFaceVerts_: function(f) {
		var eCur = f.anEdge;
		var n = 0;
		while(true) {
			++n;
			eCur = eCur.Lnext;
			if(!(eCur != f.anEdge)) {
				break;
			}
		}
		return n;
	}
	,mergeConvexFaces: function(maxVertsPerFace) {
		var eCur;
		var eNext;
		var eSym;
		var vStart;
		var curNv;
		var symNv;
		var f = this.fHead.next;
		while(f != this.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			eCur = f.anEdge;
			vStart = eCur.Org;
			while(true) {
				eNext = eCur.Lnext;
				eSym = eCur.Sym;
				if(eSym != null && eSym.Lface != null && eSym.Lface.inside) {
					curNv = this.countFaceVerts_(f);
					symNv = this.countFaceVerts_(eSym.Lface);
					if(curNv + symNv - 2 <= maxVertsPerFace) {
						if(hxGeomAlgo__$Tess2_Geom.vertCCW(eCur.get_Lprev().Org,eCur.Org,eSym.Lnext.Lnext.Org) && hxGeomAlgo__$Tess2_Geom.vertCCW(eSym.get_Lprev().Org,eSym.Org,eCur.Lnext.Lnext.Org)) {
							eNext = eSym.Lnext;
							this.delete(eSym);
							eCur = null;
							eSym = null;
						}
					}
				}
				if(eCur != null && eCur.Lnext.Org == vStart) {
					break;
				}
				eCur = eNext;
			}
			f = f.next;
		}
		return true;
	}
	,check: function() {
		var fHead = this.fHead;
		var vHead = this.vHead;
		var eHead = this.eHead;
		var f;
		var v;
		var e;
		var fPrev = fHead;
		while(true) {
			f = fPrev.next;
			if(!(f != fHead)) {
				break;
			}
			e = f.anEdge;
			while(true) {
				e = e.Lnext;
				if(!(e != f.anEdge)) {
					break;
				}
			}
			fPrev = f;
		}
		var vPrev = vHead;
		while(true) {
			v = vPrev.next;
			if(!(v != vHead)) {
				break;
			}
			e = v.anEdge;
			while(true) {
				e = e.Onext;
				if(!(e != v.anEdge)) {
					break;
				}
			}
			vPrev = v;
		}
		var ePrev = eHead;
		while(true) {
			e = ePrev.next;
			if(!(e != eHead)) {
				break;
			}
			var cond = e.get_Dst() != null;
			ePrev = e;
		}
		var cond = e.Sym.next == ePrev.Sym && e.Sym == this.eHeadSym && e.Sym.Sym == e && e.Org == null && e.get_Dst() == null && e.Lface == null && e.get_Rface() == null;
	}
};
var hxGeomAlgo__$Tess2_Geom = function() { };
hxGeomAlgo__$Tess2_Geom.__name__ = true;
hxGeomAlgo__$Tess2_Geom.vertEq = function(u,v) {
	if(u.s == v.s) {
		return u.t == v.t;
	} else {
		return false;
	}
};
hxGeomAlgo__$Tess2_Geom.vertLeq = function(u,v) {
	if(!(u.s < v.s)) {
		if(u.s == v.s) {
			return u.t <= v.t;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
hxGeomAlgo__$Tess2_Geom.transLeq = function(u,v) {
	if(!(u.t < v.t)) {
		if(u.t == v.t) {
			return u.s <= v.s;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
hxGeomAlgo__$Tess2_Geom.edgeGoesLeft = function(e) {
	return hxGeomAlgo__$Tess2_Geom.vertLeq(e.get_Dst(),e.Org);
};
hxGeomAlgo__$Tess2_Geom.edgeGoesRight = function(e) {
	return hxGeomAlgo__$Tess2_Geom.vertLeq(e.Org,e.get_Dst());
};
hxGeomAlgo__$Tess2_Geom.edgeIsInternal = function(e) {
	if(e.get_Rface() != null) {
		return e.get_Rface().inside;
	} else {
		return false;
	}
};
hxGeomAlgo__$Tess2_Geom.vertL1dist = function(u,v) {
	return Math.abs(u.s - v.s) + Math.abs(u.t - v.t);
};
hxGeomAlgo__$Tess2_Geom.edgeEval = function(u,v,w) {
	var cond = hxGeomAlgo__$Tess2_Geom.vertLeq(u,v) && hxGeomAlgo__$Tess2_Geom.vertLeq(v,w);
	var gapL = v.s - u.s;
	var gapR = w.s - v.s;
	if(gapL + gapR > 0.0) {
		if(gapL < gapR) {
			return v.t - u.t + (u.t - w.t) * (gapL / (gapL + gapR));
		} else {
			return v.t - w.t + (w.t - u.t) * (gapR / (gapL + gapR));
		}
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.edgeSign = function(u,v,w) {
	var cond = hxGeomAlgo__$Tess2_Geom.vertLeq(u,v) && hxGeomAlgo__$Tess2_Geom.vertLeq(v,w);
	var gapL = v.s - u.s;
	var gapR = w.s - v.s;
	if(gapL + gapR > 0.0) {
		return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.transEval = function(u,v,w) {
	var cond = hxGeomAlgo__$Tess2_Geom.transLeq(u,v) && hxGeomAlgo__$Tess2_Geom.transLeq(v,w);
	var gapL = v.t - u.t;
	var gapR = w.t - v.t;
	if(gapL + gapR > 0.0) {
		if(gapL < gapR) {
			return v.s - u.s + (u.s - w.s) * (gapL / (gapL + gapR));
		} else {
			return v.s - w.s + (w.s - u.s) * (gapR / (gapL + gapR));
		}
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.transSign = function(u,v,w) {
	var cond = hxGeomAlgo__$Tess2_Geom.transLeq(u,v) && hxGeomAlgo__$Tess2_Geom.transLeq(v,w);
	var gapL = v.t - u.t;
	var gapR = w.t - v.t;
	if(gapL + gapR > 0.0) {
		return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
	}
	return 0.0;
};
hxGeomAlgo__$Tess2_Geom.vertCCW = function(u,v,w) {
	return u.s * (v.t - w.t) + v.s * (w.t - u.t) + w.s * (u.t - v.t) >= 0.0;
};
hxGeomAlgo__$Tess2_Geom.interpolate = function(a,x,b,y) {
	if(a < 0) {
		a = 0;
	}
	if(b < 0) {
		b = 0;
	}
	if(a <= b) {
		if(b == 0) {
			return (x + y) / 2;
		} else {
			return x + (y - x) * (a / (a + b));
		}
	} else {
		return y + (x - y) * (b / (a + b));
	}
};
hxGeomAlgo__$Tess2_Geom.intersect = function(o1,d1,o2,d2,v) {
	var z1;
	var z2;
	var t;
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o1,d1)) {
		t = o1;
		o1 = d1;
		d1 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o2,d2)) {
		t = o2;
		o2 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o1,o2)) {
		t = o1;
		o1 = o2;
		o2 = t;
		t = d1;
		d1 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertLeq(o2,d1)) {
		v.s = (o2.s + d1.s) / 2;
	} else if(hxGeomAlgo__$Tess2_Geom.vertLeq(d1,d2)) {
		z1 = hxGeomAlgo__$Tess2_Geom.edgeEval(o1,o2,d1);
		z2 = hxGeomAlgo__$Tess2_Geom.edgeEval(o2,d1,d2);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.s = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.s,z2,d1.s);
	} else {
		z1 = hxGeomAlgo__$Tess2_Geom.edgeSign(o1,o2,d1);
		z2 = -hxGeomAlgo__$Tess2_Geom.edgeSign(o1,d2,d1);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.s = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.s,z2,d2.s);
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o1,d1)) {
		t = o1;
		o1 = d1;
		d1 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o2,d2)) {
		t = o2;
		o2 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o1,o2)) {
		t = o1;
		o1 = o2;
		o2 = t;
		t = d1;
		d1 = d2;
		d2 = t;
	}
	if(!hxGeomAlgo__$Tess2_Geom.transLeq(o2,d1)) {
		v.t = (o2.t + d1.t) / 2;
	} else if(hxGeomAlgo__$Tess2_Geom.transLeq(d1,d2)) {
		z1 = hxGeomAlgo__$Tess2_Geom.transEval(o1,o2,d1);
		z2 = hxGeomAlgo__$Tess2_Geom.transEval(o2,d1,d2);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.t = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.t,z2,d1.t);
	} else {
		z1 = hxGeomAlgo__$Tess2_Geom.transSign(o1,o2,d1);
		z2 = -hxGeomAlgo__$Tess2_Geom.transSign(o1,d2,d1);
		if(z1 + z2 < 0) {
			z1 = -z1;
			z2 = -z2;
		}
		v.t = hxGeomAlgo__$Tess2_Geom.interpolate(z1,o2.t,z2,d2.t);
	}
};
hxGeomAlgo__$Tess2_Geom.calcAngle = function(v0,v1,v2) {
	var a_0 = v2.s - v1.s;
	var a_1 = v2.t - v1.t;
	var b_0 = v0.s - v1.s;
	var b_1 = v0.t - v1.t;
	var num = a_0 * b_0 + a_1 * b_1;
	var den = Math.sqrt(a_0 * a_0 + a_1 * a_1) * Math.sqrt(b_0 * b_0 + b_1 * b_1);
	if(den > 0.0) {
		num /= den;
	}
	if(num < -1.0) {
		num = -1.0;
	}
	if(num > 1.0) {
		num = 1.0;
	}
	return Math.acos(num);
};
hxGeomAlgo__$Tess2_Geom.edgeIsLocallyDelaunay = function(e) {
	return hxGeomAlgo__$Tess2_Geom.calcAngle(e.Lnext.Org,e.Lnext.Lnext.Org,e.Org) + hxGeomAlgo__$Tess2_Geom.calcAngle(e.Sym.Lnext.Org,e.Sym.Lnext.Lnext.Org,e.Sym.Org) < Math.PI + 0.01;
};
var hxGeomAlgo__$Tess2_DictNode = function() {
	this.prev = null;
	this.next = null;
	this.key = null;
};
hxGeomAlgo__$Tess2_DictNode.__name__ = true;
var hxGeomAlgo__$Tess2_Dict = function(frame,leq) {
	this.head = new hxGeomAlgo__$Tess2_DictNode();
	this.head.next = this.head;
	this.head.prev = this.head;
	this.frame = frame;
	this.leq = leq;
};
hxGeomAlgo__$Tess2_Dict.__name__ = true;
hxGeomAlgo__$Tess2_Dict.prototype = {
	min: function() {
		return this.head.next;
	}
	,insert: function(k) {
		return this.insertBefore(this.head,k);
	}
	,search: function(key) {
		var node = this.head;
		while(true) {
			node = node.next;
			if(!(node.key != null && !this.leq(this.frame,key,node.key))) {
				break;
			}
		}
		return node;
	}
	,insertBefore: function(node,key) {
		while(true) {
			node = node.prev;
			if(!(node.key != null && !this.leq(this.frame,node.key,key))) {
				break;
			}
		}
		var newNode = new hxGeomAlgo__$Tess2_DictNode();
		newNode.key = key;
		newNode.next = node.next;
		node.next.prev = newNode;
		newNode.prev = node;
		node.next = newNode;
		return newNode;
	}
	,'delete': function(node) {
		node.next.prev = node.prev;
		node.prev.next = node.next;
	}
};
var hxGeomAlgo__$Tess2_PQNode = function() {
	this.handle = -1;
};
hxGeomAlgo__$Tess2_PQNode.__name__ = true;
var hxGeomAlgo__$Tess2_PQHandleElem = function() {
	this.node = -1;
	this.key = null;
};
hxGeomAlgo__$Tess2_PQHandleElem.__name__ = true;
var hxGeomAlgo__$Tess2_PriorityQ = function(size,leq) {
	this.size = 0;
	this.max = size;
	this.nodes = [];
	var _g = 0;
	var _g1 = size + 1;
	while(_g < _g1) {
		var i = _g++;
		this.nodes[i] = new hxGeomAlgo__$Tess2_PQNode();
	}
	this.handles = [];
	var _g = 0;
	var _g1 = size + 1;
	while(_g < _g1) {
		var i = _g++;
		this.handles[i] = new hxGeomAlgo__$Tess2_PQHandleElem();
	}
	this.initialized = false;
	this.freeList = 0;
	this.leq = leq;
	this.nodes[1].handle = 1;
	this.handles[1].key = null;
};
hxGeomAlgo__$Tess2_PriorityQ.__name__ = true;
hxGeomAlgo__$Tess2_PriorityQ.prototype = {
	floatDown_: function(curr) {
		var n = this.nodes;
		var h = this.handles;
		var hChild;
		var child;
		var hCurr = n[curr].handle;
		while(true) {
			child = curr << 1;
			if(child < this.size && this.leq(h[n[child + 1].handle].key,h[n[child].handle].key)) {
				++child;
			}
			hChild = n[child].handle;
			if(child > this.size || this.leq(h[hCurr].key,h[hChild].key)) {
				n[curr].handle = hCurr;
				h[hCurr].node = curr;
				break;
			}
			n[curr].handle = hChild;
			h[hChild].node = curr;
			curr = child;
		}
	}
	,floatUp_: function(curr) {
		var n = this.nodes;
		var h = this.handles;
		var hParent;
		var parent;
		var hCurr = n[curr].handle;
		while(true) {
			parent = curr >> 1;
			hParent = n[parent].handle;
			if(parent == 0 || this.leq(h[hParent].key,h[hCurr].key)) {
				n[curr].handle = hCurr;
				h[hCurr].node = curr;
				break;
			}
			n[curr].handle = hParent;
			h[hParent].node = curr;
			curr = parent;
		}
	}
	,init: function() {
		var i = this.size;
		while(i >= 1) {
			this.floatDown_(i);
			--i;
		}
		this.initialized = true;
	}
	,min: function() {
		return this.handles[this.nodes[1].handle].key;
	}
	,insert: function(keyNew) {
		var free;
		var curr = ++this.size;
		if(curr * 2 > this.max) {
			this.max *= 2;
			var s = this.nodes.length;
			var _g = s;
			var _g1 = this.max + 1;
			while(_g < _g1) {
				var i = _g++;
				this.nodes[i] = new hxGeomAlgo__$Tess2_PQNode();
			}
			s = this.handles.length;
			var _g = this.handles.length;
			var _g1 = this.max + 1;
			while(_g < _g1) {
				var i = _g++;
				this.handles[i] = new hxGeomAlgo__$Tess2_PQHandleElem();
			}
		}
		if(this.freeList == 0) {
			free = curr;
		} else {
			free = this.freeList;
			this.freeList = this.handles[free].node;
		}
		this.nodes[curr].handle = free;
		this.handles[free].node = curr;
		this.handles[free].key = keyNew;
		if(this.initialized) {
			this.floatUp_(curr);
		}
		return free;
	}
	,extractMin: function() {
		var n = this.nodes;
		var h = this.handles;
		var hMin = n[1].handle;
		var min = h[hMin].key;
		if(this.size > 0) {
			n[1].handle = n[this.size].handle;
			h[n[1].handle].node = 1;
			h[hMin].key = null;
			h[hMin].node = this.freeList;
			this.freeList = hMin;
			--this.size;
			if(this.size > 0) {
				this.floatDown_(1);
			}
		}
		return min;
	}
	,'delete': function(hCurr) {
		var n = this.nodes;
		var h = this.handles;
		var curr = h[hCurr].node;
		n[curr].handle = n[this.size].handle;
		h[n[curr].handle].node = curr;
		--this.size;
		if(curr <= this.size) {
			if(curr <= 1 || this.leq(h[n[curr >> 1].handle].key,h[n[curr].handle].key)) {
				this.floatDown_(curr);
			} else {
				this.floatUp_(curr);
			}
		}
		h[hCurr].key = null;
		h[hCurr].node = this.freeList;
		this.freeList = hCurr;
	}
};
var hxGeomAlgo__$Tess2_ActiveRegion = function() {
	this.fixUpperEdge = false;
	this.dirty = false;
	this.sentinel = false;
	this.inside = false;
	this.windingNumber = 0;
	this.nodeUp = null;
	this.eUp = null;
};
hxGeomAlgo__$Tess2_ActiveRegion.__name__ = true;
var hxGeomAlgo__$Tess2_Sweep = function() { };
hxGeomAlgo__$Tess2_Sweep.__name__ = true;
hxGeomAlgo__$Tess2_Sweep.regionBelow = function(r) {
	return r.nodeUp.prev.key;
};
hxGeomAlgo__$Tess2_Sweep.regionAbove = function(r) {
	return r.nodeUp.next.key;
};
hxGeomAlgo__$Tess2_Sweep.debugEvent = function(tess) {
};
hxGeomAlgo__$Tess2_Sweep.addWinding = function(eDst,eSrc) {
	eDst.winding += eSrc.winding;
	eDst.Sym.winding += eSrc.Sym.winding;
};
hxGeomAlgo__$Tess2_Sweep.edgeLeq = function(tess,reg1,reg2) {
	var ev = tess.event;
	var t1;
	var t2;
	var e1 = reg1.eUp;
	var e2 = reg2.eUp;
	if(e1.get_Dst() == ev) {
		if(e2.get_Dst() == ev) {
			if(hxGeomAlgo__$Tess2_Geom.vertLeq(e1.Org,e2.Org)) {
				return hxGeomAlgo__$Tess2_Geom.edgeSign(e2.get_Dst(),e1.Org,e2.Org) <= 0;
			}
			return hxGeomAlgo__$Tess2_Geom.edgeSign(e1.get_Dst(),e2.Org,e1.Org) >= 0;
		}
		return hxGeomAlgo__$Tess2_Geom.edgeSign(e2.get_Dst(),ev,e2.Org) <= 0;
	}
	if(e2.get_Dst() == ev) {
		return hxGeomAlgo__$Tess2_Geom.edgeSign(e1.get_Dst(),ev,e1.Org) >= 0;
	}
	var t1 = hxGeomAlgo__$Tess2_Geom.edgeEval(e1.get_Dst(),ev,e1.Org);
	var t2 = hxGeomAlgo__$Tess2_Geom.edgeEval(e2.get_Dst(),ev,e2.Org);
	return t1 >= t2;
};
hxGeomAlgo__$Tess2_Sweep.deleteRegion = function(tess,reg) {
	var reg1 = reg.fixUpperEdge;
	reg.eUp.activeRegion = null;
	tess.dict.delete(reg.nodeUp);
};
hxGeomAlgo__$Tess2_Sweep.fixUpperEdge = function(tess,reg,newEdge) {
	tess.mesh.delete(reg.eUp);
	reg.fixUpperEdge = false;
	reg.eUp = newEdge;
	newEdge.activeRegion = reg;
};
hxGeomAlgo__$Tess2_Sweep.topLeftRegion = function(tess,reg) {
	var org = reg.eUp.Org;
	var e;
	while(true) {
		reg = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg);
		if(!(reg.eUp.Org == org)) {
			break;
		}
	}
	if(reg.fixUpperEdge) {
		e = tess.mesh.connect(hxGeomAlgo__$Tess2_Sweep.regionBelow(reg).eUp.Sym,reg.eUp.Lnext);
		if(e == null) {
			return null;
		}
		hxGeomAlgo__$Tess2_Sweep.fixUpperEdge(tess,reg,e);
		reg = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg);
	}
	return reg;
};
hxGeomAlgo__$Tess2_Sweep.topRightRegion = function(reg) {
	var dst = reg.eUp.get_Dst();
	while(true) {
		reg = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg);
		if(!(reg.eUp.get_Dst() == dst)) {
			break;
		}
	}
	return reg;
};
hxGeomAlgo__$Tess2_Sweep.addRegionBelow = function(tess,regAbove,eNewUp) {
	var regNew = new hxGeomAlgo__$Tess2_ActiveRegion();
	regNew.eUp = eNewUp;
	regNew.nodeUp = tess.dict.insertBefore(regAbove.nodeUp,regNew);
	regNew.fixUpperEdge = false;
	regNew.sentinel = false;
	regNew.dirty = false;
	eNewUp.activeRegion = regNew;
	return regNew;
};
hxGeomAlgo__$Tess2_Sweep.isWindingInside = function(tess,n) {
	switch(tess.windingRule._hx_index) {
	case 0:
		return (n & 1) != 0;
	case 1:
		return n != 0;
	case 2:
		return n > 0;
	case 3:
		return n < 0;
	case 4:
		if(n < 2) {
			return n <= -2;
		} else {
			return true;
		}
		break;
	}
};
hxGeomAlgo__$Tess2_Sweep.computeWinding = function(tess,reg) {
	reg.windingNumber = hxGeomAlgo__$Tess2_Sweep.regionAbove(reg).windingNumber + reg.eUp.winding;
	reg.inside = hxGeomAlgo__$Tess2_Sweep.isWindingInside(tess,reg.windingNumber);
};
hxGeomAlgo__$Tess2_Sweep.finishRegion = function(tess,reg) {
	var e = reg.eUp;
	var f = e.Lface;
	f.inside = reg.inside;
	f.anEdge = e;
	hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,reg);
};
hxGeomAlgo__$Tess2_Sweep.finishLeftRegions = function(tess,regFirst,regLast) {
	var e;
	var ePrev;
	var reg = null;
	var regPrev = regFirst;
	var ePrev = regFirst.eUp;
	while(regPrev != regLast) {
		regPrev.fixUpperEdge = false;
		reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regPrev);
		e = reg.eUp;
		if(e.Org != ePrev.Org) {
			if(!reg.fixUpperEdge) {
				hxGeomAlgo__$Tess2_Sweep.finishRegion(tess,regPrev);
				break;
			}
			e = tess.mesh.connect(ePrev.get_Lprev(),e.Sym);
			hxGeomAlgo__$Tess2_Sweep.fixUpperEdge(tess,reg,e);
		}
		if(ePrev.Onext != e) {
			tess.mesh.splice(e.get_Oprev(),e);
			tess.mesh.splice(ePrev,e);
		}
		hxGeomAlgo__$Tess2_Sweep.finishRegion(tess,regPrev);
		ePrev = reg.eUp;
		regPrev = reg;
	}
	return ePrev;
};
hxGeomAlgo__$Tess2_Sweep.addRightEdges = function(tess,regUp,eFirst,eLast,eTopLeft,cleanUp) {
	var reg = null;
	var firstTime = true;
	var e = eFirst;
	while(true) {
		var cond = hxGeomAlgo__$Tess2_Geom.vertLeq(e.Org,e.get_Dst());
		hxGeomAlgo__$Tess2_Sweep.addRegionBelow(tess,regUp,e.Sym);
		e = e.Onext;
		if(!(e != eLast)) {
			break;
		}
	}
	if(eTopLeft == null) {
		eTopLeft = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp.get_Rprev();
	}
	var regPrev = regUp;
	var ePrev = eTopLeft;
	while(true) {
		reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regPrev);
		e = reg.eUp.Sym;
		if(e.Org != ePrev.Org) {
			break;
		}
		if(e.Onext != ePrev) {
			tess.mesh.splice(e.get_Oprev(),e);
			tess.mesh.splice(ePrev.get_Oprev(),e);
		}
		reg.windingNumber = regPrev.windingNumber - e.winding;
		reg.inside = hxGeomAlgo__$Tess2_Sweep.isWindingInside(tess,reg.windingNumber);
		regPrev.dirty = true;
		if(!firstTime && hxGeomAlgo__$Tess2_Sweep.checkForRightSplice(tess,regPrev)) {
			hxGeomAlgo__$Tess2_Sweep.addWinding(e,ePrev);
			hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regPrev);
			tess.mesh.delete(ePrev);
		}
		firstTime = false;
		regPrev = reg;
		ePrev = e;
	}
	regPrev.dirty = true;
	if(cleanUp) {
		hxGeomAlgo__$Tess2_Sweep.walkDirtyRegions(tess,regPrev);
	}
};
hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices = function(tess,e1,e2) {
	tess.mesh.splice(e1,e2);
};
hxGeomAlgo__$Tess2_Sweep.vertexWeights = function(isect,org,dst) {
	var t1 = hxGeomAlgo__$Tess2_Geom.vertL1dist(org,isect);
	var t2 = hxGeomAlgo__$Tess2_Geom.vertL1dist(dst,isect);
	var w0 = 0.5 * t2 / (t1 + t2);
	var w1 = 0.5 * t1 / (t1 + t2);
	isect.coords[0] += w0 * org.coords[0] + w1 * dst.coords[0];
	isect.coords[1] += w0 * org.coords[1] + w1 * dst.coords[1];
	isect.coords[2] += w0 * org.coords[2] + w1 * dst.coords[2];
};
hxGeomAlgo__$Tess2_Sweep.getIntersectData = function(tess,isect,orgUp,dstUp,orgLo,dstLo) {
	var tmp = isect.coords[1] = isect.coords[2] = 0;
	isect.coords[0] = tmp;
	isect.idx = -1;
	hxGeomAlgo__$Tess2_Sweep.vertexWeights(isect,orgUp,dstUp);
	hxGeomAlgo__$Tess2_Sweep.vertexWeights(isect,orgLo,dstLo);
};
hxGeomAlgo__$Tess2_Sweep.checkForRightSplice = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(eUp.Org,eLo.Org)) {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eLo.get_Dst(),eUp.Org,eLo.Org) > 0) {
			return false;
		}
		if(!hxGeomAlgo__$Tess2_Geom.vertEq(eUp.Org,eLo.Org)) {
			tess.mesh.splitEdge(eLo.Sym);
			tess.mesh.splice(eUp,eLo.get_Oprev());
			regUp.dirty = regLo.dirty = true;
		} else if(eUp.Org != eLo.Org) {
			tess.pq.delete(eUp.Org.pqHandle);
			hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,eLo.get_Oprev(),eUp);
		}
	} else {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eUp.get_Dst(),eLo.Org,eUp.Org) < 0) {
			return false;
		}
		hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
		tess.mesh.splitEdge(eUp.Sym);
		tess.mesh.splice(eLo.get_Oprev(),eUp);
	}
	return true;
};
hxGeomAlgo__$Tess2_Sweep.checkForLeftSplice = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	var e;
	var cond = !hxGeomAlgo__$Tess2_Geom.vertEq(eUp.get_Dst(),eLo.get_Dst());
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(eUp.get_Dst(),eLo.get_Dst())) {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eUp.get_Dst(),eLo.get_Dst(),eUp.Org) < 0) {
			return false;
		}
		hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
		e = tess.mesh.splitEdge(eUp);
		tess.mesh.splice(eLo.Sym,e);
		e.Lface.inside = regUp.inside;
	} else {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(eLo.get_Dst(),eUp.get_Dst(),eLo.Org) > 0) {
			return false;
		}
		regUp.dirty = regLo.dirty = true;
		e = tess.mesh.splitEdge(eLo);
		tess.mesh.splice(eUp.Lnext,eLo.Sym);
		e.get_Rface().inside = regUp.inside;
	}
	return true;
};
hxGeomAlgo__$Tess2_Sweep.checkForIntersect = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	var orgUp = eUp.Org;
	var orgLo = eLo.Org;
	var dstUp = eUp.get_Dst();
	var dstLo = eLo.get_Dst();
	var isect = new hxGeomAlgo__$Tess2_TessVertex();
	var e;
	var cond = !hxGeomAlgo__$Tess2_Geom.vertEq(dstLo,dstUp);
	var cond = hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,tess.event,orgUp) <= 0;
	var cond = hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,tess.event,orgLo) >= 0;
	if(orgUp == orgLo) {
		return false;
	}
	var tMinUp = Math.min(orgUp.t,dstUp.t);
	var tMaxLo = Math.max(orgLo.t,dstLo.t);
	if(tMinUp > tMaxLo) {
		return false;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(orgUp,orgLo)) {
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,orgUp,orgLo) > 0) {
			return false;
		}
	} else if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,orgLo,orgUp) < 0) {
		return false;
	}
	hxGeomAlgo__$Tess2_Sweep.debugEvent(tess);
	hxGeomAlgo__$Tess2_Geom.intersect(dstUp,orgUp,dstLo,orgLo,isect);
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(isect,tess.event)) {
		isect.s = tess.event.s;
		isect.t = tess.event.t;
	}
	var orgMin = hxGeomAlgo__$Tess2_Geom.vertLeq(orgUp,orgLo) ? orgUp : orgLo;
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(orgMin,isect)) {
		isect.s = orgMin.s;
		isect.t = orgMin.t;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertEq(isect,orgUp) || hxGeomAlgo__$Tess2_Geom.vertEq(isect,orgLo)) {
		hxGeomAlgo__$Tess2_Sweep.checkForRightSplice(tess,regUp);
		return false;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertEq(dstUp,tess.event) && hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,tess.event,isect) >= 0 || !hxGeomAlgo__$Tess2_Geom.vertEq(dstLo,tess.event) && hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,tess.event,isect) <= 0) {
		if(dstLo == tess.event) {
			tess.mesh.splitEdge(eUp.Sym);
			tess.mesh.splice(eLo.Sym,eUp);
			regUp = hxGeomAlgo__$Tess2_Sweep.topLeftRegion(tess,regUp);
			eUp = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp;
			hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp),regLo);
			hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eUp.get_Oprev(),eUp,eUp,true);
			return true;
		}
		if(dstUp == tess.event) {
			tess.mesh.splitEdge(eLo.Sym);
			tess.mesh.splice(eUp.Lnext,eLo.get_Oprev());
			regLo = regUp;
			regUp = hxGeomAlgo__$Tess2_Sweep.topRightRegion(regUp);
			e = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp.get_Rprev();
			regLo.eUp = eLo.get_Oprev();
			eLo = hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,regLo,null);
			hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eLo.Onext,eUp.get_Rprev(),e,true);
			return true;
		}
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstUp,tess.event,isect) >= 0) {
			hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
			tess.mesh.splitEdge(eUp.Sym);
			eUp.Org.s = tess.event.s;
			eUp.Org.t = tess.event.t;
		}
		if(hxGeomAlgo__$Tess2_Geom.edgeSign(dstLo,tess.event,isect) <= 0) {
			regUp.dirty = regLo.dirty = true;
			tess.mesh.splitEdge(eLo.Sym);
			eLo.Org.s = tess.event.s;
			eLo.Org.t = tess.event.t;
		}
		return false;
	}
	tess.mesh.splitEdge(eUp.Sym);
	tess.mesh.splitEdge(eLo.Sym);
	tess.mesh.splice(eLo.get_Oprev(),eUp);
	eUp.Org.s = isect.s;
	eUp.Org.t = isect.t;
	eUp.Org.pqHandle = tess.pq.insert(eUp.Org);
	hxGeomAlgo__$Tess2_Sweep.getIntersectData(tess,eUp.Org,orgUp,dstUp,orgLo,dstLo);
	hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp).dirty = regUp.dirty = regLo.dirty = true;
	return false;
};
hxGeomAlgo__$Tess2_Sweep.walkDirtyRegions = function(tess,regUp) {
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp;
	var eLo;
	while(true) {
		while(regLo.dirty) {
			regUp = regLo;
			regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regLo);
		}
		if(!regUp.dirty) {
			regLo = regUp;
			regUp = hxGeomAlgo__$Tess2_Sweep.regionAbove(regUp);
			if(regUp == null || !regUp.dirty) {
				return;
			}
		}
		regUp.dirty = false;
		eUp = regUp.eUp;
		eLo = regLo.eUp;
		if(eUp.get_Dst() != eLo.get_Dst()) {
			if(hxGeomAlgo__$Tess2_Sweep.checkForLeftSplice(tess,regUp)) {
				if(regLo.fixUpperEdge) {
					hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regLo);
					tess.mesh.delete(eLo);
					regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
					eLo = regLo.eUp;
				} else if(regUp.fixUpperEdge) {
					hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regUp);
					tess.mesh.delete(eUp);
					regUp = hxGeomAlgo__$Tess2_Sweep.regionAbove(regLo);
					eUp = regUp.eUp;
				}
			}
		}
		if(eUp.Org != eLo.Org) {
			if(eUp.get_Dst() != eLo.get_Dst() && !regUp.fixUpperEdge && !regLo.fixUpperEdge && (eUp.get_Dst() == tess.event || eLo.get_Dst() == tess.event)) {
				if(hxGeomAlgo__$Tess2_Sweep.checkForIntersect(tess,regUp)) {
					return;
				}
			} else {
				hxGeomAlgo__$Tess2_Sweep.checkForRightSplice(tess,regUp);
			}
		}
		if(eUp.Org == eLo.Org && eUp.get_Dst() == eLo.get_Dst()) {
			hxGeomAlgo__$Tess2_Sweep.addWinding(eLo,eUp);
			hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,regUp);
			tess.mesh.delete(eUp);
			regUp = hxGeomAlgo__$Tess2_Sweep.regionAbove(regLo);
		}
	}
};
hxGeomAlgo__$Tess2_Sweep.connectRightVertex = function(tess,regUp,eBottomLeft) {
	var eNew;
	var eTopLeft = eBottomLeft.Onext;
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	var degenerate = false;
	if(eUp.get_Dst() != eLo.get_Dst()) {
		hxGeomAlgo__$Tess2_Sweep.checkForIntersect(tess,regUp);
	}
	if(hxGeomAlgo__$Tess2_Geom.vertEq(eUp.Org,tess.event)) {
		tess.mesh.splice(eTopLeft.get_Oprev(),eUp);
		regUp = hxGeomAlgo__$Tess2_Sweep.topLeftRegion(tess,regUp);
		eTopLeft = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp).eUp;
		hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp),regLo);
		degenerate = true;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertEq(eLo.Org,tess.event)) {
		tess.mesh.splice(eBottomLeft,eLo.get_Oprev());
		eBottomLeft = hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,regLo,null);
		degenerate = true;
	}
	if(degenerate) {
		hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eBottomLeft.Onext,eTopLeft,eTopLeft,true);
		return;
	}
	if(hxGeomAlgo__$Tess2_Geom.vertLeq(eLo.Org,eUp.Org)) {
		eNew = eLo.get_Oprev();
	} else {
		eNew = eUp;
	}
	eNew = tess.mesh.connect(eBottomLeft.get_Lprev(),eNew);
	hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eNew,eNew.Onext,eNew.Onext,false);
	eNew.Sym.activeRegion.fixUpperEdge = true;
	hxGeomAlgo__$Tess2_Sweep.walkDirtyRegions(tess,regUp);
};
hxGeomAlgo__$Tess2_Sweep.connectLeftDegenerate = function(tess,regUp,vEvent) {
	var e = regUp.eUp;
	if(hxGeomAlgo__$Tess2_Geom.vertEq(e.Org,vEvent)) {
		hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,e,vEvent.anEdge);
		return;
	}
	if(!hxGeomAlgo__$Tess2_Geom.vertEq(e.get_Dst(),vEvent)) {
		tess.mesh.splitEdge(e.Sym);
		if(regUp.fixUpperEdge) {
			tess.mesh.delete(e.Onext);
			regUp.fixUpperEdge = false;
		}
		tess.mesh.splice(vEvent.anEdge,e);
		hxGeomAlgo__$Tess2_Sweep.sweepEvent(tess,vEvent);
		return;
	}
	regUp = hxGeomAlgo__$Tess2_Sweep.topRightRegion(regUp);
	var reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eTopRight = reg.eUp.Sym;
	var eLast = eTopRight.Onext;
	var eTopLeft = eLast;
	if(reg.fixUpperEdge) {
		hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,reg);
		tess.mesh.delete(eTopRight);
		eTopRight = eTopLeft.get_Oprev();
	}
	tess.mesh.splice(vEvent.anEdge,eTopRight);
	if(!hxGeomAlgo__$Tess2_Geom.edgeGoesLeft(eTopLeft)) {
		eTopLeft = null;
	}
	hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eTopRight.Onext,eLast,eTopLeft,true);
};
hxGeomAlgo__$Tess2_Sweep.connectLeftVertex = function(tess,vEvent) {
	var eNew;
	var tmp = new hxGeomAlgo__$Tess2_ActiveRegion();
	tmp.eUp = vEvent.anEdge.Sym;
	var regUp = tess.dict.search(tmp).key;
	var regLo = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	if(regLo == null) {
		return;
	}
	var eUp = regUp.eUp;
	var eLo = regLo.eUp;
	if(hxGeomAlgo__$Tess2_Geom.edgeSign(eUp.get_Dst(),vEvent,eUp.Org) == 0.0) {
		hxGeomAlgo__$Tess2_Sweep.connectLeftDegenerate(tess,regUp,vEvent);
		return;
	}
	var reg = hxGeomAlgo__$Tess2_Geom.vertLeq(eLo.get_Dst(),eUp.get_Dst()) ? regUp : regLo;
	if(regUp.inside || reg.fixUpperEdge) {
		if(reg == regUp) {
			eNew = tess.mesh.connect(vEvent.anEdge.Sym,eUp.Lnext);
		} else {
			var tempHalfEdge = tess.mesh.connect(eLo.get_Dnext(),vEvent.anEdge);
			eNew = tempHalfEdge.Sym;
		}
		if(reg.fixUpperEdge) {
			hxGeomAlgo__$Tess2_Sweep.fixUpperEdge(tess,reg,eNew);
		} else {
			hxGeomAlgo__$Tess2_Sweep.computeWinding(tess,hxGeomAlgo__$Tess2_Sweep.addRegionBelow(tess,regUp,eNew));
		}
		hxGeomAlgo__$Tess2_Sweep.sweepEvent(tess,vEvent);
	} else {
		hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,vEvent.anEdge,vEvent.anEdge,null,true);
	}
};
hxGeomAlgo__$Tess2_Sweep.sweepEvent = function(tess,vEvent) {
	tess.event = vEvent;
	hxGeomAlgo__$Tess2_Sweep.debugEvent(tess);
	var e = vEvent.anEdge;
	while(e.activeRegion == null) {
		e = e.Onext;
		if(e == vEvent.anEdge) {
			hxGeomAlgo__$Tess2_Sweep.connectLeftVertex(tess,vEvent);
			return;
		}
	}
	var regUp = hxGeomAlgo__$Tess2_Sweep.topLeftRegion(tess,e.activeRegion);
	var reg = hxGeomAlgo__$Tess2_Sweep.regionBelow(regUp);
	var eTopLeft = reg.eUp;
	var eBottomLeft = hxGeomAlgo__$Tess2_Sweep.finishLeftRegions(tess,reg,null);
	if(eBottomLeft.Onext == eTopLeft) {
		hxGeomAlgo__$Tess2_Sweep.connectRightVertex(tess,regUp,eBottomLeft);
	} else {
		hxGeomAlgo__$Tess2_Sweep.addRightEdges(tess,regUp,eBottomLeft.Onext,eTopLeft,eTopLeft,true);
	}
};
hxGeomAlgo__$Tess2_Sweep.addSentinel = function(tess,smin,smax,t) {
	var reg = new hxGeomAlgo__$Tess2_ActiveRegion();
	var e = tess.mesh.makeEdge();
	e.Org.s = smax;
	e.Org.t = t;
	e.get_Dst().s = smin;
	e.get_Dst().t = t;
	tess.event = e.get_Dst();
	reg.eUp = e;
	reg.windingNumber = 0;
	reg.inside = false;
	reg.fixUpperEdge = false;
	reg.sentinel = true;
	reg.dirty = false;
	reg.nodeUp = tess.dict.insert(reg);
};
hxGeomAlgo__$Tess2_Sweep.initEdgeDict = function(tess) {
	tess.dict = new hxGeomAlgo__$Tess2_Dict(tess,hxGeomAlgo__$Tess2_Sweep.edgeLeq);
	var w = tess.bmax[0] - tess.bmin[0];
	var h = tess.bmax[1] - tess.bmin[1];
	var smin = tess.bmin[0] - w;
	var smax = tess.bmax[0] + w;
	var tmin = tess.bmin[1] - h;
	var tmax = tess.bmax[1] + h;
	hxGeomAlgo__$Tess2_Sweep.addSentinel(tess,smin,smax,tmin);
	hxGeomAlgo__$Tess2_Sweep.addSentinel(tess,smin,smax,tmax);
};
hxGeomAlgo__$Tess2_Sweep.doneEdgeDict = function(tess) {
	var reg;
	var fixedEdges = 0;
	while(true) {
		reg = tess.dict.min().key;
		if(!(reg != null)) {
			break;
		}
		if(!reg.sentinel) {
			var cond = ++fixedEdges == 1;
		}
		hxGeomAlgo__$Tess2_Sweep.deleteRegion(tess,reg);
	}
};
hxGeomAlgo__$Tess2_Sweep.removeDegenerateEdges = function(tess) {
	var eNext;
	var eLnext;
	var eHead = tess.mesh.eHead;
	var e = eHead.next;
	while(e != eHead) {
		eNext = e.next;
		eLnext = e.Lnext;
		if(hxGeomAlgo__$Tess2_Geom.vertEq(e.Org,e.get_Dst()) && e.Lnext.Lnext != e) {
			hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,eLnext,e);
			tess.mesh.delete(e);
			e = eLnext;
			eLnext = e.Lnext;
		}
		if(eLnext.Lnext == e) {
			if(eLnext != e) {
				if(eLnext == eNext || eLnext == eNext.Sym) {
					eNext = eNext.next;
				}
				tess.mesh.delete(eLnext);
			}
			if(e == eNext || e == eNext.Sym) {
				eNext = eNext.next;
			}
			tess.mesh.delete(e);
		}
		e = eNext;
	}
};
hxGeomAlgo__$Tess2_Sweep.initPriorityQ = function(tess) {
	var vertexCount = 0;
	var vHead = tess.mesh.vHead;
	var v = vHead.next;
	while(v != vHead) {
		++vertexCount;
		v = v.next;
	}
	vertexCount += 8;
	var pq = tess.pq = new hxGeomAlgo__$Tess2_PriorityQ(vertexCount,hxGeomAlgo__$Tess2_Geom.vertLeq);
	vHead = tess.mesh.vHead;
	v = vHead.next;
	while(v != vHead) {
		v.pqHandle = pq.insert(v);
		v = v.next;
	}
	if(v != vHead) {
		return false;
	}
	pq.init();
	return true;
};
hxGeomAlgo__$Tess2_Sweep.donePriorityQ = function(tess) {
	tess.pq = null;
};
hxGeomAlgo__$Tess2_Sweep.removeDegenerateFaces = function(tess,mesh) {
	var fNext;
	var e;
	var f = mesh.fHead.next;
	while(f != mesh.fHead) {
		fNext = f.next;
		e = f.anEdge;
		if(e.Lnext.Lnext == e) {
			hxGeomAlgo__$Tess2_Sweep.addWinding(e.Onext,e);
			tess.mesh.delete(e);
		}
		f = fNext;
	}
	return true;
};
hxGeomAlgo__$Tess2_Sweep.computeInterior = function(tess) {
	var v;
	var vNext;
	hxGeomAlgo__$Tess2_Sweep.removeDegenerateEdges(tess);
	if(!hxGeomAlgo__$Tess2_Sweep.initPriorityQ(tess)) {
		return false;
	}
	hxGeomAlgo__$Tess2_Sweep.initEdgeDict(tess);
	var pq = tess.pq;
	while(true) {
		v = tess.pq.extractMin();
		if(!(v != null)) {
			break;
		}
		while(true) {
			vNext = tess.pq.min();
			if(vNext == null || !hxGeomAlgo__$Tess2_Geom.vertEq(vNext,v)) {
				break;
			}
			vNext = tess.pq.extractMin();
			hxGeomAlgo__$Tess2_Sweep.spliceMergeVertices(tess,v.anEdge,vNext.anEdge);
		}
		hxGeomAlgo__$Tess2_Sweep.sweepEvent(tess,v);
	}
	tess.event = tess.dict.min().key.eUp.Org;
	hxGeomAlgo__$Tess2_Sweep.debugEvent(tess);
	hxGeomAlgo__$Tess2_Sweep.doneEdgeDict(tess);
	hxGeomAlgo__$Tess2_Sweep.donePriorityQ(tess);
	if(!hxGeomAlgo__$Tess2_Sweep.removeDegenerateFaces(tess,tess.mesh)) {
		return false;
	}
	tess.mesh.check();
	return true;
};
var hxGeomAlgo_Tesselator = $hx_exports["hxGeomAlgo"]["Tesselator"] = function() {
	this.elementCount = 0;
	this.elements = [];
	this.vertexCount = 0;
	this.vertexIndices = [];
	this.vertices = [];
	this.vertexIndexCounter = 0;
	this.event = null;
	this.pq = null;
	this.dict = null;
	this.bmax = [0.0,0.0];
	this.bmin = [0.0,0.0];
	this.tUnit = [0.0,0.0,0.0];
	this.sUnit = [0.0,0.0,0.0];
	this.normal = [0.0,0.0,0.0];
	this.mesh = null;
	this.windingRule = hxGeomAlgo_WindingRule.ODD;
};
hxGeomAlgo_Tesselator.__name__ = true;
hxGeomAlgo_Tesselator.prototype = {
	dot_: function(u,v) {
		return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
	}
	,normalize_: function(v) {
		var len = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
		len = Math.sqrt(len);
		v[0] /= len;
		v[1] /= len;
		v[2] /= len;
	}
	,longAxis_: function(v) {
		var i = 0;
		if(Math.abs(v[1]) > Math.abs(v[0])) {
			i = 1;
		}
		if(Math.abs(v[2]) > Math.abs(v[i])) {
			i = 2;
		}
		return i;
	}
	,computeNormal_: function(norm) {
		var c;
		var tLen2;
		var maxVal = [.0,.0,.0];
		var minVal = [.0,.0,.0];
		var d1 = [.0,.0,.0];
		var d2_0 = .0;
		var d2_1 = .0;
		var d2_2 = .0;
		var tNorm_0 = .0;
		var tNorm_1 = .0;
		var tNorm_2 = .0;
		var maxVert = [null,null,null];
		var minVert = [null,null,null];
		var vHead = this.mesh.vHead;
		var v = vHead.next;
		c = v.coords[0];
		minVal[0] = c;
		minVert[0] = v;
		maxVal[0] = c;
		maxVert[0] = v;
		c = v.coords[1];
		minVal[1] = c;
		minVert[1] = v;
		maxVal[1] = c;
		maxVert[1] = v;
		c = v.coords[2];
		minVal[2] = c;
		minVert[2] = v;
		maxVal[2] = c;
		maxVert[2] = v;
		v = vHead.next;
		while(v != vHead) {
			c = v.coords[0];
			if(c < minVal[0]) {
				minVal[0] = c;
				minVert[0] = v;
			}
			if(c > maxVal[0]) {
				maxVal[0] = c;
				maxVert[0] = v;
			}
			c = v.coords[1];
			if(c < minVal[1]) {
				minVal[1] = c;
				minVert[1] = v;
			}
			if(c > maxVal[1]) {
				maxVal[1] = c;
				maxVert[1] = v;
			}
			c = v.coords[2];
			if(c < minVal[2]) {
				minVal[2] = c;
				minVert[2] = v;
			}
			if(c > maxVal[2]) {
				maxVal[2] = c;
				maxVert[2] = v;
			}
			v = v.next;
		}
		var i = 0;
		if(maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) {
			i = 1;
		}
		if(maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) {
			i = 2;
		}
		if(minVal[i] >= maxVal[i]) {
			norm[0] = 0;
			norm[1] = 0;
			norm[2] = 1;
			return;
		}
		var maxLen2 = .0;
		var v1 = minVert[i];
		var v2 = maxVert[i];
		d1[0] = v1.coords[0] - v2.coords[0];
		d1[1] = v1.coords[1] - v2.coords[1];
		d1[2] = v1.coords[2] - v2.coords[2];
		v = vHead.next;
		while(v != vHead) {
			d2_0 = v.coords[0] - v2.coords[0];
			d2_1 = v.coords[1] - v2.coords[1];
			d2_2 = v.coords[2] - v2.coords[2];
			tNorm_0 = d1[1] * d2_2 - d1[2] * d2_1;
			tNorm_1 = d1[2] * d2_0 - d1[0] * d2_2;
			tNorm_2 = d1[0] * d2_1 - d1[1] * d2_0;
			tLen2 = tNorm_0 * tNorm_0 + tNorm_1 * tNorm_1 + tNorm_2 * tNorm_2;
			if(tLen2 > maxLen2) {
				maxLen2 = tLen2;
				norm[0] = tNorm_0;
				norm[1] = tNorm_1;
				norm[2] = tNorm_2;
			}
			v = v.next;
		}
		if(maxLen2 <= 0) {
			norm[0] = norm[1] = norm[2] = 0;
			norm[this.longAxis_(d1)] = 1;
		}
	}
	,checkOrientation_: function() {
		var fHead = this.mesh.fHead;
		var v;
		var vHead = this.mesh.vHead;
		var e;
		var area = .0;
		var f = fHead.next;
		while(f != fHead) {
			e = f.anEdge;
			if(e.winding <= 0) {
				f = f.next;
				continue;
			}
			while(true) {
				area += (e.Org.s - e.get_Dst().s) * (e.Org.t + e.get_Dst().t);
				e = e.Lnext;
				if(!(e != f.anEdge)) {
					break;
				}
			}
			f = f.next;
		}
		if(area < 0) {
			v = vHead.next;
			while(v != vHead) {
				v.t = -v.t;
				v = v.next;
			}
			this.tUnit[0] = -this.tUnit[0];
			this.tUnit[1] = -this.tUnit[1];
			this.tUnit[2] = -this.tUnit[2];
		}
	}
	,projectPolygon_: function() {
		var vHead = this.mesh.vHead;
		var norm = [.0,.0,.0];
		var computedNormal = false;
		norm[0] = this.normal[0];
		norm[1] = this.normal[1];
		norm[2] = this.normal[2];
		if(norm[0] == 0.0 && norm[1] == 0.0 && norm[2] == 0.0) {
			this.computeNormal_(norm);
			computedNormal = true;
		}
		var sUnit = this.sUnit;
		var tUnit = this.tUnit;
		var i = this.longAxis_(norm);
		sUnit[i] = 0;
		sUnit[(i + 1) % 3] = 1.0;
		sUnit[(i + 2) % 3] = 0.0;
		tUnit[i] = 0;
		tUnit[(i + 1) % 3] = 0.0;
		tUnit[(i + 2) % 3] = norm[i] > 0 ? 1.0 : -1.0;
		var v = vHead.next;
		while(v != vHead) {
			v.s = this.dot_(v.coords,sUnit);
			v.t = this.dot_(v.coords,tUnit);
			v = v.next;
		}
		if(computedNormal) {
			this.checkOrientation_();
		}
		var first = true;
		v = vHead.next;
		while(v != vHead) {
			if(first) {
				var tmp = this.bmax[0] = v.s;
				this.bmin[0] = tmp;
				var tmp1 = this.bmax[1] = v.t;
				this.bmin[1] = tmp1;
				first = false;
			} else {
				if(v.s < this.bmin[0]) {
					this.bmin[0] = v.s;
				}
				if(v.s > this.bmax[0]) {
					this.bmax[0] = v.s;
				}
				if(v.t < this.bmin[1]) {
					this.bmin[1] = v.t;
				}
				if(v.t > this.bmax[1]) {
					this.bmax[1] = v.t;
				}
			}
			v = v.next;
		}
	}
	,addWinding_: function(eDst,eSrc) {
		eDst.winding += eSrc.winding;
		eDst.Sym.winding += eSrc.Sym.winding;
	}
	,tessellateMonoRegion_: function(mesh,face) {
		var up = face.anEdge;
		while(hxGeomAlgo__$Tess2_Geom.vertLeq(up.get_Dst(),up.Org)) up = up.get_Lprev();
		while(hxGeomAlgo__$Tess2_Geom.vertLeq(up.Org,up.get_Dst())) up = up.Lnext;
		var lo = up.get_Lprev();
		while(up.Lnext != lo) if(hxGeomAlgo__$Tess2_Geom.vertLeq(up.get_Dst(),lo.Org)) {
			while(lo.Lnext != up && (hxGeomAlgo__$Tess2_Geom.edgeGoesLeft(lo.Lnext) || hxGeomAlgo__$Tess2_Geom.edgeSign(lo.Org,lo.get_Dst(),lo.Lnext.get_Dst()) <= 0.0)) {
				var tempHalfEdge = mesh.connect(lo.Lnext,lo);
				lo = tempHalfEdge.Sym;
			}
			lo = lo.get_Lprev();
		} else {
			while(lo.Lnext != up && (hxGeomAlgo__$Tess2_Geom.edgeGoesRight(up.get_Lprev()) || hxGeomAlgo__$Tess2_Geom.edgeSign(up.get_Dst(),up.Org,up.get_Lprev().Org) >= 0.0)) {
				var tempHalfEdge1 = mesh.connect(up,up.get_Lprev());
				up = tempHalfEdge1.Sym;
			}
			up = up.Lnext;
		}
		while(lo.Lnext.Lnext != up) {
			var tempHalfEdge = mesh.connect(lo.Lnext,lo);
			lo = tempHalfEdge.Sym;
		}
		return true;
	}
	,tessellateInterior_: function(mesh) {
		var next;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			next = f.next;
			if(f.inside) {
				if(!this.tessellateMonoRegion_(mesh,f)) {
					return false;
				}
			}
			f = next;
		}
		return true;
	}
	,refineDelaunay_: function(mesh) {
		var stack = [];
		var e;
		var edges_0 = null;
		var edges_1 = null;
		var edges_2 = null;
		var edges_3 = null;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(f.inside) {
				e = f.anEdge;
				while(true) {
					e.mark = hxGeomAlgo__$Tess2_Geom.edgeIsInternal(e);
					if(e.mark && !e.Sym.mark) {
						stack.push(e);
					}
					e = e.Lnext;
					if(!(e != f.anEdge)) {
						break;
					}
				}
			}
			f = f.next;
		}
		while(stack.length > 0) {
			e = stack.pop();
			e.mark = e.Sym.mark = false;
			if(!hxGeomAlgo__$Tess2_Geom.edgeIsLocallyDelaunay(e)) {
				hxGeomAlgo__$Tess2_TessMesh.flipEdge(mesh,e);
				edges_0 = e.Lnext;
				edges_1 = e.get_Lprev();
				edges_2 = e.Sym.Lnext;
				edges_3 = e.Sym.get_Lprev();
				if(!edges_0.mark && hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edges_0)) {
					edges_0.mark = edges_0.Sym.mark = true;
					stack.push(edges_0);
				}
				if(!edges_1.mark && hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edges_1)) {
					edges_1.mark = edges_1.Sym.mark = true;
					stack.push(edges_1);
				}
				if(!edges_2.mark && hxGeomAlgo__$Tess2_Geom.edgeIsInternal(edges_2)) {
					edges_2.mark = edges_2.Sym.mark = true;
					stack.push(edges_2);
				}
			}
		}
		var _g = 0;
		while(_g < stack.length) {
			var e = stack[_g];
			++_g;
			stack.pop();
		}
		stack = null;
	}
	,discardExterior_: function(mesh) {
		var next;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			next = f.next;
			if(!f.inside) {
				mesh.zapFace(f);
			}
			f = next;
		}
	}
	,setWindingNumber_: function(mesh,value,keepOnlyBoundary) {
		var eNext;
		var e = mesh.eHead.next;
		while(e != mesh.eHead) {
			eNext = e.next;
			if(e.get_Rface().inside != e.Lface.inside) {
				e.winding = e.Lface.inside ? value : -value;
			} else if(!keepOnlyBoundary) {
				e.winding = 0;
			} else {
				mesh.delete(e);
			}
			e = eNext;
		}
	}
	,getNeighbourFace_: function(edge) {
		if(edge.get_Rface() == null) {
			return -1;
		}
		if(!edge.get_Rface().inside) {
			return -1;
		}
		return edge.get_Rface().n;
	}
	,outputPolymesh_: function(mesh,resultsType,polySize,vertexDim) {
		var edge;
		var maxFaceCount = 0;
		var maxVertexCount = 0;
		var faceVerts;
		var i;
		var elements = 0;
		var vert;
		if(polySize > 3) {
			mesh.mergeConvexFaces(polySize);
		}
		var v = mesh.vHead.next;
		while(v != mesh.vHead) {
			v.n = -1;
			v = v.next;
		}
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			f.n = -1;
			if(!f.inside) {
				f = f.next;
				continue;
			}
			edge = f.anEdge;
			faceVerts = 0;
			while(true) {
				v = edge.Org;
				if(v.n == -1) {
					v.n = maxVertexCount;
					++maxVertexCount;
				}
				++faceVerts;
				edge = edge.Lnext;
				if(!(edge != f.anEdge)) {
					break;
				}
			}
			f.n = maxFaceCount;
			++maxFaceCount;
			f = f.next;
		}
		this.elementCount = maxFaceCount;
		if(resultsType == hxGeomAlgo_ResultType.CONNECTED_POLYGONS) {
			maxFaceCount *= 2;
		}
		this.elements = [];
		this.vertexCount = maxVertexCount;
		this.vertices = [];
		this.vertexIndices = [];
		v = mesh.vHead.next;
		while(v != mesh.vHead) {
			if(v.n != -1) {
				var idx = v.n * vertexDim;
				this.vertices[idx] = v.coords[0];
				this.vertices[idx + 1] = v.coords[1];
				if(vertexDim > 2) {
					this.vertices[idx + 2] = v.coords[2];
				}
				this.vertexIndices[v.n] = v.idx;
			}
			v = v.next;
		}
		var nel = 0;
		f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			edge = f.anEdge;
			faceVerts = 0;
			while(true) {
				v = edge.Org;
				this.elements[nel++] = v.n;
				++faceVerts;
				edge = edge.Lnext;
				if(!(edge != f.anEdge)) {
					break;
				}
			}
			var _g = faceVerts;
			var _g1 = polySize;
			while(_g < _g1) {
				var i = _g++;
				this.elements[nel++] = -1;
			}
			if(resultsType == hxGeomAlgo_ResultType.CONNECTED_POLYGONS) {
				edge = f.anEdge;
				while(true) {
					this.elements[nel++] = this.getNeighbourFace_(edge);
					edge = edge.Lnext;
					if(!(edge != f.anEdge)) {
						break;
					}
				}
				var _g2 = faceVerts;
				var _g3 = polySize;
				while(_g2 < _g3) {
					var i1 = _g2++;
					this.elements[nel++] = -1;
				}
			}
			f = f.next;
		}
	}
	,outputContours_: function(mesh,vertexDim) {
		var edge;
		var start;
		var verts;
		var elements;
		var vertInds;
		var startVert = 0;
		var vertCount = 0;
		this.vertexCount = 0;
		this.elementCount = 0;
		var f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			edge = f.anEdge;
			start = edge;
			while(true) {
				this.vertexCount++;
				edge = edge.Lnext;
				if(!(edge != start)) {
					break;
				}
			}
			this.elementCount++;
			f = f.next;
		}
		this.elements = [];
		this.vertices = [];
		this.vertexIndices = [];
		var nv = 0;
		var nvi = 0;
		var nel = 0;
		startVert = 0;
		f = mesh.fHead.next;
		while(f != mesh.fHead) {
			if(!f.inside) {
				f = f.next;
				continue;
			}
			vertCount = 0;
			edge = f.anEdge;
			start = edge;
			while(true) {
				this.vertices[nv++] = edge.Org.coords[0];
				this.vertices[nv++] = edge.Org.coords[1];
				if(vertexDim > 2) {
					this.vertices[nv++] = edge.Org.coords[2];
				}
				this.vertexIndices[nvi++] = edge.Org.idx;
				++vertCount;
				edge = edge.Lnext;
				if(!(edge != start)) {
					break;
				}
			}
			this.elements[nel++] = startVert;
			this.elements[nel++] = vertCount;
			startVert += vertCount;
			f = f.next;
		}
	}
	,addContour: function(vertexDim,vertices) {
		if(this.mesh == null) {
			this.mesh = new hxGeomAlgo__$Tess2_TessMesh();
		}
		if(vertexDim < 2) {
			vertexDim = 2;
		}
		if(vertexDim > 3) {
			vertexDim = 3;
		}
		var e = null;
		var i = 0;
		while(i < vertices.length) {
			if(e == null) {
				e = this.mesh.makeEdge();
				this.mesh.splice(e,e.Sym);
			} else {
				this.mesh.splitEdge(e);
				e = e.Lnext;
			}
			e.Org.coords[0] = vertices[i];
			e.Org.coords[1] = vertices[i + 1];
			if(vertexDim > 2) {
				e.Org.coords[2] = vertices[i + 2];
			} else {
				e.Org.coords[2] = 0.0;
			}
			e.Org.idx = this.vertexIndexCounter++;
			e.winding = 1;
			e.Sym.winding = -1;
			i += vertexDim;
		}
	}
	,tesselate: function(windingRule,resultType,polySize,vertexDim,normal) {
		this.vertices = [];
		this.elements = [];
		this.vertexIndices = [];
		this.vertexIndexCounter = 0;
		if(normal != null) {
			this.normal[0] = normal[0];
			this.normal[1] = normal[1];
			this.normal[2] = normal[2];
		}
		this.windingRule = windingRule;
		if(vertexDim < 2) {
			vertexDim = 2;
		}
		if(vertexDim > 3) {
			vertexDim = 3;
		}
		if(this.mesh == null) {
			return false;
		}
		this.projectPolygon_();
		hxGeomAlgo__$Tess2_Sweep.computeInterior(this);
		var mesh = this.mesh;
		if(resultType == hxGeomAlgo_ResultType.BOUNDARY_CONTOURS) {
			this.setWindingNumber_(mesh,1,true);
		} else {
			this.tessellateInterior_(mesh);
			if(resultType == hxGeomAlgo_ResultType.EXPERIMENTAL_DELAUNAY) {
				this.refineDelaunay_(mesh);
				polySize = 3;
			}
		}
		mesh.check();
		if(resultType == hxGeomAlgo_ResultType.BOUNDARY_CONTOURS) {
			this.outputContours_(mesh,vertexDim);
		} else {
			this.outputPolymesh_(mesh,resultType,polySize,vertexDim);
		}
		return true;
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var kitGL_glWeb_AnimateTimer = function() { };
kitGL_glWeb_AnimateTimer.__name__ = true;
kitGL_glWeb_AnimateTimer.loop = function(tim) {
	window.requestAnimationFrame(kitGL_glWeb_AnimateTimer.loop);
	if(kitGL_glWeb_AnimateTimer.onFrame != null) {
		kitGL_glWeb_AnimateTimer.onFrame(kitGL_glWeb_AnimateTimer.counter);
	}
	kitGL_glWeb_AnimateTimer.counter++;
	return true;
};
var kitGL_glWeb_DivertTrace = function(left_) {
	if(left_ == null) {
		left_ = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	var doc = window.document;
	this.traceDiv = doc.createElement("div");
	doc.body.appendChild(this.traceDiv);
	var dom = this.traceDiv;
	var style = dom.style;
	style.position = "absolute";
	style.top = Std.string(0 + "px");
	style.left = Std.string(left_ + "px");
	style.height = Std.string(500 + "px");
	style.width = Std.string(500 + "px");
	style.zIndex = "99";
	style.overflow = "auto";
	haxe_Log.trace = $bind(this,this.myTrace);
	window.onerror = $bind(this,this.myError);
};
kitGL_glWeb_DivertTrace.__name__ = true;
kitGL_glWeb_DivertTrace.prototype = {
	myError: function(msg,url,lineNo,columnNo,errorObj) {
		var arr = url.split("/");
		var file = arr[arr.length - 2] + " " + arr[arr.length - 1];
		var str = this.textStyle0;
		str += "ERROR: " + file + " ( " + (lineNo == null ? "null" : "" + lineNo) + ": " + (columnNo == null ? "null" : "" + columnNo) + " )";
		str += "</span>";
		str += "<br> - ";
		str += this.textStyle1;
		str += Std.string(msg);
		str += "</span>";
		str += "<br>";
		this.traceString += str;
		this.traceDiv.innerHTML = this.traceString;
		return false;
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
};
var kitGL_glWeb_ImageLoader = function(imageNames,loaded_,traceOut) {
	if(traceOut == null) {
		traceOut = false;
	}
	this.images = new haxe_ds_StringMap();
	if(traceOut == true) {
		this.imageLoaded = $bind(this,this.traceImageLoad);
		this.imageFinish = $bind(this,this.traceFinish);
	}
	this.imageArr = [];
	this.loaded = loaded_;
	this.count = imageNames.length;
	var _g = 0;
	while(_g < imageNames.length) {
		var name = imageNames[_g];
		++_g;
		this.load(name);
	}
};
kitGL_glWeb_ImageLoader.__name__ = true;
kitGL_glWeb_ImageLoader.prototype = {
	traceImageLoad: function(name,count) {
		haxe_Log.trace("store " + name + " " + count,{ fileName : "kitGL/glWeb/ImageLoader.js.hx", lineNumber : 32, className : "kitGL.glWeb.ImageLoader", methodName : "traceImageLoad"});
	}
	,traceFinish: function() {
		haxe_Log.trace("finish",{ fileName : "kitGL/glWeb/ImageLoader.js.hx", lineNumber : 35, className : "kitGL.glWeb.ImageLoader", methodName : "traceFinish"});
	}
	,load: function(img) {
		var image = new Image();
		var imgStyle = image.style;
		this.topLeft(image);
		var _g = $bind(this,this.store);
		var image1 = image;
		var name = img.split("/").pop();
		image.onload = function(index,e) {
			_g(image1,name,index,e);
		};
		image.src = img;
	}
	,loadEncoded: function(imageEncoded,imageNames) {
		this.count = imageNames.length;
		var _g = 0;
		var _g1 = this.count;
		while(_g < _g1) {
			var i = _g++;
			haxe_Log.trace("loadEncoded " + i + "imageNames " + imageNames[i],{ fileName : "kitGL/glWeb/ImageLoader.js.hx", lineNumber : 50, className : "kitGL.glWeb.ImageLoader", methodName : "loadEncoded"});
			this.encodedLoad(imageEncoded[i],imageNames[i],i);
		}
	}
	,encodedLoad: function(imgStr,name,index) {
		haxe_Log.trace(" load encode ",{ fileName : "kitGL/glWeb/ImageLoader.js.hx", lineNumber : 56, className : "kitGL.glWeb.ImageLoader", methodName : "encodedLoad"});
		var image = new Image();
		this.topLeft(image);
		var _g = $bind(this,this.store);
		var image1 = image;
		var name1 = name;
		var index1 = index;
		image.onload = function(e) {
			_g(image1,name1,index1,e);
		};
		image.src = imgStr;
		haxe_Log.trace(image,{ fileName : "kitGL/glWeb/ImageLoader.js.hx", lineNumber : 62, className : "kitGL.glWeb.ImageLoader", methodName : "encodedLoad"});
	}
	,topLeft: function(image) {
		var imgStyle = image.style;
		imgStyle.left = "0px";
		imgStyle.top = "0px";
		imgStyle.paddingLeft = "0px";
		imgStyle.paddingTop = "0px";
		imgStyle.position = "absolute";
	}
	,store: function(image,name,index,e) {
		this.count--;
		if(this.imageLoaded != null) {
			this.imageLoaded(name,this.count);
		}
		this.images.h[name] = image;
		this.imageArr[index] = image;
		if(this.count == 0) {
			this.loaded();
			if(this.imageFinish != null) {
				this.imageFinish();
			}
		}
	}
};
var kitGL_glWeb_Sheet = function() {
};
kitGL_glWeb_Sheet.__name__ = true;
kitGL_glWeb_Sheet.prototype = {
	create: function(width_,height_,autoChild) {
		if(autoChild == null) {
			autoChild = false;
		}
		if(height_ == null) {
			height_ = 600;
		}
		if(width_ == null) {
			width_ = 600;
		}
		this.width = width_;
		this.height = height_;
		this.canvasGL = window.document.createElement("canvas");
		this.canvasGL.width = this.width;
		this.canvasGL.height = this.height;
		window.document.body.style.overflow = "hidden";
		window.document.body.style.position = "fixed";
		var bodyEL = window.document.body;
		var style = bodyEL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		this.domGL = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			window.document.body.appendChild(this.canvasGL);
		}
		this.canvas2D = window.document.createElement("canvas");
		this.canvas2D.width = this.width;
		this.canvas2D.height = this.height;
		this.domGL2D = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			window.document.body.appendChild(this.canvas2D);
		}
		this.gl = this.canvasGL.getContext("webgl",{ premultipliedAlpha : false});
		this.cx = this.canvas2D.getContext("2d");
	}
};
var trilateral3_Trilateral = function() { };
trilateral3_Trilateral.__name__ = true;
var trilateral3_drawing_Contour = function(pen_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.count = 0;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.pen = pen_;
	this.endLine = endLine_;
};
trilateral3_drawing_Contour.__name__ = true;
trilateral3_drawing_Contour.prototype = {
	addQuads: function(clockWise,width_) {
		var currQuadIndex = this.pen.paintType.get_pos();
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.kbx;
				var by = this.kby;
				var cx = this.ncx;
				var cy = this.ncy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.kbx;
				var by = this.kby;
				var cx = this.jxOld;
				var cy = this.jyOld;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			}
			var v = this.quadIndex;
			this.pen.paintType.set_pos(v);
			var _this = this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this.currentColor;
			}
			var ax = this.kax;
			var ay = this.kay;
			var bx = this.kbx;
			var by = this.kby;
			var cx = this.jx;
			var cy = this.jy;
			var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this.paintType.cornerColors(color,color,color);
			_this.paintType.next();
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				var v = this.quadIndex;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.kbx;
				var by = this.kby;
				var cx = this.jx;
				var cy = this.jy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.kbx;
				var by = this.kby;
				var cx = this.ncx;
				var cy = this.ncy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				var v = this.quadIndex;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.jxOld;
				var ay = this.jyOld;
				var bx = this.kbx;
				var by = this.kby;
				var cx = this.jx;
				var cy = this.jy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.jxOld;
				var ay = this.jyOld;
				var bx = this.kbx;
				var by = this.kby;
				var cx = this.ncx;
				var cy = this.ncy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			}
		}
		if(!clockWise && !this.lastClock) {
			var v = this.quadIndex;
			this.pen.paintType.set_pos(v);
			var _this = this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this.currentColor;
			}
			var ax = this.kax;
			var ay = this.kay;
			var bx = this.jx;
			var by = this.jy;
			var cx = this.kcx;
			var cy = this.kcy;
			var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this.paintType.cornerColors(color,color,color);
			_this.paintType.next();
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.jx;
				var by = this.jy;
				var cx = this.ncx;
				var cy = this.ncy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.jx;
				var by = this.jy;
				var cx = this.jxOld;
				var cy = this.jyOld;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				var v = this.quadIndex;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.jx;
				var by = this.jy;
				var cx = this.kcx;
				var cy = this.kcy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.kax;
				var ay = this.kay;
				var bx = this.jx;
				var by = this.jy;
				var cx = this.ncx;
				var cy = this.ncy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				var v = this.quadIndex;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.jxOld;
				var ay = this.jyOld;
				var bx = this.jx;
				var by = this.jy;
				var cx = this.kcx;
				var cy = this.kcy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
				var v = this.quadIndex + 1;
				this.pen.paintType.set_pos(v);
				var _this = this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this.currentColor;
				}
				var ax = this.jxOld;
				var ay = this.jyOld;
				var bx = this.jx;
				var by = this.jy;
				var cx = this.ncx;
				var cy = this.ncy;
				var windAdjust = _this.paintType.triangle(ax,ay,_this.z2D,bx,by,_this.z2D,cx,cy,_this.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this.paintType.cornerColors(color,color,color);
				_this.paintType.next();
			}
		}
		this.pen.paintType.set_pos(currQuadIndex);
	}
};
var trilateral3_drawing_Pen = function(paintType_) {
	this.currentColor = 16435934;
	this.useTexture = false;
	this.z2D = 0.;
	this.paintType = paintType_;
};
trilateral3_drawing_Pen.__name__ = true;
var trilateral3_drawing_Sketch = function(pen_,sketchForm_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.width = 0.01;
	this.y = 0.;
	this.x = 0.;
	this.contour = new trilateral3_drawing_Contour(pen_,endLine_);
	this.pen = pen_;
	this.endLine = endLine_;
	this.sketchForm = sketchForm_;
	switch(sketchForm_) {
	case 0:
		this.line = $bind(this,this.tracerLine);
		break;
	case 1:
		this.line = $bind(this,this.baseLine);
		break;
	case 2:
		this.line = $bind(this,this.crudeLine);
		break;
	case 3:
		this.line = $bind(this,this.fillOnlyLine);
		break;
	case 4:
		this.line = $bind(this,this.fineLine);
		break;
	case 5:
		this.line = $bind(this,this.fineOverlapLine);
		break;
	case 6:
		this.line = $bind(this,this.mediumLine);
		break;
	case 7:
		this.line = $bind(this,this.mediumOverlapLine);
		break;
	case 8:
		this.line = $bind(this,this.roundEndLine);
		break;
	}
	this.points = [];
	this.pointsClock = [];
	this.pointsAnti = [];
	this.points[0] = [];
	this.dim = [];
};
trilateral3_drawing_Sketch.__name__ = true;
trilateral3_drawing_Sketch.prototype = {
	tracerLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "trilateral3/drawing/Sketch.hx", lineNumber : 38, className : "trilateral3.drawing.Sketch", methodName : "tracerLine"});
	}
	,fillOnlyLine: function(x_,y_) {
	}
	,baseLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "trilateral3/drawing/Sketch.hx", lineNumber : 38, className : "trilateral3.drawing.Sketch", methodName : "tracerLine"});
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.halfA = Math.PI / 2;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var dxPrev_ = _this.dx;
		var dyPrev_ = _this.dy;
		var exPrev_ = _this.ex;
		var eyPrev_ = _this.ey;
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		var ax = dxPrev_;
		var ay = dyPrev_;
		var bx = _this.dx;
		var by = _this.dy;
		var cx = exPrev_;
		var cy = eyPrev_;
		var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this1.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
		}
		_this1.paintType.cornerColors(color,color,color);
		_this1.paintType.next();
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		var ax = dxPrev_;
		var ay = dyPrev_;
		var bx = _this.dx;
		var by = _this.dy;
		var cx = _this.ex;
		var cy = _this.ey;
		var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this1.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
		}
		_this1.paintType.cornerColors(color,color,color);
		_this1.paintType.next();
	}
	,crudeLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.halfA = Math.PI / 2;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var dxPrev_ = _this.dx;
		var dyPrev_ = _this.dy;
		var exPrev_ = _this.ex;
		var eyPrev_ = _this.ey;
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		var ax = dxPrev_;
		var ay = dyPrev_;
		var bx = _this.dx;
		var by = _this.dy;
		var cx = exPrev_;
		var cy = eyPrev_;
		var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this1.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
		}
		_this1.paintType.cornerColors(color,color,color);
		_this1.paintType.next();
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		var ax = dxPrev_;
		var ay = dyPrev_;
		var bx = _this.dx;
		var by = _this.dy;
		var cx = _this.ex;
		var cy = _this.ey;
		var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this1.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
		}
		_this1.paintType.cornerColors(color,color,color);
		_this1.paintType.next();
	}
	,roundEndLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var endLineCurve = 3;
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.halfA = Math.PI / 2;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var dxPrev_ = _this.dx;
		var dyPrev_ = _this.dy;
		var exPrev_ = _this.ex;
		var eyPrev_ = _this.ey;
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var drawType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _g = _this.pen.paintType;
			var v = _g.get_pos() - len;
			_g.set_pos(v);
			var _this1 = _this.pen;
			var color = 0;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			break;
		case 2:
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 - Math.PI;
			var drawType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = x_ + radius * Math.sin(angle);
				cy = y_ + radius * Math.cos(angle);
				if(i != 0) {
					drawType.triangle(x_,y_,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _g = _this.pen.paintType;
			var v = _g.get_pos() - len;
			_g.set_pos(v);
			var _this1 = _this.pen;
			var color = 0;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			break;
		case 3:
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var drawType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _g = _this.pen.paintType;
			var v = _g.get_pos() - len;
			_g.set_pos(v);
			var _this1 = _this.pen;
			var color = 0;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 - Math.PI;
			var drawType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = x_ + radius * Math.sin(angle);
				cy = y_ + radius * Math.cos(angle);
				if(i != 0) {
					drawType.triangle(x_,y_,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _g = _this.pen.paintType;
			var v = _g.get_pos() - len;
			_g.set_pos(v);
			var _this1 = _this.pen;
			var color = 0;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			break;
		}
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		var ax = dxPrev_;
		var ay = dyPrev_;
		var bx = _this.dx;
		var by = _this.dy;
		var cx = exPrev_;
		var cy = eyPrev_;
		var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this1.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
		}
		_this1.paintType.cornerColors(color,color,color);
		_this1.paintType.next();
		var _this1 = _this.pen;
		var color = -1;
		if(color == null) {
			color = -1;
		}
		if(color == -1) {
			color = _this1.currentColor;
		}
		var ax = dxPrev_;
		var ay = dyPrev_;
		var bx = _this.dx;
		var by = _this.dy;
		var cx = _this.ex;
		var cy = _this.ey;
		var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
		if(trilateral3_Trilateral.transformMatrix != null) {
			_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
		}
		if(_this1.useTexture) {
			ax /= 2000;
			ay /= 2000;
			bx /= 2000;
			by /= 2000;
			cx /= 2000;
			cy /= 2000;
			_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
		}
		_this1.paintType.cornerColors(color,color,color);
		_this1.paintType.next();
	}
	,mediumLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var curveEnds = false;
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(_this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var drawType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					drawType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _g = _this.pen.paintType;
			var v = _g.get_pos() - len;
			_g.set_pos(v);
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = _this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsClock[pC++] = temp[i * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(_this.count != 0) {
			_this.addQuads(clockWise,width_);
		}
		_this.quadIndex = _this.pen.paintType.get_pos();
		if(_this.count == 0) {
			_this.penultimateAX = _this.dxPrev;
			_this.penultimateAY = _this.dyPrev;
			_this.lastAntiX = _this.ex;
			_this.lastAntiY = _this.ey;
			_this.penultimateCX = _this.dx;
			_this.penultimateCY = _this.dy;
			_this.lastClockX = _this.exPrev;
			_this.lastClockY = _this.eyPrev;
			var _this1 = _this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.ex;
			var cy = _this.ey;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
			var _this1 = _this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.exPrev;
			var cy = _this.eyPrev;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
		} else {
			if(clockWise && !_this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.exPrev;
				var cy = _this.eyPrev;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
			if(clockWise && _this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.exPrev;
				var cy = _this.eyPrev;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
			if(!clockWise && !_this.lastClock) {
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.jx;
				_this.lastClockY = _this.jy;
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
			if(!clockWise && _this.lastClock) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.jx;
				_this.penultimateCY = _this.jy;
				_this.lastClockX = _this.dx;
				_this.lastClockY = _this.dy;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.jx;
				var by = _this.jy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var drawType = _this.pen.paintType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.paintType.colorTriangles(color,len);
			} else {
				var drawType = _this.pen.paintType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.paintType.colorTriangles(color,len);
			}
		} else if(_this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxOld;
				var ay = _this.dyOld;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.exOld;
				var ay = _this.eyOld;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(curveEnds && _this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxOld;
				var by = _this.dyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exOld;
				var by = _this.eyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
	,mediumOverlapLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var curveEnds = false;
		var overlap = true;
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && _this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var drawType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					drawType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _g = _this.pen.paintType;
			var v = _g.get_pos() - len;
			_g.set_pos(v);
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = _this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsClock[pC++] = temp[i * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.ex;
			var cy = _this.ey;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.exPrev;
			var cy = _this.eyPrev;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
		} else {
			if(_this.count != 0) {
				_this.addQuads(clockWise,width_);
			}
			_this.quadIndex = _this.pen.paintType.get_pos();
			if(_this.count == 0) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.exPrev;
				var cy = _this.eyPrev;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				if(clockWise && !_this.lastClock) {
					_this.penultimateAX = _this.jx;
					_this.penultimateAY = _this.jy;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.exPrev;
					_this.lastClockY = _this.eyPrev;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.exPrev;
					var cy = _this.eyPrev;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
				if(clockWise && _this.lastClock) {
					_this.penultimateAX = _this.jx;
					_this.penultimateAY = _this.jy;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.exPrev;
					_this.lastClockY = _this.eyPrev;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.exPrev;
					var cy = _this.eyPrev;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
				if(!clockWise && !_this.lastClock) {
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.jx;
					_this.lastClockY = _this.jy;
					_this.penultimateAX = _this.dxPrev;
					_this.penultimateAY = _this.dyPrev;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxPrev;
					var ay = _this.dyPrev;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.jx;
					var cy = _this.jy;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxPrev;
					var ay = _this.dyPrev;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
				if(!clockWise && _this.lastClock) {
					_this.penultimateAX = _this.dxPrev;
					_this.penultimateAY = _this.dyPrev;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.jx;
					_this.penultimateCY = _this.jy;
					_this.lastClockX = _this.dx;
					_this.lastClockY = _this.dy;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxPrev;
					var ay = _this.dyPrev;
					var bx = _this.jx;
					var by = _this.jy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var drawType = _this.pen.paintType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.paintType.colorTriangles(color,len);
			} else {
				var drawType = _this.pen.paintType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.paintType.colorTriangles(color,len);
			}
		} else if(_this.count != 0) {
			if(overlap) {
				if(clockWise) {
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxOld;
					var ay = _this.dyOld;
					var bx = _this.exPrev;
					var by = _this.eyPrev;
					var cx = _this.ax;
					var cy = _this.ay;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				} else {
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.exOld;
					var ay = _this.eyOld;
					var bx = _this.dxPrev;
					var by = _this.dyPrev;
					var cx = _this.ax;
					var cy = _this.ay;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
			} else if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxOld;
				var ay = _this.dyOld;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.exOld;
				var ay = _this.eyOld;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(curveEnds && !overlap && _this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxOld;
				var by = _this.dyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exOld;
				var by = _this.eyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
	,fineLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var curveEnds = true;
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(_this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var drawType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					drawType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _g = _this.pen.paintType;
			var v = _g.get_pos() - len;
			_g.set_pos(v);
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = _this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsClock[pC++] = temp[i * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(_this.count != 0) {
			_this.addQuads(clockWise,width_);
		}
		_this.quadIndex = _this.pen.paintType.get_pos();
		if(_this.count == 0) {
			_this.penultimateAX = _this.dxPrev;
			_this.penultimateAY = _this.dyPrev;
			_this.lastAntiX = _this.ex;
			_this.lastAntiY = _this.ey;
			_this.penultimateCX = _this.dx;
			_this.penultimateCY = _this.dy;
			_this.lastClockX = _this.exPrev;
			_this.lastClockY = _this.eyPrev;
			var _this1 = _this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.ex;
			var cy = _this.ey;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
			var _this1 = _this.pen;
			var color = -1;
			if(color == null) {
				color = -1;
			}
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.exPrev;
			var cy = _this.eyPrev;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
		} else {
			if(clockWise && !_this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.exPrev;
				var cy = _this.eyPrev;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
			if(clockWise && _this.lastClock) {
				_this.penultimateAX = _this.jx;
				_this.penultimateAY = _this.jy;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.exPrev;
				var cy = _this.eyPrev;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
			if(!clockWise && !_this.lastClock) {
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.jx;
				_this.lastClockY = _this.jy;
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
			if(!clockWise && _this.lastClock) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.jx;
				_this.penultimateCY = _this.jy;
				_this.lastClockX = _this.dx;
				_this.lastClockY = _this.dy;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.jx;
				var ay = _this.jy;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.jx;
				var by = _this.jy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var drawType = _this.pen.paintType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.paintType.colorTriangles(color,len);
			} else {
				var drawType = _this.pen.paintType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.paintType.colorTriangles(color,len);
			}
		} else if(_this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxOld;
				var ay = _this.dyOld;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.exOld;
				var ay = _this.eyOld;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(curveEnds && _this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxOld;
				var by = _this.dyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exOld;
				var by = _this.eyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
	,fineOverlapLine: function(x_,y_) {
		var _this = this.contour;
		var ax_ = this.x;
		var ay_ = this.y;
		var width_ = this.width;
		var curveEnds = true;
		var overlap = true;
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = _this.dx != null ? _this.angle1 : null;
		_this.halfA = Math.PI / 2;
		_this.ax = x_;
		_this.ay = y_;
		_this.bx = ax_;
		_this.by = ay_;
		_this.beta = Math.PI / 2 - _this.halfA;
		_this.r = width_ / 2 * Math.cos(_this.beta);
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		_this.ax = ax_;
		_this.ay = ay_;
		_this.bx = x_;
		_this.by = y_;
		_this.theta = Math.atan2(_this.ay - _this.by,_this.ax - _this.bx);
		if(_this.theta > 0) {
			if(_this.halfA < 0) {
				_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
				_this.angle1 = _this.theta - _this.halfA;
			} else {
				_this.angle1 = _this.theta + _this.halfA - Math.PI;
				_this.angle2 = _this.theta + _this.halfA;
			}
		} else if(_this.halfA > 0) {
			_this.angle1 = _this.theta + _this.halfA - Math.PI;
			_this.angle2 = _this.theta + _this.halfA;
		} else {
			_this.angle2 = _this.theta + _this.halfA + Math.PI / 2;
			_this.angle1 = _this.theta - _this.halfA;
		}
		if(_this.dxPrev != null) {
			_this.dxOld = _this.dxPrev;
		}
		if(_this.dyPrev != null) {
			_this.dyOld = _this.dyPrev;
		}
		if(_this.exPrev != null) {
			_this.exOld = _this.exPrev;
		}
		if(_this.eyPrev != null) {
			_this.eyOld = _this.eyPrev;
		}
		if(_this.dx != null) {
			_this.dxPrev = _this.dx;
		}
		if(_this.dy != null) {
			_this.dyPrev = _this.dy;
		}
		if(_this.ex != null) {
			_this.exPrev = _this.ex;
		}
		if(_this.ey != null) {
			_this.eyPrev = _this.ey;
		}
		_this.dx = _this.bx + _this.r * Math.cos(_this.angle1);
		_this.dy = _this.by + _this.r * Math.sin(_this.angle1);
		_this.ex = _this.bx + _this.r * Math.cos(_this.angle2);
		_this.ey = _this.by + _this.r * Math.sin(_this.angle2);
		var x = _this.dxOld - x_;
		var y = _this.dyOld - y_;
		var x1 = _this.exOld - x_;
		var y1 = _this.eyOld - y_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(_this.ay - _this.dyOld,_this.ax - _this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.eyPrev,_this.ax - _this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(_this.ay - _this.eyOld,_this.ax - _this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(_this.ay - _this.dyPrev,_this.ax - _this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && _this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			_this.jx = _this.ax + h * Math.sin(delta);
			_this.jy = _this.ay + h * Math.cos(delta);
		}
		if(_this.count == 0 && (_this.endLine == 1 || _this.endLine == 3)) {
			var ax = _this.ax;
			var ay = _this.ay;
			var radius = width_ / 2;
			var beta = -_this.angle1 - Math.PI / 2;
			var gamma = -_this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var drawType = _this.pen.paintType;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					drawType.triangle(ax,ay,0,bx,by,0,cx,cy,0);
					var m = trilateral3_Trilateral.transformMatrix;
					if(m != null) {
						drawType.transform(m);
					}
					drawType.next();
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var len = totalSteps;
			var _g = _this.pen.paintType;
			var v = _g.get_pos() - len;
			_g.set_pos(v);
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			_this1.paintType.colorTriangles(color,len);
			var pA = _this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				_this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = _this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				_this.pointsClock[pC++] = temp[i * 2 + len + 1];
				_this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.ex;
			var cy = _this.ey;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
			var _this1 = _this.pen;
			var color = -1;
			if(color == -1) {
				color = _this1.currentColor;
			}
			var ax = _this.dxPrev;
			var ay = _this.dyPrev;
			var bx = _this.dx;
			var by = _this.dy;
			var cx = _this.exPrev;
			var cy = _this.eyPrev;
			var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
			if(trilateral3_Trilateral.transformMatrix != null) {
				_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
			}
			if(_this1.useTexture) {
				ax /= 2000;
				ay /= 2000;
				bx /= 2000;
				by /= 2000;
				cx /= 2000;
				cy /= 2000;
				_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
			}
			_this1.paintType.cornerColors(color,color,color);
			_this1.paintType.next();
		} else {
			if(_this.count != 0) {
				_this.addQuads(clockWise,width_);
			}
			_this.quadIndex = _this.pen.paintType.get_pos();
			if(_this.count == 0) {
				_this.penultimateAX = _this.dxPrev;
				_this.penultimateAY = _this.dyPrev;
				_this.lastAntiX = _this.ex;
				_this.lastAntiY = _this.ey;
				_this.penultimateCX = _this.dx;
				_this.penultimateCY = _this.dy;
				_this.lastClockX = _this.exPrev;
				_this.lastClockY = _this.eyPrev;
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.ex;
				var cy = _this.ey;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxPrev;
				var ay = _this.dyPrev;
				var bx = _this.dx;
				var by = _this.dy;
				var cx = _this.exPrev;
				var cy = _this.eyPrev;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				if(clockWise && !_this.lastClock) {
					_this.penultimateAX = _this.jx;
					_this.penultimateAY = _this.jy;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.exPrev;
					_this.lastClockY = _this.eyPrev;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.exPrev;
					var cy = _this.eyPrev;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
				if(clockWise && _this.lastClock) {
					_this.penultimateAX = _this.jx;
					_this.penultimateAY = _this.jy;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.exPrev;
					_this.lastClockY = _this.eyPrev;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.exPrev;
					var cy = _this.eyPrev;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
				if(!clockWise && !_this.lastClock) {
					_this.penultimateCX = _this.dx;
					_this.penultimateCY = _this.dy;
					_this.lastClockX = _this.jx;
					_this.lastClockY = _this.jy;
					_this.penultimateAX = _this.dxPrev;
					_this.penultimateAY = _this.dyPrev;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxPrev;
					var ay = _this.dyPrev;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.jx;
					var cy = _this.jy;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxPrev;
					var ay = _this.dyPrev;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
				if(!clockWise && _this.lastClock) {
					_this.penultimateAX = _this.dxPrev;
					_this.penultimateAY = _this.dyPrev;
					_this.lastAntiX = _this.ex;
					_this.lastAntiY = _this.ey;
					_this.penultimateCX = _this.jx;
					_this.penultimateCY = _this.jy;
					_this.lastClockX = _this.dx;
					_this.lastClockY = _this.dy;
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.jx;
					var ay = _this.jy;
					var bx = _this.dx;
					var by = _this.dy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxPrev;
					var ay = _this.dyPrev;
					var bx = _this.jx;
					var by = _this.jy;
					var cx = _this.ex;
					var cy = _this.ey;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var drawType = _this.pen.paintType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.paintType.colorTriangles(color,len);
			} else {
				var drawType = _this.pen.paintType;
				var radius = width_ / 2;
				var edgePoly = _this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						drawType.triangle(ax_,ay_,0,bx,by,0,cx,cy,0);
						var m = trilateral3_Trilateral.transformMatrix;
						if(m != null) {
							drawType.transform(m);
						}
						drawType.next();
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				var len = totalSteps;
				var _this1 = _this.pen;
				var color = -1;
				if(color == -1) {
					color = _this1.currentColor;
				}
				_this1.paintType.colorTriangles(color,len);
			}
		} else if(_this.count != 0) {
			if(overlap) {
				if(clockWise) {
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.dxOld;
					var ay = _this.dyOld;
					var bx = _this.exPrev;
					var by = _this.eyPrev;
					var cx = _this.ax;
					var cy = _this.ay;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				} else {
					var _this1 = _this.pen;
					var color = -1;
					if(color == null) {
						color = -1;
					}
					if(color == -1) {
						color = _this1.currentColor;
					}
					var ax = _this.exOld;
					var ay = _this.eyOld;
					var bx = _this.dxPrev;
					var by = _this.dyPrev;
					var cx = _this.ax;
					var cy = _this.ay;
					var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
					if(trilateral3_Trilateral.transformMatrix != null) {
						_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
					}
					if(_this1.useTexture) {
						ax /= 2000;
						ay /= 2000;
						bx /= 2000;
						by /= 2000;
						cx /= 2000;
						cy /= 2000;
						_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
					}
					_this1.paintType.cornerColors(color,color,color);
					_this1.paintType.next();
				}
			} else if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.dxOld;
				var ay = _this.dyOld;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.exOld;
				var ay = _this.eyOld;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.kax = _this.dxPrev;
		_this.kay = _this.dyPrev;
		_this.kbx = _this.dx;
		_this.kby = _this.dy;
		_this.ncx = _this.exPrev;
		_this.ncy = _this.eyPrev;
		_this.kcx = _this.ex;
		_this.kcy = _this.ey;
		if(curveEnds && !overlap && _this.count != 0) {
			if(clockWise) {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxOld;
				var by = _this.dyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exPrev;
				var by = _this.eyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			} else {
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.exOld;
				var by = _this.eyOld;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
				var _this1 = _this.pen;
				var color = -1;
				if(color == null) {
					color = -1;
				}
				if(color == -1) {
					color = _this1.currentColor;
				}
				var ax = _this.ax;
				var ay = _this.ay;
				var bx = _this.dxPrev;
				var by = _this.dyPrev;
				var cx = _this.jx;
				var cy = _this.jy;
				var windAdjust = _this1.paintType.triangle(ax,ay,_this1.z2D,bx,by,_this1.z2D,cx,cy,_this1.z2D);
				if(trilateral3_Trilateral.transformMatrix != null) {
					_this1.paintType.transform(trilateral3_Trilateral.transformMatrix);
				}
				if(_this1.useTexture) {
					ax /= 2000;
					ay /= 2000;
					bx /= 2000;
					by /= 2000;
					cx /= 2000;
					cy /= 2000;
					_this1.paintType.triangleUV(ax,ay,bx,by,cx,cy,windAdjust);
				}
				_this1.paintType.cornerColors(color,color,color);
				_this1.paintType.next();
			}
		}
		_this.jxOld = _this.jx;
		_this.jyOld = _this.jy;
		_this.lastClock = clockWise;
		_this.count++;
	}
};
var trilateral3_geom_FlatColorTriangles = {};
trilateral3_geom_FlatColorTriangles.transform = function(this1,m) {
	var pa = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_ax(this1),dsHelper_flatInterleave_FloatColorTriangles.get_ay(this1),dsHelper_flatInterleave_FloatColorTriangles.get_az(this1),1.);
	var pb = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_bx(this1),dsHelper_flatInterleave_FloatColorTriangles.get_by(this1),dsHelper_flatInterleave_FloatColorTriangles.get_bz(this1),1.);
	var pc = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_cx(this1),dsHelper_flatInterleave_FloatColorTriangles.get_cy(this1),dsHelper_flatInterleave_FloatColorTriangles.get_cz(this1),1.);
	var v2 = new trilateral3_matrix_Vertex(m.a * pa.x + m.b * pa.y + m.c * pa.z + m.d,m.e * pa.x + m.f * pa.y + m.g * pa.z + m.h,m.i * pa.x + m.j * pa.y + m.k * pa.z + m.l,1.);
	pa = v2;
	var v2 = new trilateral3_matrix_Vertex(m.a * pb.x + m.b * pb.y + m.c * pb.z + m.d,m.e * pb.x + m.f * pb.y + m.g * pb.z + m.h,m.i * pb.x + m.j * pb.y + m.k * pb.z + m.l,1.);
	pb = v2;
	var v2 = new trilateral3_matrix_Vertex(m.a * pc.x + m.b * pc.y + m.c * pc.z + m.d,m.e * pc.x + m.f * pc.y + m.g * pc.z + m.h,m.i * pc.x + m.j * pc.y + m.k * pc.z + m.l,1.);
	pc = v2;
	dsHelper_flatInterleave_FloatColorTriangles.set_ax(this1,pa.x);
	dsHelper_flatInterleave_FloatColorTriangles.set_ay(this1,pa.y);
	dsHelper_flatInterleave_FloatColorTriangles.set_az(this1,pa.z);
	dsHelper_flatInterleave_FloatColorTriangles.set_bx(this1,pb.x);
	dsHelper_flatInterleave_FloatColorTriangles.set_by(this1,pb.y);
	dsHelper_flatInterleave_FloatColorTriangles.set_bz(this1,pb.z);
	dsHelper_flatInterleave_FloatColorTriangles.set_cx(this1,pc.x);
	dsHelper_flatInterleave_FloatColorTriangles.set_cy(this1,pc.y);
	dsHelper_flatInterleave_FloatColorTriangles.set_cz(this1,pc.z);
};
trilateral3_geom_FlatColorTriangles.transformRange = function(this1,m,startEnd) {
	var start = startEnd.start;
	var end = startEnd.end;
	this1[0] = start;
	if(this1[0] > this1[1] - 1) {
		this1[1] = this1[0];
	}
	if(end > dsHelper_flat_io_Float32Flat.get_size(this1) - 1) {
		dsHelper_flat_io_Float32Flat.get_size(this1);
	}
	var _g = start;
	var _g1 = end + 1;
	while(_g < _g1) {
		var i = _g++;
		trilateral3_geom_FlatColorTriangles.transform(this1,m);
		var pos_ = this1[0] + 1.;
		this1[0] = pos_;
		if(this1[0] > this1[1] - 1) {
			this1[1] = this1[0];
		}
	}
};
var trilateral3_geom_FlatColorTrianglesUV = {};
trilateral3_geom_FlatColorTrianglesUV.transform = function(this1,m) {
	var pa = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(this1),dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(this1),dsHelper_flatInterleave_FloatColorTrianglesUV.get_az(this1),1.);
	var pb = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(this1),dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(this1),dsHelper_flatInterleave_FloatColorTrianglesUV.get_bz(this1),1.);
	var pc = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(this1),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(this1),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cz(this1),1.);
	var v2 = new trilateral3_matrix_Vertex(m.a * pa.x + m.b * pa.y + m.c * pa.z + m.d,m.e * pa.x + m.f * pa.y + m.g * pa.z + m.h,m.i * pa.x + m.j * pa.y + m.k * pa.z + m.l,1.);
	pa = v2;
	var v2 = new trilateral3_matrix_Vertex(m.a * pb.x + m.b * pb.y + m.c * pb.z + m.d,m.e * pb.x + m.f * pb.y + m.g * pb.z + m.h,m.i * pb.x + m.j * pb.y + m.k * pb.z + m.l,1.);
	pb = v2;
	var v2 = new trilateral3_matrix_Vertex(m.a * pc.x + m.b * pc.y + m.c * pc.z + m.d,m.e * pc.x + m.f * pc.y + m.g * pc.z + m.h,m.i * pc.x + m.j * pc.y + m.k * pc.z + m.l,1.);
	pc = v2;
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_ax(this1,pa.x);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_ay(this1,pa.y);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_az(this1,pa.z);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_bx(this1,pb.x);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_by(this1,pb.y);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_bz(this1,pb.z);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_cx(this1,pc.x);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_cy(this1,pc.y);
	dsHelper_flatInterleave_FloatColorTrianglesUV.set_cz(this1,pc.z);
};
trilateral3_geom_FlatColorTrianglesUV.transformRange = function(this1,m,startEnd) {
	var start = startEnd.start;
	var end = startEnd.end;
	this1[0] = start;
	if(this1[0] > this1[1] - 1) {
		this1[1] = this1[0];
	}
	if(end > dsHelper_flat_io_Float32Flat.get_size(this1) - 1) {
		dsHelper_flat_io_Float32Flat.get_size(this1);
	}
	var _g = start;
	var _g1 = end + 1;
	while(_g < _g1) {
		var i = _g++;
		trilateral3_geom_FlatColorTrianglesUV.transform(this1,m);
		var pos_ = this1[0] + 1.;
		this1[0] = pos_;
		if(this1[0] > this1[1] - 1) {
			this1[1] = this1[0];
		}
	}
};
var trilateral3_matrix_MatrixDozen = function(a,b,c,d,e,f,g,h,i,j,k,l) {
	this.l = 0.;
	this.k = 0.;
	this.j = 0.;
	this.i = 0.;
	this.h = 0.;
	this.g = 0.;
	this.f = 0.;
	this.e = 0.;
	this.d = 0.;
	this.c = 0.;
	this.b = 0.;
	this.a = 0.;
	this.a = a;
	this.b = b;
	this.c = c;
	this.d = d;
	this.e = e;
	this.f = f;
	this.g = g;
	this.h = h;
	this.i = i;
	this.j = j;
	this.k = k;
	this.l = l;
};
trilateral3_matrix_MatrixDozen.__name__ = true;
var trilateral3_matrix_UV = function(u,v) {
	this.v = 0.;
	this.u = 0.;
	this.u = u;
	this.v = v;
};
trilateral3_matrix_UV.__name__ = true;
var trilateral3_matrix_Vertex = function(x,y,z,w) {
	if(w == null) {
		w = 1.;
	}
	this.w = 1.;
	this.z = 0.;
	this.y = 0.;
	this.x = 0.;
	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
};
trilateral3_matrix_Vertex.__name__ = true;
var trilateral3_nodule_PenNodule = function(useGLScale) {
	if(useGLScale == null) {
		useGLScale = true;
	}
	var this1 = new Float32Array(trilateral3_nodule_PenNodule.largeEnough + 2);
	this1[0] = 0.;
	this1[1] = 0.;
	this.colorTriangles = this1;
	if(useGLScale) {
		var transform1000 = new trilateral3_matrix_MatrixDozen(0.001,0,0,-1,0,-0.001,0,1,0,0,0.001,0);
		trilateral3_Trilateral.transformMatrix = transform1000;
	}
	this.createPen();
};
trilateral3_nodule_PenNodule.__name__ = true;
trilateral3_nodule_PenNodule.prototype = {
	createPen: function() {
		var t = this.colorTriangles;
		var _e = t;
		var _e1 = t;
		var _e2 = t;
		var _e3 = t;
		var _e4 = t;
		var _e5 = t;
		var _e6 = t;
		var _e7 = t;
		var _e8 = t;
		var _e9 = t;
		var _e10 = t;
		var _e11 = t;
		var _e12 = t;
		var _e13 = t;
		var _e14 = t;
		var _e15 = t;
		var _e16 = t;
		var triangleAbstract = { rotate : function(x,y,theta) {
			var cos = Math.cos(theta);
			var sin = Math.sin(theta);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ax(_g) - x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ay(_g) - y);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_bx(_g) - x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_g,dsHelper_flatInterleave_FloatColorTriangles.get_by(_g) - y);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cx(_g) - x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cy(_g) - y);
			var dx = dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e);
			var dy = dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e);
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_e,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_e,dx * sin + dy * cos);
			dx = dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e);
			dy = dsHelper_flatInterleave_FloatColorTriangles.get_by(_e);
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_e,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_e,dx * sin + dy * cos);
			dx = dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e);
			dy = dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e);
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_e,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_e,dx * sin + dy * cos);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ax(_g) + x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ay(_g) + y);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_bx(_g) + x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_g,dsHelper_flatInterleave_FloatColorTriangles.get_by(_g) + y);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cx(_g) + x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cy(_g) + y);
		}, moveDelta : function(dx,dy) {
			dsHelper_flatInterleave_FloatColorTriangles.moveDelta(_e1,dx,dy);
		}, rotateTrig : function(x,y,cos,sin) {
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ax(_g) - x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ay(_g) - y);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_bx(_g) - x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_g,dsHelper_flatInterleave_FloatColorTriangles.get_by(_g) - y);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cx(_g) - x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cy(_g) - y);
			var dx = dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e2);
			var dy = dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e2);
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_e2,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_e2,dx * sin + dy * cos);
			dx = dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e2);
			dy = dsHelper_flatInterleave_FloatColorTriangles.get_by(_e2);
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_e2,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_e2,dx * sin + dy * cos);
			dx = dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e2);
			dy = dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e2);
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_e2,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_e2,dx * sin + dy * cos);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ax(_g) + x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_g,dsHelper_flatInterleave_FloatColorTriangles.get_ay(_g) + y);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_bx(_g) + x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_g,dsHelper_flatInterleave_FloatColorTriangles.get_by(_g) + y);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cx(_g) + x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_g,dsHelper_flatInterleave_FloatColorTriangles.get_cy(_g) + y);
		}, fullHit : function(px,py) {
			return dsHelper_flatInterleave_FloatColorTriangles.fullHit(_e3,px,py);
		}, liteHit : function(px,py) {
			var planeAB = (dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e4) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_by(_e4) - py) - (dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e4) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e4) - py);
			var planeBC = (dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e4) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e4) - py) - (dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e4) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_by(_e4) - py);
			var planeCA = (dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e4) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e4) - py) - (dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e4) - px) * (dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e4) - py);
			if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
				return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
			} else {
				return false;
			}
		}, get_bottom : function() {
			return Math.max(Math.max(dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e5),dsHelper_flatInterleave_FloatColorTriangles.get_by(_e5)),dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e5));
		}, get_back : function() {
			return Math.max(Math.max(dsHelper_flatInterleave_FloatColorTriangles.get_az(_e6),dsHelper_flatInterleave_FloatColorTriangles.get_bz(_e6)),dsHelper_flatInterleave_FloatColorTriangles.get_cz(_e6));
		}, get_right : function() {
			return Math.max(Math.max(dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e7),dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e7)),dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e7));
		}, get_x : function() {
			return Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e8),dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e8)),dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e8));
		}, set_x : function(x) {
			var dx = x - Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e9),dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e9)),dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e9));
			dsHelper_flatInterleave_FloatColorTriangles.set_ax(_e9,dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e9) + dx);
			dsHelper_flatInterleave_FloatColorTriangles.set_bx(_e9,dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e9) + dx);
			dsHelper_flatInterleave_FloatColorTriangles.set_cx(_e9,dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e9) + dx);
			return x;
		}, get_y : function() {
			return Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e10),dsHelper_flatInterleave_FloatColorTriangles.get_by(_e10)),dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e10));
		}, set_y : function(y) {
			var dy = y - Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e11),dsHelper_flatInterleave_FloatColorTriangles.get_by(_e11)),dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e11));
			dsHelper_flatInterleave_FloatColorTriangles.set_ay(_e11,dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e11) + dy);
			dsHelper_flatInterleave_FloatColorTriangles.set_by(_e11,dsHelper_flatInterleave_FloatColorTriangles.get_by(_e11) + dy);
			dsHelper_flatInterleave_FloatColorTriangles.set_cy(_e11,dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e11) + dy);
			return y;
		}, get_z : function() {
			return Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_az(_e12),dsHelper_flatInterleave_FloatColorTriangles.get_bz(_e12)),dsHelper_flatInterleave_FloatColorTriangles.get_cz(_e12));
		}, set_z : function(z) {
			var dz = z - Math.min(Math.min(dsHelper_flatInterleave_FloatColorTriangles.get_az(_e13),dsHelper_flatInterleave_FloatColorTriangles.get_bz(_e13)),dsHelper_flatInterleave_FloatColorTriangles.get_cz(_e13));
			dsHelper_flatInterleave_FloatColorTriangles.set_az(_e13,dsHelper_flatInterleave_FloatColorTriangles.get_az(_e13) + dz);
			dsHelper_flatInterleave_FloatColorTriangles.set_bz(_e13,dsHelper_flatInterleave_FloatColorTriangles.get_bz(_e13) + dz);
			dsHelper_flatInterleave_FloatColorTriangles.set_cz(_e13,dsHelper_flatInterleave_FloatColorTriangles.get_cz(_e13) + dz);
			return z;
		}, triangle : function(ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
			return dsHelper_flatInterleave_FloatColorTriangles.triangle(_e14,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_);
		}, getTriangle3D : function() {
			var pa = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e15),dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e15),dsHelper_flatInterleave_FloatColorTriangles.get_az(_e15),1.);
			var pb = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e15),dsHelper_flatInterleave_FloatColorTriangles.get_by(_e15),dsHelper_flatInterleave_FloatColorTriangles.get_bz(_e15),1.);
			var pc = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e15),dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e15),dsHelper_flatInterleave_FloatColorTriangles.get_cz(_e15),1.);
			return new trilateral3_structure_Triangle3D(pa,pb,pc);
		}, transform : function(m) {
			trilateral3_geom_FlatColorTriangles.transform(_e16,m);
		}};
		var _e17 = t;
		var _e18 = t;
		var _e19 = t;
		var _e20 = t;
		var _e21 = t;
		var _e22 = t;
		var _e23 = t;
		var color3Abstract = { set_argb : function(col) {
			dsHelper_flatInterleave_FloatColorTriangles.set_redA(_e17,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 5 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 4 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 6 + 2] = v;
			dsHelper_flatInterleave_FloatColorTriangles.set_redB(_e17,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 12 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 11 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 13 + 2] = v;
			dsHelper_flatInterleave_FloatColorTriangles.set_redC(_e17,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 19 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 18 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e17[(_e17[0] | 0) * 21 + 20 + 2] = v;
			return col;
		}, set_argbA : function(col) {
			dsHelper_flatInterleave_FloatColorTriangles.set_redA(_e18,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e18[(_e18[0] | 0) * 21 + 5 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e18[(_e18[0] | 0) * 21 + 4 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e18[(_e18[0] | 0) * 21 + 6 + 2] = v;
			return col;
		}, get_argbA : function() {
			return Math.round(_e19[(_e19[0] | 0) * 21 + 6 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTriangles.get_redA(_e19) * 255) << 16 | Math.round(_e19[(_e19[0] | 0) * 21 + 4 + 2] * 255) << 8 | Math.round(_e19[(_e19[0] | 0) * 21 + 5 + 2] * 255);
		}, set_argbB : function(col) {
			dsHelper_flatInterleave_FloatColorTriangles.set_redB(_e20,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e20[(_e20[0] | 0) * 21 + 12 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e20[(_e20[0] | 0) * 21 + 11 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e20[(_e20[0] | 0) * 21 + 13 + 2] = v;
			return col;
		}, get_argbB : function() {
			return Math.round(_e21[(_e21[0] | 0) * 21 + 13 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTriangles.get_redB(_e21) * 255) << 16 | Math.round(_e21[(_e21[0] | 0) * 21 + 11 + 2] * 255) << 8 | Math.round(_e21[(_e21[0] | 0) * 21 + 12 + 2] * 255);
		}, set_argbC : function(col) {
			dsHelper_flatInterleave_FloatColorTriangles.set_redC(_e22,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e22[(_e22[0] | 0) * 21 + 19 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e22[(_e22[0] | 0) * 21 + 18 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e22[(_e22[0] | 0) * 21 + 20 + 2] = v;
			return col;
		}, get_argbC : function() {
			return Math.round(_e23[(_e23[0] | 0) * 21 + 20 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTriangles.get_redC(_e23) * 255) << 16 | Math.round(_e23[(_e23[0] | 0) * 21 + 18 + 2] * 255) << 8 | Math.round(_e23[(_e23[0] | 0) * 21 + 19 + 2] * 255);
		}};
		var _e24 = t;
		var _e25 = t;
		var _e26 = t;
		var _e27 = t;
		var _e28 = t;
		var _e29 = t;
		var _e30 = t;
		var _e31 = t;
		var _e32 = t;
		var _e33 = t;
		var _e34 = t;
		var _e35 = t;
		var _e36 = t;
		var _e37 = t;
		var _e38 = t;
		var _e39 = t;
		var paintAbstract = { triangle : function(ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
			return dsHelper_flatInterleave_FloatColorTriangles.triangle(_e24,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_);
		}, cornerColors : function(colorA,colorB,colorC) {
			dsHelper_flatInterleave_FloatColorTriangles.set_redA(_e25,(colorA >> 16 & 255) / 255);
			var v = (colorA & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 5 + 2] = v;
			var v = (colorA >> 8 & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 4 + 2] = v;
			var v = (colorA >> 24 & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 6 + 2] = v;
			dsHelper_flatInterleave_FloatColorTriangles.set_redB(_e25,(colorB >> 16 & 255) / 255);
			var v = (colorB & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 12 + 2] = v;
			var v = (colorB >> 8 & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 11 + 2] = v;
			var v = (colorB >> 24 & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 13 + 2] = v;
			dsHelper_flatInterleave_FloatColorTriangles.set_redC(_e25,(colorC >> 16 & 255) / 255);
			var v = (colorC & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 19 + 2] = v;
			var v = (colorC >> 8 & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 18 + 2] = v;
			var v = (colorC >> 24 & 255) / 255;
			_e25[(_e25[0] | 0) * 21 + 20 + 2] = v;
		}, colorTriangles : function(color,times) {
			var _g = 0;
			var _g1 = times;
			while(_g < _g1) {
				var i = _g++;
				dsHelper_flatInterleave_FloatColorTriangles.set_redA(_e26,(color >> 16 & 255) / 255);
				var v = (color & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 5 + 2] = v;
				var v1 = (color >> 8 & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 4 + 2] = v1;
				var v2 = (color >> 24 & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 6 + 2] = v2;
				dsHelper_flatInterleave_FloatColorTriangles.set_redB(_e26,(color >> 16 & 255) / 255);
				var v3 = (color & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 12 + 2] = v3;
				var v4 = (color >> 8 & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 11 + 2] = v4;
				var v5 = (color >> 24 & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 13 + 2] = v5;
				dsHelper_flatInterleave_FloatColorTriangles.set_redC(_e26,(color >> 16 & 255) / 255);
				var v6 = (color & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 19 + 2] = v6;
				var v7 = (color >> 8 & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 18 + 2] = v7;
				var v8 = (color >> 24 & 255) / 255;
				_e26[(_e26[0] | 0) * 21 + 20 + 2] = v8;
				var pos_ = _e26[0] + 1;
				_e26[0] = pos_;
				if(_e26[0] > _e26[1] - 1) {
					_e26[1] = _e26[0];
				}
			}
		}, getTriInt : function() {
			return new trilateral3_structure_TriInt(Math.round(_e27[(_e27[0] | 0) * 21 + 6 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTriangles.get_redA(_e27) * 255) << 16 | Math.round(_e27[(_e27[0] | 0) * 21 + 4 + 2] * 255) << 8 | Math.round(_e27[(_e27[0] | 0) * 21 + 5 + 2] * 255),Math.round(_e27[(_e27[0] | 0) * 21 + 13 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTriangles.get_redB(_e27) * 255) << 16 | Math.round(_e27[(_e27[0] | 0) * 21 + 11 + 2] * 255) << 8 | Math.round(_e27[(_e27[0] | 0) * 21 + 12 + 2] * 255),Math.round(_e27[(_e27[0] | 0) * 21 + 20 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTriangles.get_redC(_e27) * 255) << 16 | Math.round(_e27[(_e27[0] | 0) * 21 + 18 + 2] * 255) << 8 | Math.round(_e27[(_e27[0] | 0) * 21 + 19 + 2] * 255));
		}, transform : function(m) {
			trilateral3_geom_FlatColorTriangles.transform(_e28,m);
		}, transformRange : function(m,startEnd) {
			trilateral3_geom_FlatColorTriangles.transformRange(_e29,m,startEnd);
		}, getTriangle3D : function() {
			var pa = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_ax(_e30),dsHelper_flatInterleave_FloatColorTriangles.get_ay(_e30),dsHelper_flatInterleave_FloatColorTriangles.get_az(_e30),1.);
			var pb = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_bx(_e30),dsHelper_flatInterleave_FloatColorTriangles.get_by(_e30),dsHelper_flatInterleave_FloatColorTriangles.get_bz(_e30),1.);
			var pc = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTriangles.get_cx(_e30),dsHelper_flatInterleave_FloatColorTriangles.get_cy(_e30),dsHelper_flatInterleave_FloatColorTriangles.get_cz(_e30),1.);
			return new trilateral3_structure_Triangle3D(pa,pb,pc);
		}, next : function() {
			var pos_ = _e31[0] + 1.;
			_e31[0] = pos_;
			if(_e31[0] > _e31[1] - 1) {
				_e31[1] = _e31[0];
			}
			return _e31[0];
		}, hasNext : function() {
			return _e32[0] < dsHelper_flat_io_Float32Flat.get_size(_e32);
		}, get_pos : function() {
			return _e33[0];
		}, set_pos : function(pos_) {
			_e34[0] = pos_;
			if(_e34[0] > _e34[1] - 1) {
				_e34[1] = _e34[0];
			}
			return pos_;
		}, get_size : function() {
			return dsHelper_flat_io_Float32Flat.get_size(_e35);
		}, set_size : function(id) {
			return dsHelper_flat_io_Float32Flat.set_size(_e36,id);
		}, toStart : function(id,len) {
			var starting = id * 21;
			var totalLen = 21 * len | 0;
			if(starting == 0) {
				return false;
			} else {
				var ending = starting + totalLen;
				var temp = [];
				var count = 0;
				var _g = starting;
				var _g1 = ending;
				while(_g < _g1) {
					var i = _g++;
					temp[count] = _e37[i + 2];
					++count;
				}
				count = totalLen;
				var _g = 0;
				var _g1 = starting;
				while(_g < _g1) {
					var i = _g++;
					var v = _e37[starting - 1 - i + 2];
					_e37[ending - 1 - i + 2] = v;
				}
				count = 0;
				var _g = 0;
				var _g1 = totalLen;
				while(_g < _g1) {
					var i = _g++;
					var v = temp[count - 2];
					_e37[i + 2] = v;
					++count;
				}
				temp = null;
				return true;
			}
		}, toEnd : function(id,len) {
			return dsHelper_flat_io_Float32FlatDepth.rangeToEnd(_e38,id * 21,21 * len | 0,21 * dsHelper_flat_io_Float32Flat.get_size(_e38));
		}, swap : function(id0,id1,len) {
			var start0 = id0 * 21;
			var start1 = id1 * 21;
			var totalLen = 21 * len | 0;
			if(start0 + totalLen > dsHelper_flat_io_Float32Flat.get_size(_e39) && start1 + totalLen > dsHelper_flat_io_Float32Flat.get_size(_e39)) {
				var temp0;
				var temp1;
				var _g = 0;
				var _g1 = totalLen;
				while(_g < _g1) {
					var i = _g++;
					temp0 = _e39[start0 + i + 2];
					temp1 = _e39[start1 + i + 2];
					_e39[start0 + i + 2] = temp1;
					_e39[start1 + i + 2] = temp0;
				}
				return true;
			} else {
				return false;
			}
		}, triangleCurrent : triangleAbstract, color3current : color3Abstract};
		this.pen = new trilateral3_drawing_Pen(paintAbstract);
		return this.pen;
	}
	,get_data: function() {
		var this1 = this.colorTriangles;
		return this1.subarray(2,dsHelper_flat_io_Float32Flat.get_size(this1) * 21 + 2);
	}
	,get_size: function() {
		return dsHelper_flat_io_Float32Flat.get_size(this.colorTriangles) * 3 | 0;
	}
};
var trilateral3_nodule_PenPaint = function(useGLScale) {
	if(useGLScale == null) {
		useGLScale = true;
	}
	var this1 = new Float32Array(trilateral3_nodule_PenPaint.largeEnough + 2);
	this1[0] = 0.;
	this1[1] = 0.;
	this.colorTriangles = this1;
	if(useGLScale) {
		var transform1000 = new trilateral3_matrix_MatrixDozen(0.001,0,0,-1,0,-0.001,0,1,0,0,0.001,0);
		trilateral3_Trilateral.transformMatrix = transform1000;
	}
	this.createPen();
};
trilateral3_nodule_PenPaint.__name__ = true;
trilateral3_nodule_PenPaint.prototype = {
	createPen: function() {
		var t = this.colorTriangles;
		var _e = t;
		var _e1 = t;
		var _e2 = t;
		var _e3 = t;
		var _e4 = t;
		var _e5 = t;
		var _e6 = t;
		var _e7 = t;
		var _e8 = t;
		var _e9 = t;
		var _e10 = t;
		var _e11 = t;
		var _e12 = t;
		var _e13 = t;
		var _e14 = t;
		var _e15 = t;
		var _e16 = t;
		var triangleAbstract = { rotate : function(x,y,theta) {
			var cos = Math.cos(theta);
			var sin = Math.sin(theta);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ax(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_g) - x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ay(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_g) - y);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_bx(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_g) - x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_by(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_g) - y);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cx(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_g) - x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cy(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_g) - y);
			var dx = dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_e);
			var dy = dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_e);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ax(_e,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ay(_e,dx * sin + dy * cos);
			dx = dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_e);
			dy = dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_e);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_bx(_e,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_by(_e,dx * sin + dy * cos);
			dx = dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_e);
			dy = dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_e);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cx(_e,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cy(_e,dx * sin + dy * cos);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ax(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_g) + x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ay(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_g) + y);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_bx(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_g) + x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_by(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_g) + y);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cx(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_g) + x);
			var _g = _e;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cy(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_g) + y);
		}, moveDelta : function(dx,dy) {
			dsHelper_flatInterleave_FloatColorTrianglesUV.moveDelta(_e1,dx,dy);
		}, rotateTrig : function(x,y,cos,sin) {
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ax(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_g) - x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ay(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_g) - y);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_bx(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_g) - x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_by(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_g) - y);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cx(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_g) - x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cy(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_g) - y);
			var dx = dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_e2);
			var dy = dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_e2);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ax(_e2,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ay(_e2,dx * sin + dy * cos);
			dx = dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_e2);
			dy = dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_e2);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_bx(_e2,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_by(_e2,dx * sin + dy * cos);
			dx = dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_e2);
			dy = dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_e2);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cx(_e2,dx * cos - dy * sin);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cy(_e2,dx * sin + dy * cos);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ax(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_g) + x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ay(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_g) + y);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_bx(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_g) + x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_by(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_g) + y);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cx(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_g) + x);
			var _g = _e2;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cy(_g,dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_g) + y);
		}, fullHit : function(px,py) {
			return dsHelper_flatInterleave_FloatColorTrianglesUV.fullHit(_e3,px,py);
		}, liteHit : function(px,py) {
			var planeAB = (dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_e4) - px) * (dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_e4) - py) - (dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_e4) - px) * (dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_e4) - py);
			var planeBC = (dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_e4) - px) * (dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_e4) - py) - (dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_e4) - px) * (dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_e4) - py);
			var planeCA = (dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_e4) - px) * (dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_e4) - py) - (dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_e4) - px) * (dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_e4) - py);
			if((Math.abs(planeAB) / planeAB | 0) == (Math.abs(planeBC) / planeBC | 0)) {
				return (Math.abs(planeBC) / planeBC | 0) == (Math.abs(planeCA) / planeCA | 0);
			} else {
				return false;
			}
		}, get_bottom : function() {
			return Math.max(Math.max(dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_e5),dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_e5)),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_e5));
		}, get_back : function() {
			return Math.max(Math.max(dsHelper_flatInterleave_FloatColorTrianglesUV.get_az(_e6),dsHelper_flatInterleave_FloatColorTrianglesUV.get_bz(_e6)),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cz(_e6));
		}, get_right : function() {
			return Math.max(Math.max(dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_e7),dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_e7)),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_e7));
		}, get_x : function() {
			return Math.min(Math.min(dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_e8),dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_e8)),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_e8));
		}, set_x : function(x) {
			var dx = x - Math.min(Math.min(dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_e9),dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_e9)),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_e9));
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ax(_e9,dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_e9) + dx);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_bx(_e9,dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_e9) + dx);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cx(_e9,dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_e9) + dx);
			return x;
		}, get_y : function() {
			return Math.min(Math.min(dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_e10),dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_e10)),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_e10));
		}, set_y : function(y) {
			var dy = y - Math.min(Math.min(dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_e11),dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_e11)),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_e11));
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_ay(_e11,dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_e11) + dy);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_by(_e11,dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_e11) + dy);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cy(_e11,dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_e11) + dy);
			return y;
		}, get_z : function() {
			return Math.min(Math.min(dsHelper_flatInterleave_FloatColorTrianglesUV.get_az(_e12),dsHelper_flatInterleave_FloatColorTrianglesUV.get_bz(_e12)),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cz(_e12));
		}, set_z : function(z) {
			var dz = z - Math.min(Math.min(dsHelper_flatInterleave_FloatColorTrianglesUV.get_az(_e13),dsHelper_flatInterleave_FloatColorTrianglesUV.get_bz(_e13)),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cz(_e13));
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_az(_e13,dsHelper_flatInterleave_FloatColorTrianglesUV.get_az(_e13) + dz);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_bz(_e13,dsHelper_flatInterleave_FloatColorTrianglesUV.get_bz(_e13) + dz);
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_cz(_e13,dsHelper_flatInterleave_FloatColorTrianglesUV.get_cz(_e13) + dz);
			return z;
		}, triangle : function(ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
			return dsHelper_flatInterleave_FloatColorTrianglesUV.triangle(_e14,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_);
		}, getTriangle3D : function() {
			var pa = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_e15),dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_e15),dsHelper_flatInterleave_FloatColorTrianglesUV.get_az(_e15),1.);
			var pb = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_e15),dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_e15),dsHelper_flatInterleave_FloatColorTrianglesUV.get_bz(_e15),1.);
			var pc = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_e15),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_e15),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cz(_e15),1.);
			return new trilateral3_structure_Triangle3D(pa,pb,pc);
		}, transform : function(m) {
			trilateral3_geom_FlatColorTrianglesUV.transform(_e16,m);
		}};
		var _e17 = t;
		var _e18 = t;
		var _e19 = t;
		var _e20 = t;
		var _e21 = t;
		var _e22 = t;
		var _e23 = t;
		var _e24 = t;
		var _e25 = t;
		var triangleAbstractUV = { moveDelta : function(du,dv) {
			dsHelper_flatInterleave_FloatColorTrianglesUV.moveDeltaUV(_e17,du,dv);
		}, get_u : function() {
			return Math.min(Math.min(_e18[(_e18[0] | 0) * 27 + 7 + 2],_e18[(_e18[0] | 0) * 27 + 16 + 2]),_e18[(_e18[0] | 0) * 27 + 25 + 2]);
		}, set_u : function(u_) {
			var du = u_ - Math.min(Math.min(_e19[(_e19[0] | 0) * 27 + 7 + 2],_e19[(_e19[0] | 0) * 27 + 16 + 2]),_e19[(_e19[0] | 0) * 27 + 25 + 2]);
			var v = _e19[(_e19[0] | 0) * 27 + 7 + 2] + du;
			_e19[(_e19[0] | 0) * 27 + 7 + 2] = v;
			var v = _e19[(_e19[0] | 0) * 27 + 16 + 2] + du;
			_e19[(_e19[0] | 0) * 27 + 16 + 2] = v;
			var v = _e19[(_e19[0] | 0) * 27 + 25 + 2] + du;
			_e19[(_e19[0] | 0) * 27 + 25 + 2] = v;
			return u_;
		}, get_v : function() {
			return Math.min(Math.min(_e20[(_e20[0] | 0) * 27 + 8 + 2],_e20[(_e20[0] | 0) * 27 + 17 + 2]),_e20[(_e20[0] | 0) * 27 + 26 + 2]);
		}, set_v : function(v_) {
			var dv = v_ - Math.min(Math.min(_e21[(_e21[0] | 0) * 27 + 8 + 2],_e21[(_e21[0] | 0) * 27 + 17 + 2]),_e21[(_e21[0] | 0) * 27 + 26 + 2]);
			var v = _e21[(_e21[0] | 0) * 27 + 8 + 2] + dv;
			_e21[(_e21[0] | 0) * 27 + 8 + 2] = v;
			var v = _e21[(_e21[0] | 0) * 27 + 17 + 2] + dv;
			_e21[(_e21[0] | 0) * 27 + 17 + 2] = v;
			var v = _e21[(_e21[0] | 0) * 27 + 26 + 2] + dv;
			_e21[(_e21[0] | 0) * 27 + 26 + 2] = v;
			return v_;
		}, get_bottomV : function() {
			return Math.max(Math.max(_e22[(_e22[0] | 0) * 27 + 8 + 2],_e22[(_e22[0] | 0) * 27 + 17 + 2]),_e22[(_e22[0] | 0) * 27 + 26 + 2]);
		}, get_rightU : function() {
			return Math.max(Math.max(_e23[(_e23[0] | 0) * 27 + 7 + 2],_e23[(_e23[0] | 0) * 27 + 16 + 2]),_e23[(_e23[0] | 0) * 27 + 25 + 2]);
		}, triangleUV : function(uA_,vA_,uB_,vB_,uC_,vC_,windAdjust_) {
			return dsHelper_flatInterleave_FloatColorTrianglesUV.triangleUV(_e24,uA_,vA_,uB_,vB_,uC_,vC_,windAdjust_);
		}, getTriangleUV : function() {
			var ta = new trilateral3_matrix_UV(_e25[(_e25[0] | 0) * 27 + 7 + 2],_e25[(_e25[0] | 0) * 27 + 8 + 2]);
			var tb = new trilateral3_matrix_UV(_e25[(_e25[0] | 0) * 27 + 16 + 2],_e25[(_e25[0] | 0) * 27 + 17 + 2]);
			var tc = new trilateral3_matrix_UV(_e25[(_e25[0] | 0) * 27 + 25 + 2],_e25[(_e25[0] | 0) * 27 + 26 + 2]);
			return new trilateral3_structure_TriangleUV(ta,tb,tc);
		}};
		var _e26 = t;
		var _e27 = t;
		var _e28 = t;
		var _e29 = t;
		var _e30 = t;
		var _e31 = t;
		var _e32 = t;
		var color3Abstract = { set_argb : function(col) {
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_redA(_e26,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 5 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 4 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 6 + 2] = v;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_redB(_e26,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 14 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 13 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 15 + 2] = v;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_redC(_e26,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 23 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 22 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e26[(_e26[0] | 0) * 27 + 24 + 2] = v;
			return col;
		}, set_argbA : function(col) {
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_redA(_e27,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e27[(_e27[0] | 0) * 27 + 5 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e27[(_e27[0] | 0) * 27 + 4 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e27[(_e27[0] | 0) * 27 + 6 + 2] = v;
			return col;
		}, get_argbA : function() {
			return Math.round(_e28[(_e28[0] | 0) * 27 + 6 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTrianglesUV.get_redA(_e28) * 255) << 16 | Math.round(_e28[(_e28[0] | 0) * 27 + 4 + 2] * 255) << 8 | Math.round(_e28[(_e28[0] | 0) * 27 + 5 + 2] * 255);
		}, set_argbB : function(col) {
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_redB(_e29,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e29[(_e29[0] | 0) * 27 + 14 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e29[(_e29[0] | 0) * 27 + 13 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e29[(_e29[0] | 0) * 27 + 15 + 2] = v;
			return col;
		}, get_argbB : function() {
			return Math.round(_e30[(_e30[0] | 0) * 27 + 15 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTrianglesUV.get_redB(_e30) * 255) << 16 | Math.round(_e30[(_e30[0] | 0) * 27 + 13 + 2] * 255) << 8 | Math.round(_e30[(_e30[0] | 0) * 27 + 14 + 2] * 255);
		}, set_argbC : function(col) {
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_redC(_e31,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			_e31[(_e31[0] | 0) * 27 + 23 + 2] = v;
			var v = (col >> 8 & 255) / 255;
			_e31[(_e31[0] | 0) * 27 + 22 + 2] = v;
			var v = (col >> 24 & 255) / 255;
			_e31[(_e31[0] | 0) * 27 + 24 + 2] = v;
			return col;
		}, get_argbC : function() {
			return Math.round(_e32[(_e32[0] | 0) * 27 + 24 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTrianglesUV.get_redC(_e32) * 255) << 16 | Math.round(_e32[(_e32[0] | 0) * 27 + 22 + 2] * 255) << 8 | Math.round(_e32[(_e32[0] | 0) * 27 + 23 + 2] * 255);
		}};
		var _e33 = t;
		var _e34 = t;
		var _e35 = t;
		var _e36 = t;
		var _e37 = t;
		var _e38 = t;
		var _e39 = t;
		var _e40 = t;
		var _e41 = t;
		var _e42 = t;
		var _e43 = t;
		var _e44 = t;
		var _e45 = t;
		var _e46 = t;
		var _e47 = t;
		var _e48 = t;
		var _e49 = t;
		var _e50 = t;
		var paintAbstract = { triangle : function(ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_) {
			return dsHelper_flatInterleave_FloatColorTrianglesUV.triangle(_e33,ax_,ay_,az_,bx_,by_,bz_,cx_,cy_,cz_);
		}, triangleUV : function(uA_,vA_,uB_,vB_,uC_,vC_,windAdjust_) {
			return dsHelper_flatInterleave_FloatColorTrianglesUV.triangleUV(_e34,uA_,vA_,uB_,vB_,uC_,vC_,windAdjust_);
		}, cornerColors : function(colorA,colorB,colorC) {
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_redA(_e35,(colorA >> 16 & 255) / 255);
			var v = (colorA & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 5 + 2] = v;
			var v = (colorA >> 8 & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 4 + 2] = v;
			var v = (colorA >> 24 & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 6 + 2] = v;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_redB(_e35,(colorB >> 16 & 255) / 255);
			var v = (colorB & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 14 + 2] = v;
			var v = (colorB >> 8 & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 13 + 2] = v;
			var v = (colorB >> 24 & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 15 + 2] = v;
			dsHelper_flatInterleave_FloatColorTrianglesUV.set_redC(_e35,(colorC >> 16 & 255) / 255);
			var v = (colorC & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 23 + 2] = v;
			var v = (colorC >> 8 & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 22 + 2] = v;
			var v = (colorC >> 24 & 255) / 255;
			_e35[(_e35[0] | 0) * 27 + 24 + 2] = v;
		}, colorTriangles : function(color,times) {
			var _g = 0;
			var _g1 = times;
			while(_g < _g1) {
				var i = _g++;
				dsHelper_flatInterleave_FloatColorTrianglesUV.set_redA(_e36,(color >> 16 & 255) / 255);
				var v = (color & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 5 + 2] = v;
				var v1 = (color >> 8 & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 4 + 2] = v1;
				var v2 = (color >> 24 & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 6 + 2] = v2;
				dsHelper_flatInterleave_FloatColorTrianglesUV.set_redB(_e36,(color >> 16 & 255) / 255);
				var v3 = (color & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 14 + 2] = v3;
				var v4 = (color >> 8 & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 13 + 2] = v4;
				var v5 = (color >> 24 & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 15 + 2] = v5;
				dsHelper_flatInterleave_FloatColorTrianglesUV.set_redC(_e36,(color >> 16 & 255) / 255);
				var v6 = (color & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 23 + 2] = v6;
				var v7 = (color >> 8 & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 22 + 2] = v7;
				var v8 = (color >> 24 & 255) / 255;
				_e36[(_e36[0] | 0) * 27 + 24 + 2] = v8;
			}
		}, getTriInt : function() {
			return new trilateral3_structure_TriInt(Math.round(_e37[(_e37[0] | 0) * 27 + 6 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTrianglesUV.get_redA(_e37) * 255) << 16 | Math.round(_e37[(_e37[0] | 0) * 27 + 4 + 2] * 255) << 8 | Math.round(_e37[(_e37[0] | 0) * 27 + 5 + 2] * 255),Math.round(_e37[(_e37[0] | 0) * 27 + 15 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTrianglesUV.get_redB(_e37) * 255) << 16 | Math.round(_e37[(_e37[0] | 0) * 27 + 13 + 2] * 255) << 8 | Math.round(_e37[(_e37[0] | 0) * 27 + 14 + 2] * 255),Math.round(_e37[(_e37[0] | 0) * 27 + 24 + 2] * 255) << 24 | Math.round(dsHelper_flatInterleave_FloatColorTrianglesUV.get_redC(_e37) * 255) << 16 | Math.round(_e37[(_e37[0] | 0) * 27 + 22 + 2] * 255) << 8 | Math.round(_e37[(_e37[0] | 0) * 27 + 23 + 2] * 255));
		}, transform : function(m) {
			trilateral3_geom_FlatColorTrianglesUV.transform(_e38,m);
		}, transformRange : function(m,startEnd) {
			trilateral3_geom_FlatColorTrianglesUV.transformRange(_e39,m,startEnd);
		}, getTriangle3D : function() {
			var pa = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTrianglesUV.get_ax(_e40),dsHelper_flatInterleave_FloatColorTrianglesUV.get_ay(_e40),dsHelper_flatInterleave_FloatColorTrianglesUV.get_az(_e40),1.);
			var pb = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTrianglesUV.get_bx(_e40),dsHelper_flatInterleave_FloatColorTrianglesUV.get_by(_e40),dsHelper_flatInterleave_FloatColorTrianglesUV.get_bz(_e40),1.);
			var pc = new trilateral3_matrix_Vertex(dsHelper_flatInterleave_FloatColorTrianglesUV.get_cx(_e40),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cy(_e40),dsHelper_flatInterleave_FloatColorTrianglesUV.get_cz(_e40),1.);
			return new trilateral3_structure_Triangle3D(pa,pb,pc);
		}, getTriangleUV : function() {
			var ta = new trilateral3_matrix_UV(_e41[(_e41[0] | 0) * 27 + 7 + 2],_e41[(_e41[0] | 0) * 27 + 8 + 2]);
			var tb = new trilateral3_matrix_UV(_e41[(_e41[0] | 0) * 27 + 16 + 2],_e41[(_e41[0] | 0) * 27 + 17 + 2]);
			var tc = new trilateral3_matrix_UV(_e41[(_e41[0] | 0) * 27 + 25 + 2],_e41[(_e41[0] | 0) * 27 + 26 + 2]);
			return new trilateral3_structure_TriangleUV(ta,tb,tc);
		}, next : function() {
			var pos_ = _e42[0] + 1.;
			_e42[0] = pos_;
			if(_e42[0] > _e42[1] - 1) {
				_e42[1] = _e42[0];
			}
			return _e42[0];
		}, hasNext : function() {
			return _e43[0] < dsHelper_flat_io_Float32Flat.get_size(_e43);
		}, get_pos : function() {
			return _e44[0];
		}, set_pos : function(pos_) {
			_e45[0] = pos_;
			if(_e45[0] > _e45[1] - 1) {
				_e45[1] = _e45[0];
			}
			return pos_;
		}, get_size : function() {
			return dsHelper_flat_io_Float32Flat.get_size(_e46);
		}, set_size : function(id) {
			return dsHelper_flat_io_Float32Flat.set_size(_e47,id);
		}, toStart : function(id,len) {
			var starting = id * 27;
			var totalLen = 27 * len | 0;
			if(starting == 0) {
				return false;
			} else {
				var ending = starting + totalLen;
				var temp = [];
				var count = 0;
				var _g = starting;
				var _g1 = ending;
				while(_g < _g1) {
					var i = _g++;
					temp[count] = _e48[i + 2];
					++count;
				}
				count = totalLen;
				var _g = 0;
				var _g1 = starting;
				while(_g < _g1) {
					var i = _g++;
					var v = _e48[starting - 1 - i + 2];
					_e48[ending - 1 - i + 2] = v;
				}
				count = 0;
				var _g = 0;
				var _g1 = totalLen;
				while(_g < _g1) {
					var i = _g++;
					var v = temp[count - 2];
					_e48[i + 2] = v;
					++count;
				}
				temp = null;
				return true;
			}
		}, toEnd : function(id,len) {
			return dsHelper_flat_io_Float32FlatDepth.rangeToEnd(_e49,id * 27,27 * len | 0,27);
		}, swap : function(id0,id1,len) {
			var start0 = id0 * 21;
			var start1 = id1 * 21;
			var totalLen = 21 * len | 0;
			if(start0 + totalLen > dsHelper_flat_io_Float32Flat.get_size(_e50) && start1 + totalLen > dsHelper_flat_io_Float32Flat.get_size(_e50)) {
				var temp0;
				var temp1;
				var _g = 0;
				var _g1 = totalLen;
				while(_g < _g1) {
					var i = _g++;
					temp0 = _e50[start0 + i + 2];
					temp1 = _e50[start1 + i + 2];
					_e50[start0 + i + 2] = temp1;
					_e50[start1 + i + 2] = temp0;
				}
				return true;
			} else {
				return false;
			}
		}, triangleCurrent : triangleAbstract, triangleCurrentUV : triangleAbstractUV, color3current : color3Abstract};
		this.pen = new trilateral3_drawing_Pen(paintAbstract);
	}
	,get_data: function() {
		var this1 = this.colorTriangles;
		return this1.subarray(2,dsHelper_flat_io_Float32Flat.get_size(this1) * 27 + 2);
	}
	,get_size: function() {
		return dsHelper_flat_io_Float32Flat.get_size(this.colorTriangles) * 3 | 0;
	}
};
var trilateral3_shape_IntIterStart = function(min_,max_) {
	this.start = min_;
	this.max = max_;
};
trilateral3_shape_IntIterStart.__name__ = true;
var trilateral3_structure_StartEnd = function(start,end) {
	this.start = start;
	this.end = end;
};
trilateral3_structure_StartEnd.__name__ = true;
var trilateral3_structure_TriInt = function(a,b,c) {
	this.a = a;
	this.b = b;
	this.c = c;
};
trilateral3_structure_TriInt.__name__ = true;
var trilateral3_structure_Triangle3D = function(a,b,c) {
	this.a = a;
	this.b = b;
	this.c = c;
};
trilateral3_structure_Triangle3D.__name__ = true;
var trilateral3_structure_TriangleUV = function(a,b,c) {
	this.a = a;
	this.b = b;
	this.c = c;
};
trilateral3_structure_TriangleUV.__name__ = true;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
String.__name__ = true;
Array.__name__ = true;
hxGeomAlgo_PolyTools.exposeEnum(hxGeomAlgo_WindingRule);
hxGeomAlgo_PolyTools.exposeEnum(hxGeomAlgo_ResultType);
js_Boot.__toStr = ({ }).toString;
hxGeomAlgo_HxPoint.EMPTY = hxGeomAlgo_HxPoint._new(NaN,NaN);
hxGeomAlgo_PolyTools.point = hxGeomAlgo_HxPoint._new();
hxGeomAlgo_PolyTools.zero = hxGeomAlgo_HxPoint._new(0,0);
hxGeomAlgo_PolyTools.EPSILON = .00000001;
kitGL_glWeb_AnimateTimer.counter = 0;
trilateral3_nodule_PenNodule.largeEnough = 20000000;
trilateral3_nodule_PenPaint.largeEnough = 20000000;
TrilateralTileSheetTexture_main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
